/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "./node_modules/@spruceid/siwe-parser/dist/abnf.js":
/*!*********************************************************!*\
  !*** ./node_modules/@spruceid/siwe-parser/dist/abnf.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ParsedMessage = void 0;\nconst api_1 = __importDefault(__webpack_require__(/*! apg-js/src/apg-api/api */ \"./node_modules/apg-js/src/apg-api/api.js\"));\nconst node_exports_1 = __importDefault(__webpack_require__(/*! apg-js/src/apg-lib/node-exports */ \"./node_modules/apg-js/src/apg-lib/node-exports.js\"));\nconst GRAMMAR = `\nsign-in-with-ethereum =\n    domain %s\" wants you to sign in with your Ethereum account:\" LF\n    address LF\n    LF\n    [ statement LF ]\n    LF\n    %s\"URI: \" URI LF\n    %s\"Version: \" version LF\n    %s\"Chain ID: \" chain-id LF\n    %s\"Nonce: \" nonce LF\n    %s\"Issued At: \" issued-at\n    [ LF %s\"Expiration Time: \" expiration-time ]\n    [ LF %s\"Not Before: \" not-before ]\n    [ LF %s\"Request ID: \" request-id ]\n    [ LF %s\"Resources:\"\n    resources ]\n\ndomain = authority\n\naddress = \"0x\" 40*40HEXDIG\n    ; Must also conform to captilization\n    ; checksum encoding specified in EIP-55\n    ; where applicable (EOAs).\n\nstatement = 1*( reserved / unreserved / \" \" )\n    ; The purpose is to exclude LF (line breaks).\n\nversion = \"1\"\n\nnonce = 8*( ALPHA / DIGIT )\n\nissued-at = date-time\nexpiration-time = date-time\nnot-before = date-time\n\nrequest-id = *pchar\n\nchain-id = 1*DIGIT\n    ; See EIP-155 for valid CHAIN_IDs.\n\nresources = *( LF resource )\n\nresource = \"- \" URI\n\n; ------------------------------------------------------------------------------\n; RFC 3986\n\nURI           = scheme \":\" hier-part [ \"?\" query ] [ \"#\" fragment ]\n\nhier-part     = \"//\" authority path-abempty\n              / path-absolute\n              / path-rootless\n              / path-empty\n\nscheme        = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n\nauthority     = [ userinfo \"@\" ] host [ \":\" port ]\nuserinfo      = *( unreserved / pct-encoded / sub-delims / \":\" )\nhost          = IP-literal / IPv4address / reg-name\nport          = *DIGIT\n\nIP-literal    = \"[\" ( IPv6address / IPvFuture  ) \"]\"\n\nIPvFuture     = \"v\" 1*HEXDIG \".\" 1*( unreserved / sub-delims / \":\" )\n\nIPv6address   =                            6( h16 \":\" ) ls32\n              /                       \"::\" 5( h16 \":\" ) ls32\n              / [               h16 ] \"::\" 4( h16 \":\" ) ls32\n              / [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n              / [ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n              / [ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n              / [ *4( h16 \":\" ) h16 ] \"::\"              ls32\n              / [ *5( h16 \":\" ) h16 ] \"::\"              h16\n              / [ *6( h16 \":\" ) h16 ] \"::\"\n\nh16           = 1*4HEXDIG\nls32          = ( h16 \":\" h16 ) / IPv4address\nIPv4address   = dec-octet \".\" dec-octet \".\" dec-octet \".\" dec-octet\ndec-octet     = DIGIT                 ; 0-9\n                 / %x31-39 DIGIT         ; 10-99\n                 / \"1\" 2DIGIT            ; 100-199\n                 / \"2\" %x30-34 DIGIT     ; 200-249\n                 / \"25\" %x30-35          ; 250-255\n\nreg-name      = *( unreserved / pct-encoded / sub-delims )\n\npath-abempty  = *( \"/\" segment )\npath-absolute = \"/\" [ segment-nz *( \"/\" segment ) ]\npath-rootless = segment-nz *( \"/\" segment )\npath-empty    = 0pchar\n\nsegment       = *pchar\nsegment-nz    = 1*pchar\n\npchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n\nquery         = *( pchar / \"/\" / \"?\" )\n\nfragment      = *( pchar / \"/\" / \"?\" )\n\npct-encoded   = \"%\" HEXDIG HEXDIG\n\nunreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\nreserved      = gen-delims / sub-delims\ngen-delims    = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"\nsub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n              / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n\n; ------------------------------------------------------------------------------\n; RFC 3339\n\ndate-fullyear   = 4DIGIT\ndate-month      = 2DIGIT  ; 01-12\ndate-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on\n                          ; month/year\ntime-hour       = 2DIGIT  ; 00-23\ntime-minute     = 2DIGIT  ; 00-59\ntime-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second\n                          ; rules\ntime-secfrac    = \".\" 1*DIGIT\ntime-numoffset  = (\"+\" / \"-\") time-hour \":\" time-minute\ntime-offset     = \"Z\" / time-numoffset\n\npartial-time    = time-hour \":\" time-minute \":\" time-second\n                  [time-secfrac]\nfull-date       = date-fullyear \"-\" date-month \"-\" date-mday\nfull-time       = partial-time time-offset\n\ndate-time       = full-date \"T\" full-time\n\n; ------------------------------------------------------------------------------\n; RFC 5234\n\nALPHA          =  %x41-5A / %x61-7A   ; A-Z / a-z\nLF             =  %x0A\n                  ; linefeed\nDIGIT          =  %x30-39\n                  ; 0-9\nHEXDIG         =  DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"\n`;\nclass ParsedMessage {\n    constructor(msg) {\n        const api = new api_1.default(GRAMMAR);\n        api.generate();\n        if (api.errors.length) {\n            console.error(api.errorsToAscii());\n            console.error(api.linesToAscii());\n            console.log(api.displayAttributeErrors());\n            throw new Error(`ABNF grammar has errors`);\n        }\n        const grammarObj = api.toObject();\n        const parser = new node_exports_1.default.parser();\n        parser.ast = new node_exports_1.default.ast();\n        const id = node_exports_1.default.ids;\n        const domain = function (state, chars, phraseIndex, phraseLength, data) {\n            const ret = id.SEM_OK;\n            if (state === id.SEM_PRE) {\n                data.domain = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);\n            }\n            return ret;\n        };\n        parser.ast.callbacks.domain = domain;\n        const address = function (state, chars, phraseIndex, phraseLength, data) {\n            const ret = id.SEM_OK;\n            if (state === id.SEM_PRE) {\n                data.address = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);\n            }\n            return ret;\n        };\n        parser.ast.callbacks.address = address;\n        const statement = function (state, chars, phraseIndex, phraseLength, data) {\n            const ret = id.SEM_OK;\n            if (state === id.SEM_PRE) {\n                data.statement = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);\n            }\n            return ret;\n        };\n        parser.ast.callbacks.statement = statement;\n        const uri = function (state, chars, phraseIndex, phraseLength, data) {\n            const ret = id.SEM_OK;\n            if (state === id.SEM_PRE) {\n                if (!data.uri) {\n                    data.uri = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);\n                }\n            }\n            return ret;\n        };\n        parser.ast.callbacks.uri = uri;\n        const version = function (state, chars, phraseIndex, phraseLength, data) {\n            const ret = id.SEM_OK;\n            if (state === id.SEM_PRE) {\n                data.version = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);\n            }\n            return ret;\n        };\n        parser.ast.callbacks.version = version;\n        const chainId = function (state, chars, phraseIndex, phraseLength, data) {\n            const ret = id.SEM_OK;\n            if (state === id.SEM_PRE) {\n                data.chainId = parseInt(node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength));\n            }\n            return ret;\n        };\n        parser.ast.callbacks['chain-id'] = chainId;\n        const nonce = function (state, chars, phraseIndex, phraseLength, data) {\n            const ret = id.SEM_OK;\n            if (state === id.SEM_PRE) {\n                data.nonce = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);\n            }\n            return ret;\n        };\n        parser.ast.callbacks.nonce = nonce;\n        const issuedAt = function (state, chars, phraseIndex, phraseLength, data) {\n            const ret = id.SEM_OK;\n            if (state === id.SEM_PRE) {\n                data.issuedAt = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);\n            }\n            return ret;\n        };\n        parser.ast.callbacks['issued-at'] = issuedAt;\n        const expirationTime = function (state, chars, phraseIndex, phraseLength, data) {\n            const ret = id.SEM_OK;\n            if (state === id.SEM_PRE) {\n                data.expirationTime = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);\n            }\n            return ret;\n        };\n        parser.ast.callbacks['expiration-time'] = expirationTime;\n        const notBefore = function (state, chars, phraseIndex, phraseLength, data) {\n            const ret = id.SEM_OK;\n            if (state === id.SEM_PRE) {\n                data.notBefore = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);\n            }\n            return ret;\n        };\n        parser.ast.callbacks['not-before'] = notBefore;\n        const requestId = function (state, chars, phraseIndex, phraseLength, data) {\n            const ret = id.SEM_OK;\n            if (state === id.SEM_PRE) {\n                data.requestId = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);\n            }\n            return ret;\n        };\n        parser.ast.callbacks['request-id'] = requestId;\n        const resources = function (state, chars, phraseIndex, phraseLength, data) {\n            const ret = id.SEM_OK;\n            if (state === id.SEM_PRE) {\n                data.resources = node_exports_1.default.utils\n                    .charsToString(chars, phraseIndex, phraseLength)\n                    .slice(3)\n                    .split('\\n- ');\n            }\n            return ret;\n        };\n        parser.ast.callbacks.resources = resources;\n        const result = parser.parse(grammarObj, 'sign-in-with-ethereum', msg);\n        if (!result.success) {\n            throw new Error(`Invalid message: ${JSON.stringify(result)}`);\n        }\n        const elements = {};\n        parser.ast.translate(elements);\n        for (const [key, value] of Object.entries(elements)) {\n            this[key] = value;\n        }\n    }\n}\nexports.ParsedMessage = ParsedMessage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNwcnVjZWlkL3Npd2UtcGFyc2VyL2Rpc3QvYWJuZi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQiw4QkFBOEIsbUJBQU8sQ0FBQyx3RUFBd0I7QUFDOUQsdUNBQXVDLG1CQUFPLENBQUMsMEZBQWlDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFNO0FBQ04sTUFBTTtBQUNOLE1BQU07O0FBRU47QUFDQSxNQUFNOztBQUVOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7O0FBRUEsRUFBRTtBQUNGLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDLEVBQUU7QUFDRixFQUFFOztBQUVGO0FBQ0EsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFO0FBQ0YsRUFBRTs7QUFFRix3Q0FBd0M7QUFDeEM7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx1QkFBdUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNwcnVjZWlkL3Npd2UtcGFyc2VyL2Rpc3QvYWJuZi5qcz8zM2Y5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXJzZWRNZXNzYWdlID0gdm9pZCAwO1xuY29uc3QgYXBpXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFwZy1qcy9zcmMvYXBnLWFwaS9hcGlcIikpO1xuY29uc3Qgbm9kZV9leHBvcnRzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFwZy1qcy9zcmMvYXBnLWxpYi9ub2RlLWV4cG9ydHNcIikpO1xuY29uc3QgR1JBTU1BUiA9IGBcbnNpZ24taW4td2l0aC1ldGhlcmV1bSA9XG4gICAgZG9tYWluICVzXCIgd2FudHMgeW91IHRvIHNpZ24gaW4gd2l0aCB5b3VyIEV0aGVyZXVtIGFjY291bnQ6XCIgTEZcbiAgICBhZGRyZXNzIExGXG4gICAgTEZcbiAgICBbIHN0YXRlbWVudCBMRiBdXG4gICAgTEZcbiAgICAlc1wiVVJJOiBcIiBVUkkgTEZcbiAgICAlc1wiVmVyc2lvbjogXCIgdmVyc2lvbiBMRlxuICAgICVzXCJDaGFpbiBJRDogXCIgY2hhaW4taWQgTEZcbiAgICAlc1wiTm9uY2U6IFwiIG5vbmNlIExGXG4gICAgJXNcIklzc3VlZCBBdDogXCIgaXNzdWVkLWF0XG4gICAgWyBMRiAlc1wiRXhwaXJhdGlvbiBUaW1lOiBcIiBleHBpcmF0aW9uLXRpbWUgXVxuICAgIFsgTEYgJXNcIk5vdCBCZWZvcmU6IFwiIG5vdC1iZWZvcmUgXVxuICAgIFsgTEYgJXNcIlJlcXVlc3QgSUQ6IFwiIHJlcXVlc3QtaWQgXVxuICAgIFsgTEYgJXNcIlJlc291cmNlczpcIlxuICAgIHJlc291cmNlcyBdXG5cbmRvbWFpbiA9IGF1dGhvcml0eVxuXG5hZGRyZXNzID0gXCIweFwiIDQwKjQwSEVYRElHXG4gICAgOyBNdXN0IGFsc28gY29uZm9ybSB0byBjYXB0aWxpemF0aW9uXG4gICAgOyBjaGVja3N1bSBlbmNvZGluZyBzcGVjaWZpZWQgaW4gRUlQLTU1XG4gICAgOyB3aGVyZSBhcHBsaWNhYmxlIChFT0FzKS5cblxuc3RhdGVtZW50ID0gMSooIHJlc2VydmVkIC8gdW5yZXNlcnZlZCAvIFwiIFwiIClcbiAgICA7IFRoZSBwdXJwb3NlIGlzIHRvIGV4Y2x1ZGUgTEYgKGxpbmUgYnJlYWtzKS5cblxudmVyc2lvbiA9IFwiMVwiXG5cbm5vbmNlID0gOCooIEFMUEhBIC8gRElHSVQgKVxuXG5pc3N1ZWQtYXQgPSBkYXRlLXRpbWVcbmV4cGlyYXRpb24tdGltZSA9IGRhdGUtdGltZVxubm90LWJlZm9yZSA9IGRhdGUtdGltZVxuXG5yZXF1ZXN0LWlkID0gKnBjaGFyXG5cbmNoYWluLWlkID0gMSpESUdJVFxuICAgIDsgU2VlIEVJUC0xNTUgZm9yIHZhbGlkIENIQUlOX0lEcy5cblxucmVzb3VyY2VzID0gKiggTEYgcmVzb3VyY2UgKVxuXG5yZXNvdXJjZSA9IFwiLSBcIiBVUklcblxuOyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbjsgUkZDIDM5ODZcblxuVVJJICAgICAgICAgICA9IHNjaGVtZSBcIjpcIiBoaWVyLXBhcnQgWyBcIj9cIiBxdWVyeSBdIFsgXCIjXCIgZnJhZ21lbnQgXVxuXG5oaWVyLXBhcnQgICAgID0gXCIvL1wiIGF1dGhvcml0eSBwYXRoLWFiZW1wdHlcbiAgICAgICAgICAgICAgLyBwYXRoLWFic29sdXRlXG4gICAgICAgICAgICAgIC8gcGF0aC1yb290bGVzc1xuICAgICAgICAgICAgICAvIHBhdGgtZW1wdHlcblxuc2NoZW1lICAgICAgICA9IEFMUEhBICooIEFMUEhBIC8gRElHSVQgLyBcIitcIiAvIFwiLVwiIC8gXCIuXCIgKVxuXG5hdXRob3JpdHkgICAgID0gWyB1c2VyaW5mbyBcIkBcIiBdIGhvc3QgWyBcIjpcIiBwb3J0IF1cbnVzZXJpbmZvICAgICAgPSAqKCB1bnJlc2VydmVkIC8gcGN0LWVuY29kZWQgLyBzdWItZGVsaW1zIC8gXCI6XCIgKVxuaG9zdCAgICAgICAgICA9IElQLWxpdGVyYWwgLyBJUHY0YWRkcmVzcyAvIHJlZy1uYW1lXG5wb3J0ICAgICAgICAgID0gKkRJR0lUXG5cbklQLWxpdGVyYWwgICAgPSBcIltcIiAoIElQdjZhZGRyZXNzIC8gSVB2RnV0dXJlICApIFwiXVwiXG5cbklQdkZ1dHVyZSAgICAgPSBcInZcIiAxKkhFWERJRyBcIi5cIiAxKiggdW5yZXNlcnZlZCAvIHN1Yi1kZWxpbXMgLyBcIjpcIiApXG5cbklQdjZhZGRyZXNzICAgPSAgICAgICAgICAgICAgICAgICAgICAgICAgICA2KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgICAgICAgICAgIC8gICAgICAgICAgICAgICAgICAgICAgIFwiOjpcIiA1KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgICAgICAgICAgIC8gWyAgICAgICAgICAgICAgIGgxNiBdIFwiOjpcIiA0KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgICAgICAgICAgIC8gWyAqMSggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiIDMoIGgxNiBcIjpcIiApIGxzMzJcbiAgICAgICAgICAgICAgLyBbICoyKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMiggaDE2IFwiOlwiICkgbHMzMlxuICAgICAgICAgICAgICAvIFsgKjMoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICBoMTYgXCI6XCIgICBsczMyXG4gICAgICAgICAgICAgIC8gWyAqNCggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgICAgICAgICAgICBsczMyXG4gICAgICAgICAgICAgIC8gWyAqNSggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgICAgICAgICAgICBoMTZcbiAgICAgICAgICAgICAgLyBbICo2KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCJcblxuaDE2ICAgICAgICAgICA9IDEqNEhFWERJR1xubHMzMiAgICAgICAgICA9ICggaDE2IFwiOlwiIGgxNiApIC8gSVB2NGFkZHJlc3NcbklQdjRhZGRyZXNzICAgPSBkZWMtb2N0ZXQgXCIuXCIgZGVjLW9jdGV0IFwiLlwiIGRlYy1vY3RldCBcIi5cIiBkZWMtb2N0ZXRcbmRlYy1vY3RldCAgICAgPSBESUdJVCAgICAgICAgICAgICAgICAgOyAwLTlcbiAgICAgICAgICAgICAgICAgLyAleDMxLTM5IERJR0lUICAgICAgICAgOyAxMC05OVxuICAgICAgICAgICAgICAgICAvIFwiMVwiIDJESUdJVCAgICAgICAgICAgIDsgMTAwLTE5OVxuICAgICAgICAgICAgICAgICAvIFwiMlwiICV4MzAtMzQgRElHSVQgICAgIDsgMjAwLTI0OVxuICAgICAgICAgICAgICAgICAvIFwiMjVcIiAleDMwLTM1ICAgICAgICAgIDsgMjUwLTI1NVxuXG5yZWctbmFtZSAgICAgID0gKiggdW5yZXNlcnZlZCAvIHBjdC1lbmNvZGVkIC8gc3ViLWRlbGltcyApXG5cbnBhdGgtYWJlbXB0eSAgPSAqKCBcIi9cIiBzZWdtZW50IClcbnBhdGgtYWJzb2x1dGUgPSBcIi9cIiBbIHNlZ21lbnQtbnogKiggXCIvXCIgc2VnbWVudCApIF1cbnBhdGgtcm9vdGxlc3MgPSBzZWdtZW50LW56ICooIFwiL1wiIHNlZ21lbnQgKVxucGF0aC1lbXB0eSAgICA9IDBwY2hhclxuXG5zZWdtZW50ICAgICAgID0gKnBjaGFyXG5zZWdtZW50LW56ICAgID0gMSpwY2hhclxuXG5wY2hhciAgICAgICAgID0gdW5yZXNlcnZlZCAvIHBjdC1lbmNvZGVkIC8gc3ViLWRlbGltcyAvIFwiOlwiIC8gXCJAXCJcblxucXVlcnkgICAgICAgICA9ICooIHBjaGFyIC8gXCIvXCIgLyBcIj9cIiApXG5cbmZyYWdtZW50ICAgICAgPSAqKCBwY2hhciAvIFwiL1wiIC8gXCI/XCIgKVxuXG5wY3QtZW5jb2RlZCAgID0gXCIlXCIgSEVYRElHIEhFWERJR1xuXG51bnJlc2VydmVkICAgID0gQUxQSEEgLyBESUdJVCAvIFwiLVwiIC8gXCIuXCIgLyBcIl9cIiAvIFwiflwiXG5yZXNlcnZlZCAgICAgID0gZ2VuLWRlbGltcyAvIHN1Yi1kZWxpbXNcbmdlbi1kZWxpbXMgICAgPSBcIjpcIiAvIFwiL1wiIC8gXCI/XCIgLyBcIiNcIiAvIFwiW1wiIC8gXCJdXCIgLyBcIkBcIlxuc3ViLWRlbGltcyAgICA9IFwiIVwiIC8gXCIkXCIgLyBcIiZcIiAvIFwiJ1wiIC8gXCIoXCIgLyBcIilcIlxuICAgICAgICAgICAgICAvIFwiKlwiIC8gXCIrXCIgLyBcIixcIiAvIFwiO1wiIC8gXCI9XCJcblxuOyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbjsgUkZDIDMzMzlcblxuZGF0ZS1mdWxseWVhciAgID0gNERJR0lUXG5kYXRlLW1vbnRoICAgICAgPSAyRElHSVQgIDsgMDEtMTJcbmRhdGUtbWRheSAgICAgICA9IDJESUdJVCAgOyAwMS0yOCwgMDEtMjksIDAxLTMwLCAwMS0zMSBiYXNlZCBvblxuICAgICAgICAgICAgICAgICAgICAgICAgICA7IG1vbnRoL3llYXJcbnRpbWUtaG91ciAgICAgICA9IDJESUdJVCAgOyAwMC0yM1xudGltZS1taW51dGUgICAgID0gMkRJR0lUICA7IDAwLTU5XG50aW1lLXNlY29uZCAgICAgPSAyRElHSVQgIDsgMDAtNTgsIDAwLTU5LCAwMC02MCBiYXNlZCBvbiBsZWFwIHNlY29uZFxuICAgICAgICAgICAgICAgICAgICAgICAgICA7IHJ1bGVzXG50aW1lLXNlY2ZyYWMgICAgPSBcIi5cIiAxKkRJR0lUXG50aW1lLW51bW9mZnNldCAgPSAoXCIrXCIgLyBcIi1cIikgdGltZS1ob3VyIFwiOlwiIHRpbWUtbWludXRlXG50aW1lLW9mZnNldCAgICAgPSBcIlpcIiAvIHRpbWUtbnVtb2Zmc2V0XG5cbnBhcnRpYWwtdGltZSAgICA9IHRpbWUtaG91ciBcIjpcIiB0aW1lLW1pbnV0ZSBcIjpcIiB0aW1lLXNlY29uZFxuICAgICAgICAgICAgICAgICAgW3RpbWUtc2VjZnJhY11cbmZ1bGwtZGF0ZSAgICAgICA9IGRhdGUtZnVsbHllYXIgXCItXCIgZGF0ZS1tb250aCBcIi1cIiBkYXRlLW1kYXlcbmZ1bGwtdGltZSAgICAgICA9IHBhcnRpYWwtdGltZSB0aW1lLW9mZnNldFxuXG5kYXRlLXRpbWUgICAgICAgPSBmdWxsLWRhdGUgXCJUXCIgZnVsbC10aW1lXG5cbjsgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG47IFJGQyA1MjM0XG5cbkFMUEhBICAgICAgICAgID0gICV4NDEtNUEgLyAleDYxLTdBICAgOyBBLVogLyBhLXpcbkxGICAgICAgICAgICAgID0gICV4MEFcbiAgICAgICAgICAgICAgICAgIDsgbGluZWZlZWRcbkRJR0lUICAgICAgICAgID0gICV4MzAtMzlcbiAgICAgICAgICAgICAgICAgIDsgMC05XG5IRVhESUcgICAgICAgICA9ICBESUdJVCAvIFwiQVwiIC8gXCJCXCIgLyBcIkNcIiAvIFwiRFwiIC8gXCJFXCIgLyBcIkZcIlxuYDtcbmNsYXNzIFBhcnNlZE1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKG1zZykge1xuICAgICAgICBjb25zdCBhcGkgPSBuZXcgYXBpXzEuZGVmYXVsdChHUkFNTUFSKTtcbiAgICAgICAgYXBpLmdlbmVyYXRlKCk7XG4gICAgICAgIGlmIChhcGkuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihhcGkuZXJyb3JzVG9Bc2NpaSgpKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYXBpLmxpbmVzVG9Bc2NpaSgpKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGFwaS5kaXNwbGF5QXR0cmlidXRlRXJyb3JzKCkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBQk5GIGdyYW1tYXIgaGFzIGVycm9yc2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdyYW1tYXJPYmogPSBhcGkudG9PYmplY3QoKTtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IG5vZGVfZXhwb3J0c18xLmRlZmF1bHQucGFyc2VyKCk7XG4gICAgICAgIHBhcnNlci5hc3QgPSBuZXcgbm9kZV9leHBvcnRzXzEuZGVmYXVsdC5hc3QoKTtcbiAgICAgICAgY29uc3QgaWQgPSBub2RlX2V4cG9ydHNfMS5kZWZhdWx0LmlkcztcbiAgICAgICAgY29uc3QgZG9tYWluID0gZnVuY3Rpb24gKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUxlbmd0aCwgZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5kb21haW4gPSBub2RlX2V4cG9ydHNfMS5kZWZhdWx0LnV0aWxzLmNoYXJzVG9TdHJpbmcoY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICAgICAgcGFyc2VyLmFzdC5jYWxsYmFja3MuZG9tYWluID0gZG9tYWluO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gZnVuY3Rpb24gKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUxlbmd0aCwgZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5hZGRyZXNzID0gbm9kZV9leHBvcnRzXzEuZGVmYXVsdC51dGlscy5jaGFyc1RvU3RyaW5nKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHBhcnNlci5hc3QuY2FsbGJhY2tzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICBjb25zdCBzdGF0ZW1lbnQgPSBmdW5jdGlvbiAoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlTGVuZ3RoLCBkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnN0YXRlbWVudCA9IG5vZGVfZXhwb3J0c18xLmRlZmF1bHQudXRpbHMuY2hhcnNUb1N0cmluZyhjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgICAgICBwYXJzZXIuYXN0LmNhbGxiYWNrcy5zdGF0ZW1lbnQgPSBzdGF0ZW1lbnQ7XG4gICAgICAgIGNvbnN0IHVyaSA9IGZ1bmN0aW9uIChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VMZW5ndGgsIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgICAgICAgICAgIGlmICghZGF0YS51cmkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS51cmkgPSBub2RlX2V4cG9ydHNfMS5kZWZhdWx0LnV0aWxzLmNoYXJzVG9TdHJpbmcoY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VMZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHBhcnNlci5hc3QuY2FsbGJhY2tzLnVyaSA9IHVyaTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IGZ1bmN0aW9uIChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VMZW5ndGgsIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgICAgICAgICAgIGRhdGEudmVyc2lvbiA9IG5vZGVfZXhwb3J0c18xLmRlZmF1bHQudXRpbHMuY2hhcnNUb1N0cmluZyhjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgICAgICBwYXJzZXIuYXN0LmNhbGxiYWNrcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgY29uc3QgY2hhaW5JZCA9IGZ1bmN0aW9uIChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VMZW5ndGgsIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgICAgICAgICAgIGRhdGEuY2hhaW5JZCA9IHBhcnNlSW50KG5vZGVfZXhwb3J0c18xLmRlZmF1bHQudXRpbHMuY2hhcnNUb1N0cmluZyhjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICAgICAgcGFyc2VyLmFzdC5jYWxsYmFja3NbJ2NoYWluLWlkJ10gPSBjaGFpbklkO1xuICAgICAgICBjb25zdCBub25jZSA9IGZ1bmN0aW9uIChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VMZW5ndGgsIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgICAgICAgICAgIGRhdGEubm9uY2UgPSBub2RlX2V4cG9ydHNfMS5kZWZhdWx0LnV0aWxzLmNoYXJzVG9TdHJpbmcoY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICAgICAgcGFyc2VyLmFzdC5jYWxsYmFja3Mubm9uY2UgPSBub25jZTtcbiAgICAgICAgY29uc3QgaXNzdWVkQXQgPSBmdW5jdGlvbiAoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlTGVuZ3RoLCBkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmlzc3VlZEF0ID0gbm9kZV9leHBvcnRzXzEuZGVmYXVsdC51dGlscy5jaGFyc1RvU3RyaW5nKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHBhcnNlci5hc3QuY2FsbGJhY2tzWydpc3N1ZWQtYXQnXSA9IGlzc3VlZEF0O1xuICAgICAgICBjb25zdCBleHBpcmF0aW9uVGltZSA9IGZ1bmN0aW9uIChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VMZW5ndGgsIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgICAgICAgICAgIGRhdGEuZXhwaXJhdGlvblRpbWUgPSBub2RlX2V4cG9ydHNfMS5kZWZhdWx0LnV0aWxzLmNoYXJzVG9TdHJpbmcoY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICAgICAgcGFyc2VyLmFzdC5jYWxsYmFja3NbJ2V4cGlyYXRpb24tdGltZSddID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICAgIGNvbnN0IG5vdEJlZm9yZSA9IGZ1bmN0aW9uIChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VMZW5ndGgsIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgICAgICAgICAgIGRhdGEubm90QmVmb3JlID0gbm9kZV9leHBvcnRzXzEuZGVmYXVsdC51dGlscy5jaGFyc1RvU3RyaW5nKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHBhcnNlci5hc3QuY2FsbGJhY2tzWydub3QtYmVmb3JlJ10gPSBub3RCZWZvcmU7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IGZ1bmN0aW9uIChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VMZW5ndGgsIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgICAgICAgICAgIGRhdGEucmVxdWVzdElkID0gbm9kZV9leHBvcnRzXzEuZGVmYXVsdC51dGlscy5jaGFyc1RvU3RyaW5nKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHBhcnNlci5hc3QuY2FsbGJhY2tzWydyZXF1ZXN0LWlkJ10gPSByZXF1ZXN0SWQ7XG4gICAgICAgIGNvbnN0IHJlc291cmNlcyA9IGZ1bmN0aW9uIChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VMZW5ndGgsIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgICAgICAgICAgIGRhdGEucmVzb3VyY2VzID0gbm9kZV9leHBvcnRzXzEuZGVmYXVsdC51dGlsc1xuICAgICAgICAgICAgICAgICAgICAuY2hhcnNUb1N0cmluZyhjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDMpXG4gICAgICAgICAgICAgICAgICAgIC5zcGxpdCgnXFxuLSAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHBhcnNlci5hc3QuY2FsbGJhY2tzLnJlc291cmNlcyA9IHJlc291cmNlcztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyLnBhcnNlKGdyYW1tYXJPYmosICdzaWduLWluLXdpdGgtZXRoZXJldW0nLCBtc2cpO1xuICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWVzc2FnZTogJHtKU09OLnN0cmluZ2lmeShyZXN1bHQpfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0ge307XG4gICAgICAgIHBhcnNlci5hc3QudHJhbnNsYXRlKGVsZW1lbnRzKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZWxlbWVudHMpKSB7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUGFyc2VkTWVzc2FnZSA9IFBhcnNlZE1lc3NhZ2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@spruceid/siwe-parser/dist/abnf.js\n"));

/***/ }),

/***/ "./node_modules/@spruceid/siwe-parser/dist/parsers.js":
/*!************************************************************!*\
  !*** ./node_modules/@spruceid/siwe-parser/dist/parsers.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ParsedMessageRegExp = exports.ParsedMessage = void 0;\nconst abnf_1 = __webpack_require__(/*! ./abnf */ \"./node_modules/@spruceid/siwe-parser/dist/abnf.js\");\nObject.defineProperty(exports, \"ParsedMessage\", ({ enumerable: true, get: function () { return abnf_1.ParsedMessage; } }));\nconst regex_1 = __webpack_require__(/*! ./regex */ \"./node_modules/@spruceid/siwe-parser/dist/regex.js\");\nObject.defineProperty(exports, \"ParsedMessageRegExp\", ({ enumerable: true, get: function () { return regex_1.ParsedMessage; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNwcnVjZWlkL3Npd2UtcGFyc2VyL2Rpc3QvcGFyc2Vycy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyxxQkFBcUI7QUFDbkQsZUFBZSxtQkFBTyxDQUFDLGlFQUFRO0FBQy9CLGlEQUFnRCxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUN4SCxnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBUztBQUNqQyx1REFBc0QsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzcHJ1Y2VpZC9zaXdlLXBhcnNlci9kaXN0L3BhcnNlcnMuanM/NWU0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFyc2VkTWVzc2FnZVJlZ0V4cCA9IGV4cG9ydHMuUGFyc2VkTWVzc2FnZSA9IHZvaWQgMDtcbmNvbnN0IGFibmZfMSA9IHJlcXVpcmUoXCIuL2FibmZcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXJzZWRNZXNzYWdlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhYm5mXzEuUGFyc2VkTWVzc2FnZTsgfSB9KTtcbmNvbnN0IHJlZ2V4XzEgPSByZXF1aXJlKFwiLi9yZWdleFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBhcnNlZE1lc3NhZ2VSZWdFeHBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZ2V4XzEuUGFyc2VkTWVzc2FnZTsgfSB9KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@spruceid/siwe-parser/dist/parsers.js\n"));

/***/ }),

/***/ "./node_modules/@spruceid/siwe-parser/dist/regex.js":
/*!**********************************************************!*\
  !*** ./node_modules/@spruceid/siwe-parser/dist/regex.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ParsedMessage = void 0;\nconst DOMAIN = '(?<domain>([^?#]*)) wants you to sign in with your Ethereum account:';\nconst ADDRESS = '\\\\n(?<address>0x[a-zA-Z0-9]{40})\\\\n\\\\n';\nconst STATEMENT = '((?<statement>[^\\\\n]+)\\\\n)?';\nconst URI = '(([^:?#]+):)?(([^?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))';\nconst URI_LINE = `\\\\nURI: (?<uri>${URI}?)`;\nconst VERSION = '\\\\nVersion: (?<version>1)';\nconst CHAIN_ID = '\\\\nChain ID: (?<chainId>[0-9]+)';\nconst NONCE = '\\\\nNonce: (?<nonce>[a-zA-Z0-9]{8,})';\nconst DATETIME = `([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(([Zz])|([\\+|\\-]([01][0-9]|2[0-3]):[0-5][0-9]))`;\nconst ISSUED_AT = `\\\\nIssued At: (?<issuedAt>${DATETIME})`;\nconst EXPIRATION_TIME = `(\\\\nExpiration Time: (?<expirationTime>${DATETIME}))?`;\nconst NOT_BEFORE = `(\\\\nNot Before: (?<notBefore>${DATETIME}))?`;\nconst REQUEST_ID = \"(\\\\nRequest ID: (?<requestId>[-._~!$&'()*+,;=:@%a-zA-Z0-9]*))?\";\nconst RESOURCES = `(\\\\nResources:(?<resources>(\\\\n- ${URI}?)+))?`;\nconst MESSAGE = `^${DOMAIN}${ADDRESS}${STATEMENT}${URI_LINE}${VERSION}${CHAIN_ID}${NONCE}${ISSUED_AT}${EXPIRATION_TIME}${NOT_BEFORE}${REQUEST_ID}${RESOURCES}$`;\nclass ParsedMessage {\n    constructor(msg) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;\n        const REGEX = new RegExp(MESSAGE, 'g');\n        let match = REGEX.exec(msg);\n        if (!match) {\n            throw new Error('Message did not match the regular expression.');\n        }\n        this.match = match;\n        this.domain = (_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.domain;\n        this.address = (_b = match === null || match === void 0 ? void 0 : match.groups) === null || _b === void 0 ? void 0 : _b.address;\n        this.statement = (_c = match === null || match === void 0 ? void 0 : match.groups) === null || _c === void 0 ? void 0 : _c.statement;\n        this.uri = (_d = match === null || match === void 0 ? void 0 : match.groups) === null || _d === void 0 ? void 0 : _d.uri;\n        this.version = (_e = match === null || match === void 0 ? void 0 : match.groups) === null || _e === void 0 ? void 0 : _e.version;\n        this.nonce = (_f = match === null || match === void 0 ? void 0 : match.groups) === null || _f === void 0 ? void 0 : _f.nonce;\n        this.chainId = parseInt((_g = match === null || match === void 0 ? void 0 : match.groups) === null || _g === void 0 ? void 0 : _g.chainId);\n        this.issuedAt = (_h = match === null || match === void 0 ? void 0 : match.groups) === null || _h === void 0 ? void 0 : _h.issuedAt;\n        this.expirationTime = (_j = match === null || match === void 0 ? void 0 : match.groups) === null || _j === void 0 ? void 0 : _j.expirationTime;\n        this.notBefore = (_k = match === null || match === void 0 ? void 0 : match.groups) === null || _k === void 0 ? void 0 : _k.notBefore;\n        this.requestId = (_l = match === null || match === void 0 ? void 0 : match.groups) === null || _l === void 0 ? void 0 : _l.requestId;\n        this.resources = (_o = (_m = match === null || match === void 0 ? void 0 : match.groups) === null || _m === void 0 ? void 0 : _m.resources) === null || _o === void 0 ? void 0 : _o.split('\\n- ').slice(1);\n    }\n}\nexports.ParsedMessage = ParsedMessage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNwcnVjZWlkL3Npd2UtcGFyc2VyL2Rpc3QvcmVnZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCO0FBQ0EsNkNBQTZDLEdBQUc7QUFDaEQ7QUFDQTtBQUNBLG1DQUFtQyxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQSw4Q0FBOEMsR0FBRztBQUNqRDtBQUNBLCtDQUErQyxTQUFTO0FBQ3hELGtFQUFrRSxTQUFTO0FBQzNFLG1EQUFtRCxTQUFTO0FBQzVELGdFQUFnRTtBQUNoRSxzREFBc0QsSUFBSTtBQUMxRCxvQkFBb0IsT0FBTyxFQUFFLFFBQVEsRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxnQkFBZ0IsRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLFVBQVU7QUFDN0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNwcnVjZWlkL3Npd2UtcGFyc2VyL2Rpc3QvcmVnZXguanM/ZWUzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFyc2VkTWVzc2FnZSA9IHZvaWQgMDtcbmNvbnN0IERPTUFJTiA9ICcoPzxkb21haW4+KFtePyNdKikpIHdhbnRzIHlvdSB0byBzaWduIGluIHdpdGggeW91ciBFdGhlcmV1bSBhY2NvdW50Oic7XG5jb25zdCBBRERSRVNTID0gJ1xcXFxuKD88YWRkcmVzcz4weFthLXpBLVowLTldezQwfSlcXFxcblxcXFxuJztcbmNvbnN0IFNUQVRFTUVOVCA9ICcoKD88c3RhdGVtZW50PlteXFxcXG5dKylcXFxcbik/JztcbmNvbnN0IFVSSSA9ICcoKFteOj8jXSspOik/KChbXj8jXSopKT8oW14/I10qKShcXFxcPyhbXiNdKikpPygjKC4qKSknO1xuY29uc3QgVVJJX0xJTkUgPSBgXFxcXG5VUkk6ICg/PHVyaT4ke1VSSX0/KWA7XG5jb25zdCBWRVJTSU9OID0gJ1xcXFxuVmVyc2lvbjogKD88dmVyc2lvbj4xKSc7XG5jb25zdCBDSEFJTl9JRCA9ICdcXFxcbkNoYWluIElEOiAoPzxjaGFpbklkPlswLTldKyknO1xuY29uc3QgTk9OQ0UgPSAnXFxcXG5Ob25jZTogKD88bm9uY2U+W2EtekEtWjAtOV17OCx9KSc7XG5jb25zdCBEQVRFVElNRSA9IGAoWzAtOV0rKS0oMFsxLTldfDFbMDEyXSktKDBbMS05XXxbMTJdWzAtOV18M1swMV0pW1R0XShbMDFdWzAtOV18MlswLTNdKTooWzAtNV1bMC05XSk6KFswLTVdWzAtOV18NjApKFxcLlswLTldKyk/KChbWnpdKXwoW1xcK3xcXC1dKFswMV1bMC05XXwyWzAtM10pOlswLTVdWzAtOV0pKWA7XG5jb25zdCBJU1NVRURfQVQgPSBgXFxcXG5Jc3N1ZWQgQXQ6ICg/PGlzc3VlZEF0PiR7REFURVRJTUV9KWA7XG5jb25zdCBFWFBJUkFUSU9OX1RJTUUgPSBgKFxcXFxuRXhwaXJhdGlvbiBUaW1lOiAoPzxleHBpcmF0aW9uVGltZT4ke0RBVEVUSU1FfSkpP2A7XG5jb25zdCBOT1RfQkVGT1JFID0gYChcXFxcbk5vdCBCZWZvcmU6ICg/PG5vdEJlZm9yZT4ke0RBVEVUSU1FfSkpP2A7XG5jb25zdCBSRVFVRVNUX0lEID0gXCIoXFxcXG5SZXF1ZXN0IElEOiAoPzxyZXF1ZXN0SWQ+Wy0uX34hJCYnKCkqKyw7PTpAJWEtekEtWjAtOV0qKSk/XCI7XG5jb25zdCBSRVNPVVJDRVMgPSBgKFxcXFxuUmVzb3VyY2VzOig/PHJlc291cmNlcz4oXFxcXG4tICR7VVJJfT8pKykpP2A7XG5jb25zdCBNRVNTQUdFID0gYF4ke0RPTUFJTn0ke0FERFJFU1N9JHtTVEFURU1FTlR9JHtVUklfTElORX0ke1ZFUlNJT059JHtDSEFJTl9JRH0ke05PTkNFfSR7SVNTVUVEX0FUfSR7RVhQSVJBVElPTl9USU1FfSR7Tk9UX0JFRk9SRX0ke1JFUVVFU1RfSUR9JHtSRVNPVVJDRVN9JGA7XG5jbGFzcyBQYXJzZWRNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX20sIF9vO1xuICAgICAgICBjb25zdCBSRUdFWCA9IG5ldyBSZWdFeHAoTUVTU0FHRSwgJ2cnKTtcbiAgICAgICAgbGV0IG1hdGNoID0gUkVHRVguZXhlYyhtc2cpO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lc3NhZ2UgZGlkIG5vdCBtYXRjaCB0aGUgcmVndWxhciBleHByZXNzaW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgdGhpcy5kb21haW4gPSAoX2EgPSBtYXRjaCA9PT0gbnVsbCB8fCBtYXRjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF0Y2guZ3JvdXBzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZG9tYWluO1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSAoX2IgPSBtYXRjaCA9PT0gbnVsbCB8fCBtYXRjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF0Y2guZ3JvdXBzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWRkcmVzcztcbiAgICAgICAgdGhpcy5zdGF0ZW1lbnQgPSAoX2MgPSBtYXRjaCA9PT0gbnVsbCB8fCBtYXRjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF0Y2guZ3JvdXBzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc3RhdGVtZW50O1xuICAgICAgICB0aGlzLnVyaSA9IChfZCA9IG1hdGNoID09PSBudWxsIHx8IG1hdGNoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXRjaC5ncm91cHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC51cmk7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IChfZSA9IG1hdGNoID09PSBudWxsIHx8IG1hdGNoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXRjaC5ncm91cHMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS52ZXJzaW9uO1xuICAgICAgICB0aGlzLm5vbmNlID0gKF9mID0gbWF0Y2ggPT09IG51bGwgfHwgbWF0Y2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hdGNoLmdyb3VwcykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLm5vbmNlO1xuICAgICAgICB0aGlzLmNoYWluSWQgPSBwYXJzZUludCgoX2cgPSBtYXRjaCA9PT0gbnVsbCB8fCBtYXRjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF0Y2guZ3JvdXBzKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuY2hhaW5JZCk7XG4gICAgICAgIHRoaXMuaXNzdWVkQXQgPSAoX2ggPSBtYXRjaCA9PT0gbnVsbCB8fCBtYXRjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF0Y2guZ3JvdXBzKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guaXNzdWVkQXQ7XG4gICAgICAgIHRoaXMuZXhwaXJhdGlvblRpbWUgPSAoX2ogPSBtYXRjaCA9PT0gbnVsbCB8fCBtYXRjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF0Y2guZ3JvdXBzKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ouZXhwaXJhdGlvblRpbWU7XG4gICAgICAgIHRoaXMubm90QmVmb3JlID0gKF9rID0gbWF0Y2ggPT09IG51bGwgfHwgbWF0Y2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hdGNoLmdyb3VwcykgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rLm5vdEJlZm9yZTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SWQgPSAoX2wgPSBtYXRjaCA9PT0gbnVsbCB8fCBtYXRjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF0Y2guZ3JvdXBzKSA9PT0gbnVsbCB8fCBfbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2wucmVxdWVzdElkO1xuICAgICAgICB0aGlzLnJlc291cmNlcyA9IChfbyA9IChfbSA9IG1hdGNoID09PSBudWxsIHx8IG1hdGNoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXRjaC5ncm91cHMpID09PSBudWxsIHx8IF9tID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbS5yZXNvdXJjZXMpID09PSBudWxsIHx8IF9vID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfby5zcGxpdCgnXFxuLSAnKS5zbGljZSgxKTtcbiAgICB9XG59XG5leHBvcnRzLlBhcnNlZE1lc3NhZ2UgPSBQYXJzZWRNZXNzYWdlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@spruceid/siwe-parser/dist/regex.js\n"));

/***/ }),

/***/ "./node_modules/@stablelib/binary/lib/binary.js":
/*!******************************************************!*\
  !*** ./node_modules/@stablelib/binary/lib/binary.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Package binary provides functions for encoding and decoding numbers in byte arrays.\n */\nvar int_1 = __webpack_require__(/*! @stablelib/int */ \"./node_modules/@stablelib/int/lib/int.js\");\n// TODO(dchest): add asserts for correct value ranges and array offsets.\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * signed 16-bit integer and returns it.\n */\nfunction readInt16BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return (((array[offset + 0] << 8) | array[offset + 1]) << 16) >> 16;\n}\nexports.readInt16BE = readInt16BE;\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * unsigned 16-bit integer and returns it.\n */\nfunction readUint16BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return ((array[offset + 0] << 8) | array[offset + 1]) >>> 0;\n}\nexports.readUint16BE = readUint16BE;\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * signed 16-bit integer and returns it.\n */\nfunction readInt16LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return (((array[offset + 1] << 8) | array[offset]) << 16) >> 16;\n}\nexports.readInt16LE = readInt16LE;\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * unsigned 16-bit integer and returns it.\n */\nfunction readUint16LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return ((array[offset + 1] << 8) | array[offset]) >>> 0;\n}\nexports.readUint16LE = readUint16LE;\n/**\n * Writes 2-byte big-endian representation of 16-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint16BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(2); }\n    if (offset === void 0) { offset = 0; }\n    out[offset + 0] = value >>> 8;\n    out[offset + 1] = value >>> 0;\n    return out;\n}\nexports.writeUint16BE = writeUint16BE;\nexports.writeInt16BE = writeUint16BE;\n/**\n * Writes 2-byte little-endian representation of 16-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint16LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(2); }\n    if (offset === void 0) { offset = 0; }\n    out[offset + 0] = value >>> 0;\n    out[offset + 1] = value >>> 8;\n    return out;\n}\nexports.writeUint16LE = writeUint16LE;\nexports.writeInt16LE = writeUint16LE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * signed 32-bit integer and returns it.\n */\nfunction readInt32BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return (array[offset] << 24) |\n        (array[offset + 1] << 16) |\n        (array[offset + 2] << 8) |\n        array[offset + 3];\n}\nexports.readInt32BE = readInt32BE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * unsigned 32-bit integer and returns it.\n */\nfunction readUint32BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return ((array[offset] << 24) |\n        (array[offset + 1] << 16) |\n        (array[offset + 2] << 8) |\n        array[offset + 3]) >>> 0;\n}\nexports.readUint32BE = readUint32BE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * signed 32-bit integer and returns it.\n */\nfunction readInt32LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return (array[offset + 3] << 24) |\n        (array[offset + 2] << 16) |\n        (array[offset + 1] << 8) |\n        array[offset];\n}\nexports.readInt32LE = readInt32LE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * unsigned 32-bit integer and returns it.\n */\nfunction readUint32LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return ((array[offset + 3] << 24) |\n        (array[offset + 2] << 16) |\n        (array[offset + 1] << 8) |\n        array[offset]) >>> 0;\n}\nexports.readUint32LE = readUint32LE;\n/**\n * Writes 4-byte big-endian representation of 32-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint32BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(4); }\n    if (offset === void 0) { offset = 0; }\n    out[offset + 0] = value >>> 24;\n    out[offset + 1] = value >>> 16;\n    out[offset + 2] = value >>> 8;\n    out[offset + 3] = value >>> 0;\n    return out;\n}\nexports.writeUint32BE = writeUint32BE;\nexports.writeInt32BE = writeUint32BE;\n/**\n * Writes 4-byte little-endian representation of 32-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint32LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(4); }\n    if (offset === void 0) { offset = 0; }\n    out[offset + 0] = value >>> 0;\n    out[offset + 1] = value >>> 8;\n    out[offset + 2] = value >>> 16;\n    out[offset + 3] = value >>> 24;\n    return out;\n}\nexports.writeUint32LE = writeUint32LE;\nexports.writeInt32LE = writeUint32LE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\nfunction readInt64BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var hi = readInt32BE(array, offset);\n    var lo = readInt32BE(array, offset + 4);\n    return hi * 0x100000000 + lo - ((lo >> 31) * 0x100000000);\n}\nexports.readInt64BE = readInt64BE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\nfunction readUint64BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var hi = readUint32BE(array, offset);\n    var lo = readUint32BE(array, offset + 4);\n    return hi * 0x100000000 + lo;\n}\nexports.readUint64BE = readUint64BE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\nfunction readInt64LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var lo = readInt32LE(array, offset);\n    var hi = readInt32LE(array, offset + 4);\n    return hi * 0x100000000 + lo - ((lo >> 31) * 0x100000000);\n}\nexports.readInt64LE = readInt64LE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\nfunction readUint64LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var lo = readUint32LE(array, offset);\n    var hi = readUint32LE(array, offset + 4);\n    return hi * 0x100000000 + lo;\n}\nexports.readUint64LE = readUint64LE;\n/**\n * Writes 8-byte big-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint64BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(8); }\n    if (offset === void 0) { offset = 0; }\n    writeUint32BE(value / 0x100000000 >>> 0, out, offset);\n    writeUint32BE(value >>> 0, out, offset + 4);\n    return out;\n}\nexports.writeUint64BE = writeUint64BE;\nexports.writeInt64BE = writeUint64BE;\n/**\n * Writes 8-byte little-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint64LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(8); }\n    if (offset === void 0) { offset = 0; }\n    writeUint32LE(value >>> 0, out, offset);\n    writeUint32LE(value / 0x100000000 >>> 0, out, offset + 4);\n    return out;\n}\nexports.writeUint64LE = writeUint64LE;\nexports.writeInt64LE = writeUint64LE;\n/**\n * Reads bytes from array starting at offset as big-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\nfunction readUintBE(bitLength, array, offset) {\n    if (offset === void 0) { offset = 0; }\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"readUintBE supports only bitLengths divisible by 8\");\n    }\n    if (bitLength / 8 > array.length - offset) {\n        throw new Error(\"readUintBE: array is too short for the given bitLength\");\n    }\n    var result = 0;\n    var mul = 1;\n    for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {\n        result += array[i] * mul;\n        mul *= 256;\n    }\n    return result;\n}\nexports.readUintBE = readUintBE;\n/**\n * Reads bytes from array starting at offset as little-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\nfunction readUintLE(bitLength, array, offset) {\n    if (offset === void 0) { offset = 0; }\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"readUintLE supports only bitLengths divisible by 8\");\n    }\n    if (bitLength / 8 > array.length - offset) {\n        throw new Error(\"readUintLE: array is too short for the given bitLength\");\n    }\n    var result = 0;\n    var mul = 1;\n    for (var i = offset; i < offset + bitLength / 8; i++) {\n        result += array[i] * mul;\n        mul *= 256;\n    }\n    return result;\n}\nexports.readUintLE = readUintLE;\n/**\n * Writes a big-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\nfunction writeUintBE(bitLength, value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(bitLength / 8); }\n    if (offset === void 0) { offset = 0; }\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"writeUintBE supports only bitLengths divisible by 8\");\n    }\n    if (!int_1.isSafeInteger(value)) {\n        throw new Error(\"writeUintBE value must be an integer\");\n    }\n    var div = 1;\n    for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {\n        out[i] = (value / div) & 0xff;\n        div *= 256;\n    }\n    return out;\n}\nexports.writeUintBE = writeUintBE;\n/**\n * Writes a little-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\nfunction writeUintLE(bitLength, value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(bitLength / 8); }\n    if (offset === void 0) { offset = 0; }\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"writeUintLE supports only bitLengths divisible by 8\");\n    }\n    if (!int_1.isSafeInteger(value)) {\n        throw new Error(\"writeUintLE value must be an integer\");\n    }\n    var div = 1;\n    for (var i = offset; i < offset + bitLength / 8; i++) {\n        out[i] = (value / div) & 0xff;\n        div *= 256;\n    }\n    return out;\n}\nexports.writeUintLE = writeUintLE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * 32-bit floating-point number and returns it.\n */\nfunction readFloat32BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat32(offset);\n}\nexports.readFloat32BE = readFloat32BE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * 32-bit floating-point number and returns it.\n */\nfunction readFloat32LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat32(offset, true);\n}\nexports.readFloat32LE = readFloat32LE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\nfunction readFloat64BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat64(offset);\n}\nexports.readFloat64BE = readFloat64BE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\nfunction readFloat64LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat64(offset, true);\n}\nexports.readFloat64LE = readFloat64LE;\n/**\n * Writes 4-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat32BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(4); }\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat32(offset, value);\n    return out;\n}\nexports.writeFloat32BE = writeFloat32BE;\n/**\n * Writes 4-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat32LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(4); }\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat32(offset, value, true);\n    return out;\n}\nexports.writeFloat32LE = writeFloat32LE;\n/**\n * Writes 8-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat64BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(8); }\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat64(offset, value);\n    return out;\n}\nexports.writeFloat64BE = writeFloat64BE;\n/**\n * Writes 8-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat64LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(8); }\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat64(offset, value, true);\n    return out;\n}\nexports.writeFloat64LE = writeFloat64LE;\n//# sourceMappingURL=binary.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN0YWJsZWxpYi9iaW5hcnkvbGliL2JpbmFyeS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLGdFQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRCQUE0QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsYUFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNEJBQTRCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN0YWJsZWxpYi9iaW5hcnkvbGliL2JpbmFyeS5qcz9iNWI1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChDKSAyMDE2IERtaXRyeSBDaGVzdG55a2hcbi8vIE1JVCBMaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGZvciBkZXRhaWxzLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBQYWNrYWdlIGJpbmFyeSBwcm92aWRlcyBmdW5jdGlvbnMgZm9yIGVuY29kaW5nIGFuZCBkZWNvZGluZyBudW1iZXJzIGluIGJ5dGUgYXJyYXlzLlxuICovXG52YXIgaW50XzEgPSByZXF1aXJlKFwiQHN0YWJsZWxpYi9pbnRcIik7XG4vLyBUT0RPKGRjaGVzdCk6IGFkZCBhc3NlcnRzIGZvciBjb3JyZWN0IHZhbHVlIHJhbmdlcyBhbmQgYXJyYXkgb2Zmc2V0cy5cbi8qKlxuICogUmVhZHMgMiBieXRlcyBmcm9tIGFycmF5IHN0YXJ0aW5nIGF0IG9mZnNldCBhcyBiaWctZW5kaWFuXG4gKiBzaWduZWQgMTYtYml0IGludGVnZXIgYW5kIHJldHVybnMgaXQuXG4gKi9cbmZ1bmN0aW9uIHJlYWRJbnQxNkJFKGFycmF5LCBvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsgb2Zmc2V0ID0gMDsgfVxuICAgIHJldHVybiAoKChhcnJheVtvZmZzZXQgKyAwXSA8PCA4KSB8IGFycmF5W29mZnNldCArIDFdKSA8PCAxNikgPj4gMTY7XG59XG5leHBvcnRzLnJlYWRJbnQxNkJFID0gcmVhZEludDE2QkU7XG4vKipcbiAqIFJlYWRzIDIgYnl0ZXMgZnJvbSBhcnJheSBzdGFydGluZyBhdCBvZmZzZXQgYXMgYmlnLWVuZGlhblxuICogdW5zaWduZWQgMTYtYml0IGludGVnZXIgYW5kIHJldHVybnMgaXQuXG4gKi9cbmZ1bmN0aW9uIHJlYWRVaW50MTZCRShhcnJheSwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9IDA7IH1cbiAgICByZXR1cm4gKChhcnJheVtvZmZzZXQgKyAwXSA8PCA4KSB8IGFycmF5W29mZnNldCArIDFdKSA+Pj4gMDtcbn1cbmV4cG9ydHMucmVhZFVpbnQxNkJFID0gcmVhZFVpbnQxNkJFO1xuLyoqXG4gKiBSZWFkcyAyIGJ5dGVzIGZyb20gYXJyYXkgc3RhcnRpbmcgYXQgb2Zmc2V0IGFzIGxpdHRsZS1lbmRpYW5cbiAqIHNpZ25lZCAxNi1iaXQgaW50ZWdlciBhbmQgcmV0dXJucyBpdC5cbiAqL1xuZnVuY3Rpb24gcmVhZEludDE2TEUoYXJyYXksIG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgeyBvZmZzZXQgPSAwOyB9XG4gICAgcmV0dXJuICgoKGFycmF5W29mZnNldCArIDFdIDw8IDgpIHwgYXJyYXlbb2Zmc2V0XSkgPDwgMTYpID4+IDE2O1xufVxuZXhwb3J0cy5yZWFkSW50MTZMRSA9IHJlYWRJbnQxNkxFO1xuLyoqXG4gKiBSZWFkcyAyIGJ5dGVzIGZyb20gYXJyYXkgc3RhcnRpbmcgYXQgb2Zmc2V0IGFzIGxpdHRsZS1lbmRpYW5cbiAqIHVuc2lnbmVkIDE2LWJpdCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0LlxuICovXG5mdW5jdGlvbiByZWFkVWludDE2TEUoYXJyYXksIG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgeyBvZmZzZXQgPSAwOyB9XG4gICAgcmV0dXJuICgoYXJyYXlbb2Zmc2V0ICsgMV0gPDwgOCkgfCBhcnJheVtvZmZzZXRdKSA+Pj4gMDtcbn1cbmV4cG9ydHMucmVhZFVpbnQxNkxFID0gcmVhZFVpbnQxNkxFO1xuLyoqXG4gKiBXcml0ZXMgMi1ieXRlIGJpZy1lbmRpYW4gcmVwcmVzZW50YXRpb24gb2YgMTYtYml0IHVuc2lnbmVkXG4gKiB2YWx1ZSB0byBieXRlIGFycmF5IHN0YXJ0aW5nIGF0IG9mZnNldC5cbiAqXG4gKiBJZiBieXRlIGFycmF5IGlzIG5vdCBnaXZlbiwgY3JlYXRlcyBhIG5ldyAyLWJ5dGUgb25lLlxuICpcbiAqIFJldHVybnMgdGhlIG91dHB1dCBieXRlIGFycmF5LlxuICovXG5mdW5jdGlvbiB3cml0ZVVpbnQxNkJFKHZhbHVlLCBvdXQsIG9mZnNldCkge1xuICAgIGlmIChvdXQgPT09IHZvaWQgMCkgeyBvdXQgPSBuZXcgVWludDhBcnJheSgyKTsgfVxuICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgeyBvZmZzZXQgPSAwOyB9XG4gICAgb3V0W29mZnNldCArIDBdID0gdmFsdWUgPj4+IDg7XG4gICAgb3V0W29mZnNldCArIDFdID0gdmFsdWUgPj4+IDA7XG4gICAgcmV0dXJuIG91dDtcbn1cbmV4cG9ydHMud3JpdGVVaW50MTZCRSA9IHdyaXRlVWludDE2QkU7XG5leHBvcnRzLndyaXRlSW50MTZCRSA9IHdyaXRlVWludDE2QkU7XG4vKipcbiAqIFdyaXRlcyAyLWJ5dGUgbGl0dGxlLWVuZGlhbiByZXByZXNlbnRhdGlvbiBvZiAxNi1iaXQgdW5zaWduZWRcbiAqIHZhbHVlIHRvIGFycmF5IHN0YXJ0aW5nIGF0IG9mZnNldC5cbiAqXG4gKiBJZiBieXRlIGFycmF5IGlzIG5vdCBnaXZlbiwgY3JlYXRlcyBhIG5ldyAyLWJ5dGUgb25lLlxuICpcbiAqIFJldHVybnMgdGhlIG91dHB1dCBieXRlIGFycmF5LlxuICovXG5mdW5jdGlvbiB3cml0ZVVpbnQxNkxFKHZhbHVlLCBvdXQsIG9mZnNldCkge1xuICAgIGlmIChvdXQgPT09IHZvaWQgMCkgeyBvdXQgPSBuZXcgVWludDhBcnJheSgyKTsgfVxuICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgeyBvZmZzZXQgPSAwOyB9XG4gICAgb3V0W29mZnNldCArIDBdID0gdmFsdWUgPj4+IDA7XG4gICAgb3V0W29mZnNldCArIDFdID0gdmFsdWUgPj4+IDg7XG4gICAgcmV0dXJuIG91dDtcbn1cbmV4cG9ydHMud3JpdGVVaW50MTZMRSA9IHdyaXRlVWludDE2TEU7XG5leHBvcnRzLndyaXRlSW50MTZMRSA9IHdyaXRlVWludDE2TEU7XG4vKipcbiAqIFJlYWRzIDQgYnl0ZXMgZnJvbSBhcnJheSBzdGFydGluZyBhdCBvZmZzZXQgYXMgYmlnLWVuZGlhblxuICogc2lnbmVkIDMyLWJpdCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0LlxuICovXG5mdW5jdGlvbiByZWFkSW50MzJCRShhcnJheSwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9IDA7IH1cbiAgICByZXR1cm4gKGFycmF5W29mZnNldF0gPDwgMjQpIHxcbiAgICAgICAgKGFycmF5W29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgICAgIChhcnJheVtvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgICAgIGFycmF5W29mZnNldCArIDNdO1xufVxuZXhwb3J0cy5yZWFkSW50MzJCRSA9IHJlYWRJbnQzMkJFO1xuLyoqXG4gKiBSZWFkcyA0IGJ5dGVzIGZyb20gYXJyYXkgc3RhcnRpbmcgYXQgb2Zmc2V0IGFzIGJpZy1lbmRpYW5cbiAqIHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0LlxuICovXG5mdW5jdGlvbiByZWFkVWludDMyQkUoYXJyYXksIG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgeyBvZmZzZXQgPSAwOyB9XG4gICAgcmV0dXJuICgoYXJyYXlbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICAgICAoYXJyYXlbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAgICAgKGFycmF5W29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgM10pID4+PiAwO1xufVxuZXhwb3J0cy5yZWFkVWludDMyQkUgPSByZWFkVWludDMyQkU7XG4vKipcbiAqIFJlYWRzIDQgYnl0ZXMgZnJvbSBhcnJheSBzdGFydGluZyBhdCBvZmZzZXQgYXMgbGl0dGxlLWVuZGlhblxuICogc2lnbmVkIDMyLWJpdCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0LlxuICovXG5mdW5jdGlvbiByZWFkSW50MzJMRShhcnJheSwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9IDA7IH1cbiAgICByZXR1cm4gKGFycmF5W29mZnNldCArIDNdIDw8IDI0KSB8XG4gICAgICAgIChhcnJheVtvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICAgICAoYXJyYXlbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgICBhcnJheVtvZmZzZXRdO1xufVxuZXhwb3J0cy5yZWFkSW50MzJMRSA9IHJlYWRJbnQzMkxFO1xuLyoqXG4gKiBSZWFkcyA0IGJ5dGVzIGZyb20gYXJyYXkgc3RhcnRpbmcgYXQgb2Zmc2V0IGFzIGxpdHRsZS1lbmRpYW5cbiAqIHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0LlxuICovXG5mdW5jdGlvbiByZWFkVWludDMyTEUoYXJyYXksIG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgeyBvZmZzZXQgPSAwOyB9XG4gICAgcmV0dXJuICgoYXJyYXlbb2Zmc2V0ICsgM10gPDwgMjQpIHxcbiAgICAgICAgKGFycmF5W29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgICAgIChhcnJheVtvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAgIGFycmF5W29mZnNldF0pID4+PiAwO1xufVxuZXhwb3J0cy5yZWFkVWludDMyTEUgPSByZWFkVWludDMyTEU7XG4vKipcbiAqIFdyaXRlcyA0LWJ5dGUgYmlnLWVuZGlhbiByZXByZXNlbnRhdGlvbiBvZiAzMi1iaXQgdW5zaWduZWRcbiAqIHZhbHVlIHRvIGJ5dGUgYXJyYXkgc3RhcnRpbmcgYXQgb2Zmc2V0LlxuICpcbiAqIElmIGJ5dGUgYXJyYXkgaXMgbm90IGdpdmVuLCBjcmVhdGVzIGEgbmV3IDQtYnl0ZSBvbmUuXG4gKlxuICogUmV0dXJucyB0aGUgb3V0cHV0IGJ5dGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlVWludDMyQkUodmFsdWUsIG91dCwgb2Zmc2V0KSB7XG4gICAgaWYgKG91dCA9PT0gdm9pZCAwKSB7IG91dCA9IG5ldyBVaW50OEFycmF5KDQpOyB9XG4gICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9IDA7IH1cbiAgICBvdXRbb2Zmc2V0ICsgMF0gPSB2YWx1ZSA+Pj4gMjQ7XG4gICAgb3V0W29mZnNldCArIDFdID0gdmFsdWUgPj4+IDE2O1xuICAgIG91dFtvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiA4O1xuICAgIG91dFtvZmZzZXQgKyAzXSA9IHZhbHVlID4+PiAwO1xuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnRzLndyaXRlVWludDMyQkUgPSB3cml0ZVVpbnQzMkJFO1xuZXhwb3J0cy53cml0ZUludDMyQkUgPSB3cml0ZVVpbnQzMkJFO1xuLyoqXG4gKiBXcml0ZXMgNC1ieXRlIGxpdHRsZS1lbmRpYW4gcmVwcmVzZW50YXRpb24gb2YgMzItYml0IHVuc2lnbmVkXG4gKiB2YWx1ZSB0byBhcnJheSBzdGFydGluZyBhdCBvZmZzZXQuXG4gKlxuICogSWYgYnl0ZSBhcnJheSBpcyBub3QgZ2l2ZW4sIGNyZWF0ZXMgYSBuZXcgNC1ieXRlIG9uZS5cbiAqXG4gKiBSZXR1cm5zIHRoZSBvdXRwdXQgYnl0ZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gd3JpdGVVaW50MzJMRSh2YWx1ZSwgb3V0LCBvZmZzZXQpIHtcbiAgICBpZiAob3V0ID09PSB2b2lkIDApIHsgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoNCk7IH1cbiAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsgb2Zmc2V0ID0gMDsgfVxuICAgIG91dFtvZmZzZXQgKyAwXSA9IHZhbHVlID4+PiAwO1xuICAgIG91dFtvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiA4O1xuICAgIG91dFtvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiAxNjtcbiAgICBvdXRbb2Zmc2V0ICsgM10gPSB2YWx1ZSA+Pj4gMjQ7XG4gICAgcmV0dXJuIG91dDtcbn1cbmV4cG9ydHMud3JpdGVVaW50MzJMRSA9IHdyaXRlVWludDMyTEU7XG5leHBvcnRzLndyaXRlSW50MzJMRSA9IHdyaXRlVWludDMyTEU7XG4vKipcbiAqIFJlYWRzIDggYnl0ZXMgZnJvbSBhcnJheSBzdGFydGluZyBhdCBvZmZzZXQgYXMgYmlnLWVuZGlhblxuICogc2lnbmVkIDY0LWJpdCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0LlxuICpcbiAqIElNUE9SVEFOVDogZHVlIHRvIEphdmFTY3JpcHQgbGltaXRhdGlvbiwgc3VwcG9ydHMgZXhhY3RcbiAqIG51bWJlcnMgaW4gcmFuZ2UgLTkwMDcxOTkyNTQ3NDA5OTEgdG8gOTAwNzE5OTI1NDc0MDk5MS5cbiAqIElmIHRoZSBudW1iZXIgc3RvcmVkIGluIHRoZSBieXRlIGFycmF5IGlzIG91dHNpZGUgdGhpcyByYW5nZSxcbiAqIHRoZSByZXN1bHQgaXMgbm90IGV4YWN0LlxuICovXG5mdW5jdGlvbiByZWFkSW50NjRCRShhcnJheSwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9IDA7IH1cbiAgICB2YXIgaGkgPSByZWFkSW50MzJCRShhcnJheSwgb2Zmc2V0KTtcbiAgICB2YXIgbG8gPSByZWFkSW50MzJCRShhcnJheSwgb2Zmc2V0ICsgNCk7XG4gICAgcmV0dXJuIGhpICogMHgxMDAwMDAwMDAgKyBsbyAtICgobG8gPj4gMzEpICogMHgxMDAwMDAwMDApO1xufVxuZXhwb3J0cy5yZWFkSW50NjRCRSA9IHJlYWRJbnQ2NEJFO1xuLyoqXG4gKiBSZWFkcyA4IGJ5dGVzIGZyb20gYXJyYXkgc3RhcnRpbmcgYXQgb2Zmc2V0IGFzIGJpZy1lbmRpYW5cbiAqIHVuc2lnbmVkIDY0LWJpdCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0LlxuICpcbiAqIElNUE9SVEFOVDogZHVlIHRvIEphdmFTY3JpcHQgbGltaXRhdGlvbiwgc3VwcG9ydHMgdmFsdWVzIHVwIHRvIDJeNTMtMS5cbiAqL1xuZnVuY3Rpb24gcmVhZFVpbnQ2NEJFKGFycmF5LCBvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsgb2Zmc2V0ID0gMDsgfVxuICAgIHZhciBoaSA9IHJlYWRVaW50MzJCRShhcnJheSwgb2Zmc2V0KTtcbiAgICB2YXIgbG8gPSByZWFkVWludDMyQkUoYXJyYXksIG9mZnNldCArIDQpO1xuICAgIHJldHVybiBoaSAqIDB4MTAwMDAwMDAwICsgbG87XG59XG5leHBvcnRzLnJlYWRVaW50NjRCRSA9IHJlYWRVaW50NjRCRTtcbi8qKlxuICogUmVhZHMgOCBieXRlcyBmcm9tIGFycmF5IHN0YXJ0aW5nIGF0IG9mZnNldCBhcyBsaXR0bGUtZW5kaWFuXG4gKiBzaWduZWQgNjQtYml0IGludGVnZXIgYW5kIHJldHVybnMgaXQuXG4gKlxuICogSU1QT1JUQU5UOiBkdWUgdG8gSmF2YVNjcmlwdCBsaW1pdGF0aW9uLCBzdXBwb3J0cyBleGFjdFxuICogbnVtYmVycyBpbiByYW5nZSAtOTAwNzE5OTI1NDc0MDk5MSB0byA5MDA3MTk5MjU0NzQwOTkxLlxuICogSWYgdGhlIG51bWJlciBzdG9yZWQgaW4gdGhlIGJ5dGUgYXJyYXkgaXMgb3V0c2lkZSB0aGlzIHJhbmdlLFxuICogdGhlIHJlc3VsdCBpcyBub3QgZXhhY3QuXG4gKi9cbmZ1bmN0aW9uIHJlYWRJbnQ2NExFKGFycmF5LCBvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsgb2Zmc2V0ID0gMDsgfVxuICAgIHZhciBsbyA9IHJlYWRJbnQzMkxFKGFycmF5LCBvZmZzZXQpO1xuICAgIHZhciBoaSA9IHJlYWRJbnQzMkxFKGFycmF5LCBvZmZzZXQgKyA0KTtcbiAgICByZXR1cm4gaGkgKiAweDEwMDAwMDAwMCArIGxvIC0gKChsbyA+PiAzMSkgKiAweDEwMDAwMDAwMCk7XG59XG5leHBvcnRzLnJlYWRJbnQ2NExFID0gcmVhZEludDY0TEU7XG4vKipcbiAqIFJlYWRzIDggYnl0ZXMgZnJvbSBhcnJheSBzdGFydGluZyBhdCBvZmZzZXQgYXMgbGl0dGxlLWVuZGlhblxuICogdW5zaWduZWQgNjQtYml0IGludGVnZXIgYW5kIHJldHVybnMgaXQuXG4gKlxuICogSU1QT1JUQU5UOiBkdWUgdG8gSmF2YVNjcmlwdCBsaW1pdGF0aW9uLCBzdXBwb3J0cyB2YWx1ZXMgdXAgdG8gMl41My0xLlxuICovXG5mdW5jdGlvbiByZWFkVWludDY0TEUoYXJyYXksIG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgeyBvZmZzZXQgPSAwOyB9XG4gICAgdmFyIGxvID0gcmVhZFVpbnQzMkxFKGFycmF5LCBvZmZzZXQpO1xuICAgIHZhciBoaSA9IHJlYWRVaW50MzJMRShhcnJheSwgb2Zmc2V0ICsgNCk7XG4gICAgcmV0dXJuIGhpICogMHgxMDAwMDAwMDAgKyBsbztcbn1cbmV4cG9ydHMucmVhZFVpbnQ2NExFID0gcmVhZFVpbnQ2NExFO1xuLyoqXG4gKiBXcml0ZXMgOC1ieXRlIGJpZy1lbmRpYW4gcmVwcmVzZW50YXRpb24gb2YgNjQtYml0IHVuc2lnbmVkXG4gKiB2YWx1ZSB0byBieXRlIGFycmF5IHN0YXJ0aW5nIGF0IG9mZnNldC5cbiAqXG4gKiBEdWUgdG8gSmF2YVNjcmlwdCBsaW1pdGF0aW9uLCBzdXBwb3J0cyB2YWx1ZXMgdXAgdG8gMl41My0xLlxuICpcbiAqIElmIGJ5dGUgYXJyYXkgaXMgbm90IGdpdmVuLCBjcmVhdGVzIGEgbmV3IDgtYnl0ZSBvbmUuXG4gKlxuICogUmV0dXJucyB0aGUgb3V0cHV0IGJ5dGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlVWludDY0QkUodmFsdWUsIG91dCwgb2Zmc2V0KSB7XG4gICAgaWYgKG91dCA9PT0gdm9pZCAwKSB7IG91dCA9IG5ldyBVaW50OEFycmF5KDgpOyB9XG4gICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9IDA7IH1cbiAgICB3cml0ZVVpbnQzMkJFKHZhbHVlIC8gMHgxMDAwMDAwMDAgPj4+IDAsIG91dCwgb2Zmc2V0KTtcbiAgICB3cml0ZVVpbnQzMkJFKHZhbHVlID4+PiAwLCBvdXQsIG9mZnNldCArIDQpO1xuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnRzLndyaXRlVWludDY0QkUgPSB3cml0ZVVpbnQ2NEJFO1xuZXhwb3J0cy53cml0ZUludDY0QkUgPSB3cml0ZVVpbnQ2NEJFO1xuLyoqXG4gKiBXcml0ZXMgOC1ieXRlIGxpdHRsZS1lbmRpYW4gcmVwcmVzZW50YXRpb24gb2YgNjQtYml0IHVuc2lnbmVkXG4gKiB2YWx1ZSB0byBieXRlIGFycmF5IHN0YXJ0aW5nIGF0IG9mZnNldC5cbiAqXG4gKiBEdWUgdG8gSmF2YVNjcmlwdCBsaW1pdGF0aW9uLCBzdXBwb3J0cyB2YWx1ZXMgdXAgdG8gMl41My0xLlxuICpcbiAqIElmIGJ5dGUgYXJyYXkgaXMgbm90IGdpdmVuLCBjcmVhdGVzIGEgbmV3IDgtYnl0ZSBvbmUuXG4gKlxuICogUmV0dXJucyB0aGUgb3V0cHV0IGJ5dGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlVWludDY0TEUodmFsdWUsIG91dCwgb2Zmc2V0KSB7XG4gICAgaWYgKG91dCA9PT0gdm9pZCAwKSB7IG91dCA9IG5ldyBVaW50OEFycmF5KDgpOyB9XG4gICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9IDA7IH1cbiAgICB3cml0ZVVpbnQzMkxFKHZhbHVlID4+PiAwLCBvdXQsIG9mZnNldCk7XG4gICAgd3JpdGVVaW50MzJMRSh2YWx1ZSAvIDB4MTAwMDAwMDAwID4+PiAwLCBvdXQsIG9mZnNldCArIDQpO1xuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnRzLndyaXRlVWludDY0TEUgPSB3cml0ZVVpbnQ2NExFO1xuZXhwb3J0cy53cml0ZUludDY0TEUgPSB3cml0ZVVpbnQ2NExFO1xuLyoqXG4gKiBSZWFkcyBieXRlcyBmcm9tIGFycmF5IHN0YXJ0aW5nIGF0IG9mZnNldCBhcyBiaWctZW5kaWFuXG4gKiB1bnNpZ25lZCBiaXRMZW4tYml0IGludGVnZXIgYW5kIHJldHVybnMgaXQuXG4gKlxuICogU3VwcG9ydHMgYml0IGxlbmd0aHMgZGl2aXNpYmxlIGJ5IDgsIHVwIHRvIDQ4LlxuICovXG5mdW5jdGlvbiByZWFkVWludEJFKGJpdExlbmd0aCwgYXJyYXksIG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgeyBvZmZzZXQgPSAwOyB9XG4gICAgLy8gVE9ETyhkY2hlc3QpOiBpbXBsZW1lbnQgc3VwcG9ydCBmb3IgYml0TGVuZ3RocyBub24tZGl2aXNpYmxlIGJ5IDhcbiAgICBpZiAoYml0TGVuZ3RoICUgOCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWFkVWludEJFIHN1cHBvcnRzIG9ubHkgYml0TGVuZ3RocyBkaXZpc2libGUgYnkgOFwiKTtcbiAgICB9XG4gICAgaWYgKGJpdExlbmd0aCAvIDggPiBhcnJheS5sZW5ndGggLSBvZmZzZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVhZFVpbnRCRTogYXJyYXkgaXMgdG9vIHNob3J0IGZvciB0aGUgZ2l2ZW4gYml0TGVuZ3RoXCIpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICB2YXIgbXVsID0gMTtcbiAgICBmb3IgKHZhciBpID0gYml0TGVuZ3RoIC8gOCArIG9mZnNldCAtIDE7IGkgPj0gb2Zmc2V0OyBpLS0pIHtcbiAgICAgICAgcmVzdWx0ICs9IGFycmF5W2ldICogbXVsO1xuICAgICAgICBtdWwgKj0gMjU2O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5yZWFkVWludEJFID0gcmVhZFVpbnRCRTtcbi8qKlxuICogUmVhZHMgYnl0ZXMgZnJvbSBhcnJheSBzdGFydGluZyBhdCBvZmZzZXQgYXMgbGl0dGxlLWVuZGlhblxuICogdW5zaWduZWQgYml0TGVuLWJpdCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0LlxuICpcbiAqIFN1cHBvcnRzIGJpdCBsZW5ndGhzIGRpdmlzaWJsZSBieSA4LCB1cCB0byA0OC5cbiAqL1xuZnVuY3Rpb24gcmVhZFVpbnRMRShiaXRMZW5ndGgsIGFycmF5LCBvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsgb2Zmc2V0ID0gMDsgfVxuICAgIC8vIFRPRE8oZGNoZXN0KTogaW1wbGVtZW50IHN1cHBvcnQgZm9yIGJpdExlbmd0aHMgbm9uLWRpdmlzaWJsZSBieSA4XG4gICAgaWYgKGJpdExlbmd0aCAlIDggIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVhZFVpbnRMRSBzdXBwb3J0cyBvbmx5IGJpdExlbmd0aHMgZGl2aXNpYmxlIGJ5IDhcIik7XG4gICAgfVxuICAgIGlmIChiaXRMZW5ndGggLyA4ID4gYXJyYXkubGVuZ3RoIC0gb2Zmc2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlYWRVaW50TEU6IGFycmF5IGlzIHRvbyBzaG9ydCBmb3IgdGhlIGdpdmVuIGJpdExlbmd0aFwiKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgdmFyIG11bCA9IDE7XG4gICAgZm9yICh2YXIgaSA9IG9mZnNldDsgaSA8IG9mZnNldCArIGJpdExlbmd0aCAvIDg7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gYXJyYXlbaV0gKiBtdWw7XG4gICAgICAgIG11bCAqPSAyNTY7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnJlYWRVaW50TEUgPSByZWFkVWludExFO1xuLyoqXG4gKiBXcml0ZXMgYSBiaWctZW5kaWFuIHJlcHJlc2VudGF0aW9uIG9mIGJpdExlbi1iaXQgdW5zaWduZWRcbiAqIHZhbHVlIHRvIGFycmF5IHN0YXJ0aW5nIGF0IG9mZnNldC5cbiAqXG4gKiBTdXBwb3J0cyBiaXQgbGVuZ3RocyBkaXZpc2libGUgYnkgOCwgdXAgdG8gNDguXG4gKlxuICogSWYgYnl0ZSBhcnJheSBpcyBub3QgZ2l2ZW4sIGNyZWF0ZXMgYSBuZXcgb25lLlxuICpcbiAqIFJldHVybnMgdGhlIG91dHB1dCBieXRlIGFycmF5LlxuICovXG5mdW5jdGlvbiB3cml0ZVVpbnRCRShiaXRMZW5ndGgsIHZhbHVlLCBvdXQsIG9mZnNldCkge1xuICAgIGlmIChvdXQgPT09IHZvaWQgMCkgeyBvdXQgPSBuZXcgVWludDhBcnJheShiaXRMZW5ndGggLyA4KTsgfVxuICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgeyBvZmZzZXQgPSAwOyB9XG4gICAgLy8gVE9ETyhkY2hlc3QpOiBpbXBsZW1lbnQgc3VwcG9ydCBmb3IgYml0TGVuZ3RocyBub24tZGl2aXNpYmxlIGJ5IDhcbiAgICBpZiAoYml0TGVuZ3RoICUgOCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3cml0ZVVpbnRCRSBzdXBwb3J0cyBvbmx5IGJpdExlbmd0aHMgZGl2aXNpYmxlIGJ5IDhcIik7XG4gICAgfVxuICAgIGlmICghaW50XzEuaXNTYWZlSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid3JpdGVVaW50QkUgdmFsdWUgbXVzdCBiZSBhbiBpbnRlZ2VyXCIpO1xuICAgIH1cbiAgICB2YXIgZGl2ID0gMTtcbiAgICBmb3IgKHZhciBpID0gYml0TGVuZ3RoIC8gOCArIG9mZnNldCAtIDE7IGkgPj0gb2Zmc2V0OyBpLS0pIHtcbiAgICAgICAgb3V0W2ldID0gKHZhbHVlIC8gZGl2KSAmIDB4ZmY7XG4gICAgICAgIGRpdiAqPSAyNTY7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnRzLndyaXRlVWludEJFID0gd3JpdGVVaW50QkU7XG4vKipcbiAqIFdyaXRlcyBhIGxpdHRsZS1lbmRpYW4gcmVwcmVzZW50YXRpb24gb2YgYml0TGVuLWJpdCB1bnNpZ25lZFxuICogdmFsdWUgdG8gYXJyYXkgc3RhcnRpbmcgYXQgb2Zmc2V0LlxuICpcbiAqIFN1cHBvcnRzIGJpdCBsZW5ndGhzIGRpdmlzaWJsZSBieSA4LCB1cCB0byA0OC5cbiAqXG4gKiBJZiBieXRlIGFycmF5IGlzIG5vdCBnaXZlbiwgY3JlYXRlcyBhIG5ldyBvbmUuXG4gKlxuICogUmV0dXJucyB0aGUgb3V0cHV0IGJ5dGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlVWludExFKGJpdExlbmd0aCwgdmFsdWUsIG91dCwgb2Zmc2V0KSB7XG4gICAgaWYgKG91dCA9PT0gdm9pZCAwKSB7IG91dCA9IG5ldyBVaW50OEFycmF5KGJpdExlbmd0aCAvIDgpOyB9XG4gICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9IDA7IH1cbiAgICAvLyBUT0RPKGRjaGVzdCk6IGltcGxlbWVudCBzdXBwb3J0IGZvciBiaXRMZW5ndGhzIG5vbi1kaXZpc2libGUgYnkgOFxuICAgIGlmIChiaXRMZW5ndGggJSA4ICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIndyaXRlVWludExFIHN1cHBvcnRzIG9ubHkgYml0TGVuZ3RocyBkaXZpc2libGUgYnkgOFwiKTtcbiAgICB9XG4gICAgaWYgKCFpbnRfMS5pc1NhZmVJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3cml0ZVVpbnRMRSB2YWx1ZSBtdXN0IGJlIGFuIGludGVnZXJcIik7XG4gICAgfVxuICAgIHZhciBkaXYgPSAxO1xuICAgIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCBvZmZzZXQgKyBiaXRMZW5ndGggLyA4OyBpKyspIHtcbiAgICAgICAgb3V0W2ldID0gKHZhbHVlIC8gZGl2KSAmIDB4ZmY7XG4gICAgICAgIGRpdiAqPSAyNTY7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnRzLndyaXRlVWludExFID0gd3JpdGVVaW50TEU7XG4vKipcbiAqIFJlYWRzIDQgYnl0ZXMgZnJvbSBhcnJheSBzdGFydGluZyBhdCBvZmZzZXQgYXMgYmlnLWVuZGlhblxuICogMzItYml0IGZsb2F0aW5nLXBvaW50IG51bWJlciBhbmQgcmV0dXJucyBpdC5cbiAqL1xuZnVuY3Rpb24gcmVhZEZsb2F0MzJCRShhcnJheSwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9IDA7IH1cbiAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhhcnJheS5idWZmZXIsIGFycmF5LmJ5dGVPZmZzZXQsIGFycmF5LmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiB2aWV3LmdldEZsb2F0MzIob2Zmc2V0KTtcbn1cbmV4cG9ydHMucmVhZEZsb2F0MzJCRSA9IHJlYWRGbG9hdDMyQkU7XG4vKipcbiAqIFJlYWRzIDQgYnl0ZXMgZnJvbSBhcnJheSBzdGFydGluZyBhdCBvZmZzZXQgYXMgbGl0dGxlLWVuZGlhblxuICogMzItYml0IGZsb2F0aW5nLXBvaW50IG51bWJlciBhbmQgcmV0dXJucyBpdC5cbiAqL1xuZnVuY3Rpb24gcmVhZEZsb2F0MzJMRShhcnJheSwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9IDA7IH1cbiAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhhcnJheS5idWZmZXIsIGFycmF5LmJ5dGVPZmZzZXQsIGFycmF5LmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiB2aWV3LmdldEZsb2F0MzIob2Zmc2V0LCB0cnVlKTtcbn1cbmV4cG9ydHMucmVhZEZsb2F0MzJMRSA9IHJlYWRGbG9hdDMyTEU7XG4vKipcbiAqIFJlYWRzIDggYnl0ZXMgZnJvbSBhcnJheSBzdGFydGluZyBhdCBvZmZzZXQgYXMgYmlnLWVuZGlhblxuICogNjQtYml0IGZsb2F0aW5nLXBvaW50IG51bWJlciAoXCJkb3VibGVcIikgYW5kIHJldHVybnMgaXQuXG4gKi9cbmZ1bmN0aW9uIHJlYWRGbG9hdDY0QkUoYXJyYXksIG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgeyBvZmZzZXQgPSAwOyB9XG4gICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXkuYnVmZmVyLCBhcnJheS5ieXRlT2Zmc2V0LCBhcnJheS5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gdmlldy5nZXRGbG9hdDY0KG9mZnNldCk7XG59XG5leHBvcnRzLnJlYWRGbG9hdDY0QkUgPSByZWFkRmxvYXQ2NEJFO1xuLyoqXG4gKiBSZWFkcyA4IGJ5dGVzIGZyb20gYXJyYXkgc3RhcnRpbmcgYXQgb2Zmc2V0IGFzIGxpdHRsZS1lbmRpYW5cbiAqIDY0LWJpdCBmbG9hdGluZy1wb2ludCBudW1iZXIgKFwiZG91YmxlXCIpIGFuZCByZXR1cm5zIGl0LlxuICovXG5mdW5jdGlvbiByZWFkRmxvYXQ2NExFKGFycmF5LCBvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsgb2Zmc2V0ID0gMDsgfVxuICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGFycmF5LmJ1ZmZlciwgYXJyYXkuYnl0ZU9mZnNldCwgYXJyYXkuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHZpZXcuZ2V0RmxvYXQ2NChvZmZzZXQsIHRydWUpO1xufVxuZXhwb3J0cy5yZWFkRmxvYXQ2NExFID0gcmVhZEZsb2F0NjRMRTtcbi8qKlxuICogV3JpdGVzIDQtYnl0ZSBiaWctZW5kaWFuIGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIG9mIHZhbHVlXG4gKiB0byBieXRlIGFycmF5IHN0YXJ0aW5nIGF0IG9mZnNldC5cbiAqXG4gKiBJZiBieXRlIGFycmF5IGlzIG5vdCBnaXZlbiwgY3JlYXRlcyBhIG5ldyA0LWJ5dGUgb25lLlxuICpcbiAqIFJldHVybnMgdGhlIG91dHB1dCBieXRlIGFycmF5LlxuICovXG5mdW5jdGlvbiB3cml0ZUZsb2F0MzJCRSh2YWx1ZSwgb3V0LCBvZmZzZXQpIHtcbiAgICBpZiAob3V0ID09PSB2b2lkIDApIHsgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoNCk7IH1cbiAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsgb2Zmc2V0ID0gMDsgfVxuICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KG91dC5idWZmZXIsIG91dC5ieXRlT2Zmc2V0LCBvdXQuYnl0ZUxlbmd0aCk7XG4gICAgdmlldy5zZXRGbG9hdDMyKG9mZnNldCwgdmFsdWUpO1xuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnRzLndyaXRlRmxvYXQzMkJFID0gd3JpdGVGbG9hdDMyQkU7XG4vKipcbiAqIFdyaXRlcyA0LWJ5dGUgbGl0dGxlLWVuZGlhbiBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiBvZiB2YWx1ZVxuICogdG8gYnl0ZSBhcnJheSBzdGFydGluZyBhdCBvZmZzZXQuXG4gKlxuICogSWYgYnl0ZSBhcnJheSBpcyBub3QgZ2l2ZW4sIGNyZWF0ZXMgYSBuZXcgNC1ieXRlIG9uZS5cbiAqXG4gKiBSZXR1cm5zIHRoZSBvdXRwdXQgYnl0ZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gd3JpdGVGbG9hdDMyTEUodmFsdWUsIG91dCwgb2Zmc2V0KSB7XG4gICAgaWYgKG91dCA9PT0gdm9pZCAwKSB7IG91dCA9IG5ldyBVaW50OEFycmF5KDQpOyB9XG4gICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9IDA7IH1cbiAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhvdXQuYnVmZmVyLCBvdXQuYnl0ZU9mZnNldCwgb3V0LmJ5dGVMZW5ndGgpO1xuICAgIHZpZXcuc2V0RmxvYXQzMihvZmZzZXQsIHZhbHVlLCB0cnVlKTtcbiAgICByZXR1cm4gb3V0O1xufVxuZXhwb3J0cy53cml0ZUZsb2F0MzJMRSA9IHdyaXRlRmxvYXQzMkxFO1xuLyoqXG4gKiBXcml0ZXMgOC1ieXRlIGJpZy1lbmRpYW4gZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gb2YgdmFsdWVcbiAqIHRvIGJ5dGUgYXJyYXkgc3RhcnRpbmcgYXQgb2Zmc2V0LlxuICpcbiAqIElmIGJ5dGUgYXJyYXkgaXMgbm90IGdpdmVuLCBjcmVhdGVzIGEgbmV3IDgtYnl0ZSBvbmUuXG4gKlxuICogUmV0dXJucyB0aGUgb3V0cHV0IGJ5dGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlRmxvYXQ2NEJFKHZhbHVlLCBvdXQsIG9mZnNldCkge1xuICAgIGlmIChvdXQgPT09IHZvaWQgMCkgeyBvdXQgPSBuZXcgVWludDhBcnJheSg4KTsgfVxuICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgeyBvZmZzZXQgPSAwOyB9XG4gICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcob3V0LmJ1ZmZlciwgb3V0LmJ5dGVPZmZzZXQsIG91dC5ieXRlTGVuZ3RoKTtcbiAgICB2aWV3LnNldEZsb2F0NjQob2Zmc2V0LCB2YWx1ZSk7XG4gICAgcmV0dXJuIG91dDtcbn1cbmV4cG9ydHMud3JpdGVGbG9hdDY0QkUgPSB3cml0ZUZsb2F0NjRCRTtcbi8qKlxuICogV3JpdGVzIDgtYnl0ZSBsaXR0bGUtZW5kaWFuIGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIG9mIHZhbHVlXG4gKiB0byBieXRlIGFycmF5IHN0YXJ0aW5nIGF0IG9mZnNldC5cbiAqXG4gKiBJZiBieXRlIGFycmF5IGlzIG5vdCBnaXZlbiwgY3JlYXRlcyBhIG5ldyA4LWJ5dGUgb25lLlxuICpcbiAqIFJldHVybnMgdGhlIG91dHB1dCBieXRlIGFycmF5LlxuICovXG5mdW5jdGlvbiB3cml0ZUZsb2F0NjRMRSh2YWx1ZSwgb3V0LCBvZmZzZXQpIHtcbiAgICBpZiAob3V0ID09PSB2b2lkIDApIHsgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoOCk7IH1cbiAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsgb2Zmc2V0ID0gMDsgfVxuICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KG91dC5idWZmZXIsIG91dC5ieXRlT2Zmc2V0LCBvdXQuYnl0ZUxlbmd0aCk7XG4gICAgdmlldy5zZXRGbG9hdDY0KG9mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnRzLndyaXRlRmxvYXQ2NExFID0gd3JpdGVGbG9hdDY0TEU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5hcnkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@stablelib/binary/lib/binary.js\n"));

/***/ }),

/***/ "./node_modules/@stablelib/int/lib/int.js":
/*!************************************************!*\
  !*** ./node_modules/@stablelib/int/lib/int.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Package int provides helper functions for integerss.\n */\n// Shim using 16-bit pieces.\nfunction imulShim(a, b) {\n    var ah = (a >>> 16) & 0xffff, al = a & 0xffff;\n    var bh = (b >>> 16) & 0xffff, bl = b & 0xffff;\n    return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);\n}\n/** 32-bit integer multiplication.  */\n// Use system Math.imul if available, otherwise use our shim.\nexports.mul = Math.imul || imulShim;\n/** 32-bit integer addition.  */\nfunction add(a, b) {\n    return (a + b) | 0;\n}\nexports.add = add;\n/**  32-bit integer subtraction.  */\nfunction sub(a, b) {\n    return (a - b) | 0;\n}\nexports.sub = sub;\n/** 32-bit integer left rotation */\nfunction rotl(x, n) {\n    return x << n | x >>> (32 - n);\n}\nexports.rotl = rotl;\n/** 32-bit integer left rotation */\nfunction rotr(x, n) {\n    return x << (32 - n) | x >>> n;\n}\nexports.rotr = rotr;\nfunction isIntegerShim(n) {\n    return typeof n === \"number\" && isFinite(n) && Math.floor(n) === n;\n}\n/**\n * Returns true if the argument is an integer number.\n *\n * In ES2015, Number.isInteger.\n */\nexports.isInteger = Number.isInteger || isIntegerShim;\n/**\n *  Math.pow(2, 53) - 1\n *\n *  In ES2015 Number.MAX_SAFE_INTEGER.\n */\nexports.MAX_SAFE_INTEGER = 9007199254740991;\n/**\n * Returns true if the argument is a safe integer number\n * (-MIN_SAFE_INTEGER < number <= MAX_SAFE_INTEGER)\n *\n * In ES2015, Number.isSafeInteger.\n */\nexports.isSafeInteger = function (n) {\n    return exports.isInteger(n) && (n >= -exports.MAX_SAFE_INTEGER && n <= exports.MAX_SAFE_INTEGER);\n};\n//# sourceMappingURL=int.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN0YWJsZWxpYi9pbnQvbGliL2ludC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN0YWJsZWxpYi9pbnQvbGliL2ludC5qcz9iNGY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChDKSAyMDE2IERtaXRyeSBDaGVzdG55a2hcbi8vIE1JVCBMaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGZvciBkZXRhaWxzLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBQYWNrYWdlIGludCBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIGZvciBpbnRlZ2Vyc3MuXG4gKi9cbi8vIFNoaW0gdXNpbmcgMTYtYml0IHBpZWNlcy5cbmZ1bmN0aW9uIGltdWxTaGltKGEsIGIpIHtcbiAgICB2YXIgYWggPSAoYSA+Pj4gMTYpICYgMHhmZmZmLCBhbCA9IGEgJiAweGZmZmY7XG4gICAgdmFyIGJoID0gKGIgPj4+IDE2KSAmIDB4ZmZmZiwgYmwgPSBiICYgMHhmZmZmO1xuICAgIHJldHVybiAoKGFsICogYmwpICsgKCgoYWggKiBibCArIGFsICogYmgpIDw8IDE2KSA+Pj4gMCkgfCAwKTtcbn1cbi8qKiAzMi1iaXQgaW50ZWdlciBtdWx0aXBsaWNhdGlvbi4gICovXG4vLyBVc2Ugc3lzdGVtIE1hdGguaW11bCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1c2Ugb3VyIHNoaW0uXG5leHBvcnRzLm11bCA9IE1hdGguaW11bCB8fCBpbXVsU2hpbTtcbi8qKiAzMi1iaXQgaW50ZWdlciBhZGRpdGlvbi4gICovXG5mdW5jdGlvbiBhZGQoYSwgYikge1xuICAgIHJldHVybiAoYSArIGIpIHwgMDtcbn1cbmV4cG9ydHMuYWRkID0gYWRkO1xuLyoqICAzMi1iaXQgaW50ZWdlciBzdWJ0cmFjdGlvbi4gICovXG5mdW5jdGlvbiBzdWIoYSwgYikge1xuICAgIHJldHVybiAoYSAtIGIpIHwgMDtcbn1cbmV4cG9ydHMuc3ViID0gc3ViO1xuLyoqIDMyLWJpdCBpbnRlZ2VyIGxlZnQgcm90YXRpb24gKi9cbmZ1bmN0aW9uIHJvdGwoeCwgbikge1xuICAgIHJldHVybiB4IDw8IG4gfCB4ID4+PiAoMzIgLSBuKTtcbn1cbmV4cG9ydHMucm90bCA9IHJvdGw7XG4vKiogMzItYml0IGludGVnZXIgbGVmdCByb3RhdGlvbiAqL1xuZnVuY3Rpb24gcm90cih4LCBuKSB7XG4gICAgcmV0dXJuIHggPDwgKDMyIC0gbikgfCB4ID4+PiBuO1xufVxuZXhwb3J0cy5yb3RyID0gcm90cjtcbmZ1bmN0aW9uIGlzSW50ZWdlclNoaW0obikge1xuICAgIHJldHVybiB0eXBlb2YgbiA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZShuKSAmJiBNYXRoLmZsb29yKG4pID09PSBuO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGFuIGludGVnZXIgbnVtYmVyLlxuICpcbiAqIEluIEVTMjAxNSwgTnVtYmVyLmlzSW50ZWdlci5cbiAqL1xuZXhwb3J0cy5pc0ludGVnZXIgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IGlzSW50ZWdlclNoaW07XG4vKipcbiAqICBNYXRoLnBvdygyLCA1MykgLSAxXG4gKlxuICogIEluIEVTMjAxNSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUi5cbiAqL1xuZXhwb3J0cy5NQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhIHNhZmUgaW50ZWdlciBudW1iZXJcbiAqICgtTUlOX1NBRkVfSU5URUdFUiA8IG51bWJlciA8PSBNQVhfU0FGRV9JTlRFR0VSKVxuICpcbiAqIEluIEVTMjAxNSwgTnVtYmVyLmlzU2FmZUludGVnZXIuXG4gKi9cbmV4cG9ydHMuaXNTYWZlSW50ZWdlciA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuaXNJbnRlZ2VyKG4pICYmIChuID49IC1leHBvcnRzLk1BWF9TQUZFX0lOVEVHRVIgJiYgbiA8PSBleHBvcnRzLk1BWF9TQUZFX0lOVEVHRVIpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@stablelib/int/lib/int.js\n"));

/***/ }),

/***/ "./node_modules/@stablelib/random/lib/random.js":
/*!******************************************************!*\
  !*** ./node_modules/@stablelib/random/lib/random.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar system_1 = __webpack_require__(/*! ./source/system */ \"./node_modules/@stablelib/random/lib/source/system.js\");\nvar binary_1 = __webpack_require__(/*! @stablelib/binary */ \"./node_modules/@stablelib/binary/lib/binary.js\");\nvar wipe_1 = __webpack_require__(/*! @stablelib/wipe */ \"./node_modules/@stablelib/wipe/lib/wipe.js\");\nexports.defaultRandomSource = new system_1.SystemRandomSource();\nfunction randomBytes(length, prng) {\n    if (prng === void 0) { prng = exports.defaultRandomSource; }\n    return prng.randomBytes(length);\n}\nexports.randomBytes = randomBytes;\n/**\n * Returns a uniformly random unsigned 32-bit integer.\n */\nfunction randomUint32(prng) {\n    if (prng === void 0) { prng = exports.defaultRandomSource; }\n    // Generate 4-byte random buffer.\n    var buf = randomBytes(4, prng);\n    // Convert bytes from buffer into a 32-bit integer.\n    // It's not important which byte order to use, since\n    // the result is random.\n    var result = binary_1.readUint32LE(buf);\n    // Clean the buffer.\n    wipe_1.wipe(buf);\n    return result;\n}\nexports.randomUint32 = randomUint32;\n/** 62 alphanumeric characters for default charset of randomString() */\nvar ALPHANUMERIC = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n/**\n * Returns a uniform random string of the given length\n * with characters from the given charset.\n *\n * Charset must not have more than 256 characters.\n *\n * Default charset generates case-sensitive alphanumeric\n * strings (0-9, A-Z, a-z).\n */\nfunction randomString(length, charset, prng) {\n    if (charset === void 0) { charset = ALPHANUMERIC; }\n    if (prng === void 0) { prng = exports.defaultRandomSource; }\n    if (charset.length < 2) {\n        throw new Error(\"randomString charset is too short\");\n    }\n    if (charset.length > 256) {\n        throw new Error(\"randomString charset is too long\");\n    }\n    var out = '';\n    var charsLen = charset.length;\n    var maxByte = 256 - (256 % charsLen);\n    while (length > 0) {\n        var buf = randomBytes(Math.ceil(length * 256 / maxByte), prng);\n        for (var i = 0; i < buf.length && length > 0; i++) {\n            var randomByte = buf[i];\n            if (randomByte < maxByte) {\n                out += charset.charAt(randomByte % charsLen);\n                length--;\n            }\n        }\n        wipe_1.wipe(buf);\n    }\n    return out;\n}\nexports.randomString = randomString;\n/**\n * Returns uniform random string containing at least the given\n * number of bits of entropy.\n *\n * For example, randomStringForEntropy(128) will return a 22-character\n * alphanumeric string, while randomStringForEntropy(128, \"0123456789\")\n * will return a 39-character numeric string, both will contain at\n * least 128 bits of entropy.\n *\n * Default charset generates case-sensitive alphanumeric\n * strings (0-9, A-Z, a-z).\n */\nfunction randomStringForEntropy(bits, charset, prng) {\n    if (charset === void 0) { charset = ALPHANUMERIC; }\n    if (prng === void 0) { prng = exports.defaultRandomSource; }\n    var length = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));\n    return randomString(length, charset, prng);\n}\nexports.randomStringForEntropy = randomStringForEntropy;\n//# sourceMappingURL=random.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN0YWJsZWxpYi9yYW5kb20vbGliL3JhbmRvbS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxtQkFBTyxDQUFDLDhFQUFpQjtBQUN4QyxlQUFlLG1CQUFPLENBQUMseUVBQW1CO0FBQzFDLGFBQWEsbUJBQU8sQ0FBQyxtRUFBaUI7QUFDdEMsMkJBQTJCO0FBQzNCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3RhYmxlbGliL3JhbmRvbS9saWIvcmFuZG9tLmpzPzgzNTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTYgRG1pdHJ5IENoZXN0bnlraFxuLy8gTUlUIExpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgZm9yIGRldGFpbHMuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc3lzdGVtXzEgPSByZXF1aXJlKFwiLi9zb3VyY2Uvc3lzdGVtXCIpO1xudmFyIGJpbmFyeV8xID0gcmVxdWlyZShcIkBzdGFibGVsaWIvYmluYXJ5XCIpO1xudmFyIHdpcGVfMSA9IHJlcXVpcmUoXCJAc3RhYmxlbGliL3dpcGVcIik7XG5leHBvcnRzLmRlZmF1bHRSYW5kb21Tb3VyY2UgPSBuZXcgc3lzdGVtXzEuU3lzdGVtUmFuZG9tU291cmNlKCk7XG5mdW5jdGlvbiByYW5kb21CeXRlcyhsZW5ndGgsIHBybmcpIHtcbiAgICBpZiAocHJuZyA9PT0gdm9pZCAwKSB7IHBybmcgPSBleHBvcnRzLmRlZmF1bHRSYW5kb21Tb3VyY2U7IH1cbiAgICByZXR1cm4gcHJuZy5yYW5kb21CeXRlcyhsZW5ndGgpO1xufVxuZXhwb3J0cy5yYW5kb21CeXRlcyA9IHJhbmRvbUJ5dGVzO1xuLyoqXG4gKiBSZXR1cm5zIGEgdW5pZm9ybWx5IHJhbmRvbSB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tVWludDMyKHBybmcpIHtcbiAgICBpZiAocHJuZyA9PT0gdm9pZCAwKSB7IHBybmcgPSBleHBvcnRzLmRlZmF1bHRSYW5kb21Tb3VyY2U7IH1cbiAgICAvLyBHZW5lcmF0ZSA0LWJ5dGUgcmFuZG9tIGJ1ZmZlci5cbiAgICB2YXIgYnVmID0gcmFuZG9tQnl0ZXMoNCwgcHJuZyk7XG4gICAgLy8gQ29udmVydCBieXRlcyBmcm9tIGJ1ZmZlciBpbnRvIGEgMzItYml0IGludGVnZXIuXG4gICAgLy8gSXQncyBub3QgaW1wb3J0YW50IHdoaWNoIGJ5dGUgb3JkZXIgdG8gdXNlLCBzaW5jZVxuICAgIC8vIHRoZSByZXN1bHQgaXMgcmFuZG9tLlxuICAgIHZhciByZXN1bHQgPSBiaW5hcnlfMS5yZWFkVWludDMyTEUoYnVmKTtcbiAgICAvLyBDbGVhbiB0aGUgYnVmZmVyLlxuICAgIHdpcGVfMS53aXBlKGJ1Zik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucmFuZG9tVWludDMyID0gcmFuZG9tVWludDMyO1xuLyoqIDYyIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGZvciBkZWZhdWx0IGNoYXJzZXQgb2YgcmFuZG9tU3RyaW5nKCkgKi9cbnZhciBBTFBIQU5VTUVSSUMgPSBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCI7XG4vKipcbiAqIFJldHVybnMgYSB1bmlmb3JtIHJhbmRvbSBzdHJpbmcgb2YgdGhlIGdpdmVuIGxlbmd0aFxuICogd2l0aCBjaGFyYWN0ZXJzIGZyb20gdGhlIGdpdmVuIGNoYXJzZXQuXG4gKlxuICogQ2hhcnNldCBtdXN0IG5vdCBoYXZlIG1vcmUgdGhhbiAyNTYgY2hhcmFjdGVycy5cbiAqXG4gKiBEZWZhdWx0IGNoYXJzZXQgZ2VuZXJhdGVzIGNhc2Utc2Vuc2l0aXZlIGFscGhhbnVtZXJpY1xuICogc3RyaW5ncyAoMC05LCBBLVosIGEteikuXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbVN0cmluZyhsZW5ndGgsIGNoYXJzZXQsIHBybmcpIHtcbiAgICBpZiAoY2hhcnNldCA9PT0gdm9pZCAwKSB7IGNoYXJzZXQgPSBBTFBIQU5VTUVSSUM7IH1cbiAgICBpZiAocHJuZyA9PT0gdm9pZCAwKSB7IHBybmcgPSBleHBvcnRzLmRlZmF1bHRSYW5kb21Tb3VyY2U7IH1cbiAgICBpZiAoY2hhcnNldC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJhbmRvbVN0cmluZyBjaGFyc2V0IGlzIHRvbyBzaG9ydFwiKTtcbiAgICB9XG4gICAgaWYgKGNoYXJzZXQubGVuZ3RoID4gMjU2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJhbmRvbVN0cmluZyBjaGFyc2V0IGlzIHRvbyBsb25nXCIpO1xuICAgIH1cbiAgICB2YXIgb3V0ID0gJyc7XG4gICAgdmFyIGNoYXJzTGVuID0gY2hhcnNldC5sZW5ndGg7XG4gICAgdmFyIG1heEJ5dGUgPSAyNTYgLSAoMjU2ICUgY2hhcnNMZW4pO1xuICAgIHdoaWxlIChsZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBidWYgPSByYW5kb21CeXRlcyhNYXRoLmNlaWwobGVuZ3RoICogMjU2IC8gbWF4Qnl0ZSksIHBybmcpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGggJiYgbGVuZ3RoID4gMDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmFuZG9tQnl0ZSA9IGJ1ZltpXTtcbiAgICAgICAgICAgIGlmIChyYW5kb21CeXRlIDwgbWF4Qnl0ZSkge1xuICAgICAgICAgICAgICAgIG91dCArPSBjaGFyc2V0LmNoYXJBdChyYW5kb21CeXRlICUgY2hhcnNMZW4pO1xuICAgICAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdpcGVfMS53aXBlKGJ1Zik7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnRzLnJhbmRvbVN0cmluZyA9IHJhbmRvbVN0cmluZztcbi8qKlxuICogUmV0dXJucyB1bmlmb3JtIHJhbmRvbSBzdHJpbmcgY29udGFpbmluZyBhdCBsZWFzdCB0aGUgZ2l2ZW5cbiAqIG51bWJlciBvZiBiaXRzIG9mIGVudHJvcHkuXG4gKlxuICogRm9yIGV4YW1wbGUsIHJhbmRvbVN0cmluZ0ZvckVudHJvcHkoMTI4KSB3aWxsIHJldHVybiBhIDIyLWNoYXJhY3RlclxuICogYWxwaGFudW1lcmljIHN0cmluZywgd2hpbGUgcmFuZG9tU3RyaW5nRm9yRW50cm9weSgxMjgsIFwiMDEyMzQ1Njc4OVwiKVxuICogd2lsbCByZXR1cm4gYSAzOS1jaGFyYWN0ZXIgbnVtZXJpYyBzdHJpbmcsIGJvdGggd2lsbCBjb250YWluIGF0XG4gKiBsZWFzdCAxMjggYml0cyBvZiBlbnRyb3B5LlxuICpcbiAqIERlZmF1bHQgY2hhcnNldCBnZW5lcmF0ZXMgY2FzZS1zZW5zaXRpdmUgYWxwaGFudW1lcmljXG4gKiBzdHJpbmdzICgwLTksIEEtWiwgYS16KS5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tU3RyaW5nRm9yRW50cm9weShiaXRzLCBjaGFyc2V0LCBwcm5nKSB7XG4gICAgaWYgKGNoYXJzZXQgPT09IHZvaWQgMCkgeyBjaGFyc2V0ID0gQUxQSEFOVU1FUklDOyB9XG4gICAgaWYgKHBybmcgPT09IHZvaWQgMCkgeyBwcm5nID0gZXhwb3J0cy5kZWZhdWx0UmFuZG9tU291cmNlOyB9XG4gICAgdmFyIGxlbmd0aCA9IE1hdGguY2VpbChiaXRzIC8gKE1hdGgubG9nKGNoYXJzZXQubGVuZ3RoKSAvIE1hdGguTE4yKSk7XG4gICAgcmV0dXJuIHJhbmRvbVN0cmluZyhsZW5ndGgsIGNoYXJzZXQsIHBybmcpO1xufVxuZXhwb3J0cy5yYW5kb21TdHJpbmdGb3JFbnRyb3B5ID0gcmFuZG9tU3RyaW5nRm9yRW50cm9weTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhbmRvbS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@stablelib/random/lib/random.js\n"));

/***/ }),

/***/ "./node_modules/@stablelib/random/lib/source/browser.js":
/*!**************************************************************!*\
  !*** ./node_modules/@stablelib/random/lib/source/browser.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar QUOTA = 65536;\nvar BrowserRandomSource = /** @class */ (function () {\n    function BrowserRandomSource() {\n        this.isAvailable = false;\n        this.isInstantiated = false;\n        var browserCrypto = typeof self !== 'undefined'\n            ? (self.crypto || self.msCrypto) // IE11 has msCrypto\n            : null;\n        if (browserCrypto && browserCrypto.getRandomValues) {\n            this._crypto = browserCrypto;\n            this.isAvailable = true;\n            this.isInstantiated = true;\n        }\n    }\n    BrowserRandomSource.prototype.randomBytes = function (length) {\n        if (!this.isAvailable || !this._crypto) {\n            throw new Error(\"Browser random byte generator is not available.\");\n        }\n        var out = new Uint8Array(length);\n        for (var i = 0; i < out.length; i += QUOTA) {\n            this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));\n        }\n        return out;\n    };\n    return BrowserRandomSource;\n}());\nexports.BrowserRandomSource = BrowserRandomSource;\n//# sourceMappingURL=browser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN0YWJsZWxpYi9yYW5kb20vbGliL3NvdXJjZS9icm93c2VyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzdGFibGVsaWIvcmFuZG9tL2xpYi9zb3VyY2UvYnJvd3Nlci5qcz9iMmJjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChDKSAyMDE2IERtaXRyeSBDaGVzdG55a2hcbi8vIE1JVCBMaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGZvciBkZXRhaWxzLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFFVT1RBID0gNjU1MzY7XG52YXIgQnJvd3NlclJhbmRvbVNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCcm93c2VyUmFuZG9tU291cmNlKCkge1xuICAgICAgICB0aGlzLmlzQXZhaWxhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNJbnN0YW50aWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGJyb3dzZXJDcnlwdG8gPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gKHNlbGYuY3J5cHRvIHx8IHNlbGYubXNDcnlwdG8pIC8vIElFMTEgaGFzIG1zQ3J5cHRvXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGlmIChicm93c2VyQ3J5cHRvICYmIGJyb3dzZXJDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICAgICAgICB0aGlzLl9jcnlwdG8gPSBicm93c2VyQ3J5cHRvO1xuICAgICAgICAgICAgdGhpcy5pc0F2YWlsYWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmlzSW5zdGFudGlhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBCcm93c2VyUmFuZG9tU291cmNlLnByb3RvdHlwZS5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQXZhaWxhYmxlIHx8ICF0aGlzLl9jcnlwdG8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJyb3dzZXIgcmFuZG9tIGJ5dGUgZ2VuZXJhdG9yIGlzIG5vdCBhdmFpbGFibGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkgKz0gUVVPVEEpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyeXB0by5nZXRSYW5kb21WYWx1ZXMob3V0LnN1YmFycmF5KGksIGkgKyBNYXRoLm1pbihvdXQubGVuZ3RoIC0gaSwgUVVPVEEpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIHJldHVybiBCcm93c2VyUmFuZG9tU291cmNlO1xufSgpKTtcbmV4cG9ydHMuQnJvd3NlclJhbmRvbVNvdXJjZSA9IEJyb3dzZXJSYW5kb21Tb3VyY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm93c2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@stablelib/random/lib/source/browser.js\n"));

/***/ }),

/***/ "./node_modules/@stablelib/random/lib/source/node.js":
/*!***********************************************************!*\
  !*** ./node_modules/@stablelib/random/lib/source/node.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar wipe_1 = __webpack_require__(/*! @stablelib/wipe */ \"./node_modules/@stablelib/wipe/lib/wipe.js\");\nvar NodeRandomSource = /** @class */ (function () {\n    function NodeRandomSource() {\n        this.isAvailable = false;\n        this.isInstantiated = false;\n        if (true) {\n            var nodeCrypto = __webpack_require__(/*! crypto */ \"?4908\");\n            if (nodeCrypto && nodeCrypto.randomBytes) {\n                this._crypto = nodeCrypto;\n                this.isAvailable = true;\n                this.isInstantiated = true;\n            }\n        }\n    }\n    NodeRandomSource.prototype.randomBytes = function (length) {\n        if (!this.isAvailable || !this._crypto) {\n            throw new Error(\"Node.js random byte generator is not available.\");\n        }\n        // Get random bytes (result is Buffer).\n        var buffer = this._crypto.randomBytes(length);\n        // Make sure we got the length that we requested.\n        if (buffer.length !== length) {\n            throw new Error(\"NodeRandomSource: got fewer bytes than requested\");\n        }\n        // Allocate output array.\n        var out = new Uint8Array(length);\n        // Copy bytes from buffer to output.\n        for (var i = 0; i < out.length; i++) {\n            out[i] = buffer[i];\n        }\n        // Cleanup.\n        wipe_1.wipe(buffer);\n        return out;\n    };\n    return NodeRandomSource;\n}());\nexports.NodeRandomSource = NodeRandomSource;\n//# sourceMappingURL=node.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN0YWJsZWxpYi9yYW5kb20vbGliL3NvdXJjZS9ub2RlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsbUVBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUE4QjtBQUMxQyw2QkFBNkIsbUJBQU8sQ0FBQyxxQkFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx3QkFBd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzdGFibGVsaWIvcmFuZG9tL2xpYi9zb3VyY2Uvbm9kZS5qcz9iNDI2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChDKSAyMDE2IERtaXRyeSBDaGVzdG55a2hcbi8vIE1JVCBMaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGZvciBkZXRhaWxzLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdpcGVfMSA9IHJlcXVpcmUoXCJAc3RhYmxlbGliL3dpcGVcIik7XG52YXIgTm9kZVJhbmRvbVNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2RlUmFuZG9tU291cmNlKCkge1xuICAgICAgICB0aGlzLmlzQXZhaWxhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNJbnN0YW50aWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB2YXIgbm9kZUNyeXB0byA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG4gICAgICAgICAgICBpZiAobm9kZUNyeXB0byAmJiBub2RlQ3J5cHRvLnJhbmRvbUJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3J5cHRvID0gbm9kZUNyeXB0bztcbiAgICAgICAgICAgICAgICB0aGlzLmlzQXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzSW5zdGFudGlhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBOb2RlUmFuZG9tU291cmNlLnByb3RvdHlwZS5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQXZhaWxhYmxlIHx8ICF0aGlzLl9jcnlwdG8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vZGUuanMgcmFuZG9tIGJ5dGUgZ2VuZXJhdG9yIGlzIG5vdCBhdmFpbGFibGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCByYW5kb20gYnl0ZXMgKHJlc3VsdCBpcyBCdWZmZXIpLlxuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5fY3J5cHRvLnJhbmRvbUJ5dGVzKGxlbmd0aCk7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBnb3QgdGhlIGxlbmd0aCB0aGF0IHdlIHJlcXVlc3RlZC5cbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggIT09IGxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9kZVJhbmRvbVNvdXJjZTogZ290IGZld2VyIGJ5dGVzIHRoYW4gcmVxdWVzdGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsbG9jYXRlIG91dHB1dCBhcnJheS5cbiAgICAgICAgdmFyIG91dCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgICAgIC8vIENvcHkgYnl0ZXMgZnJvbSBidWZmZXIgdG8gb3V0cHV0LlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gYnVmZmVyW2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFudXAuXG4gICAgICAgIHdpcGVfMS53aXBlKGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICByZXR1cm4gTm9kZVJhbmRvbVNvdXJjZTtcbn0oKSk7XG5leHBvcnRzLk5vZGVSYW5kb21Tb3VyY2UgPSBOb2RlUmFuZG9tU291cmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9kZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@stablelib/random/lib/source/node.js\n"));

/***/ }),

/***/ "./node_modules/@stablelib/random/lib/source/system.js":
/*!*************************************************************!*\
  !*** ./node_modules/@stablelib/random/lib/source/system.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar browser_1 = __webpack_require__(/*! ./browser */ \"./node_modules/@stablelib/random/lib/source/browser.js\");\nvar node_1 = __webpack_require__(/*! ./node */ \"./node_modules/@stablelib/random/lib/source/node.js\");\nvar SystemRandomSource = /** @class */ (function () {\n    function SystemRandomSource() {\n        this.isAvailable = false;\n        this.name = \"\";\n        // Try browser.\n        this._source = new browser_1.BrowserRandomSource();\n        if (this._source.isAvailable) {\n            this.isAvailable = true;\n            this.name = \"Browser\";\n            return;\n        }\n        // If no browser source, try Node.\n        this._source = new node_1.NodeRandomSource();\n        if (this._source.isAvailable) {\n            this.isAvailable = true;\n            this.name = \"Node\";\n            return;\n        }\n        // No sources, we're out of options.\n    }\n    SystemRandomSource.prototype.randomBytes = function (length) {\n        if (!this.isAvailable) {\n            throw new Error(\"System random byte generator is not available.\");\n        }\n        return this._source.randomBytes(length);\n    };\n    return SystemRandomSource;\n}());\nexports.SystemRandomSource = SystemRandomSource;\n//# sourceMappingURL=system.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN0YWJsZWxpYi9yYW5kb20vbGliL3NvdXJjZS9zeXN0ZW0uanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLHlFQUFXO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQyxtRUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMEJBQTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3RhYmxlbGliL3JhbmRvbS9saWIvc291cmNlL3N5c3RlbS5qcz8xODkwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChDKSAyMDE2IERtaXRyeSBDaGVzdG55a2hcbi8vIE1JVCBMaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGZvciBkZXRhaWxzLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJyb3dzZXJfMSA9IHJlcXVpcmUoXCIuL2Jyb3dzZXJcIik7XG52YXIgbm9kZV8xID0gcmVxdWlyZShcIi4vbm9kZVwiKTtcbnZhciBTeXN0ZW1SYW5kb21Tb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3lzdGVtUmFuZG9tU291cmNlKCkge1xuICAgICAgICB0aGlzLmlzQXZhaWxhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiXCI7XG4gICAgICAgIC8vIFRyeSBicm93c2VyLlxuICAgICAgICB0aGlzLl9zb3VyY2UgPSBuZXcgYnJvd3Nlcl8xLkJyb3dzZXJSYW5kb21Tb3VyY2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX3NvdXJjZS5pc0F2YWlsYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5pc0F2YWlsYWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBcIkJyb3dzZXJcIjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyBicm93c2VyIHNvdXJjZSwgdHJ5IE5vZGUuXG4gICAgICAgIHRoaXMuX3NvdXJjZSA9IG5ldyBub2RlXzEuTm9kZVJhbmRvbVNvdXJjZSgpO1xuICAgICAgICBpZiAodGhpcy5fc291cmNlLmlzQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmlzQXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IFwiTm9kZVwiO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIHNvdXJjZXMsIHdlJ3JlIG91dCBvZiBvcHRpb25zLlxuICAgIH1cbiAgICBTeXN0ZW1SYW5kb21Tb3VyY2UucHJvdG90eXBlLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5c3RlbSByYW5kb20gYnl0ZSBnZW5lcmF0b3IgaXMgbm90IGF2YWlsYWJsZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5yYW5kb21CeXRlcyhsZW5ndGgpO1xuICAgIH07XG4gICAgcmV0dXJuIFN5c3RlbVJhbmRvbVNvdXJjZTtcbn0oKSk7XG5leHBvcnRzLlN5c3RlbVJhbmRvbVNvdXJjZSA9IFN5c3RlbVJhbmRvbVNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN5c3RlbS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@stablelib/random/lib/source/system.js\n"));

/***/ }),

/***/ "./node_modules/@stablelib/wipe/lib/wipe.js":
/*!**************************************************!*\
  !*** ./node_modules/@stablelib/wipe/lib/wipe.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Sets all values in the given array to zero and returns it.\n *\n * The fact that it sets bytes to zero can be relied on.\n *\n * There is no guarantee that this function makes data disappear from memory,\n * as runtime implementation can, for example, have copying garbage collector\n * that will make copies of sensitive data before we wipe it. Or that an\n * operating system will write our data to swap or sleep image. Another thing\n * is that an optimizing compiler can remove calls to this function or make it\n * no-op. There's nothing we can do with it, so we just do our best and hope\n * that everything will be okay and good will triumph over evil.\n */\nfunction wipe(array) {\n    // Right now it's similar to array.fill(0). If it turns\n    // out that runtimes optimize this call away, maybe\n    // we can try something else.\n    for (var i = 0; i < array.length; i++) {\n        array[i] = 0;\n    }\n    return array;\n}\nexports.wipe = wipe;\n//# sourceMappingURL=wipe.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN0YWJsZWxpYi93aXBlL2xpYi93aXBlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN0YWJsZWxpYi93aXBlL2xpYi93aXBlLmpzP2ZhNDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTYgRG1pdHJ5IENoZXN0bnlraFxuLy8gTUlUIExpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgZm9yIGRldGFpbHMuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFNldHMgYWxsIHZhbHVlcyBpbiB0aGUgZ2l2ZW4gYXJyYXkgdG8gemVybyBhbmQgcmV0dXJucyBpdC5cbiAqXG4gKiBUaGUgZmFjdCB0aGF0IGl0IHNldHMgYnl0ZXMgdG8gemVybyBjYW4gYmUgcmVsaWVkIG9uLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoaXMgZnVuY3Rpb24gbWFrZXMgZGF0YSBkaXNhcHBlYXIgZnJvbSBtZW1vcnksXG4gKiBhcyBydW50aW1lIGltcGxlbWVudGF0aW9uIGNhbiwgZm9yIGV4YW1wbGUsIGhhdmUgY29weWluZyBnYXJiYWdlIGNvbGxlY3RvclxuICogdGhhdCB3aWxsIG1ha2UgY29waWVzIG9mIHNlbnNpdGl2ZSBkYXRhIGJlZm9yZSB3ZSB3aXBlIGl0LiBPciB0aGF0IGFuXG4gKiBvcGVyYXRpbmcgc3lzdGVtIHdpbGwgd3JpdGUgb3VyIGRhdGEgdG8gc3dhcCBvciBzbGVlcCBpbWFnZS4gQW5vdGhlciB0aGluZ1xuICogaXMgdGhhdCBhbiBvcHRpbWl6aW5nIGNvbXBpbGVyIGNhbiByZW1vdmUgY2FsbHMgdG8gdGhpcyBmdW5jdGlvbiBvciBtYWtlIGl0XG4gKiBuby1vcC4gVGhlcmUncyBub3RoaW5nIHdlIGNhbiBkbyB3aXRoIGl0LCBzbyB3ZSBqdXN0IGRvIG91ciBiZXN0IGFuZCBob3BlXG4gKiB0aGF0IGV2ZXJ5dGhpbmcgd2lsbCBiZSBva2F5IGFuZCBnb29kIHdpbGwgdHJpdW1waCBvdmVyIGV2aWwuXG4gKi9cbmZ1bmN0aW9uIHdpcGUoYXJyYXkpIHtcbiAgICAvLyBSaWdodCBub3cgaXQncyBzaW1pbGFyIHRvIGFycmF5LmZpbGwoMCkuIElmIGl0IHR1cm5zXG4gICAgLy8gb3V0IHRoYXQgcnVudGltZXMgb3B0aW1pemUgdGhpcyBjYWxsIGF3YXksIG1heWJlXG4gICAgLy8gd2UgY2FuIHRyeSBzb21ldGhpbmcgZWxzZS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5W2ldID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZXhwb3J0cy53aXBlID0gd2lwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpcGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@stablelib/wipe/lib/wipe.js\n"));

/***/ }),

/***/ "./node_modules/@wagmi/core/connectors/metaMask/dist/wagmi-core-connectors-metaMask.esm.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@wagmi/core/connectors/metaMask/dist/wagmi-core-connectors-metaMask.esm.js ***!
  \*************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MetaMaskConnector\": function() { return /* binding */ MetaMaskConnector; }\n/* harmony export */ });\n/* harmony import */ var _dist_getProvider_e3d84eba_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../dist/getProvider-e3d84eba.esm.js */ \"./node_modules/@wagmi/core/dist/getProvider-e3d84eba.esm.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n\n\n\n\n\n\nvar _provider = /*#__PURE__*/new WeakMap();\n\nvar _UNSTABLE_shimOnConnectSelectAccount = /*#__PURE__*/new WeakMap();\n\nvar _getReady = /*#__PURE__*/new WeakSet();\n\nvar _findProvider = /*#__PURE__*/new WeakSet();\n\nclass MetaMaskConnector extends _dist_getProvider_e3d84eba_esm_js__WEBPACK_IMPORTED_MODULE_1__.I {\n  constructor() {\n    let {\n      chains,\n      options: options_\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const options = {\n      name: 'MetaMask',\n      shimDisconnect: true,\n      shimChainChangedDisconnect: true,\n      ...options_\n    };\n    super({\n      chains,\n      options\n    });\n\n    (0,_dist_getProvider_e3d84eba_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(this, _findProvider);\n\n    (0,_dist_getProvider_e3d84eba_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(this, _getReady);\n\n    (0,_dist_getProvider_e3d84eba_esm_js__WEBPACK_IMPORTED_MODULE_1__.r)(this, \"id\", 'metaMask');\n\n    (0,_dist_getProvider_e3d84eba_esm_js__WEBPACK_IMPORTED_MODULE_1__.r)(this, \"ready\", typeof window != 'undefined' && !!(0,_dist_getProvider_e3d84eba_esm_js__WEBPACK_IMPORTED_MODULE_1__.v)(this, _findProvider, _findProvider2).call(this, window.ethereum));\n\n    (0,_dist_getProvider_e3d84eba_esm_js__WEBPACK_IMPORTED_MODULE_1__.s)(this, _provider, {\n      writable: true,\n      value: void 0\n    });\n\n    (0,_dist_getProvider_e3d84eba_esm_js__WEBPACK_IMPORTED_MODULE_1__.s)(this, _UNSTABLE_shimOnConnectSelectAccount, {\n      writable: true,\n      value: void 0\n    });\n\n    (0,_dist_getProvider_e3d84eba_esm_js__WEBPACK_IMPORTED_MODULE_1__.u)(this, _UNSTABLE_shimOnConnectSelectAccount, options.UNSTABLE_shimOnConnectSelectAccount);\n  }\n\n  async connect() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      var _this$options, _getClient$storage, _this$options2, _getClient$storage2;\n\n      const provider = await this.getProvider();\n      if (!provider) throw new _dist_getProvider_e3d84eba_esm_js__WEBPACK_IMPORTED_MODULE_1__.a();\n\n      if (provider.on) {\n        provider.on('accountsChanged', this.onAccountsChanged);\n        provider.on('chainChanged', this.onChainChanged);\n        provider.on('disconnect', this.onDisconnect);\n      }\n\n      this.emit('message', {\n        type: 'connecting'\n      }); // Attempt to show wallet select prompt with `wallet_requestPermissions` when\n      // `shimDisconnect` is active and account is in disconnected state (flag in storage)\n\n      if ((0,_dist_getProvider_e3d84eba_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(this, _UNSTABLE_shimOnConnectSelectAccount) && (_this$options = this.options) !== null && _this$options !== void 0 && _this$options.shimDisconnect && !((_getClient$storage = (0,_dist_getProvider_e3d84eba_esm_js__WEBPACK_IMPORTED_MODULE_1__.g)().storage) !== null && _getClient$storage !== void 0 && _getClient$storage.getItem(this.shimDisconnectKey))) {\n        const accounts = await provider.request({\n          method: 'eth_accounts'\n        }).catch(() => []);\n        const isConnected = !!accounts[0];\n        if (isConnected) await provider.request({\n          method: 'wallet_requestPermissions',\n          params: [{\n            eth_accounts: {}\n          }]\n        });\n      }\n\n      const account = await this.getAccount(); // Switch to chain if provided\n\n      let id = await this.getChainId();\n      let unsupported = this.isChainUnsupported(id);\n\n      if (chainId && id !== chainId) {\n        const chain = await this.switchChain(chainId);\n        id = chain.id;\n        unsupported = this.isChainUnsupported(id);\n      }\n\n      if ((_this$options2 = this.options) !== null && _this$options2 !== void 0 && _this$options2.shimDisconnect) (_getClient$storage2 = (0,_dist_getProvider_e3d84eba_esm_js__WEBPACK_IMPORTED_MODULE_1__.g)().storage) === null || _getClient$storage2 === void 0 ? void 0 : _getClient$storage2.setItem(this.shimDisconnectKey, true);\n      return {\n        account,\n        chain: {\n          id,\n          unsupported\n        },\n        provider\n      };\n    } catch (error) {\n      if (this.isUserRejectedRequestError(error)) throw new _dist_getProvider_e3d84eba_esm_js__WEBPACK_IMPORTED_MODULE_1__.U(error);\n      if (error.code === -32002) throw new _dist_getProvider_e3d84eba_esm_js__WEBPACK_IMPORTED_MODULE_1__.R(error);\n      throw error;\n    }\n  }\n\n  async getProvider() {\n    if (typeof window !== 'undefined') {\n      // TODO: Fallback to `ethereum#initialized` event for async injection\n      // https://github.com/MetaMask/detect-provider#synchronous-and-asynchronous-injection=\n      (0,_dist_getProvider_e3d84eba_esm_js__WEBPACK_IMPORTED_MODULE_1__.u)(this, _provider, (0,_dist_getProvider_e3d84eba_esm_js__WEBPACK_IMPORTED_MODULE_1__.v)(this, _findProvider, _findProvider2).call(this, window.ethereum));\n    }\n\n    return (0,_dist_getProvider_e3d84eba_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(this, _provider);\n  }\n\n}\n\nfunction _getReady2(ethereum) {\n  const isMetaMask = !!(ethereum !== null && ethereum !== void 0 && ethereum.isMetaMask);\n  if (!isMetaMask) return; // Brave tries to make itself look like MetaMask\n  // Could also try RPC `web3_clientVersion` if following is unreliable\n\n  if (ethereum.isBraveWallet && !ethereum._events && !ethereum._state) return;\n  if (ethereum.isTokenPocket) return;\n  if (ethereum.isTokenary) return;\n  return ethereum;\n}\n\nfunction _findProvider2(ethereum) {\n  if (ethereum !== null && ethereum !== void 0 && ethereum.providers) return ethereum.providers.find((0,_dist_getProvider_e3d84eba_esm_js__WEBPACK_IMPORTED_MODULE_1__.v)(this, _getReady, _getReady2));\n  return (0,_dist_getProvider_e3d84eba_esm_js__WEBPACK_IMPORTED_MODULE_1__.v)(this, _getReady, _getReady2).call(this, ethereum);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHdhZ21pL2NvcmUvY29ubmVjdG9ycy9tZXRhTWFzay9kaXN0L3dhZ21pLWNvcmUtY29ubmVjdG9ycy1tZXRhTWFzay5lc20uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE0VztBQUNoVjtBQUNIO0FBQ1Q7QUFDVTtBQUNIO0FBQ3VCO0FBQ0Y7O0FBRTVDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGdDQUFnQyxnRUFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxJQUFJLG9FQUEyQjs7QUFFL0IsSUFBSSxvRUFBMkI7O0FBRS9CLElBQUksb0VBQWU7O0FBRW5CLElBQUksb0VBQWUsa0RBQWtELG9FQUFzQjs7QUFFM0YsSUFBSSxvRUFBMEI7QUFDOUI7QUFDQTtBQUNBLEtBQUs7O0FBRUwsSUFBSSxvRUFBMEI7QUFDOUI7QUFDQTtBQUNBLEtBQUs7O0FBRUwsSUFBSSxvRUFBcUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLGdFQUFzQjs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTyxHQUFHO0FBQ1Y7O0FBRUEsVUFBVSxvRUFBcUIsK0tBQStLLG9FQUFTO0FBQ3ZOO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7O0FBRUEsK0NBQStDOztBQUUvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUlBQXlJLG9FQUFTO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTiw0REFBNEQsZ0VBQXdCO0FBQ3BGLDJDQUEyQyxnRUFBd0I7QUFDbkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvRUFBcUIsa0JBQWtCLG9FQUFzQjtBQUNuRTs7QUFFQSxXQUFXLG9FQUFxQjtBQUNoQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxR0FBcUcsb0VBQXNCO0FBQzNILFNBQVMsb0VBQXNCO0FBQy9COztBQUU2QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHdhZ21pL2NvcmUvY29ubmVjdG9ycy9tZXRhTWFzay9kaXN0L3dhZ21pLWNvcmUtY29ubmVjdG9ycy1tZXRhTWFzay5lc20uanM/MmVmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJIGFzIEluamVjdGVkQ29ubmVjdG9yLCBfIGFzIF9jbGFzc1ByaXZhdGVNZXRob2RJbml0U3BlYywgciBhcyBfZGVmaW5lUHJvcGVydHksIHYgYXMgX2NsYXNzUHJpdmF0ZU1ldGhvZEdldCwgcyBhcyBfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYywgdSBhcyBfY2xhc3NQcml2YXRlRmllbGRTZXQsIGEgYXMgQ29ubmVjdG9yTm90Rm91bmRFcnJvciwgdCBhcyBfY2xhc3NQcml2YXRlRmllbGRHZXQsIGcgYXMgZ2V0Q2xpZW50LCBVIGFzIFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvciwgUiBhcyBSZXNvdXJjZVVuYXZhaWxhYmxlRXJyb3IgfSBmcm9tICcuLi8uLi8uLi9kaXN0L2dldFByb3ZpZGVyLWUzZDg0ZWJhLmVzbS5qcyc7XG5pbXBvcnQgJ3p1c3RhbmQvbWlkZGxld2FyZSc7XG5pbXBvcnQgJ3p1c3RhbmQvdmFuaWxsYSc7XG5pbXBvcnQgJ2V0aGVycyc7XG5pbXBvcnQgJ2V0aGVycy9saWIvdXRpbHMnO1xuaW1wb3J0ICdldmVudGVtaXR0ZXIzJztcbmltcG9ydCAnLi4vLi4vLi4vZGlzdC9jaGFpbnMtNTA1ZTEwNzAuZXNtLmpzJztcbmltcG9ydCAnLi4vLi4vLi4vZGlzdC9ycGNzLWU4MzdhYmYyLmVzbS5qcyc7XG5cbnZhciBfcHJvdmlkZXIgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcblxudmFyIF9VTlNUQUJMRV9zaGltT25Db25uZWN0U2VsZWN0QWNjb3VudCA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuXG52YXIgX2dldFJlYWR5ID0gLyojX19QVVJFX18qL25ldyBXZWFrU2V0KCk7XG5cbnZhciBfZmluZFByb3ZpZGVyID0gLyojX19QVVJFX18qL25ldyBXZWFrU2V0KCk7XG5cbmNsYXNzIE1ldGFNYXNrQ29ubmVjdG9yIGV4dGVuZHMgSW5qZWN0ZWRDb25uZWN0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQge1xuICAgICAgY2hhaW5zLFxuICAgICAgb3B0aW9uczogb3B0aW9uc19cbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgbmFtZTogJ01ldGFNYXNrJyxcbiAgICAgIHNoaW1EaXNjb25uZWN0OiB0cnVlLFxuICAgICAgc2hpbUNoYWluQ2hhbmdlZERpc2Nvbm5lY3Q6IHRydWUsXG4gICAgICAuLi5vcHRpb25zX1xuICAgIH07XG4gICAgc3VwZXIoe1xuICAgICAgY2hhaW5zLFxuICAgICAgb3B0aW9uc1xuICAgIH0pO1xuXG4gICAgX2NsYXNzUHJpdmF0ZU1ldGhvZEluaXRTcGVjKHRoaXMsIF9maW5kUHJvdmlkZXIpO1xuXG4gICAgX2NsYXNzUHJpdmF0ZU1ldGhvZEluaXRTcGVjKHRoaXMsIF9nZXRSZWFkeSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZFwiLCAnbWV0YU1hc2snKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlYWR5XCIsIHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgISFfY2xhc3NQcml2YXRlTWV0aG9kR2V0KHRoaXMsIF9maW5kUHJvdmlkZXIsIF9maW5kUHJvdmlkZXIyKS5jYWxsKHRoaXMsIHdpbmRvdy5ldGhlcmV1bSkpO1xuXG4gICAgX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWModGhpcywgX3Byb3ZpZGVyLCB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICB9KTtcblxuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjKHRoaXMsIF9VTlNUQUJMRV9zaGltT25Db25uZWN0U2VsZWN0QWNjb3VudCwge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdm9pZCAwXG4gICAgfSk7XG5cbiAgICBfY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1VOU1RBQkxFX3NoaW1PbkNvbm5lY3RTZWxlY3RBY2NvdW50LCBvcHRpb25zLlVOU1RBQkxFX3NoaW1PbkNvbm5lY3RTZWxlY3RBY2NvdW50KTtcbiAgfVxuXG4gIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgbGV0IHtcbiAgICAgIGNoYWluSWRcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgX3RoaXMkb3B0aW9ucywgX2dldENsaWVudCRzdG9yYWdlLCBfdGhpcyRvcHRpb25zMiwgX2dldENsaWVudCRzdG9yYWdlMjtcblxuICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICBpZiAoIXByb3ZpZGVyKSB0aHJvdyBuZXcgQ29ubmVjdG9yTm90Rm91bmRFcnJvcigpO1xuXG4gICAgICBpZiAocHJvdmlkZXIub24pIHtcbiAgICAgICAgcHJvdmlkZXIub24oJ2FjY291bnRzQ2hhbmdlZCcsIHRoaXMub25BY2NvdW50c0NoYW5nZWQpO1xuICAgICAgICBwcm92aWRlci5vbignY2hhaW5DaGFuZ2VkJywgdGhpcy5vbkNoYWluQ2hhbmdlZCk7XG4gICAgICAgIHByb3ZpZGVyLm9uKCdkaXNjb25uZWN0JywgdGhpcy5vbkRpc2Nvbm5lY3QpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCB7XG4gICAgICAgIHR5cGU6ICdjb25uZWN0aW5nJ1xuICAgICAgfSk7IC8vIEF0dGVtcHQgdG8gc2hvdyB3YWxsZXQgc2VsZWN0IHByb21wdCB3aXRoIGB3YWxsZXRfcmVxdWVzdFBlcm1pc3Npb25zYCB3aGVuXG4gICAgICAvLyBgc2hpbURpc2Nvbm5lY3RgIGlzIGFjdGl2ZSBhbmQgYWNjb3VudCBpcyBpbiBkaXNjb25uZWN0ZWQgc3RhdGUgKGZsYWcgaW4gc3RvcmFnZSlcblxuICAgICAgaWYgKF9jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfVU5TVEFCTEVfc2hpbU9uQ29ubmVjdFNlbGVjdEFjY291bnQpICYmIChfdGhpcyRvcHRpb25zID0gdGhpcy5vcHRpb25zKSAhPT0gbnVsbCAmJiBfdGhpcyRvcHRpb25zICE9PSB2b2lkIDAgJiYgX3RoaXMkb3B0aW9ucy5zaGltRGlzY29ubmVjdCAmJiAhKChfZ2V0Q2xpZW50JHN0b3JhZ2UgPSBnZXRDbGllbnQoKS5zdG9yYWdlKSAhPT0gbnVsbCAmJiBfZ2V0Q2xpZW50JHN0b3JhZ2UgIT09IHZvaWQgMCAmJiBfZ2V0Q2xpZW50JHN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnNoaW1EaXNjb25uZWN0S2V5KSkpIHtcbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICBtZXRob2Q6ICdldGhfYWNjb3VudHMnXG4gICAgICAgIH0pLmNhdGNoKCgpID0+IFtdKTtcbiAgICAgICAgY29uc3QgaXNDb25uZWN0ZWQgPSAhIWFjY291bnRzWzBdO1xuICAgICAgICBpZiAoaXNDb25uZWN0ZWQpIGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF9yZXF1ZXN0UGVybWlzc2lvbnMnLFxuICAgICAgICAgIHBhcmFtczogW3tcbiAgICAgICAgICAgIGV0aF9hY2NvdW50czoge31cbiAgICAgICAgICB9XVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWNjb3VudCA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudCgpOyAvLyBTd2l0Y2ggdG8gY2hhaW4gaWYgcHJvdmlkZWRcblxuICAgICAgbGV0IGlkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgICBsZXQgdW5zdXBwb3J0ZWQgPSB0aGlzLmlzQ2hhaW5VbnN1cHBvcnRlZChpZCk7XG5cbiAgICAgIGlmIChjaGFpbklkICYmIGlkICE9PSBjaGFpbklkKSB7XG4gICAgICAgIGNvbnN0IGNoYWluID0gYXdhaXQgdGhpcy5zd2l0Y2hDaGFpbihjaGFpbklkKTtcbiAgICAgICAgaWQgPSBjaGFpbi5pZDtcbiAgICAgICAgdW5zdXBwb3J0ZWQgPSB0aGlzLmlzQ2hhaW5VbnN1cHBvcnRlZChpZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoX3RoaXMkb3B0aW9uczIgPSB0aGlzLm9wdGlvbnMpICE9PSBudWxsICYmIF90aGlzJG9wdGlvbnMyICE9PSB2b2lkIDAgJiYgX3RoaXMkb3B0aW9uczIuc2hpbURpc2Nvbm5lY3QpIChfZ2V0Q2xpZW50JHN0b3JhZ2UyID0gZ2V0Q2xpZW50KCkuc3RvcmFnZSkgPT09IG51bGwgfHwgX2dldENsaWVudCRzdG9yYWdlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldENsaWVudCRzdG9yYWdlMi5zZXRJdGVtKHRoaXMuc2hpbURpc2Nvbm5lY3RLZXksIHRydWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWNjb3VudCxcbiAgICAgICAgY2hhaW46IHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICB1bnN1cHBvcnRlZFxuICAgICAgICB9LFxuICAgICAgICBwcm92aWRlclxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKHRoaXMuaXNVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IoZXJyb3IpKSB0aHJvdyBuZXcgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yKGVycm9yKTtcbiAgICAgIGlmIChlcnJvci5jb2RlID09PSAtMzIwMDIpIHRocm93IG5ldyBSZXNvdXJjZVVuYXZhaWxhYmxlRXJyb3IoZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0UHJvdmlkZXIoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBUT0RPOiBGYWxsYmFjayB0byBgZXRoZXJldW0jaW5pdGlhbGl6ZWRgIGV2ZW50IGZvciBhc3luYyBpbmplY3Rpb25cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9kZXRlY3QtcHJvdmlkZXIjc3luY2hyb25vdXMtYW5kLWFzeW5jaHJvbm91cy1pbmplY3Rpb249XG4gICAgICBfY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX3Byb3ZpZGVyLCBfY2xhc3NQcml2YXRlTWV0aG9kR2V0KHRoaXMsIF9maW5kUHJvdmlkZXIsIF9maW5kUHJvdmlkZXIyKS5jYWxsKHRoaXMsIHdpbmRvdy5ldGhlcmV1bSkpO1xuICAgIH1cblxuICAgIHJldHVybiBfY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX3Byb3ZpZGVyKTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIF9nZXRSZWFkeTIoZXRoZXJldW0pIHtcbiAgY29uc3QgaXNNZXRhTWFzayA9ICEhKGV0aGVyZXVtICE9PSBudWxsICYmIGV0aGVyZXVtICE9PSB2b2lkIDAgJiYgZXRoZXJldW0uaXNNZXRhTWFzayk7XG4gIGlmICghaXNNZXRhTWFzaykgcmV0dXJuOyAvLyBCcmF2ZSB0cmllcyB0byBtYWtlIGl0c2VsZiBsb29rIGxpa2UgTWV0YU1hc2tcbiAgLy8gQ291bGQgYWxzbyB0cnkgUlBDIGB3ZWIzX2NsaWVudFZlcnNpb25gIGlmIGZvbGxvd2luZyBpcyB1bnJlbGlhYmxlXG5cbiAgaWYgKGV0aGVyZXVtLmlzQnJhdmVXYWxsZXQgJiYgIWV0aGVyZXVtLl9ldmVudHMgJiYgIWV0aGVyZXVtLl9zdGF0ZSkgcmV0dXJuO1xuICBpZiAoZXRoZXJldW0uaXNUb2tlblBvY2tldCkgcmV0dXJuO1xuICBpZiAoZXRoZXJldW0uaXNUb2tlbmFyeSkgcmV0dXJuO1xuICByZXR1cm4gZXRoZXJldW07XG59XG5cbmZ1bmN0aW9uIF9maW5kUHJvdmlkZXIyKGV0aGVyZXVtKSB7XG4gIGlmIChldGhlcmV1bSAhPT0gbnVsbCAmJiBldGhlcmV1bSAhPT0gdm9pZCAwICYmIGV0aGVyZXVtLnByb3ZpZGVycykgcmV0dXJuIGV0aGVyZXVtLnByb3ZpZGVycy5maW5kKF9jbGFzc1ByaXZhdGVNZXRob2RHZXQodGhpcywgX2dldFJlYWR5LCBfZ2V0UmVhZHkyKSk7XG4gIHJldHVybiBfY2xhc3NQcml2YXRlTWV0aG9kR2V0KHRoaXMsIF9nZXRSZWFkeSwgX2dldFJlYWR5MikuY2FsbCh0aGlzLCBldGhlcmV1bSk7XG59XG5cbmV4cG9ydCB7IE1ldGFNYXNrQ29ubmVjdG9yIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@wagmi/core/connectors/metaMask/dist/wagmi-core-connectors-metaMask.esm.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-api/api.js":
/*!************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/api.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module is Application Programming Interface (API) for **APG** - the ABNF Parser Generator.\n//\n// *Note on teminology.*\n// APG is a parser generator.\n// However, it really only generates a \"grammar object\" (see below) from the defining SABNF grammar.\n// The generated parser is incomplete at this stage.\n// Remaining, it is the job of the user to develop the generated parser from the grammar object and the **APG** Library (**apg-lib**).\n//\n// The following terminology my help clear up any confusion between the idea of a \"generated parser\" versus a \"generated grammar object\".\n\n// - The generating parser: **APG** is an **APG** parser (yes, there is a circular dependence between **apg-api** and **apg-lib**). We'll call it the generating parser.\n// - The target parser: **APG**'s goal is to generate a parser. We'll call it the target parser.\n// - The target grammar: this is the (ASCII) SABNF grammar defining the target parser.\n// - The target grammar object: **APG** parses the SABNF grammar and generates the JavaScript source for a target grammar object constructor function\n// and/or an actual grammar object.\n// - The final target parser: The user then develops the final target parser using the generated target grammar\n// object and the **APG** parsing library, **apg-lib**.\n// Throws execeptions on fatal errors.\n//\n// src: the input SABNF grammar<br>\n// may be one of:\n// - Buffer of bytes\n// - JavaScript string\n// - Array of integer character codes\nmodule.exports = function api(src) {\n  const thisFileName = 'api.js: ';\n  const thisObject = this;\n\n  /* PRIVATE PROPERTIES */\n  const apglib = __webpack_require__(/*! ../apg-lib/node-exports */ \"./node_modules/apg-js/src/apg-lib/node-exports.js\");\n  const converter = __webpack_require__(/*! ../apg-conv-api/converter */ \"./node_modules/apg-js/src/apg-conv-api/converter.js\");\n  const scanner = __webpack_require__(/*! ./scanner */ \"./node_modules/apg-js/src/apg-api/scanner.js\");\n  const parser = new (__webpack_require__(/*! ./parser */ \"./node_modules/apg-js/src/apg-api/parser.js\"))();\n  const { attributes, showAttributes, showAttributeErrors, showRuleDependencies } = __webpack_require__(/*! ./attributes */ \"./node_modules/apg-js/src/apg-api/attributes.js\");\n  const showRules = __webpack_require__(/*! ./show-rules */ \"./node_modules/apg-js/src/apg-api/show-rules.js\");\n\n  /* PRIVATE MEMBERS (FUNCTIONS) */\n  /* Convert a phrase (array of character codes) to HTML. */\n  const abnfToHtml = function abnfToHtml(chars, beg, len) {\n    const NORMAL = 0;\n    const CONTROL = 1;\n    const INVALID = 2;\n    const CONTROL_BEG = `<span class=\"${apglib.style.CLASS_CTRLCHAR}\">`;\n    const CONTROL_END = '</span>';\n    const INVALID_BEG = `<span class=\"${apglib.style.CLASS_NOMATCH}\">`;\n    const INVALID_END = '</span>';\n    let end;\n    let html = '';\n    const TRUE = true;\n    while (TRUE) {\n      if (!Array.isArray(chars) || chars.length === 0) {\n        break;\n      }\n      if (typeof beg !== 'number') {\n        throw new Error('abnfToHtml: beg must be type number');\n      }\n      if (beg >= chars.length) {\n        break;\n      }\n      if (typeof len !== 'number' || beg + len >= chars.length) {\n        end = chars.length;\n      } else {\n        end = beg + len;\n      }\n      let state = NORMAL;\n      for (let i = beg; i < end; i += 1) {\n        const ch = chars[i];\n        if (ch >= 32 && ch <= 126) {\n          /* normal - printable ASCII characters */\n          if (state === CONTROL) {\n            html += CONTROL_END;\n            state = NORMAL;\n          } else if (state === INVALID) {\n            html += INVALID_END;\n            state = NORMAL;\n          }\n          /* handle reserved HTML entity characters */\n          switch (ch) {\n            case 32:\n              html += '&nbsp;';\n              break;\n            case 60:\n              html += '&lt;';\n              break;\n            case 62:\n              html += '&gt;';\n              break;\n            case 38:\n              html += '&amp;';\n              break;\n            case 34:\n              html += '&quot;';\n              break;\n            case 39:\n              html += '&#039;';\n              break;\n            case 92:\n              html += '&#092;';\n              break;\n            default:\n              html += String.fromCharCode(ch);\n              break;\n          }\n        } else if (ch === 9 || ch === 10 || ch === 13) {\n          /* control characters */\n          if (state === NORMAL) {\n            html += CONTROL_BEG;\n            state = CONTROL;\n          } else if (state === INVALID) {\n            html += INVALID_END + CONTROL_BEG;\n            state = CONTROL;\n          }\n          if (ch === 9) {\n            html += 'TAB';\n          }\n          if (ch === 10) {\n            html += 'LF';\n          }\n          if (ch === 13) {\n            html += 'CR';\n          }\n        } else {\n          /* invalid characters */\n          if (state === NORMAL) {\n            html += INVALID_BEG;\n            state = INVALID;\n          } else if (state === CONTROL) {\n            html += CONTROL_END + INVALID_BEG;\n            state = INVALID;\n          }\n          /* display character as hexadecimal value */\n          html += `\\\\x${apglib.utils.charToHex(ch)}`;\n        }\n      }\n      if (state === INVALID) {\n        html += INVALID_END;\n      }\n      if (state === CONTROL) {\n        html += CONTROL_END;\n      }\n      break;\n    }\n    return html;\n  };\n  /* Convert a phrase (array of character codes) to ASCII text. */\n  const abnfToAscii = function abnfToAscii(chars, beg, len) {\n    let str = '';\n    for (let i = beg; i < beg + len; i += 1) {\n      const ch = chars[i];\n      if (ch >= 32 && ch <= 126) {\n        str += String.fromCharCode(ch);\n      } else {\n        switch (ch) {\n          case 9:\n            str += '\\\\t';\n            break;\n          case 10:\n            str += '\\\\n';\n            break;\n          case 13:\n            str += '\\\\r';\n            break;\n          default:\n            str += '\\\\unknown';\n            break;\n        }\n      }\n    }\n    return str;\n  };\n  /* translate lines (SABNF grammar) to ASCII text */\n  const linesToAscii = function linesToAscii(lines) {\n    let str = 'Annotated Input Grammar';\n    lines.forEach((val) => {\n      str += '\\n';\n      str += `line no: ${val.lineNo}`;\n      str += ` : char index: ${val.beginChar}`;\n      str += ` : length: ${val.length}`;\n      str += ` : abnf: ${abnfToAscii(thisObject.chars, val.beginChar, val.length)}`;\n    });\n    str += '\\n';\n    return str;\n  };\n  /* translate lines (SABNF grammar) to HTML */\n  const linesToHtml = function linesToHtml(lines) {\n    let html = '';\n    html += `<table class=\"${apglib.style.CLASS_GRAMMAR}\">\\n`;\n    const title = 'Annotated Input Grammar';\n    html += `<caption>${title}</caption>\\n`;\n    html += '<tr>';\n    html += '<th>line<br>no.</th><th>first<br>char</th><th><br>length</th><th><br>text</th>';\n    html += '</tr>\\n';\n    lines.forEach((val) => {\n      html += '<tr>';\n      html += `<td>${val.lineNo}`;\n      html += `</td><td>${val.beginChar}`;\n      html += `</td><td>${val.length}`;\n      html += `</td><td>${abnfToHtml(thisObject.chars, val.beginChar, val.length)}`;\n      html += '</td>';\n      html += '</tr>\\n';\n    });\n\n    html += '</table>\\n';\n    return html;\n  };\n  /* Format the error messages to HTML, for page display. */\n  const errorsToHtml = function errorsToHtml(errors, lines, chars, title) {\n    const [style] = apglib;\n    let html = '';\n    const errorArrow = `<span class=\"${style.CLASS_NOMATCH}\">&raquo;</span>`;\n    html += `<p><table class=\"${style.CLASS_GRAMMAR}\">\\n`;\n    if (title && typeof title === 'string') {\n      html += `<caption>${title}</caption>\\n`;\n    }\n    html += '<tr><th>line<br>no.</th><th>line<br>offset</th><th>error<br>offset</th><th><br>text</th></tr>\\n';\n    errors.forEach((val) => {\n      let line;\n      let relchar;\n      let beg;\n      let end;\n      let text;\n      let prefix = '';\n      let suffix = '';\n      if (lines.length === 0) {\n        text = errorArrow;\n        relchar = 0;\n      } else {\n        line = lines[val.line];\n        beg = line.beginChar;\n        if (val.char > beg) {\n          prefix = abnfToHtml(chars, beg, val.char - beg);\n        }\n        beg = val.char;\n        end = line.beginChar + line.length;\n        if (beg < end) {\n          suffix = abnfToHtml(chars, beg, end - beg);\n        }\n        text = prefix + errorArrow + suffix;\n        relchar = val.char - line.beginChar;\n        html += '<tr>';\n        html += `<td>${val.line}</td><td>${line.beginChar}</td><td>${relchar}</td><td>${text}</td>`;\n        html += '</tr>\\n';\n        html += '<tr>';\n        html += `<td colspan=\"3\"></td><td>&uarr;:&nbsp;${apglib.utils.stringToAsciiHtml(val.msg)}</td>`;\n        html += '</tr>\\n';\n      }\n    });\n    html += '</table></p>\\n';\n    return html;\n  };\n  /* Display an array of errors in ASCII text */\n  const errorsToAscii = function errorsToAscii(errors, lines, chars) {\n    let str;\n    let line;\n    let beg;\n    let len;\n    str = '';\n    errors.forEach((error) => {\n      line = lines[error.line];\n      str += `${line.lineNo}: `;\n      str += `${line.beginChar}: `;\n      str += `${error.char - line.beginChar}: `;\n      beg = line.beginChar;\n      len = error.char - line.beginChar;\n      str += abnfToAscii(chars, beg, len);\n      str += ' >> ';\n      beg = error.char;\n      len = line.beginChar + line.length - error.char;\n      str += abnfToAscii(chars, beg, len);\n      str += '\\n';\n      str += `${line.lineNo}: `;\n      str += `${line.beginChar}: `;\n      str += `${error.char - line.beginChar}: `;\n      str += 'error: ';\n      str += error.msg;\n      str += '\\n';\n    });\n    return str;\n  };\n  let isScanned = false;\n  let isParsed = false;\n  let isTranslated = false;\n  let haveAttributes = false;\n  let attributeErrors = 0;\n  let lineMap;\n\n  /* PUBLIC PROPERTIES */\n  // The input SABNF grammar as a JavaScript string.\n  // this.sabnf;\n  // The input SABNF grammar as an array of character codes.\n  // this.chars;\n  // An array of line objects, defining each line of the input SABNF grammar\n  // - lineNo : the zero-based line number\n  // - beginChar : offset (into `this.chars`) of the first character in the line\n  // - length : the number of characters in the line\n  // - textLength : the number of characters of text in the line, excluding the line ending characters\n  // - endType : \"CRLF\", \"LF\", \"CR\" or \"none\" if the last line has no line ending characters\n  // - invalidChars : `true` if the line contains invalid characters, `false` otherwise\n  // this.lines;\n  // An array of rule names and data.\n  // - name : the rule name\n  // - lower : the rule name in lower case\n  // - index : the index of the rule (ordered by appearance in SABNF grammar)\n  // - isBkr : `true` if this rule has been back referenced, `false` otherwise\n  // - opcodes : array of opcodes for this rule\n  // - attrs : the rule attributes\n  // - ctrl : system data\n  // this.rules;\n  // An array of UDT names and data.\n  // this.udts;\n  // An array of errors, if any.\n  // - line : the line number containing the error\n  // - char : the character offset of the error\n  // - msg : the error message\n  this.errors = [];\n\n  /* CONSTRUCTOR */\n  if (Buffer.isBuffer(src)) {\n    this.chars = converter.decode('BINARY', src);\n  } else if (Array.isArray(src)) {\n    this.chars = src.slice();\n  } else if (typeof src === 'string') {\n    this.chars = converter.decode('STRING', src);\n  } else {\n    throw new Error(`${thisFileName}input source is not a string, byte Buffer or character array`);\n  }\n  this.sabnf = converter.encode('STRING', this.chars);\n\n  /* PUBLIC MEMBERS (FUNCTIONS) */\n  // Scan the input SABNF grammar for invalid characters and catalog the lines via `this.lines`.\n  // - strict : (optional) if `true`, all lines, including the last must end with CRLF (\\r\\n),\n  // if `false` (in any JavaScript sense) then line endings may be any mix of CRLF, LF, CR, or end-of-file.\n  // - trace (*) : (optional) a parser trace object, which will trace the parser that does the scan\n  this.scan = function scan(strict, trace) {\n    this.lines = scanner(this.chars, this.errors, strict, trace);\n    isScanned = true;\n  };\n  // Parse the input SABNF grammar for correct syntax.\n  // - strict : (optional) if `true`, the input grammar must be strict ABNF, conforming to [RFC 5234](https://tools.ietf.org/html/rfc5234)\n  // and [RFC 7405](https://tools.ietf.org/html/rfc7405). No superset features allowed.\n  // - trace (\\*) : (optional) a parser trace object, which will trace the syntax parser\n  //\n  // <i>(*)NOTE: the trace option was used primarily during development.\n  // Error detection and reporting is now fairly robust and tracing should be unnecessary. Use at your own peril.</i>\n  this.parse = function parse(strict, trace) {\n    if (!isScanned) {\n      throw new Error(`${thisFileName}grammar not scanned`);\n    }\n    parser.syntax(this.chars, this.lines, this.errors, strict, trace);\n    isParsed = true;\n  };\n  // Translate the SABNF grammar syntax into the opcodes that will guide the parser for this grammar.\n  this.translate = function translate() {\n    if (!isParsed) {\n      throw new Error(`${thisFileName}grammar not scanned and parsed`);\n    }\n    const ret = parser.semantic(this.chars, this.lines, this.errors);\n    if (this.errors.length === 0) {\n      this.rules = ret.rules;\n      this.udts = ret.udts;\n      lineMap = ret.lineMap;\n      isTranslated = true;\n    }\n  };\n  // Compute the attributes of each rule.\n  this.attributes = function attrs() {\n    if (!isTranslated) {\n      throw new Error(`${thisFileName}grammar not scanned, parsed and translated`);\n    }\n    attributeErrors = attributes(this.rules, this.udts, lineMap, this.errors);\n    haveAttributes = true;\n    return attributeErrors;\n  };\n  // This function will perform the full suite of steps required to generate a parser grammar object\n  // from the input SABNF grammar.\n  this.generate = function generate(strict) {\n    this.lines = scanner(this.chars, this.errors, strict);\n    if (this.errors.length) {\n      return;\n    }\n    parser.syntax(this.chars, this.lines, this.errors, strict);\n    if (this.errors.length) {\n      return;\n    }\n    const ret = parser.semantic(this.chars, this.lines, this.errors);\n    if (this.errors.length) {\n      return;\n    }\n    this.rules = ret.rules;\n    this.udts = ret.udts;\n    lineMap = ret.lineMap;\n\n    attributeErrors = attributes(this.rules, this.udts, lineMap, this.errors);\n    haveAttributes = true;\n  };\n  // Display the rules.\n  // Must scan, parse and translate before calling this function, otherwise there are no rules to display.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - none of above, index order (default)\n  this.displayRules = function displayRules(order = 'index') {\n    if (!isTranslated) {\n      throw new Error(`${thisFileName}grammar not scanned, parsed and translated`);\n    }\n    return showRules(this.rules, this.udts, order);\n  };\n  // Display the rule dependencies.\n  // Must scan, parse, translate and compute attributes before calling this function.\n  // Otherwise the rule dependencies are not known.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, index order (default)\n  this.displayRuleDependencies = function displayRuleDependencies(order = 'index') {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);\n    }\n    return showRuleDependencies(order);\n  };\n  // Display the attributes.\n  // Must scan, parse, translate and compute attributes before calling this function.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, type order (default)\n  this.displayAttributes = function displayAttributes(order = 'index') {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);\n    }\n    if (attributeErrors) {\n      showAttributeErrors(order);\n    }\n    return showAttributes(order);\n  };\n  this.displayAttributeErrors = function displayAttributeErrors() {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);\n    }\n    return showAttributeErrors();\n  };\n  // Returns a parser grammar object constructor function as a JavaScript string.\n  // This object can then be used to construct a parser.\n  this.toSource = function toSource(name) {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}can't generate parser source - must be preceeded by call to attributes()`);\n    }\n    if (attributeErrors) {\n      throw new Error(`${thisFileName}can't generate parser source - attributes have ${attributeErrors} errors`);\n    }\n    return parser.generateSource(this.chars, this.lines, this.rules, this.udts, name);\n  };\n  // Returns a parser grammar object.\n  // This grammar object may be used by the application to construct a parser.\n  this.toObject = function toObject() {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}can't generate parser source - must be preceeded by call to attributes()`);\n    }\n    if (attributeErrors) {\n      throw new Error(`${thisFileName}can't generate parser source - attributes have ${attributeErrors} errors`);\n    }\n    return parser.generateObject(this.sabnf, this.rules, this.udts);\n  };\n  // Display errors in text format, suitable for `console.log()`.\n  this.errorsToAscii = function errorsToAsciiFunc() {\n    return errorsToAscii(this.errors, this.lines, this.chars);\n  };\n  // Display errors in HTML format, suitable for web page display.\n  // (`apg-lib.css` required for proper styling)\n  this.errorsToHtml = function errorsToHtmlFunc(title) {\n    return errorsToHtml(this.errors, this.lines, this.chars, title);\n  };\n  // Generate an annotated the SABNF grammar display in text format.\n  this.linesToAscii = function linesToAsciiFunc() {\n    return linesToAscii(this.lines);\n  };\n  // Generate an annotated the SABNF grammar display in HTML format.\n  // (`apg-lib.css` required for proper styling)\n  this.linesToHtml = function linesToHtmlFunc() {\n    return linesToHtml(this.lines);\n  };\n  // This function was only used by apg.html which has been abandoned.\n  /*\n    this.getAttributesObject = function () {\n        return null;\n    };\n    */\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL2FwaS5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLGtGQUF5QjtBQUNsRCxvQkFBb0IsbUJBQU8sQ0FBQyxzRkFBMkI7QUFDdkQsa0JBQWtCLG1CQUFPLENBQUMsK0RBQVc7QUFDckMsc0JBQXNCLG1CQUFPLENBQUMsNkRBQVU7QUFDeEMsVUFBVSx3RUFBd0UsRUFBRSxtQkFBTyxDQUFDLHFFQUFjO0FBQzFHLG9CQUFvQixtQkFBTyxDQUFDLHFFQUFjOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNEJBQTRCO0FBQ3BFO0FBQ0Esd0NBQXdDLDJCQUEyQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixXQUFXO0FBQ3BDLCtCQUErQixjQUFjO0FBQzdDLDJCQUEyQixXQUFXO0FBQ3RDLHlCQUF5Qix5REFBeUQ7QUFDbEYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyQkFBMkI7QUFDeEQ7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEMsMEJBQTBCLGNBQWM7QUFDeEMsMEJBQTBCLFdBQVc7QUFDckMsMEJBQTBCLHdEQUF3RDtBQUNsRjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxvQkFBb0IsU0FBUztBQUNwRSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUyxXQUFXLGVBQWUsV0FBVyxRQUFRLFdBQVcsS0FBSztBQUM3RjtBQUNBO0FBQ0EsZ0RBQWdELE9BQU8sRUFBRSx3Q0FBd0M7QUFDakc7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QixnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QixnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLE1BQU07QUFDWjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSix1QkFBdUIsYUFBYTtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0EseUJBQXlCLGFBQWEsaURBQWlELGlCQUFpQjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYSxpREFBaUQsaUJBQWlCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvYXBpLmpzP2ZiY2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgaXMgQXBwbGljYXRpb24gUHJvZ3JhbW1pbmcgSW50ZXJmYWNlIChBUEkpIGZvciAqKkFQRyoqIC0gdGhlIEFCTkYgUGFyc2VyIEdlbmVyYXRvci5cbi8vXG4vLyAqTm90ZSBvbiB0ZW1pbm9sb2d5Lipcbi8vIEFQRyBpcyBhIHBhcnNlciBnZW5lcmF0b3IuXG4vLyBIb3dldmVyLCBpdCByZWFsbHkgb25seSBnZW5lcmF0ZXMgYSBcImdyYW1tYXIgb2JqZWN0XCIgKHNlZSBiZWxvdykgZnJvbSB0aGUgZGVmaW5pbmcgU0FCTkYgZ3JhbW1hci5cbi8vIFRoZSBnZW5lcmF0ZWQgcGFyc2VyIGlzIGluY29tcGxldGUgYXQgdGhpcyBzdGFnZS5cbi8vIFJlbWFpbmluZywgaXQgaXMgdGhlIGpvYiBvZiB0aGUgdXNlciB0byBkZXZlbG9wIHRoZSBnZW5lcmF0ZWQgcGFyc2VyIGZyb20gdGhlIGdyYW1tYXIgb2JqZWN0IGFuZCB0aGUgKipBUEcqKiBMaWJyYXJ5ICgqKmFwZy1saWIqKikuXG4vL1xuLy8gVGhlIGZvbGxvd2luZyB0ZXJtaW5vbG9neSBteSBoZWxwIGNsZWFyIHVwIGFueSBjb25mdXNpb24gYmV0d2VlbiB0aGUgaWRlYSBvZiBhIFwiZ2VuZXJhdGVkIHBhcnNlclwiIHZlcnN1cyBhIFwiZ2VuZXJhdGVkIGdyYW1tYXIgb2JqZWN0XCIuXG5cbi8vIC0gVGhlIGdlbmVyYXRpbmcgcGFyc2VyOiAqKkFQRyoqIGlzIGFuICoqQVBHKiogcGFyc2VyICh5ZXMsIHRoZXJlIGlzIGEgY2lyY3VsYXIgZGVwZW5kZW5jZSBiZXR3ZWVuICoqYXBnLWFwaSoqIGFuZCAqKmFwZy1saWIqKikuIFdlJ2xsIGNhbGwgaXQgdGhlIGdlbmVyYXRpbmcgcGFyc2VyLlxuLy8gLSBUaGUgdGFyZ2V0IHBhcnNlcjogKipBUEcqKidzIGdvYWwgaXMgdG8gZ2VuZXJhdGUgYSBwYXJzZXIuIFdlJ2xsIGNhbGwgaXQgdGhlIHRhcmdldCBwYXJzZXIuXG4vLyAtIFRoZSB0YXJnZXQgZ3JhbW1hcjogdGhpcyBpcyB0aGUgKEFTQ0lJKSBTQUJORiBncmFtbWFyIGRlZmluaW5nIHRoZSB0YXJnZXQgcGFyc2VyLlxuLy8gLSBUaGUgdGFyZ2V0IGdyYW1tYXIgb2JqZWN0OiAqKkFQRyoqIHBhcnNlcyB0aGUgU0FCTkYgZ3JhbW1hciBhbmQgZ2VuZXJhdGVzIHRoZSBKYXZhU2NyaXB0IHNvdXJjZSBmb3IgYSB0YXJnZXQgZ3JhbW1hciBvYmplY3QgY29uc3RydWN0b3IgZnVuY3Rpb25cbi8vIGFuZC9vciBhbiBhY3R1YWwgZ3JhbW1hciBvYmplY3QuXG4vLyAtIFRoZSBmaW5hbCB0YXJnZXQgcGFyc2VyOiBUaGUgdXNlciB0aGVuIGRldmVsb3BzIHRoZSBmaW5hbCB0YXJnZXQgcGFyc2VyIHVzaW5nIHRoZSBnZW5lcmF0ZWQgdGFyZ2V0IGdyYW1tYXJcbi8vIG9iamVjdCBhbmQgdGhlICoqQVBHKiogcGFyc2luZyBsaWJyYXJ5LCAqKmFwZy1saWIqKi5cbi8vIFRocm93cyBleGVjZXB0aW9ucyBvbiBmYXRhbCBlcnJvcnMuXG4vL1xuLy8gc3JjOiB0aGUgaW5wdXQgU0FCTkYgZ3JhbW1hcjxicj5cbi8vIG1heSBiZSBvbmUgb2Y6XG4vLyAtIEJ1ZmZlciBvZiBieXRlc1xuLy8gLSBKYXZhU2NyaXB0IHN0cmluZ1xuLy8gLSBBcnJheSBvZiBpbnRlZ2VyIGNoYXJhY3RlciBjb2Rlc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhcGkoc3JjKSB7XG4gIGNvbnN0IHRoaXNGaWxlTmFtZSA9ICdhcGkuanM6ICc7XG4gIGNvbnN0IHRoaXNPYmplY3QgPSB0aGlzO1xuXG4gIC8qIFBSSVZBVEUgUFJPUEVSVElFUyAqL1xuICBjb25zdCBhcGdsaWIgPSByZXF1aXJlKCcuLi9hcGctbGliL25vZGUtZXhwb3J0cycpO1xuICBjb25zdCBjb252ZXJ0ZXIgPSByZXF1aXJlKCcuLi9hcGctY29udi1hcGkvY29udmVydGVyJyk7XG4gIGNvbnN0IHNjYW5uZXIgPSByZXF1aXJlKCcuL3NjYW5uZXInKTtcbiAgY29uc3QgcGFyc2VyID0gbmV3IChyZXF1aXJlKCcuL3BhcnNlcicpKSgpO1xuICBjb25zdCB7IGF0dHJpYnV0ZXMsIHNob3dBdHRyaWJ1dGVzLCBzaG93QXR0cmlidXRlRXJyb3JzLCBzaG93UnVsZURlcGVuZGVuY2llcyB9ID0gcmVxdWlyZSgnLi9hdHRyaWJ1dGVzJyk7XG4gIGNvbnN0IHNob3dSdWxlcyA9IHJlcXVpcmUoJy4vc2hvdy1ydWxlcycpO1xuXG4gIC8qIFBSSVZBVEUgTUVNQkVSUyAoRlVOQ1RJT05TKSAqL1xuICAvKiBDb252ZXJ0IGEgcGhyYXNlIChhcnJheSBvZiBjaGFyYWN0ZXIgY29kZXMpIHRvIEhUTUwuICovXG4gIGNvbnN0IGFibmZUb0h0bWwgPSBmdW5jdGlvbiBhYm5mVG9IdG1sKGNoYXJzLCBiZWcsIGxlbikge1xuICAgIGNvbnN0IE5PUk1BTCA9IDA7XG4gICAgY29uc3QgQ09OVFJPTCA9IDE7XG4gICAgY29uc3QgSU5WQUxJRCA9IDI7XG4gICAgY29uc3QgQ09OVFJPTF9CRUcgPSBgPHNwYW4gY2xhc3M9XCIke2FwZ2xpYi5zdHlsZS5DTEFTU19DVFJMQ0hBUn1cIj5gO1xuICAgIGNvbnN0IENPTlRST0xfRU5EID0gJzwvc3Bhbj4nO1xuICAgIGNvbnN0IElOVkFMSURfQkVHID0gYDxzcGFuIGNsYXNzPVwiJHthcGdsaWIuc3R5bGUuQ0xBU1NfTk9NQVRDSH1cIj5gO1xuICAgIGNvbnN0IElOVkFMSURfRU5EID0gJzwvc3Bhbj4nO1xuICAgIGxldCBlbmQ7XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBjb25zdCBUUlVFID0gdHJ1ZTtcbiAgICB3aGlsZSAoVFJVRSkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNoYXJzKSB8fCBjaGFycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGJlZyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhYm5mVG9IdG1sOiBiZWcgbXVzdCBiZSB0eXBlIG51bWJlcicpO1xuICAgICAgfVxuICAgICAgaWYgKGJlZyA+PSBjaGFycy5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGxlbiAhPT0gJ251bWJlcicgfHwgYmVnICsgbGVuID49IGNoYXJzLmxlbmd0aCkge1xuICAgICAgICBlbmQgPSBjaGFycy5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSBiZWcgKyBsZW47XG4gICAgICB9XG4gICAgICBsZXQgc3RhdGUgPSBOT1JNQUw7XG4gICAgICBmb3IgKGxldCBpID0gYmVnOyBpIDwgZW5kOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgY2ggPSBjaGFyc1tpXTtcbiAgICAgICAgaWYgKGNoID49IDMyICYmIGNoIDw9IDEyNikge1xuICAgICAgICAgIC8qIG5vcm1hbCAtIHByaW50YWJsZSBBU0NJSSBjaGFyYWN0ZXJzICovXG4gICAgICAgICAgaWYgKHN0YXRlID09PSBDT05UUk9MKSB7XG4gICAgICAgICAgICBodG1sICs9IENPTlRST0xfRU5EO1xuICAgICAgICAgICAgc3RhdGUgPSBOT1JNQUw7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gSU5WQUxJRCkge1xuICAgICAgICAgICAgaHRtbCArPSBJTlZBTElEX0VORDtcbiAgICAgICAgICAgIHN0YXRlID0gTk9STUFMO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBoYW5kbGUgcmVzZXJ2ZWQgSFRNTCBlbnRpdHkgY2hhcmFjdGVycyAqL1xuICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgIGh0bWwgKz0gJyZuYnNwOyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2MDpcbiAgICAgICAgICAgICAgaHRtbCArPSAnJmx0Oyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2MjpcbiAgICAgICAgICAgICAgaHRtbCArPSAnJmd0Oyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgICAgaHRtbCArPSAnJmFtcDsnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgIGh0bWwgKz0gJyZxdW90Oyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgaHRtbCArPSAnJiMwMzk7JztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDkyOlxuICAgICAgICAgICAgICBodG1sICs9ICcmIzA5MjsnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGh0bWwgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gOSB8fCBjaCA9PT0gMTAgfHwgY2ggPT09IDEzKSB7XG4gICAgICAgICAgLyogY29udHJvbCBjaGFyYWN0ZXJzICovXG4gICAgICAgICAgaWYgKHN0YXRlID09PSBOT1JNQUwpIHtcbiAgICAgICAgICAgIGh0bWwgKz0gQ09OVFJPTF9CRUc7XG4gICAgICAgICAgICBzdGF0ZSA9IENPTlRST0w7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gSU5WQUxJRCkge1xuICAgICAgICAgICAgaHRtbCArPSBJTlZBTElEX0VORCArIENPTlRST0xfQkVHO1xuICAgICAgICAgICAgc3RhdGUgPSBDT05UUk9MO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2ggPT09IDkpIHtcbiAgICAgICAgICAgIGh0bWwgKz0gJ1RBQic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaCA9PT0gMTApIHtcbiAgICAgICAgICAgIGh0bWwgKz0gJ0xGJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoID09PSAxMykge1xuICAgICAgICAgICAgaHRtbCArPSAnQ1InO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBpbnZhbGlkIGNoYXJhY3RlcnMgKi9cbiAgICAgICAgICBpZiAoc3RhdGUgPT09IE5PUk1BTCkge1xuICAgICAgICAgICAgaHRtbCArPSBJTlZBTElEX0JFRztcbiAgICAgICAgICAgIHN0YXRlID0gSU5WQUxJRDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBDT05UUk9MKSB7XG4gICAgICAgICAgICBodG1sICs9IENPTlRST0xfRU5EICsgSU5WQUxJRF9CRUc7XG4gICAgICAgICAgICBzdGF0ZSA9IElOVkFMSUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qIGRpc3BsYXkgY2hhcmFjdGVyIGFzIGhleGFkZWNpbWFsIHZhbHVlICovXG4gICAgICAgICAgaHRtbCArPSBgXFxcXHgke2FwZ2xpYi51dGlscy5jaGFyVG9IZXgoY2gpfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZSA9PT0gSU5WQUxJRCkge1xuICAgICAgICBodG1sICs9IElOVkFMSURfRU5EO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlID09PSBDT05UUk9MKSB7XG4gICAgICAgIGh0bWwgKz0gQ09OVFJPTF9FTkQ7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIC8qIENvbnZlcnQgYSBwaHJhc2UgKGFycmF5IG9mIGNoYXJhY3RlciBjb2RlcykgdG8gQVNDSUkgdGV4dC4gKi9cbiAgY29uc3QgYWJuZlRvQXNjaWkgPSBmdW5jdGlvbiBhYm5mVG9Bc2NpaShjaGFycywgYmVnLCBsZW4pIHtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IGJlZzsgaSA8IGJlZyArIGxlbjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBjaCA9IGNoYXJzW2ldO1xuICAgICAgaWYgKGNoID49IDMyICYmIGNoIDw9IDEyNikge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgc3RyICs9ICdcXFxcdCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgc3RyICs9ICdcXFxcbic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgc3RyICs9ICdcXFxccic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc3RyICs9ICdcXFxcdW5rbm93bic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuICAvKiB0cmFuc2xhdGUgbGluZXMgKFNBQk5GIGdyYW1tYXIpIHRvIEFTQ0lJIHRleHQgKi9cbiAgY29uc3QgbGluZXNUb0FzY2lpID0gZnVuY3Rpb24gbGluZXNUb0FzY2lpKGxpbmVzKSB7XG4gICAgbGV0IHN0ciA9ICdBbm5vdGF0ZWQgSW5wdXQgR3JhbW1hcic7XG4gICAgbGluZXMuZm9yRWFjaCgodmFsKSA9PiB7XG4gICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICBzdHIgKz0gYGxpbmUgbm86ICR7dmFsLmxpbmVOb31gO1xuICAgICAgc3RyICs9IGAgOiBjaGFyIGluZGV4OiAke3ZhbC5iZWdpbkNoYXJ9YDtcbiAgICAgIHN0ciArPSBgIDogbGVuZ3RoOiAke3ZhbC5sZW5ndGh9YDtcbiAgICAgIHN0ciArPSBgIDogYWJuZjogJHthYm5mVG9Bc2NpaSh0aGlzT2JqZWN0LmNoYXJzLCB2YWwuYmVnaW5DaGFyLCB2YWwubGVuZ3RoKX1gO1xuICAgIH0pO1xuICAgIHN0ciArPSAnXFxuJztcbiAgICByZXR1cm4gc3RyO1xuICB9O1xuICAvKiB0cmFuc2xhdGUgbGluZXMgKFNBQk5GIGdyYW1tYXIpIHRvIEhUTUwgKi9cbiAgY29uc3QgbGluZXNUb0h0bWwgPSBmdW5jdGlvbiBsaW5lc1RvSHRtbChsaW5lcykge1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgaHRtbCArPSBgPHRhYmxlIGNsYXNzPVwiJHthcGdsaWIuc3R5bGUuQ0xBU1NfR1JBTU1BUn1cIj5cXG5gO1xuICAgIGNvbnN0IHRpdGxlID0gJ0Fubm90YXRlZCBJbnB1dCBHcmFtbWFyJztcbiAgICBodG1sICs9IGA8Y2FwdGlvbj4ke3RpdGxlfTwvY2FwdGlvbj5cXG5gO1xuICAgIGh0bWwgKz0gJzx0cj4nO1xuICAgIGh0bWwgKz0gJzx0aD5saW5lPGJyPm5vLjwvdGg+PHRoPmZpcnN0PGJyPmNoYXI8L3RoPjx0aD48YnI+bGVuZ3RoPC90aD48dGg+PGJyPnRleHQ8L3RoPic7XG4gICAgaHRtbCArPSAnPC90cj5cXG4nO1xuICAgIGxpbmVzLmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgaHRtbCArPSAnPHRyPic7XG4gICAgICBodG1sICs9IGA8dGQ+JHt2YWwubGluZU5vfWA7XG4gICAgICBodG1sICs9IGA8L3RkPjx0ZD4ke3ZhbC5iZWdpbkNoYXJ9YDtcbiAgICAgIGh0bWwgKz0gYDwvdGQ+PHRkPiR7dmFsLmxlbmd0aH1gO1xuICAgICAgaHRtbCArPSBgPC90ZD48dGQ+JHthYm5mVG9IdG1sKHRoaXNPYmplY3QuY2hhcnMsIHZhbC5iZWdpbkNoYXIsIHZhbC5sZW5ndGgpfWA7XG4gICAgICBodG1sICs9ICc8L3RkPic7XG4gICAgICBodG1sICs9ICc8L3RyPlxcbic7XG4gICAgfSk7XG5cbiAgICBodG1sICs9ICc8L3RhYmxlPlxcbic7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIC8qIEZvcm1hdCB0aGUgZXJyb3IgbWVzc2FnZXMgdG8gSFRNTCwgZm9yIHBhZ2UgZGlzcGxheS4gKi9cbiAgY29uc3QgZXJyb3JzVG9IdG1sID0gZnVuY3Rpb24gZXJyb3JzVG9IdG1sKGVycm9ycywgbGluZXMsIGNoYXJzLCB0aXRsZSkge1xuICAgIGNvbnN0IFtzdHlsZV0gPSBhcGdsaWI7XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBjb25zdCBlcnJvckFycm93ID0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19OT01BVENIfVwiPiZyYXF1bzs8L3NwYW4+YDtcbiAgICBodG1sICs9IGA8cD48dGFibGUgY2xhc3M9XCIke3N0eWxlLkNMQVNTX0dSQU1NQVJ9XCI+XFxuYDtcbiAgICBpZiAodGl0bGUgJiYgdHlwZW9mIHRpdGxlID09PSAnc3RyaW5nJykge1xuICAgICAgaHRtbCArPSBgPGNhcHRpb24+JHt0aXRsZX08L2NhcHRpb24+XFxuYDtcbiAgICB9XG4gICAgaHRtbCArPSAnPHRyPjx0aD5saW5lPGJyPm5vLjwvdGg+PHRoPmxpbmU8YnI+b2Zmc2V0PC90aD48dGg+ZXJyb3I8YnI+b2Zmc2V0PC90aD48dGg+PGJyPnRleHQ8L3RoPjwvdHI+XFxuJztcbiAgICBlcnJvcnMuZm9yRWFjaCgodmFsKSA9PiB7XG4gICAgICBsZXQgbGluZTtcbiAgICAgIGxldCByZWxjaGFyO1xuICAgICAgbGV0IGJlZztcbiAgICAgIGxldCBlbmQ7XG4gICAgICBsZXQgdGV4dDtcbiAgICAgIGxldCBwcmVmaXggPSAnJztcbiAgICAgIGxldCBzdWZmaXggPSAnJztcbiAgICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGV4dCA9IGVycm9yQXJyb3c7XG4gICAgICAgIHJlbGNoYXIgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZSA9IGxpbmVzW3ZhbC5saW5lXTtcbiAgICAgICAgYmVnID0gbGluZS5iZWdpbkNoYXI7XG4gICAgICAgIGlmICh2YWwuY2hhciA+IGJlZykge1xuICAgICAgICAgIHByZWZpeCA9IGFibmZUb0h0bWwoY2hhcnMsIGJlZywgdmFsLmNoYXIgLSBiZWcpO1xuICAgICAgICB9XG4gICAgICAgIGJlZyA9IHZhbC5jaGFyO1xuICAgICAgICBlbmQgPSBsaW5lLmJlZ2luQ2hhciArIGxpbmUubGVuZ3RoO1xuICAgICAgICBpZiAoYmVnIDwgZW5kKSB7XG4gICAgICAgICAgc3VmZml4ID0gYWJuZlRvSHRtbChjaGFycywgYmVnLCBlbmQgLSBiZWcpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBwcmVmaXggKyBlcnJvckFycm93ICsgc3VmZml4O1xuICAgICAgICByZWxjaGFyID0gdmFsLmNoYXIgLSBsaW5lLmJlZ2luQ2hhcjtcbiAgICAgICAgaHRtbCArPSAnPHRyPic7XG4gICAgICAgIGh0bWwgKz0gYDx0ZD4ke3ZhbC5saW5lfTwvdGQ+PHRkPiR7bGluZS5iZWdpbkNoYXJ9PC90ZD48dGQ+JHtyZWxjaGFyfTwvdGQ+PHRkPiR7dGV4dH08L3RkPmA7XG4gICAgICAgIGh0bWwgKz0gJzwvdHI+XFxuJztcbiAgICAgICAgaHRtbCArPSAnPHRyPic7XG4gICAgICAgIGh0bWwgKz0gYDx0ZCBjb2xzcGFuPVwiM1wiPjwvdGQ+PHRkPiZ1YXJyOzombmJzcDske2FwZ2xpYi51dGlscy5zdHJpbmdUb0FzY2lpSHRtbCh2YWwubXNnKX08L3RkPmA7XG4gICAgICAgIGh0bWwgKz0gJzwvdHI+XFxuJztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBodG1sICs9ICc8L3RhYmxlPjwvcD5cXG4nO1xuICAgIHJldHVybiBodG1sO1xuICB9O1xuICAvKiBEaXNwbGF5IGFuIGFycmF5IG9mIGVycm9ycyBpbiBBU0NJSSB0ZXh0ICovXG4gIGNvbnN0IGVycm9yc1RvQXNjaWkgPSBmdW5jdGlvbiBlcnJvcnNUb0FzY2lpKGVycm9ycywgbGluZXMsIGNoYXJzKSB7XG4gICAgbGV0IHN0cjtcbiAgICBsZXQgbGluZTtcbiAgICBsZXQgYmVnO1xuICAgIGxldCBsZW47XG4gICAgc3RyID0gJyc7XG4gICAgZXJyb3JzLmZvckVhY2goKGVycm9yKSA9PiB7XG4gICAgICBsaW5lID0gbGluZXNbZXJyb3IubGluZV07XG4gICAgICBzdHIgKz0gYCR7bGluZS5saW5lTm99OiBgO1xuICAgICAgc3RyICs9IGAke2xpbmUuYmVnaW5DaGFyfTogYDtcbiAgICAgIHN0ciArPSBgJHtlcnJvci5jaGFyIC0gbGluZS5iZWdpbkNoYXJ9OiBgO1xuICAgICAgYmVnID0gbGluZS5iZWdpbkNoYXI7XG4gICAgICBsZW4gPSBlcnJvci5jaGFyIC0gbGluZS5iZWdpbkNoYXI7XG4gICAgICBzdHIgKz0gYWJuZlRvQXNjaWkoY2hhcnMsIGJlZywgbGVuKTtcbiAgICAgIHN0ciArPSAnID4+ICc7XG4gICAgICBiZWcgPSBlcnJvci5jaGFyO1xuICAgICAgbGVuID0gbGluZS5iZWdpbkNoYXIgKyBsaW5lLmxlbmd0aCAtIGVycm9yLmNoYXI7XG4gICAgICBzdHIgKz0gYWJuZlRvQXNjaWkoY2hhcnMsIGJlZywgbGVuKTtcbiAgICAgIHN0ciArPSAnXFxuJztcbiAgICAgIHN0ciArPSBgJHtsaW5lLmxpbmVOb306IGA7XG4gICAgICBzdHIgKz0gYCR7bGluZS5iZWdpbkNoYXJ9OiBgO1xuICAgICAgc3RyICs9IGAke2Vycm9yLmNoYXIgLSBsaW5lLmJlZ2luQ2hhcn06IGA7XG4gICAgICBzdHIgKz0gJ2Vycm9yOiAnO1xuICAgICAgc3RyICs9IGVycm9yLm1zZztcbiAgICAgIHN0ciArPSAnXFxuJztcbiAgICB9KTtcbiAgICByZXR1cm4gc3RyO1xuICB9O1xuICBsZXQgaXNTY2FubmVkID0gZmFsc2U7XG4gIGxldCBpc1BhcnNlZCA9IGZhbHNlO1xuICBsZXQgaXNUcmFuc2xhdGVkID0gZmFsc2U7XG4gIGxldCBoYXZlQXR0cmlidXRlcyA9IGZhbHNlO1xuICBsZXQgYXR0cmlidXRlRXJyb3JzID0gMDtcbiAgbGV0IGxpbmVNYXA7XG5cbiAgLyogUFVCTElDIFBST1BFUlRJRVMgKi9cbiAgLy8gVGhlIGlucHV0IFNBQk5GIGdyYW1tYXIgYXMgYSBKYXZhU2NyaXB0IHN0cmluZy5cbiAgLy8gdGhpcy5zYWJuZjtcbiAgLy8gVGhlIGlucHV0IFNBQk5GIGdyYW1tYXIgYXMgYW4gYXJyYXkgb2YgY2hhcmFjdGVyIGNvZGVzLlxuICAvLyB0aGlzLmNoYXJzO1xuICAvLyBBbiBhcnJheSBvZiBsaW5lIG9iamVjdHMsIGRlZmluaW5nIGVhY2ggbGluZSBvZiB0aGUgaW5wdXQgU0FCTkYgZ3JhbW1hclxuICAvLyAtIGxpbmVObyA6IHRoZSB6ZXJvLWJhc2VkIGxpbmUgbnVtYmVyXG4gIC8vIC0gYmVnaW5DaGFyIDogb2Zmc2V0IChpbnRvIGB0aGlzLmNoYXJzYCkgb2YgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgbGluZVxuICAvLyAtIGxlbmd0aCA6IHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBpbiB0aGUgbGluZVxuICAvLyAtIHRleHRMZW5ndGggOiB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgb2YgdGV4dCBpbiB0aGUgbGluZSwgZXhjbHVkaW5nIHRoZSBsaW5lIGVuZGluZyBjaGFyYWN0ZXJzXG4gIC8vIC0gZW5kVHlwZSA6IFwiQ1JMRlwiLCBcIkxGXCIsIFwiQ1JcIiBvciBcIm5vbmVcIiBpZiB0aGUgbGFzdCBsaW5lIGhhcyBubyBsaW5lIGVuZGluZyBjaGFyYWN0ZXJzXG4gIC8vIC0gaW52YWxpZENoYXJzIDogYHRydWVgIGlmIHRoZSBsaW5lIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycywgYGZhbHNlYCBvdGhlcndpc2VcbiAgLy8gdGhpcy5saW5lcztcbiAgLy8gQW4gYXJyYXkgb2YgcnVsZSBuYW1lcyBhbmQgZGF0YS5cbiAgLy8gLSBuYW1lIDogdGhlIHJ1bGUgbmFtZVxuICAvLyAtIGxvd2VyIDogdGhlIHJ1bGUgbmFtZSBpbiBsb3dlciBjYXNlXG4gIC8vIC0gaW5kZXggOiB0aGUgaW5kZXggb2YgdGhlIHJ1bGUgKG9yZGVyZWQgYnkgYXBwZWFyYW5jZSBpbiBTQUJORiBncmFtbWFyKVxuICAvLyAtIGlzQmtyIDogYHRydWVgIGlmIHRoaXMgcnVsZSBoYXMgYmVlbiBiYWNrIHJlZmVyZW5jZWQsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gIC8vIC0gb3Bjb2RlcyA6IGFycmF5IG9mIG9wY29kZXMgZm9yIHRoaXMgcnVsZVxuICAvLyAtIGF0dHJzIDogdGhlIHJ1bGUgYXR0cmlidXRlc1xuICAvLyAtIGN0cmwgOiBzeXN0ZW0gZGF0YVxuICAvLyB0aGlzLnJ1bGVzO1xuICAvLyBBbiBhcnJheSBvZiBVRFQgbmFtZXMgYW5kIGRhdGEuXG4gIC8vIHRoaXMudWR0cztcbiAgLy8gQW4gYXJyYXkgb2YgZXJyb3JzLCBpZiBhbnkuXG4gIC8vIC0gbGluZSA6IHRoZSBsaW5lIG51bWJlciBjb250YWluaW5nIHRoZSBlcnJvclxuICAvLyAtIGNoYXIgOiB0aGUgY2hhcmFjdGVyIG9mZnNldCBvZiB0aGUgZXJyb3JcbiAgLy8gLSBtc2cgOiB0aGUgZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVycm9ycyA9IFtdO1xuXG4gIC8qIENPTlNUUlVDVE9SICovXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3JjKSkge1xuICAgIHRoaXMuY2hhcnMgPSBjb252ZXJ0ZXIuZGVjb2RlKCdCSU5BUlknLCBzcmMpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3JjKSkge1xuICAgIHRoaXMuY2hhcnMgPSBzcmMuc2xpY2UoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuY2hhcnMgPSBjb252ZXJ0ZXIuZGVjb2RlKCdTVFJJTkcnLCBzcmMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9aW5wdXQgc291cmNlIGlzIG5vdCBhIHN0cmluZywgYnl0ZSBCdWZmZXIgb3IgY2hhcmFjdGVyIGFycmF5YCk7XG4gIH1cbiAgdGhpcy5zYWJuZiA9IGNvbnZlcnRlci5lbmNvZGUoJ1NUUklORycsIHRoaXMuY2hhcnMpO1xuXG4gIC8qIFBVQkxJQyBNRU1CRVJTIChGVU5DVElPTlMpICovXG4gIC8vIFNjYW4gdGhlIGlucHV0IFNBQk5GIGdyYW1tYXIgZm9yIGludmFsaWQgY2hhcmFjdGVycyBhbmQgY2F0YWxvZyB0aGUgbGluZXMgdmlhIGB0aGlzLmxpbmVzYC5cbiAgLy8gLSBzdHJpY3QgOiAob3B0aW9uYWwpIGlmIGB0cnVlYCwgYWxsIGxpbmVzLCBpbmNsdWRpbmcgdGhlIGxhc3QgbXVzdCBlbmQgd2l0aCBDUkxGIChcXHJcXG4pLFxuICAvLyBpZiBgZmFsc2VgIChpbiBhbnkgSmF2YVNjcmlwdCBzZW5zZSkgdGhlbiBsaW5lIGVuZGluZ3MgbWF5IGJlIGFueSBtaXggb2YgQ1JMRiwgTEYsIENSLCBvciBlbmQtb2YtZmlsZS5cbiAgLy8gLSB0cmFjZSAoKikgOiAob3B0aW9uYWwpIGEgcGFyc2VyIHRyYWNlIG9iamVjdCwgd2hpY2ggd2lsbCB0cmFjZSB0aGUgcGFyc2VyIHRoYXQgZG9lcyB0aGUgc2NhblxuICB0aGlzLnNjYW4gPSBmdW5jdGlvbiBzY2FuKHN0cmljdCwgdHJhY2UpIHtcbiAgICB0aGlzLmxpbmVzID0gc2Nhbm5lcih0aGlzLmNoYXJzLCB0aGlzLmVycm9ycywgc3RyaWN0LCB0cmFjZSk7XG4gICAgaXNTY2FubmVkID0gdHJ1ZTtcbiAgfTtcbiAgLy8gUGFyc2UgdGhlIGlucHV0IFNBQk5GIGdyYW1tYXIgZm9yIGNvcnJlY3Qgc3ludGF4LlxuICAvLyAtIHN0cmljdCA6IChvcHRpb25hbCkgaWYgYHRydWVgLCB0aGUgaW5wdXQgZ3JhbW1hciBtdXN0IGJlIHN0cmljdCBBQk5GLCBjb25mb3JtaW5nIHRvIFtSRkMgNTIzNF0oaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUyMzQpXG4gIC8vIGFuZCBbUkZDIDc0MDVdKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NDA1KS4gTm8gc3VwZXJzZXQgZmVhdHVyZXMgYWxsb3dlZC5cbiAgLy8gLSB0cmFjZSAoXFwqKSA6IChvcHRpb25hbCkgYSBwYXJzZXIgdHJhY2Ugb2JqZWN0LCB3aGljaCB3aWxsIHRyYWNlIHRoZSBzeW50YXggcGFyc2VyXG4gIC8vXG4gIC8vIDxpPigqKU5PVEU6IHRoZSB0cmFjZSBvcHRpb24gd2FzIHVzZWQgcHJpbWFyaWx5IGR1cmluZyBkZXZlbG9wbWVudC5cbiAgLy8gRXJyb3IgZGV0ZWN0aW9uIGFuZCByZXBvcnRpbmcgaXMgbm93IGZhaXJseSByb2J1c3QgYW5kIHRyYWNpbmcgc2hvdWxkIGJlIHVubmVjZXNzYXJ5LiBVc2UgYXQgeW91ciBvd24gcGVyaWwuPC9pPlxuICB0aGlzLnBhcnNlID0gZnVuY3Rpb24gcGFyc2Uoc3RyaWN0LCB0cmFjZSkge1xuICAgIGlmICghaXNTY2FubmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWdyYW1tYXIgbm90IHNjYW5uZWRgKTtcbiAgICB9XG4gICAgcGFyc2VyLnN5bnRheCh0aGlzLmNoYXJzLCB0aGlzLmxpbmVzLCB0aGlzLmVycm9ycywgc3RyaWN0LCB0cmFjZSk7XG4gICAgaXNQYXJzZWQgPSB0cnVlO1xuICB9O1xuICAvLyBUcmFuc2xhdGUgdGhlIFNBQk5GIGdyYW1tYXIgc3ludGF4IGludG8gdGhlIG9wY29kZXMgdGhhdCB3aWxsIGd1aWRlIHRoZSBwYXJzZXIgZm9yIHRoaXMgZ3JhbW1hci5cbiAgdGhpcy50cmFuc2xhdGUgPSBmdW5jdGlvbiB0cmFuc2xhdGUoKSB7XG4gICAgaWYgKCFpc1BhcnNlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1ncmFtbWFyIG5vdCBzY2FubmVkIGFuZCBwYXJzZWRgKTtcbiAgICB9XG4gICAgY29uc3QgcmV0ID0gcGFyc2VyLnNlbWFudGljKHRoaXMuY2hhcnMsIHRoaXMubGluZXMsIHRoaXMuZXJyb3JzKTtcbiAgICBpZiAodGhpcy5lcnJvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnJ1bGVzID0gcmV0LnJ1bGVzO1xuICAgICAgdGhpcy51ZHRzID0gcmV0LnVkdHM7XG4gICAgICBsaW5lTWFwID0gcmV0LmxpbmVNYXA7XG4gICAgICBpc1RyYW5zbGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgLy8gQ29tcHV0ZSB0aGUgYXR0cmlidXRlcyBvZiBlYWNoIHJ1bGUuXG4gIHRoaXMuYXR0cmlidXRlcyA9IGZ1bmN0aW9uIGF0dHJzKCkge1xuICAgIGlmICghaXNUcmFuc2xhdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWdyYW1tYXIgbm90IHNjYW5uZWQsIHBhcnNlZCBhbmQgdHJhbnNsYXRlZGApO1xuICAgIH1cbiAgICBhdHRyaWJ1dGVFcnJvcnMgPSBhdHRyaWJ1dGVzKHRoaXMucnVsZXMsIHRoaXMudWR0cywgbGluZU1hcCwgdGhpcy5lcnJvcnMpO1xuICAgIGhhdmVBdHRyaWJ1dGVzID0gdHJ1ZTtcbiAgICByZXR1cm4gYXR0cmlidXRlRXJyb3JzO1xuICB9O1xuICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgcGVyZm9ybSB0aGUgZnVsbCBzdWl0ZSBvZiBzdGVwcyByZXF1aXJlZCB0byBnZW5lcmF0ZSBhIHBhcnNlciBncmFtbWFyIG9iamVjdFxuICAvLyBmcm9tIHRoZSBpbnB1dCBTQUJORiBncmFtbWFyLlxuICB0aGlzLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUoc3RyaWN0KSB7XG4gICAgdGhpcy5saW5lcyA9IHNjYW5uZXIodGhpcy5jaGFycywgdGhpcy5lcnJvcnMsIHN0cmljdCk7XG4gICAgaWYgKHRoaXMuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwYXJzZXIuc3ludGF4KHRoaXMuY2hhcnMsIHRoaXMubGluZXMsIHRoaXMuZXJyb3JzLCBzdHJpY3QpO1xuICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmV0ID0gcGFyc2VyLnNlbWFudGljKHRoaXMuY2hhcnMsIHRoaXMubGluZXMsIHRoaXMuZXJyb3JzKTtcbiAgICBpZiAodGhpcy5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucnVsZXMgPSByZXQucnVsZXM7XG4gICAgdGhpcy51ZHRzID0gcmV0LnVkdHM7XG4gICAgbGluZU1hcCA9IHJldC5saW5lTWFwO1xuXG4gICAgYXR0cmlidXRlRXJyb3JzID0gYXR0cmlidXRlcyh0aGlzLnJ1bGVzLCB0aGlzLnVkdHMsIGxpbmVNYXAsIHRoaXMuZXJyb3JzKTtcbiAgICBoYXZlQXR0cmlidXRlcyA9IHRydWU7XG4gIH07XG4gIC8vIERpc3BsYXkgdGhlIHJ1bGVzLlxuICAvLyBNdXN0IHNjYW4sIHBhcnNlIGFuZCB0cmFuc2xhdGUgYmVmb3JlIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiwgb3RoZXJ3aXNlIHRoZXJlIGFyZSBubyBydWxlcyB0byBkaXNwbGF5LlxuICAvLyAtIG9yZGVyXG4gIC8vICAgICAgLSBcImluZGV4XCIgb3IgXCJpXCIsIGluZGV4IG9yZGVyIChkZWZhdWx0KVxuICAvLyAgICAgIC0gXCJhbHBoYVwiIG9yIFwiYVwiLCBhbHBoYWJldGljYWwgb3JkZXJcbiAgLy8gICAgICAtIG5vbmUgb2YgYWJvdmUsIGluZGV4IG9yZGVyIChkZWZhdWx0KVxuICB0aGlzLmRpc3BsYXlSdWxlcyA9IGZ1bmN0aW9uIGRpc3BsYXlSdWxlcyhvcmRlciA9ICdpbmRleCcpIHtcbiAgICBpZiAoIWlzVHJhbnNsYXRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1ncmFtbWFyIG5vdCBzY2FubmVkLCBwYXJzZWQgYW5kIHRyYW5zbGF0ZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHNob3dSdWxlcyh0aGlzLnJ1bGVzLCB0aGlzLnVkdHMsIG9yZGVyKTtcbiAgfTtcbiAgLy8gRGlzcGxheSB0aGUgcnVsZSBkZXBlbmRlbmNpZXMuXG4gIC8vIE11c3Qgc2NhbiwgcGFyc2UsIHRyYW5zbGF0ZSBhbmQgY29tcHV0ZSBhdHRyaWJ1dGVzIGJlZm9yZSBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uXG4gIC8vIE90aGVyd2lzZSB0aGUgcnVsZSBkZXBlbmRlbmNpZXMgYXJlIG5vdCBrbm93bi5cbiAgLy8gLSBvcmRlclxuICAvLyAgICAgIC0gXCJpbmRleFwiIG9yIFwiaVwiLCBpbmRleCBvcmRlciAoZGVmYXVsdClcbiAgLy8gICAgICAtIFwiYWxwaGFcIiBvciBcImFcIiwgYWxwaGFiZXRpY2FsIG9yZGVyXG4gIC8vICAgICAgLSBcInR5cGVcIiBvciBcInRcIiwgb3JkZXJlZCBieSB0eXBlIChhbHBoYWJldGljYWwgd2l0aGluIGVhY2ggdHlwZS9ncm91cClcbiAgLy8gICAgICAtIG5vbmUgb2YgYWJvdmUsIGluZGV4IG9yZGVyIChkZWZhdWx0KVxuICB0aGlzLmRpc3BsYXlSdWxlRGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gZGlzcGxheVJ1bGVEZXBlbmRlbmNpZXMob3JkZXIgPSAnaW5kZXgnKSB7XG4gICAgaWYgKCFoYXZlQXR0cmlidXRlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1ubyBhdHRyaWJ1dGVzIC0gbXVzdCBiZSBwcmVjZWVkZWQgYnkgY2FsbCB0byBhdHRyaWJ1dGVzKClgKTtcbiAgICB9XG4gICAgcmV0dXJuIHNob3dSdWxlRGVwZW5kZW5jaWVzKG9yZGVyKTtcbiAgfTtcbiAgLy8gRGlzcGxheSB0aGUgYXR0cmlidXRlcy5cbiAgLy8gTXVzdCBzY2FuLCBwYXJzZSwgdHJhbnNsYXRlIGFuZCBjb21wdXRlIGF0dHJpYnV0ZXMgYmVmb3JlIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgLy8gLSBvcmRlclxuICAvLyAgICAgIC0gXCJpbmRleFwiIG9yIFwiaVwiLCBpbmRleCBvcmRlciAoZGVmYXVsdClcbiAgLy8gICAgICAtIFwiYWxwaGFcIiBvciBcImFcIiwgYWxwaGFiZXRpY2FsIG9yZGVyXG4gIC8vICAgICAgLSBcInR5cGVcIiBvciBcInRcIiwgb3JkZXJlZCBieSB0eXBlIChhbHBoYWJldGljYWwgd2l0aGluIGVhY2ggdHlwZS9ncm91cClcbiAgLy8gICAgICAtIG5vbmUgb2YgYWJvdmUsIHR5cGUgb3JkZXIgKGRlZmF1bHQpXG4gIHRoaXMuZGlzcGxheUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBkaXNwbGF5QXR0cmlidXRlcyhvcmRlciA9ICdpbmRleCcpIHtcbiAgICBpZiAoIWhhdmVBdHRyaWJ1dGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfW5vIGF0dHJpYnV0ZXMgLSBtdXN0IGJlIHByZWNlZWRlZCBieSBjYWxsIHRvIGF0dHJpYnV0ZXMoKWApO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlRXJyb3JzKSB7XG4gICAgICBzaG93QXR0cmlidXRlRXJyb3JzKG9yZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHNob3dBdHRyaWJ1dGVzKG9yZGVyKTtcbiAgfTtcbiAgdGhpcy5kaXNwbGF5QXR0cmlidXRlRXJyb3JzID0gZnVuY3Rpb24gZGlzcGxheUF0dHJpYnV0ZUVycm9ycygpIHtcbiAgICBpZiAoIWhhdmVBdHRyaWJ1dGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfW5vIGF0dHJpYnV0ZXMgLSBtdXN0IGJlIHByZWNlZWRlZCBieSBjYWxsIHRvIGF0dHJpYnV0ZXMoKWApO1xuICAgIH1cbiAgICByZXR1cm4gc2hvd0F0dHJpYnV0ZUVycm9ycygpO1xuICB9O1xuICAvLyBSZXR1cm5zIGEgcGFyc2VyIGdyYW1tYXIgb2JqZWN0IGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGFzIGEgSmF2YVNjcmlwdCBzdHJpbmcuXG4gIC8vIFRoaXMgb2JqZWN0IGNhbiB0aGVuIGJlIHVzZWQgdG8gY29uc3RydWN0IGEgcGFyc2VyLlxuICB0aGlzLnRvU291cmNlID0gZnVuY3Rpb24gdG9Tb3VyY2UobmFtZSkge1xuICAgIGlmICghaGF2ZUF0dHJpYnV0ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Y2FuJ3QgZ2VuZXJhdGUgcGFyc2VyIHNvdXJjZSAtIG11c3QgYmUgcHJlY2VlZGVkIGJ5IGNhbGwgdG8gYXR0cmlidXRlcygpYCk7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGVFcnJvcnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Y2FuJ3QgZ2VuZXJhdGUgcGFyc2VyIHNvdXJjZSAtIGF0dHJpYnV0ZXMgaGF2ZSAke2F0dHJpYnV0ZUVycm9yc30gZXJyb3JzYCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXIuZ2VuZXJhdGVTb3VyY2UodGhpcy5jaGFycywgdGhpcy5saW5lcywgdGhpcy5ydWxlcywgdGhpcy51ZHRzLCBuYW1lKTtcbiAgfTtcbiAgLy8gUmV0dXJucyBhIHBhcnNlciBncmFtbWFyIG9iamVjdC5cbiAgLy8gVGhpcyBncmFtbWFyIG9iamVjdCBtYXkgYmUgdXNlZCBieSB0aGUgYXBwbGljYXRpb24gdG8gY29uc3RydWN0IGEgcGFyc2VyLlxuICB0aGlzLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gICAgaWYgKCFoYXZlQXR0cmlidXRlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1jYW4ndCBnZW5lcmF0ZSBwYXJzZXIgc291cmNlIC0gbXVzdCBiZSBwcmVjZWVkZWQgYnkgY2FsbCB0byBhdHRyaWJ1dGVzKClgKTtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZUVycm9ycykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1jYW4ndCBnZW5lcmF0ZSBwYXJzZXIgc291cmNlIC0gYXR0cmlidXRlcyBoYXZlICR7YXR0cmlidXRlRXJyb3JzfSBlcnJvcnNgKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlci5nZW5lcmF0ZU9iamVjdCh0aGlzLnNhYm5mLCB0aGlzLnJ1bGVzLCB0aGlzLnVkdHMpO1xuICB9O1xuICAvLyBEaXNwbGF5IGVycm9ycyBpbiB0ZXh0IGZvcm1hdCwgc3VpdGFibGUgZm9yIGBjb25zb2xlLmxvZygpYC5cbiAgdGhpcy5lcnJvcnNUb0FzY2lpID0gZnVuY3Rpb24gZXJyb3JzVG9Bc2NpaUZ1bmMoKSB7XG4gICAgcmV0dXJuIGVycm9yc1RvQXNjaWkodGhpcy5lcnJvcnMsIHRoaXMubGluZXMsIHRoaXMuY2hhcnMpO1xuICB9O1xuICAvLyBEaXNwbGF5IGVycm9ycyBpbiBIVE1MIGZvcm1hdCwgc3VpdGFibGUgZm9yIHdlYiBwYWdlIGRpc3BsYXkuXG4gIC8vIChgYXBnLWxpYi5jc3NgIHJlcXVpcmVkIGZvciBwcm9wZXIgc3R5bGluZylcbiAgdGhpcy5lcnJvcnNUb0h0bWwgPSBmdW5jdGlvbiBlcnJvcnNUb0h0bWxGdW5jKHRpdGxlKSB7XG4gICAgcmV0dXJuIGVycm9yc1RvSHRtbCh0aGlzLmVycm9ycywgdGhpcy5saW5lcywgdGhpcy5jaGFycywgdGl0bGUpO1xuICB9O1xuICAvLyBHZW5lcmF0ZSBhbiBhbm5vdGF0ZWQgdGhlIFNBQk5GIGdyYW1tYXIgZGlzcGxheSBpbiB0ZXh0IGZvcm1hdC5cbiAgdGhpcy5saW5lc1RvQXNjaWkgPSBmdW5jdGlvbiBsaW5lc1RvQXNjaWlGdW5jKCkge1xuICAgIHJldHVybiBsaW5lc1RvQXNjaWkodGhpcy5saW5lcyk7XG4gIH07XG4gIC8vIEdlbmVyYXRlIGFuIGFubm90YXRlZCB0aGUgU0FCTkYgZ3JhbW1hciBkaXNwbGF5IGluIEhUTUwgZm9ybWF0LlxuICAvLyAoYGFwZy1saWIuY3NzYCByZXF1aXJlZCBmb3IgcHJvcGVyIHN0eWxpbmcpXG4gIHRoaXMubGluZXNUb0h0bWwgPSBmdW5jdGlvbiBsaW5lc1RvSHRtbEZ1bmMoKSB7XG4gICAgcmV0dXJuIGxpbmVzVG9IdG1sKHRoaXMubGluZXMpO1xuICB9O1xuICAvLyBUaGlzIGZ1bmN0aW9uIHdhcyBvbmx5IHVzZWQgYnkgYXBnLmh0bWwgd2hpY2ggaGFzIGJlZW4gYWJhbmRvbmVkLlxuICAvKlxuICAgIHRoaXMuZ2V0QXR0cmlidXRlc09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAqL1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-api/api.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-api/attributes.js":
/*!*******************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/attributes.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* eslint-disable class-methods-use-this */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// Attributes Validation\n//\n// It is well known that recursive-descent parsers will fail if a rule is left recursive.\n// Besides left recursion, there are a couple of other fatal attributes that need to be disclosed as well.\n// There are several non-fatal attributes that are of interest also.\n// This module will determine six different attributes listed here with simple examples.\n//\n// **fatal attributes**<br>\n// left recursion<br>\n// S = S \"x\" / \"y\"\n//\n// cyclic<br>\n// S = S\n//\n// infinite<br>\n// S = \"y\" S\n//\n// **non-fatal attributes** (but nice to know)<br>\n// nested recursion<br>\n// S = \"a\" S \"b\" / \"y\"\n//\n// right recursion<br>\n// S = \"x\" S / \"y\"\n//\n// empty string<br>\n// S = \"x\" S / \"\"\n//\n// Note that these are “aggregate” attributes, in that if the attribute is true it only means that it can be true,\n// not that it will always be true for every input string.\n// In the simple examples above the attributes may be obvious and definite – always true or false.\n// However, for a large grammar with possibly hundreds of rules and parse tree branches,\n// it can be obscure which branches lead to which attributes.\n// Furthermore, different input strings will lead the parser down different branches.\n// One input string may parse perfectly while another will hit a left-recursive branch and bottom out the call stack.\n//\n// It is for this reason that the APG parser generator computes these attributes.\n// When using the API the attributes call is optional but generating a parser without checking the attributes - proceed at your own peril.\n//\n// Additionally, the attribute phase will identify rule dependencies and mutually-recursive groups. For example,\n//\n// S = \"a\" A \"b\" / \"y\"<br>\n// A = \"x\"\n//\n// S is dependent on A but A is not dependent on S.\n//\n// S = \"a\" A \"b\" / \"c\"<br>\n// A = \"x\" S \"y\" / \"z\"\n//\n// S and A are dependent on one another and are mutually recursive.\nmodule.exports = (function exportAttributes() {\n  const id = __webpack_require__(/*! ../apg-lib/identifiers */ \"./node_modules/apg-js/src/apg-lib/identifiers.js\");\n  const { ruleAttributes, showAttributes, showAttributeErrors } = __webpack_require__(/*! ./rule-attributes */ \"./node_modules/apg-js/src/apg-api/rule-attributes.js\");\n  const { ruleDependencies, showRuleDependencies } = __webpack_require__(/*! ./rule-dependencies */ \"./node_modules/apg-js/src/apg-api/rule-dependencies.js\");\n  class State {\n    constructor(rules, udts) {\n      this.rules = rules;\n      this.udts = udts;\n      this.ruleCount = rules.length;\n      this.udtCount = udts.length;\n      this.startRule = 0;\n      this.dependenciesComplete = false;\n      this.attributesComplete = false;\n      this.isMutuallyRecursive = false;\n      this.ruleIndexes = this.indexArray(this.ruleCount);\n      this.ruleAlphaIndexes = this.indexArray(this.ruleCount);\n      this.ruleTypeIndexes = this.indexArray(this.ruleCount);\n      this.udtIndexes = this.indexArray(this.udtCount);\n      this.udtAlphaIndexes = this.indexArray(this.udtCount);\n      this.attrsErrorCount = 0;\n      this.attrs = [];\n      this.attrsErrors = [];\n      this.attrsWorking = [];\n      this.ruleDeps = [];\n      for (let i = 0; i < this.ruleCount; i += 1) {\n        this.attrs.push(this.attrGen(this.rules[i]));\n        this.attrsWorking.push(this.attrGen(this.rules[i]));\n        this.ruleDeps.push(this.rdGen(rules[i], this.ruleCount, this.udtCount));\n      }\n      this.compRulesAlpha = this.compRulesAlpha.bind(this);\n      this.compUdtsAlpha = this.compUdtsAlpha.bind(this);\n      this.compRulesType = this.compRulesType.bind(this);\n      this.compRulesGroup = this.compRulesGroup.bind(this);\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    attrGen(rule) {\n      return {\n        left: false,\n        nested: false,\n        right: false,\n        empty: false,\n        finite: false,\n        cyclic: false,\n        leaf: false,\n        isOpen: false,\n        isComplete: false,\n        rule,\n      };\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    attrInit(attr) {\n      attr.left = false;\n      attr.nested = false;\n      attr.right = false;\n      attr.empty = false;\n      attr.finite = false;\n      attr.cyclic = false;\n      attr.leaf = false;\n      attr.isOpen = false;\n      attr.isComplete = false;\n    }\n\n    attrCopy(dst, src) {\n      dst.left = src.left;\n      dst.nested = src.nested;\n      dst.right = src.right;\n      dst.empty = src.empty;\n      dst.finite = src.finite;\n      dst.cyclic = src.cyclic;\n      dst.leaf = src.leaf;\n      dst.isOpen = src.isOpen;\n      dst.isComplete = src.isComplete;\n      dst.rule = src.rule;\n    }\n\n    rdGen(rule, ruleCount, udtCount) {\n      const ret = {\n        rule,\n        recursiveType: id.ATTR_N,\n        groupNumber: -1,\n        refersTo: this.falseArray(ruleCount),\n        refersToUdt: this.falseArray(udtCount),\n        referencedBy: this.falseArray(ruleCount),\n      };\n      return ret;\n    }\n\n    typeToString(recursiveType) {\n      switch (recursiveType) {\n        case id.ATTR_N:\n          return ' N';\n        case id.ATTR_R:\n          return ' R';\n        case id.ATTR_MR:\n          return 'MR';\n        default:\n          return 'UNKNOWN';\n      }\n    }\n\n    falseArray(length) {\n      const ret = [];\n      if (length > 0) {\n        for (let i = 0; i < length; i += 1) {\n          ret.push(false);\n        }\n      }\n      return ret;\n    }\n\n    falsifyArray(a) {\n      for (let i = 0; i < a.length; i += 1) {\n        a[i] = false;\n      }\n    }\n\n    indexArray(length) {\n      const ret = [];\n      if (length > 0) {\n        for (let i = 0; i < length; i += 1) {\n          ret.push(i);\n        }\n      }\n      return ret;\n    }\n\n    compRulesAlpha(left, right) {\n      if (this.rules[left].lower < this.rules[right].lower) {\n        return -1;\n      }\n      if (this.rules[left].lower > this.rules[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n\n    compUdtsAlpha(left, right) {\n      if (this.udts[left].lower < this.udts[right].lower) {\n        return -1;\n      }\n      if (this.udts[left].lower > this.udts[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n\n    compRulesType(left, right) {\n      if (this.ruleDeps[left].recursiveType < this.ruleDeps[right].recursiveType) {\n        return -1;\n      }\n      if (this.ruleDeps[left].recursiveType > this.ruleDeps[right].recursiveType) {\n        return 1;\n      }\n      return 0;\n    }\n\n    compRulesGroup(left, right) {\n      if (this.ruleDeps[left].recursiveType === id.ATTR_MR && this.ruleDeps[right].recursiveType === id.ATTR_MR) {\n        if (this.ruleDeps[left].groupNumber < this.ruleDeps[right].groupNumber) {\n          return -1;\n        }\n        if (this.ruleDeps[left].groupNumber > this.ruleDeps[right].groupNumber) {\n          return 1;\n        }\n      }\n      return 0;\n    }\n  }\n  // eslint-disable-next-line no-unused-vars\n  const attributes = function attributes(rules = [], udts = [], lineMap = [], errors = []) {\n    // let i = 0;\n    // Initialize the state. The state of the computation get passed around to multiple functions in multiple files.\n    const state = new State(rules, udts);\n\n    // Determine all rule dependencies\n    //  - which rules each rule refers to\n    //  - which rules reference each rule\n    ruleDependencies(state);\n\n    // Determine the attributes for each rule.\n    ruleAttributes(state);\n    if (state.attrsErrorCount) {\n      errors.push({ line: 0, char: 0, msg: `${state.attrsErrorCount} attribute errors` });\n    }\n\n    // Return the number of attribute errors to the caller.\n    return state.attrsErrorCount;\n  };\n\n  /* Destructuring assignment - see MDN Web Docs */\n  return { attributes, showAttributes, showAttributeErrors, showRuleDependencies };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL2F0dHJpYnV0ZXMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsZ0ZBQXdCO0FBQzdDLFVBQVUsc0RBQXNELEVBQUUsbUJBQU8sQ0FBQywrRUFBbUI7QUFDN0YsVUFBVSx5Q0FBeUMsRUFBRSxtQkFBTyxDQUFDLG1GQUFxQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQix1QkFBdUIsbUJBQW1CO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvYXR0cmlidXRlcy5qcz9mYjJjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cbi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIEF0dHJpYnV0ZXMgVmFsaWRhdGlvblxuLy9cbi8vIEl0IGlzIHdlbGwga25vd24gdGhhdCByZWN1cnNpdmUtZGVzY2VudCBwYXJzZXJzIHdpbGwgZmFpbCBpZiBhIHJ1bGUgaXMgbGVmdCByZWN1cnNpdmUuXG4vLyBCZXNpZGVzIGxlZnQgcmVjdXJzaW9uLCB0aGVyZSBhcmUgYSBjb3VwbGUgb2Ygb3RoZXIgZmF0YWwgYXR0cmlidXRlcyB0aGF0IG5lZWQgdG8gYmUgZGlzY2xvc2VkIGFzIHdlbGwuXG4vLyBUaGVyZSBhcmUgc2V2ZXJhbCBub24tZmF0YWwgYXR0cmlidXRlcyB0aGF0IGFyZSBvZiBpbnRlcmVzdCBhbHNvLlxuLy8gVGhpcyBtb2R1bGUgd2lsbCBkZXRlcm1pbmUgc2l4IGRpZmZlcmVudCBhdHRyaWJ1dGVzIGxpc3RlZCBoZXJlIHdpdGggc2ltcGxlIGV4YW1wbGVzLlxuLy9cbi8vICoqZmF0YWwgYXR0cmlidXRlcyoqPGJyPlxuLy8gbGVmdCByZWN1cnNpb248YnI+XG4vLyBTID0gUyBcInhcIiAvIFwieVwiXG4vL1xuLy8gY3ljbGljPGJyPlxuLy8gUyA9IFNcbi8vXG4vLyBpbmZpbml0ZTxicj5cbi8vIFMgPSBcInlcIiBTXG4vL1xuLy8gKipub24tZmF0YWwgYXR0cmlidXRlcyoqIChidXQgbmljZSB0byBrbm93KTxicj5cbi8vIG5lc3RlZCByZWN1cnNpb248YnI+XG4vLyBTID0gXCJhXCIgUyBcImJcIiAvIFwieVwiXG4vL1xuLy8gcmlnaHQgcmVjdXJzaW9uPGJyPlxuLy8gUyA9IFwieFwiIFMgLyBcInlcIlxuLy9cbi8vIGVtcHR5IHN0cmluZzxicj5cbi8vIFMgPSBcInhcIiBTIC8gXCJcIlxuLy9cbi8vIE5vdGUgdGhhdCB0aGVzZSBhcmUg4oCcYWdncmVnYXRl4oCdIGF0dHJpYnV0ZXMsIGluIHRoYXQgaWYgdGhlIGF0dHJpYnV0ZSBpcyB0cnVlIGl0IG9ubHkgbWVhbnMgdGhhdCBpdCBjYW4gYmUgdHJ1ZSxcbi8vIG5vdCB0aGF0IGl0IHdpbGwgYWx3YXlzIGJlIHRydWUgZm9yIGV2ZXJ5IGlucHV0IHN0cmluZy5cbi8vIEluIHRoZSBzaW1wbGUgZXhhbXBsZXMgYWJvdmUgdGhlIGF0dHJpYnV0ZXMgbWF5IGJlIG9idmlvdXMgYW5kIGRlZmluaXRlIOKAkyBhbHdheXMgdHJ1ZSBvciBmYWxzZS5cbi8vIEhvd2V2ZXIsIGZvciBhIGxhcmdlIGdyYW1tYXIgd2l0aCBwb3NzaWJseSBodW5kcmVkcyBvZiBydWxlcyBhbmQgcGFyc2UgdHJlZSBicmFuY2hlcyxcbi8vIGl0IGNhbiBiZSBvYnNjdXJlIHdoaWNoIGJyYW5jaGVzIGxlYWQgdG8gd2hpY2ggYXR0cmlidXRlcy5cbi8vIEZ1cnRoZXJtb3JlLCBkaWZmZXJlbnQgaW5wdXQgc3RyaW5ncyB3aWxsIGxlYWQgdGhlIHBhcnNlciBkb3duIGRpZmZlcmVudCBicmFuY2hlcy5cbi8vIE9uZSBpbnB1dCBzdHJpbmcgbWF5IHBhcnNlIHBlcmZlY3RseSB3aGlsZSBhbm90aGVyIHdpbGwgaGl0IGEgbGVmdC1yZWN1cnNpdmUgYnJhbmNoIGFuZCBib3R0b20gb3V0IHRoZSBjYWxsIHN0YWNrLlxuLy9cbi8vIEl0IGlzIGZvciB0aGlzIHJlYXNvbiB0aGF0IHRoZSBBUEcgcGFyc2VyIGdlbmVyYXRvciBjb21wdXRlcyB0aGVzZSBhdHRyaWJ1dGVzLlxuLy8gV2hlbiB1c2luZyB0aGUgQVBJIHRoZSBhdHRyaWJ1dGVzIGNhbGwgaXMgb3B0aW9uYWwgYnV0IGdlbmVyYXRpbmcgYSBwYXJzZXIgd2l0aG91dCBjaGVja2luZyB0aGUgYXR0cmlidXRlcyAtIHByb2NlZWQgYXQgeW91ciBvd24gcGVyaWwuXG4vL1xuLy8gQWRkaXRpb25hbGx5LCB0aGUgYXR0cmlidXRlIHBoYXNlIHdpbGwgaWRlbnRpZnkgcnVsZSBkZXBlbmRlbmNpZXMgYW5kIG11dHVhbGx5LXJlY3Vyc2l2ZSBncm91cHMuIEZvciBleGFtcGxlLFxuLy9cbi8vIFMgPSBcImFcIiBBIFwiYlwiIC8gXCJ5XCI8YnI+XG4vLyBBID0gXCJ4XCJcbi8vXG4vLyBTIGlzIGRlcGVuZGVudCBvbiBBIGJ1dCBBIGlzIG5vdCBkZXBlbmRlbnQgb24gUy5cbi8vXG4vLyBTID0gXCJhXCIgQSBcImJcIiAvIFwiY1wiPGJyPlxuLy8gQSA9IFwieFwiIFMgXCJ5XCIgLyBcInpcIlxuLy9cbi8vIFMgYW5kIEEgYXJlIGRlcGVuZGVudCBvbiBvbmUgYW5vdGhlciBhbmQgYXJlIG11dHVhbGx5IHJlY3Vyc2l2ZS5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uIGV4cG9ydEF0dHJpYnV0ZXMoKSB7XG4gIGNvbnN0IGlkID0gcmVxdWlyZSgnLi4vYXBnLWxpYi9pZGVudGlmaWVycycpO1xuICBjb25zdCB7IHJ1bGVBdHRyaWJ1dGVzLCBzaG93QXR0cmlidXRlcywgc2hvd0F0dHJpYnV0ZUVycm9ycyB9ID0gcmVxdWlyZSgnLi9ydWxlLWF0dHJpYnV0ZXMnKTtcbiAgY29uc3QgeyBydWxlRGVwZW5kZW5jaWVzLCBzaG93UnVsZURlcGVuZGVuY2llcyB9ID0gcmVxdWlyZSgnLi9ydWxlLWRlcGVuZGVuY2llcycpO1xuICBjbGFzcyBTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IocnVsZXMsIHVkdHMpIHtcbiAgICAgIHRoaXMucnVsZXMgPSBydWxlcztcbiAgICAgIHRoaXMudWR0cyA9IHVkdHM7XG4gICAgICB0aGlzLnJ1bGVDb3VudCA9IHJ1bGVzLmxlbmd0aDtcbiAgICAgIHRoaXMudWR0Q291bnQgPSB1ZHRzLmxlbmd0aDtcbiAgICAgIHRoaXMuc3RhcnRSdWxlID0gMDtcbiAgICAgIHRoaXMuZGVwZW5kZW5jaWVzQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuYXR0cmlidXRlc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgICB0aGlzLmlzTXV0dWFsbHlSZWN1cnNpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMucnVsZUluZGV4ZXMgPSB0aGlzLmluZGV4QXJyYXkodGhpcy5ydWxlQ291bnQpO1xuICAgICAgdGhpcy5ydWxlQWxwaGFJbmRleGVzID0gdGhpcy5pbmRleEFycmF5KHRoaXMucnVsZUNvdW50KTtcbiAgICAgIHRoaXMucnVsZVR5cGVJbmRleGVzID0gdGhpcy5pbmRleEFycmF5KHRoaXMucnVsZUNvdW50KTtcbiAgICAgIHRoaXMudWR0SW5kZXhlcyA9IHRoaXMuaW5kZXhBcnJheSh0aGlzLnVkdENvdW50KTtcbiAgICAgIHRoaXMudWR0QWxwaGFJbmRleGVzID0gdGhpcy5pbmRleEFycmF5KHRoaXMudWR0Q291bnQpO1xuICAgICAgdGhpcy5hdHRyc0Vycm9yQ291bnQgPSAwO1xuICAgICAgdGhpcy5hdHRycyA9IFtdO1xuICAgICAgdGhpcy5hdHRyc0Vycm9ycyA9IFtdO1xuICAgICAgdGhpcy5hdHRyc1dvcmtpbmcgPSBbXTtcbiAgICAgIHRoaXMucnVsZURlcHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ydWxlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICB0aGlzLmF0dHJzLnB1c2godGhpcy5hdHRyR2VuKHRoaXMucnVsZXNbaV0pKTtcbiAgICAgICAgdGhpcy5hdHRyc1dvcmtpbmcucHVzaCh0aGlzLmF0dHJHZW4odGhpcy5ydWxlc1tpXSkpO1xuICAgICAgICB0aGlzLnJ1bGVEZXBzLnB1c2godGhpcy5yZEdlbihydWxlc1tpXSwgdGhpcy5ydWxlQ291bnQsIHRoaXMudWR0Q291bnQpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29tcFJ1bGVzQWxwaGEgPSB0aGlzLmNvbXBSdWxlc0FscGhhLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmNvbXBVZHRzQWxwaGEgPSB0aGlzLmNvbXBVZHRzQWxwaGEuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuY29tcFJ1bGVzVHlwZSA9IHRoaXMuY29tcFJ1bGVzVHlwZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5jb21wUnVsZXNHcm91cCA9IHRoaXMuY29tcFJ1bGVzR3JvdXAuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIGF0dHJHZW4ocnVsZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgIG5lc3RlZDogZmFsc2UsXG4gICAgICAgIHJpZ2h0OiBmYWxzZSxcbiAgICAgICAgZW1wdHk6IGZhbHNlLFxuICAgICAgICBmaW5pdGU6IGZhbHNlLFxuICAgICAgICBjeWNsaWM6IGZhbHNlLFxuICAgICAgICBsZWFmOiBmYWxzZSxcbiAgICAgICAgaXNPcGVuOiBmYWxzZSxcbiAgICAgICAgaXNDb21wbGV0ZTogZmFsc2UsXG4gICAgICAgIHJ1bGUsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgYXR0ckluaXQoYXR0cikge1xuICAgICAgYXR0ci5sZWZ0ID0gZmFsc2U7XG4gICAgICBhdHRyLm5lc3RlZCA9IGZhbHNlO1xuICAgICAgYXR0ci5yaWdodCA9IGZhbHNlO1xuICAgICAgYXR0ci5lbXB0eSA9IGZhbHNlO1xuICAgICAgYXR0ci5maW5pdGUgPSBmYWxzZTtcbiAgICAgIGF0dHIuY3ljbGljID0gZmFsc2U7XG4gICAgICBhdHRyLmxlYWYgPSBmYWxzZTtcbiAgICAgIGF0dHIuaXNPcGVuID0gZmFsc2U7XG4gICAgICBhdHRyLmlzQ29tcGxldGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBhdHRyQ29weShkc3QsIHNyYykge1xuICAgICAgZHN0LmxlZnQgPSBzcmMubGVmdDtcbiAgICAgIGRzdC5uZXN0ZWQgPSBzcmMubmVzdGVkO1xuICAgICAgZHN0LnJpZ2h0ID0gc3JjLnJpZ2h0O1xuICAgICAgZHN0LmVtcHR5ID0gc3JjLmVtcHR5O1xuICAgICAgZHN0LmZpbml0ZSA9IHNyYy5maW5pdGU7XG4gICAgICBkc3QuY3ljbGljID0gc3JjLmN5Y2xpYztcbiAgICAgIGRzdC5sZWFmID0gc3JjLmxlYWY7XG4gICAgICBkc3QuaXNPcGVuID0gc3JjLmlzT3BlbjtcbiAgICAgIGRzdC5pc0NvbXBsZXRlID0gc3JjLmlzQ29tcGxldGU7XG4gICAgICBkc3QucnVsZSA9IHNyYy5ydWxlO1xuICAgIH1cblxuICAgIHJkR2VuKHJ1bGUsIHJ1bGVDb3VudCwgdWR0Q291bnQpIHtcbiAgICAgIGNvbnN0IHJldCA9IHtcbiAgICAgICAgcnVsZSxcbiAgICAgICAgcmVjdXJzaXZlVHlwZTogaWQuQVRUUl9OLFxuICAgICAgICBncm91cE51bWJlcjogLTEsXG4gICAgICAgIHJlZmVyc1RvOiB0aGlzLmZhbHNlQXJyYXkocnVsZUNvdW50KSxcbiAgICAgICAgcmVmZXJzVG9VZHQ6IHRoaXMuZmFsc2VBcnJheSh1ZHRDb3VudCksXG4gICAgICAgIHJlZmVyZW5jZWRCeTogdGhpcy5mYWxzZUFycmF5KHJ1bGVDb3VudCksXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICB0eXBlVG9TdHJpbmcocmVjdXJzaXZlVHlwZSkge1xuICAgICAgc3dpdGNoIChyZWN1cnNpdmVUeXBlKSB7XG4gICAgICAgIGNhc2UgaWQuQVRUUl9OOlxuICAgICAgICAgIHJldHVybiAnIE4nO1xuICAgICAgICBjYXNlIGlkLkFUVFJfUjpcbiAgICAgICAgICByZXR1cm4gJyBSJztcbiAgICAgICAgY2FzZSBpZC5BVFRSX01SOlxuICAgICAgICAgIHJldHVybiAnTVInO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAnVU5LTk9XTic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmFsc2VBcnJheShsZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJldCA9IFtdO1xuICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHJldC5wdXNoKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBmYWxzaWZ5QXJyYXkoYSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGFbaV0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbmRleEFycmF5KGxlbmd0aCkge1xuICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgcmV0LnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY29tcFJ1bGVzQWxwaGEobGVmdCwgcmlnaHQpIHtcbiAgICAgIGlmICh0aGlzLnJ1bGVzW2xlZnRdLmxvd2VyIDwgdGhpcy5ydWxlc1tyaWdodF0ubG93ZXIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucnVsZXNbbGVmdF0ubG93ZXIgPiB0aGlzLnJ1bGVzW3JpZ2h0XS5sb3dlcikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGNvbXBVZHRzQWxwaGEobGVmdCwgcmlnaHQpIHtcbiAgICAgIGlmICh0aGlzLnVkdHNbbGVmdF0ubG93ZXIgPCB0aGlzLnVkdHNbcmlnaHRdLmxvd2VyKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnVkdHNbbGVmdF0ubG93ZXIgPiB0aGlzLnVkdHNbcmlnaHRdLmxvd2VyKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgY29tcFJ1bGVzVHlwZShsZWZ0LCByaWdodCkge1xuICAgICAgaWYgKHRoaXMucnVsZURlcHNbbGVmdF0ucmVjdXJzaXZlVHlwZSA8IHRoaXMucnVsZURlcHNbcmlnaHRdLnJlY3Vyc2l2ZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucnVsZURlcHNbbGVmdF0ucmVjdXJzaXZlVHlwZSA+IHRoaXMucnVsZURlcHNbcmlnaHRdLnJlY3Vyc2l2ZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBjb21wUnVsZXNHcm91cChsZWZ0LCByaWdodCkge1xuICAgICAgaWYgKHRoaXMucnVsZURlcHNbbGVmdF0ucmVjdXJzaXZlVHlwZSA9PT0gaWQuQVRUUl9NUiAmJiB0aGlzLnJ1bGVEZXBzW3JpZ2h0XS5yZWN1cnNpdmVUeXBlID09PSBpZC5BVFRSX01SKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bGVEZXBzW2xlZnRdLmdyb3VwTnVtYmVyIDwgdGhpcy5ydWxlRGVwc1tyaWdodF0uZ3JvdXBOdW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucnVsZURlcHNbbGVmdF0uZ3JvdXBOdW1iZXIgPiB0aGlzLnJ1bGVEZXBzW3JpZ2h0XS5ncm91cE51bWJlcikge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBhdHRyaWJ1dGVzKHJ1bGVzID0gW10sIHVkdHMgPSBbXSwgbGluZU1hcCA9IFtdLCBlcnJvcnMgPSBbXSkge1xuICAgIC8vIGxldCBpID0gMDtcbiAgICAvLyBJbml0aWFsaXplIHRoZSBzdGF0ZS4gVGhlIHN0YXRlIG9mIHRoZSBjb21wdXRhdGlvbiBnZXQgcGFzc2VkIGFyb3VuZCB0byBtdWx0aXBsZSBmdW5jdGlvbnMgaW4gbXVsdGlwbGUgZmlsZXMuXG4gICAgY29uc3Qgc3RhdGUgPSBuZXcgU3RhdGUocnVsZXMsIHVkdHMpO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGFsbCBydWxlIGRlcGVuZGVuY2llc1xuICAgIC8vICAtIHdoaWNoIHJ1bGVzIGVhY2ggcnVsZSByZWZlcnMgdG9cbiAgICAvLyAgLSB3aGljaCBydWxlcyByZWZlcmVuY2UgZWFjaCBydWxlXG4gICAgcnVsZURlcGVuZGVuY2llcyhzdGF0ZSk7XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIGF0dHJpYnV0ZXMgZm9yIGVhY2ggcnVsZS5cbiAgICBydWxlQXR0cmlidXRlcyhzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLmF0dHJzRXJyb3JDb3VudCkge1xuICAgICAgZXJyb3JzLnB1c2goeyBsaW5lOiAwLCBjaGFyOiAwLCBtc2c6IGAke3N0YXRlLmF0dHJzRXJyb3JDb3VudH0gYXR0cmlidXRlIGVycm9yc2AgfSk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgYXR0cmlidXRlIGVycm9ycyB0byB0aGUgY2FsbGVyLlxuICAgIHJldHVybiBzdGF0ZS5hdHRyc0Vycm9yQ291bnQ7XG4gIH07XG5cbiAgLyogRGVzdHJ1Y3R1cmluZyBhc3NpZ25tZW50IC0gc2VlIE1ETiBXZWIgRG9jcyAqL1xuICByZXR1cm4geyBhdHRyaWJ1dGVzLCBzaG93QXR0cmlidXRlcywgc2hvd0F0dHJpYnV0ZUVycm9ycywgc2hvd1J1bGVEZXBlbmRlbmNpZXMgfTtcbn0pKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-api/attributes.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-api/parser.js":
/*!***************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/parser.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module converts an input SABNF grammar text file into a\n// grammar object that can be used with `apg-lib` in an application parser.\n// **apg** is, in fact itself, an ABNF parser that generates an SABNF parser.\n// It is based on the grammar<br>\n// `./dist/abnf-for-sabnf-grammar.bnf`.<br>\n// In its syntax phase, **apg** analyzes the user's input SABNF grammar for correct syntax, generating an AST as it goes.\n// In its semantic phase, **apg** translates the AST to generate the parser for the input grammar.\nmodule.exports = function exportParser() {\n  const thisFileName = 'parser: ';\n  const ApgLib = __webpack_require__(/*! ../apg-lib/node-exports */ \"./node_modules/apg-js/src/apg-lib/node-exports.js\");\n  const id = ApgLib.ids;\n  const syn = new (__webpack_require__(/*! ./syntax-callbacks */ \"./node_modules/apg-js/src/apg-api/syntax-callbacks.js\"))();\n  const sem = new (__webpack_require__(/*! ./semantic-callbacks */ \"./node_modules/apg-js/src/apg-api/semantic-callbacks.js\"))();\n  const sabnfGrammar = new (__webpack_require__(/*! ./sabnf-grammar */ \"./node_modules/apg-js/src/apg-api/sabnf-grammar.js\"))();\n  // eslint-disable-next-line new-cap\n  const parser = new ApgLib.parser();\n  // eslint-disable-next-line new-cap\n  parser.ast = new ApgLib.ast();\n  parser.callbacks = syn.callbacks;\n  parser.ast.callbacks = sem.callbacks;\n\n  /* find the line containing the given character index */\n  const findLine = function findLine(lines, charIndex, charLength) {\n    if (charIndex < 0 || charIndex >= charLength) {\n      /* return error if out of range */\n      return -1;\n    }\n    for (let i = 0; i < lines.length; i += 1) {\n      if (charIndex >= lines[i].beginChar && charIndex < lines[i].beginChar + lines[i].length) {\n        return i;\n      }\n    }\n    /* should never reach here */\n    return -1;\n  };\n  const translateIndex = function translateIndex(map, index) {\n    let ret = -1;\n    if (index < map.length) {\n      for (let i = index; i < map.length; i += 1) {\n        if (map[i] !== null) {\n          ret = map[i];\n          break;\n        }\n      }\n    }\n    return ret;\n  };\n  /* helper function when removing redundant opcodes */\n  const reduceOpcodes = function reduceOpcodes(rules) {\n    rules.forEach((rule) => {\n      const opcodes = [];\n      const map = [];\n      let reducedIndex = 0;\n      rule.opcodes.forEach((op) => {\n        if (op.type === id.ALT && op.children.length === 1) {\n          map.push(null);\n        } else if (op.type === id.CAT && op.children.length === 1) {\n          map.push(null);\n        } else if (op.type === id.REP && op.min === 1 && op.max === 1) {\n          map.push(null);\n        } else {\n          map.push(reducedIndex);\n          opcodes.push(op);\n          reducedIndex += 1;\n        }\n      });\n      map.push(reducedIndex);\n      /* translate original opcode indexes to the reduced set. */\n      opcodes.forEach((op) => {\n        if (op.type === id.ALT || op.type === id.CAT) {\n          for (let i = 0; i < op.children.length; i += 1) {\n            op.children[i] = translateIndex(map, op.children[i]);\n          }\n        }\n      });\n      rule.opcodes = opcodes;\n    });\n  };\n  /* Parse the grammar - the syntax phase. */\n  /* SABNF grammar syntax errors are caught and reported here. */\n  this.syntax = function syntax(chars, lines, errors, strict, trace) {\n    if (trace) {\n      if (trace.traceObject !== 'traceObject') {\n        throw new TypeError(`${thisFileName}trace argument is not a trace object`);\n      }\n      parser.trace = trace;\n    }\n    const data = {};\n    data.errors = errors;\n    data.strict = !!strict;\n    data.lines = lines;\n    data.findLine = findLine;\n    data.charsLength = chars.length;\n    data.ruleCount = 0;\n    const result = parser.parse(sabnfGrammar, 'file', chars, data);\n    if (!result.success) {\n      errors.push({\n        line: 0,\n        char: 0,\n        msg: 'syntax analysis of input grammar failed',\n      });\n    }\n  };\n  /* Parse the grammar - the semantic phase, translates the AST. */\n  /* SABNF grammar syntax errors are caught and reported here. */\n  this.semantic = function semantic(chars, lines, errors) {\n    const data = {};\n    data.errors = errors;\n    data.lines = lines;\n    data.findLine = findLine;\n    data.charsLength = chars.length;\n    parser.ast.translate(data);\n    if (errors.length) {\n      return null;\n    }\n    /* Remove unneeded operators. */\n    /* ALT operators with a single alternate */\n    /* CAT operators with a single phrase to concatenate */\n    /* REP(1,1) operators (`1*1RuleName` or `1RuleName` is the same as just `RuleName`.) */\n    reduceOpcodes(data.rules);\n    return {\n      rules: data.rules,\n      udts: data.udts,\n      lineMap: data.rulesLineMap,\n    };\n  };\n  // Generate a grammar constructor function.\n  // An object instantiated from this constructor is used with the `apg-lib` `parser()` function.\n  this.generateSource = function generateSource(chars, lines, rules, udts, name) {\n    let source = '';\n    let i;\n    let bkrname;\n    let bkrlower;\n    let opcodeCount = 0;\n    let charCodeMin = Infinity;\n    let charCodeMax = 0;\n    const ruleNames = [];\n    const udtNames = [];\n    let alt = 0;\n    let cat = 0;\n    let rnm = 0;\n    let udt = 0;\n    let rep = 0;\n    let and = 0;\n    let not = 0;\n    let tls = 0;\n    let tbs = 0;\n    let trg = 0;\n    let bkr = 0;\n    let bka = 0;\n    let bkn = 0;\n    let abg = 0;\n    let aen = 0;\n    rules.forEach((rule) => {\n      ruleNames.push(rule.lower);\n      opcodeCount += rule.opcodes.length;\n      rule.opcodes.forEach((op) => {\n        switch (op.type) {\n          case id.ALT:\n            alt += 1;\n            break;\n          case id.CAT:\n            cat += 1;\n            break;\n          case id.RNM:\n            rnm += 1;\n            break;\n          case id.UDT:\n            udt += 1;\n            break;\n          case id.REP:\n            rep += 1;\n            break;\n          case id.AND:\n            and += 1;\n            break;\n          case id.NOT:\n            not += 1;\n            break;\n          case id.BKA:\n            bka += 1;\n            break;\n          case id.BKN:\n            bkn += 1;\n            break;\n          case id.BKR:\n            bkr += 1;\n            break;\n          case id.ABG:\n            abg += 1;\n            break;\n          case id.AEN:\n            aen += 1;\n            break;\n          case id.TLS:\n            tls += 1;\n            for (i = 0; i < op.string.length; i += 1) {\n              if (op.string[i] < charCodeMin) {\n                charCodeMin = op.string[i];\n              }\n              if (op.string[i] > charCodeMax) {\n                charCodeMax = op.string[i];\n              }\n            }\n            break;\n          case id.TBS:\n            tbs += 1;\n            for (i = 0; i < op.string.length; i += 1) {\n              if (op.string[i] < charCodeMin) {\n                charCodeMin = op.string[i];\n              }\n              if (op.string[i] > charCodeMax) {\n                charCodeMax = op.string[i];\n              }\n            }\n            break;\n          case id.TRG:\n            trg += 1;\n            if (op.min < charCodeMin) {\n              charCodeMin = op.min;\n            }\n            if (op.max > charCodeMax) {\n              charCodeMax = op.max;\n            }\n            break;\n          default:\n            throw new Error('generateSource: unrecognized opcode');\n        }\n      });\n    });\n    ruleNames.sort();\n    if (udts.length > 0) {\n      udts.forEach((udtFunc) => {\n        udtNames.push(udtFunc.lower);\n      });\n      udtNames.sort();\n    }\n    let funcname = 'module.exports';\n    if (name && typeof name === 'string') {\n      funcname = `let ${name}`;\n    }\n    source += '// copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved<br>\\n';\n    source += '//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\\n';\n    source += '//\\n';\n    source += '// Generated by apg-js, Version 4.0.0 [apg-js](https://github.com/ldthomas/apg-js)\\n';\n    source += `${funcname} = function grammar(){\\n`;\n    source += '  // ```\\n';\n    source += '  // SUMMARY\\n';\n    source += `  //      rules = ${rules.length}\\n`;\n    source += `  //       udts = ${udts.length}\\n`;\n    source += `  //    opcodes = ${opcodeCount}\\n`;\n    source += '  //        ---   ABNF original opcodes\\n';\n    source += `  //        ALT = ${alt}\\n`;\n    source += `  //        CAT = ${cat}\\n`;\n    source += `  //        REP = ${rep}\\n`;\n    source += `  //        RNM = ${rnm}\\n`;\n    source += `  //        TLS = ${tls}\\n`;\n    source += `  //        TBS = ${tbs}\\n`;\n    source += `  //        TRG = ${trg}\\n`;\n    source += '  //        ---   SABNF superset opcodes\\n';\n    source += `  //        UDT = ${udt}\\n`;\n    source += `  //        AND = ${and}\\n`;\n    source += `  //        NOT = ${not}\\n`;\n    source += `  //        BKA = ${bka}\\n`;\n    source += `  //        BKN = ${bkn}\\n`;\n    source += `  //        BKR = ${bkr}\\n`;\n    source += `  //        ABG = ${abg}\\n`;\n    source += `  //        AEN = ${aen}\\n`;\n    source += '  // characters = [';\n    if (tls + tbs + trg === 0) {\n      source += ' none defined ]';\n    } else {\n      source += `${charCodeMin} - ${charCodeMax}]`;\n    }\n    if (udt > 0) {\n      source += ' + user defined';\n    }\n    source += '\\n';\n    source += '  // ```\\n';\n    source += '  /* OBJECT IDENTIFIER (for internal parser use) */\\n';\n    source += \"  this.grammarObject = 'grammarObject';\\n\";\n    source += '\\n';\n    source += '  /* RULES */\\n';\n    source += '  this.rules = [];\\n';\n    rules.forEach((rule, ii) => {\n      let thisRule = '  this.rules[';\n      thisRule += ii;\n      thisRule += \"] = {name: '\";\n      thisRule += rule.name;\n      thisRule += \"', lower: '\";\n      thisRule += rule.lower;\n      thisRule += \"', index: \";\n      thisRule += rule.index;\n      thisRule += ', isBkr: ';\n      thisRule += rule.isBkr;\n      thisRule += '};\\n';\n      source += thisRule;\n    });\n    source += '\\n';\n    source += '  /* UDTS */\\n';\n    source += '  this.udts = [];\\n';\n    if (udts.length > 0) {\n      udts.forEach((udtFunc, ii) => {\n        let thisUdt = '  this.udts[';\n        thisUdt += ii;\n        thisUdt += \"] = {name: '\";\n        thisUdt += udtFunc.name;\n        thisUdt += \"', lower: '\";\n        thisUdt += udtFunc.lower;\n        thisUdt += \"', index: \";\n        thisUdt += udtFunc.index;\n        thisUdt += ', empty: ';\n        thisUdt += udtFunc.empty;\n        thisUdt += ', isBkr: ';\n        thisUdt += udtFunc.isBkr;\n        thisUdt += '};\\n';\n        source += thisUdt;\n      });\n    }\n    source += '\\n';\n    source += '  /* OPCODES */\\n';\n    rules.forEach((rule, ruleIndex) => {\n      if (ruleIndex > 0) {\n        source += '\\n';\n      }\n      source += `  /* ${rule.name} */\\n`;\n      source += `  this.rules[${ruleIndex}].opcodes = [];\\n`;\n      rule.opcodes.forEach((op, opIndex) => {\n        let prefix;\n        switch (op.type) {\n          case id.ALT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${\n              op.type\n            }, children: [${op.children.toString()}]};// ALT\\n`;\n            break;\n          case id.CAT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${\n              op.type\n            }, children: [${op.children.toString()}]};// CAT\\n`;\n            break;\n          case id.RNM:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, index: ${op.index}};// RNM(${\n              rules[op.index].name\n            })\\n`;\n            break;\n          case id.BKR:\n            if (op.index >= rules.length) {\n              bkrname = udts[op.index - rules.length].name;\n              bkrlower = udts[op.index - rules.length].lower;\n            } else {\n              bkrname = rules[op.index].name;\n              bkrlower = rules[op.index].lower;\n            }\n            prefix = '%i';\n            if (op.bkrCase === id.BKR_MODE_CS) {\n              prefix = '%s';\n            }\n            if (op.bkrMode === id.BKR_MODE_UM) {\n              prefix += '%u';\n            } else {\n              prefix += '%p';\n            }\n            bkrname = prefix + bkrname;\n            source +=\n              `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, index: ${op.index}, lower: '${bkrlower}'` +\n              `, bkrCase: ${op.bkrCase}, bkrMode: ${op.bkrMode}};// BKR(\\\\${bkrname})\\n`;\n            break;\n          case id.UDT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, empty: ${op.empty}, index: ${\n              op.index\n            }};// UDT(${udts[op.index].name})\\n`;\n            break;\n          case id.REP:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, min: ${op.min}, max: ${op.max}};// REP\\n`;\n            break;\n          case id.AND:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// AND\\n`;\n            break;\n          case id.NOT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// NOT\\n`;\n            break;\n          case id.ABG:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// ABG(%^)\\n`;\n            break;\n          case id.AEN:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// AEN(%$)\\n`;\n            break;\n          case id.BKA:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// BKA\\n`;\n            break;\n          case id.BKN:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// BKN\\n`;\n            break;\n          case id.TLS:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${\n              op.type\n            }, string: [${op.string.toString()}]};// TLS\\n`;\n            break;\n          case id.TBS:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${\n              op.type\n            }, string: [${op.string.toString()}]};// TBS\\n`;\n            break;\n          case id.TRG:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, min: ${op.min}, max: ${op.max}};// TRG\\n`;\n            break;\n          default:\n            throw new Error('parser.js: ~143: unrecognized opcode');\n        }\n      });\n    });\n    source += '\\n';\n    source += '  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\\n';\n    source += '  this.toString = function toString(){\\n';\n    source += '    let str = \"\";\\n';\n    let str;\n    lines.forEach((line) => {\n      const end = line.beginChar + line.length;\n      str = '';\n      source += '    str += \"';\n      for (let ii = line.beginChar; ii < end; ii += 1) {\n        switch (chars[ii]) {\n          case 9:\n            str = ' ';\n            break;\n          case 10:\n            str = '\\\\n';\n            break;\n          case 13:\n            str = '\\\\r';\n            break;\n          case 34:\n            str = '\\\\\"';\n            break;\n          case 92:\n            str = '\\\\\\\\';\n            break;\n          default:\n            str = String.fromCharCode(chars[ii]);\n            break;\n        }\n        source += str;\n      }\n      source += '\";\\n';\n    });\n    source += '    return str;\\n';\n    source += '  }\\n';\n    source += '}\\n';\n    return source;\n  };\n  // Generate a grammar file object.\n  // Returns the same object as instantiating the constructor function returned by<br>\n  // `this.generateSource()`.<br>\n  this.generateObject = function generateObject(stringArg, rules, udts) {\n    const obj = {};\n    const ruleNames = [];\n    const udtNames = [];\n    const string = stringArg.slice(0);\n    obj.grammarObject = 'grammarObject';\n    rules.forEach((rule) => {\n      ruleNames.push(rule.lower);\n    });\n    ruleNames.sort();\n    if (udts.length > 0) {\n      udts.forEach((udtFunc) => {\n        udtNames.push(udtFunc.lower);\n      });\n      udtNames.sort();\n    }\n    obj.callbacks = [];\n    ruleNames.forEach((name) => {\n      obj.callbacks[name] = false;\n    });\n    if (udts.length > 0) {\n      udtNames.forEach((name) => {\n        obj.callbacks[name] = false;\n      });\n    }\n    obj.rules = rules;\n    obj.udts = udts;\n    obj.toString = function toStringFunc() {\n      return string;\n    };\n    return obj;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3BhcnNlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLGtGQUF5QjtBQUNsRDtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLGlGQUFvQjtBQUMvQyxtQkFBbUIsbUJBQU8sQ0FBQyxxRkFBc0I7QUFDakQsNEJBQTRCLG1CQUFPLENBQUMsMkVBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQsbUNBQW1DLFlBQVk7QUFDL0MsbUNBQW1DLFlBQVk7QUFDL0M7QUFDQSxtQ0FBbUMsSUFBSTtBQUN2QyxtQ0FBbUMsSUFBSTtBQUN2QyxtQ0FBbUMsSUFBSTtBQUN2QyxtQ0FBbUMsSUFBSTtBQUN2QyxtQ0FBbUMsSUFBSTtBQUN2QyxtQ0FBbUMsSUFBSTtBQUN2QyxtQ0FBbUMsSUFBSTtBQUN2QztBQUNBLG1DQUFtQyxJQUFJO0FBQ3ZDLG1DQUFtQyxJQUFJO0FBQ3ZDLG1DQUFtQyxJQUFJO0FBQ3ZDLG1DQUFtQyxJQUFJO0FBQ3ZDLG1DQUFtQyxJQUFJO0FBQ3ZDLG1DQUFtQyxJQUFJO0FBQ3ZDLG1DQUFtQyxJQUFJO0FBQ3ZDLG1DQUFtQyxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixtQkFBbUIsYUFBYSxJQUFJLFlBQVk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQyxnQ0FBZ0MsVUFBVSxlQUFlO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsWUFBWSxRQUFRLEtBQUs7QUFDekU7QUFDQSxhQUFhLGVBQWUsdUJBQXVCLEdBQUc7QUFDdEQ7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLFlBQVksUUFBUSxLQUFLO0FBQ3pFO0FBQ0EsYUFBYSxlQUFlLHVCQUF1QixHQUFHO0FBQ3REO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVSxZQUFZLFFBQVEsS0FBSyxRQUFRLFFBQVEsV0FBVyxXQUFXO0FBQy9HO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVUsWUFBWSxRQUFRLEtBQUssUUFBUSxRQUFRLFdBQVcsU0FBUyxZQUFZLFNBQVM7QUFDMUgsNEJBQTRCLFdBQVcsYUFBYSxhQUFhLFdBQVcsUUFBUTtBQUNwRjtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsWUFBWSxRQUFRLEtBQUssUUFBUSxRQUFRLFdBQVcsU0FBUztBQUM3RztBQUNBLGVBQWUsU0FBUyxvQkFBb0I7QUFDNUM7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLFlBQVksUUFBUSxLQUFLLFFBQVEsUUFBUSxTQUFTLE9BQU8sU0FBUyxTQUFTO0FBQzNIO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVSxZQUFZLFFBQVEsS0FBSyxRQUFRLFVBQVU7QUFDM0Y7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLFlBQVksUUFBUSxLQUFLLFFBQVEsVUFBVTtBQUMzRjtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsWUFBWSxRQUFRLEtBQUssUUFBUSxVQUFVO0FBQzNGO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVSxZQUFZLFFBQVEsS0FBSyxRQUFRLFVBQVU7QUFDM0Y7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLFlBQVksUUFBUSxLQUFLLFFBQVEsVUFBVTtBQUMzRjtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsWUFBWSxRQUFRLEtBQUssUUFBUSxVQUFVO0FBQzNGO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVSxZQUFZLFFBQVEsS0FBSztBQUN6RTtBQUNBLGFBQWEsYUFBYSxxQkFBcUIsR0FBRztBQUNsRDtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsWUFBWSxRQUFRLEtBQUs7QUFDekU7QUFDQSxhQUFhLGFBQWEscUJBQXFCLEdBQUc7QUFDbEQ7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLFlBQVksUUFBUSxLQUFLLFFBQVEsUUFBUSxTQUFTLE9BQU8sU0FBUyxTQUFTO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsS0FBSztBQUNMLDhCQUE4QjtBQUM5QixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3BhcnNlci5qcz9lNjU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIGNvbnZlcnRzIGFuIGlucHV0IFNBQk5GIGdyYW1tYXIgdGV4dCBmaWxlIGludG8gYVxuLy8gZ3JhbW1hciBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIGBhcGctbGliYCBpbiBhbiBhcHBsaWNhdGlvbiBwYXJzZXIuXG4vLyAqKmFwZyoqIGlzLCBpbiBmYWN0IGl0c2VsZiwgYW4gQUJORiBwYXJzZXIgdGhhdCBnZW5lcmF0ZXMgYW4gU0FCTkYgcGFyc2VyLlxuLy8gSXQgaXMgYmFzZWQgb24gdGhlIGdyYW1tYXI8YnI+XG4vLyBgLi9kaXN0L2FibmYtZm9yLXNhYm5mLWdyYW1tYXIuYm5mYC48YnI+XG4vLyBJbiBpdHMgc3ludGF4IHBoYXNlLCAqKmFwZyoqIGFuYWx5emVzIHRoZSB1c2VyJ3MgaW5wdXQgU0FCTkYgZ3JhbW1hciBmb3IgY29ycmVjdCBzeW50YXgsIGdlbmVyYXRpbmcgYW4gQVNUIGFzIGl0IGdvZXMuXG4vLyBJbiBpdHMgc2VtYW50aWMgcGhhc2UsICoqYXBnKiogdHJhbnNsYXRlcyB0aGUgQVNUIHRvIGdlbmVyYXRlIHRoZSBwYXJzZXIgZm9yIHRoZSBpbnB1dCBncmFtbWFyLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHBvcnRQYXJzZXIoKSB7XG4gIGNvbnN0IHRoaXNGaWxlTmFtZSA9ICdwYXJzZXI6ICc7XG4gIGNvbnN0IEFwZ0xpYiA9IHJlcXVpcmUoJy4uL2FwZy1saWIvbm9kZS1leHBvcnRzJyk7XG4gIGNvbnN0IGlkID0gQXBnTGliLmlkcztcbiAgY29uc3Qgc3luID0gbmV3IChyZXF1aXJlKCcuL3N5bnRheC1jYWxsYmFja3MnKSkoKTtcbiAgY29uc3Qgc2VtID0gbmV3IChyZXF1aXJlKCcuL3NlbWFudGljLWNhbGxiYWNrcycpKSgpO1xuICBjb25zdCBzYWJuZkdyYW1tYXIgPSBuZXcgKHJlcXVpcmUoJy4vc2FibmYtZ3JhbW1hcicpKSgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuICBjb25zdCBwYXJzZXIgPSBuZXcgQXBnTGliLnBhcnNlcigpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuICBwYXJzZXIuYXN0ID0gbmV3IEFwZ0xpYi5hc3QoKTtcbiAgcGFyc2VyLmNhbGxiYWNrcyA9IHN5bi5jYWxsYmFja3M7XG4gIHBhcnNlci5hc3QuY2FsbGJhY2tzID0gc2VtLmNhbGxiYWNrcztcblxuICAvKiBmaW5kIHRoZSBsaW5lIGNvbnRhaW5pbmcgdGhlIGdpdmVuIGNoYXJhY3RlciBpbmRleCAqL1xuICBjb25zdCBmaW5kTGluZSA9IGZ1bmN0aW9uIGZpbmRMaW5lKGxpbmVzLCBjaGFySW5kZXgsIGNoYXJMZW5ndGgpIHtcbiAgICBpZiAoY2hhckluZGV4IDwgMCB8fCBjaGFySW5kZXggPj0gY2hhckxlbmd0aCkge1xuICAgICAgLyogcmV0dXJuIGVycm9yIGlmIG91dCBvZiByYW5nZSAqL1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoY2hhckluZGV4ID49IGxpbmVzW2ldLmJlZ2luQ2hhciAmJiBjaGFySW5kZXggPCBsaW5lc1tpXS5iZWdpbkNoYXIgKyBsaW5lc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIHNob3VsZCBuZXZlciByZWFjaCBoZXJlICovXG4gICAgcmV0dXJuIC0xO1xuICB9O1xuICBjb25zdCB0cmFuc2xhdGVJbmRleCA9IGZ1bmN0aW9uIHRyYW5zbGF0ZUluZGV4KG1hcCwgaW5kZXgpIHtcbiAgICBsZXQgcmV0ID0gLTE7XG4gICAgaWYgKGluZGV4IDwgbWFwLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IGluZGV4OyBpIDwgbWFwLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChtYXBbaV0gIT09IG51bGwpIHtcbiAgICAgICAgICByZXQgPSBtYXBbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbiAgLyogaGVscGVyIGZ1bmN0aW9uIHdoZW4gcmVtb3ZpbmcgcmVkdW5kYW50IG9wY29kZXMgKi9cbiAgY29uc3QgcmVkdWNlT3Bjb2RlcyA9IGZ1bmN0aW9uIHJlZHVjZU9wY29kZXMocnVsZXMpIHtcbiAgICBydWxlcy5mb3JFYWNoKChydWxlKSA9PiB7XG4gICAgICBjb25zdCBvcGNvZGVzID0gW107XG4gICAgICBjb25zdCBtYXAgPSBbXTtcbiAgICAgIGxldCByZWR1Y2VkSW5kZXggPSAwO1xuICAgICAgcnVsZS5vcGNvZGVzLmZvckVhY2goKG9wKSA9PiB7XG4gICAgICAgIGlmIChvcC50eXBlID09PSBpZC5BTFQgJiYgb3AuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgbWFwLnB1c2gobnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3AudHlwZSA9PT0gaWQuQ0FUICYmIG9wLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIG1hcC5wdXNoKG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wLnR5cGUgPT09IGlkLlJFUCAmJiBvcC5taW4gPT09IDEgJiYgb3AubWF4ID09PSAxKSB7XG4gICAgICAgICAgbWFwLnB1c2gobnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFwLnB1c2gocmVkdWNlZEluZGV4KTtcbiAgICAgICAgICBvcGNvZGVzLnB1c2gob3ApO1xuICAgICAgICAgIHJlZHVjZWRJbmRleCArPSAxO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG1hcC5wdXNoKHJlZHVjZWRJbmRleCk7XG4gICAgICAvKiB0cmFuc2xhdGUgb3JpZ2luYWwgb3Bjb2RlIGluZGV4ZXMgdG8gdGhlIHJlZHVjZWQgc2V0LiAqL1xuICAgICAgb3Bjb2Rlcy5mb3JFYWNoKChvcCkgPT4ge1xuICAgICAgICBpZiAob3AudHlwZSA9PT0gaWQuQUxUIHx8IG9wLnR5cGUgPT09IGlkLkNBVCkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3AuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG9wLmNoaWxkcmVuW2ldID0gdHJhbnNsYXRlSW5kZXgobWFwLCBvcC5jaGlsZHJlbltpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJ1bGUub3Bjb2RlcyA9IG9wY29kZXM7XG4gICAgfSk7XG4gIH07XG4gIC8qIFBhcnNlIHRoZSBncmFtbWFyIC0gdGhlIHN5bnRheCBwaGFzZS4gKi9cbiAgLyogU0FCTkYgZ3JhbW1hciBzeW50YXggZXJyb3JzIGFyZSBjYXVnaHQgYW5kIHJlcG9ydGVkIGhlcmUuICovXG4gIHRoaXMuc3ludGF4ID0gZnVuY3Rpb24gc3ludGF4KGNoYXJzLCBsaW5lcywgZXJyb3JzLCBzdHJpY3QsIHRyYWNlKSB7XG4gICAgaWYgKHRyYWNlKSB7XG4gICAgICBpZiAodHJhY2UudHJhY2VPYmplY3QgIT09ICd0cmFjZU9iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt0aGlzRmlsZU5hbWV9dHJhY2UgYXJndW1lbnQgaXMgbm90IGEgdHJhY2Ugb2JqZWN0YCk7XG4gICAgICB9XG4gICAgICBwYXJzZXIudHJhY2UgPSB0cmFjZTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuICAgIGRhdGEuZXJyb3JzID0gZXJyb3JzO1xuICAgIGRhdGEuc3RyaWN0ID0gISFzdHJpY3Q7XG4gICAgZGF0YS5saW5lcyA9IGxpbmVzO1xuICAgIGRhdGEuZmluZExpbmUgPSBmaW5kTGluZTtcbiAgICBkYXRhLmNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgIGRhdGEucnVsZUNvdW50ID0gMDtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIucGFyc2Uoc2FibmZHcmFtbWFyLCAnZmlsZScsIGNoYXJzLCBkYXRhKTtcbiAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgIGxpbmU6IDAsXG4gICAgICAgIGNoYXI6IDAsXG4gICAgICAgIG1zZzogJ3N5bnRheCBhbmFseXNpcyBvZiBpbnB1dCBncmFtbWFyIGZhaWxlZCcsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIC8qIFBhcnNlIHRoZSBncmFtbWFyIC0gdGhlIHNlbWFudGljIHBoYXNlLCB0cmFuc2xhdGVzIHRoZSBBU1QuICovXG4gIC8qIFNBQk5GIGdyYW1tYXIgc3ludGF4IGVycm9ycyBhcmUgY2F1Z2h0IGFuZCByZXBvcnRlZCBoZXJlLiAqL1xuICB0aGlzLnNlbWFudGljID0gZnVuY3Rpb24gc2VtYW50aWMoY2hhcnMsIGxpbmVzLCBlcnJvcnMpIHtcbiAgICBjb25zdCBkYXRhID0ge307XG4gICAgZGF0YS5lcnJvcnMgPSBlcnJvcnM7XG4gICAgZGF0YS5saW5lcyA9IGxpbmVzO1xuICAgIGRhdGEuZmluZExpbmUgPSBmaW5kTGluZTtcbiAgICBkYXRhLmNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgIHBhcnNlci5hc3QudHJhbnNsYXRlKGRhdGEpO1xuICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyogUmVtb3ZlIHVubmVlZGVkIG9wZXJhdG9ycy4gKi9cbiAgICAvKiBBTFQgb3BlcmF0b3JzIHdpdGggYSBzaW5nbGUgYWx0ZXJuYXRlICovXG4gICAgLyogQ0FUIG9wZXJhdG9ycyB3aXRoIGEgc2luZ2xlIHBocmFzZSB0byBjb25jYXRlbmF0ZSAqL1xuICAgIC8qIFJFUCgxLDEpIG9wZXJhdG9ycyAoYDEqMVJ1bGVOYW1lYCBvciBgMVJ1bGVOYW1lYCBpcyB0aGUgc2FtZSBhcyBqdXN0IGBSdWxlTmFtZWAuKSAqL1xuICAgIHJlZHVjZU9wY29kZXMoZGF0YS5ydWxlcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJ1bGVzOiBkYXRhLnJ1bGVzLFxuICAgICAgdWR0czogZGF0YS51ZHRzLFxuICAgICAgbGluZU1hcDogZGF0YS5ydWxlc0xpbmVNYXAsXG4gICAgfTtcbiAgfTtcbiAgLy8gR2VuZXJhdGUgYSBncmFtbWFyIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAvLyBBbiBvYmplY3QgaW5zdGFudGlhdGVkIGZyb20gdGhpcyBjb25zdHJ1Y3RvciBpcyB1c2VkIHdpdGggdGhlIGBhcGctbGliYCBgcGFyc2VyKClgIGZ1bmN0aW9uLlxuICB0aGlzLmdlbmVyYXRlU291cmNlID0gZnVuY3Rpb24gZ2VuZXJhdGVTb3VyY2UoY2hhcnMsIGxpbmVzLCBydWxlcywgdWR0cywgbmFtZSkge1xuICAgIGxldCBzb3VyY2UgPSAnJztcbiAgICBsZXQgaTtcbiAgICBsZXQgYmtybmFtZTtcbiAgICBsZXQgYmtybG93ZXI7XG4gICAgbGV0IG9wY29kZUNvdW50ID0gMDtcbiAgICBsZXQgY2hhckNvZGVNaW4gPSBJbmZpbml0eTtcbiAgICBsZXQgY2hhckNvZGVNYXggPSAwO1xuICAgIGNvbnN0IHJ1bGVOYW1lcyA9IFtdO1xuICAgIGNvbnN0IHVkdE5hbWVzID0gW107XG4gICAgbGV0IGFsdCA9IDA7XG4gICAgbGV0IGNhdCA9IDA7XG4gICAgbGV0IHJubSA9IDA7XG4gICAgbGV0IHVkdCA9IDA7XG4gICAgbGV0IHJlcCA9IDA7XG4gICAgbGV0IGFuZCA9IDA7XG4gICAgbGV0IG5vdCA9IDA7XG4gICAgbGV0IHRscyA9IDA7XG4gICAgbGV0IHRicyA9IDA7XG4gICAgbGV0IHRyZyA9IDA7XG4gICAgbGV0IGJrciA9IDA7XG4gICAgbGV0IGJrYSA9IDA7XG4gICAgbGV0IGJrbiA9IDA7XG4gICAgbGV0IGFiZyA9IDA7XG4gICAgbGV0IGFlbiA9IDA7XG4gICAgcnVsZXMuZm9yRWFjaCgocnVsZSkgPT4ge1xuICAgICAgcnVsZU5hbWVzLnB1c2gocnVsZS5sb3dlcik7XG4gICAgICBvcGNvZGVDb3VudCArPSBydWxlLm9wY29kZXMubGVuZ3RoO1xuICAgICAgcnVsZS5vcGNvZGVzLmZvckVhY2goKG9wKSA9PiB7XG4gICAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICAgIGNhc2UgaWQuQUxUOlxuICAgICAgICAgICAgYWx0ICs9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkNBVDpcbiAgICAgICAgICAgIGNhdCArPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5STk06XG4gICAgICAgICAgICBybm0gKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuVURUOlxuICAgICAgICAgICAgdWR0ICs9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlJFUDpcbiAgICAgICAgICAgIHJlcCArPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5BTkQ6XG4gICAgICAgICAgICBhbmQgKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuTk9UOlxuICAgICAgICAgICAgbm90ICs9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkJLQTpcbiAgICAgICAgICAgIGJrYSArPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5CS046XG4gICAgICAgICAgICBia24gKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQktSOlxuICAgICAgICAgICAgYmtyICs9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkFCRzpcbiAgICAgICAgICAgIGFiZyArPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5BRU46XG4gICAgICAgICAgICBhZW4gKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuVExTOlxuICAgICAgICAgICAgdGxzICs9IDE7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3Auc3RyaW5nLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgIGlmIChvcC5zdHJpbmdbaV0gPCBjaGFyQ29kZU1pbikge1xuICAgICAgICAgICAgICAgIGNoYXJDb2RlTWluID0gb3Auc3RyaW5nW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChvcC5zdHJpbmdbaV0gPiBjaGFyQ29kZU1heCkge1xuICAgICAgICAgICAgICAgIGNoYXJDb2RlTWF4ID0gb3Auc3RyaW5nW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlRCUzpcbiAgICAgICAgICAgIHRicyArPSAxO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG9wLnN0cmluZy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAob3Auc3RyaW5nW2ldIDwgY2hhckNvZGVNaW4pIHtcbiAgICAgICAgICAgICAgICBjaGFyQ29kZU1pbiA9IG9wLnN0cmluZ1tpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAob3Auc3RyaW5nW2ldID4gY2hhckNvZGVNYXgpIHtcbiAgICAgICAgICAgICAgICBjaGFyQ29kZU1heCA9IG9wLnN0cmluZ1tpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5UUkc6XG4gICAgICAgICAgICB0cmcgKz0gMTtcbiAgICAgICAgICAgIGlmIChvcC5taW4gPCBjaGFyQ29kZU1pbikge1xuICAgICAgICAgICAgICBjaGFyQ29kZU1pbiA9IG9wLm1pbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcC5tYXggPiBjaGFyQ29kZU1heCkge1xuICAgICAgICAgICAgICBjaGFyQ29kZU1heCA9IG9wLm1heDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlbmVyYXRlU291cmNlOiB1bnJlY29nbml6ZWQgb3Bjb2RlJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJ1bGVOYW1lcy5zb3J0KCk7XG4gICAgaWYgKHVkdHMubGVuZ3RoID4gMCkge1xuICAgICAgdWR0cy5mb3JFYWNoKCh1ZHRGdW5jKSA9PiB7XG4gICAgICAgIHVkdE5hbWVzLnB1c2godWR0RnVuYy5sb3dlcik7XG4gICAgICB9KTtcbiAgICAgIHVkdE5hbWVzLnNvcnQoKTtcbiAgICB9XG4gICAgbGV0IGZ1bmNuYW1lID0gJ21vZHVsZS5leHBvcnRzJztcbiAgICBpZiAobmFtZSAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZ1bmNuYW1lID0gYGxldCAke25hbWV9YDtcbiAgICB9XG4gICAgc291cmNlICs9ICcvLyBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkPGJyPlxcbic7XG4gICAgc291cmNlICs9ICcvLyAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpPGJyPlxcbic7XG4gICAgc291cmNlICs9ICcvL1xcbic7XG4gICAgc291cmNlICs9ICcvLyBHZW5lcmF0ZWQgYnkgYXBnLWpzLCBWZXJzaW9uIDQuMC4wIFthcGctanNdKGh0dHBzOi8vZ2l0aHViLmNvbS9sZHRob21hcy9hcGctanMpXFxuJztcbiAgICBzb3VyY2UgKz0gYCR7ZnVuY25hbWV9ID0gZnVuY3Rpb24gZ3JhbW1hcigpe1xcbmA7XG4gICAgc291cmNlICs9ICcgIC8vIGBgYFxcbic7XG4gICAgc291cmNlICs9ICcgIC8vIFNVTU1BUllcXG4nO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgIHJ1bGVzID0gJHtydWxlcy5sZW5ndGh9XFxuYDtcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICAgdWR0cyA9ICR7dWR0cy5sZW5ndGh9XFxuYDtcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgb3Bjb2RlcyA9ICR7b3Bjb2RlQ291bnR9XFxuYDtcbiAgICBzb3VyY2UgKz0gJyAgLy8gICAgICAgIC0tLSAgIEFCTkYgb3JpZ2luYWwgb3Bjb2Rlc1xcbic7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgICBBTFQgPSAke2FsdH1cXG5gO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgQ0FUID0gJHtjYXR9XFxuYDtcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICAgIFJFUCA9ICR7cmVwfVxcbmA7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgICBSTk0gPSAke3JubX1cXG5gO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgVExTID0gJHt0bHN9XFxuYDtcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICAgIFRCUyA9ICR7dGJzfVxcbmA7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgICBUUkcgPSAke3RyZ31cXG5gO1xuICAgIHNvdXJjZSArPSAnICAvLyAgICAgICAgLS0tICAgU0FCTkYgc3VwZXJzZXQgb3Bjb2Rlc1xcbic7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgICBVRFQgPSAke3VkdH1cXG5gO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgQU5EID0gJHthbmR9XFxuYDtcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICAgIE5PVCA9ICR7bm90fVxcbmA7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgICBCS0EgPSAke2JrYX1cXG5gO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgQktOID0gJHtia259XFxuYDtcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICAgIEJLUiA9ICR7YmtyfVxcbmA7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgICBBQkcgPSAke2FiZ31cXG5gO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgQUVOID0gJHthZW59XFxuYDtcbiAgICBzb3VyY2UgKz0gJyAgLy8gY2hhcmFjdGVycyA9IFsnO1xuICAgIGlmICh0bHMgKyB0YnMgKyB0cmcgPT09IDApIHtcbiAgICAgIHNvdXJjZSArPSAnIG5vbmUgZGVmaW5lZCBdJztcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlICs9IGAke2NoYXJDb2RlTWlufSAtICR7Y2hhckNvZGVNYXh9XWA7XG4gICAgfVxuICAgIGlmICh1ZHQgPiAwKSB7XG4gICAgICBzb3VyY2UgKz0gJyArIHVzZXIgZGVmaW5lZCc7XG4gICAgfVxuICAgIHNvdXJjZSArPSAnXFxuJztcbiAgICBzb3VyY2UgKz0gJyAgLy8gYGBgXFxuJztcbiAgICBzb3VyY2UgKz0gJyAgLyogT0JKRUNUIElERU5USUZJRVIgKGZvciBpbnRlcm5hbCBwYXJzZXIgdXNlKSAqL1xcbic7XG4gICAgc291cmNlICs9IFwiICB0aGlzLmdyYW1tYXJPYmplY3QgPSAnZ3JhbW1hck9iamVjdCc7XFxuXCI7XG4gICAgc291cmNlICs9ICdcXG4nO1xuICAgIHNvdXJjZSArPSAnICAvKiBSVUxFUyAqL1xcbic7XG4gICAgc291cmNlICs9ICcgIHRoaXMucnVsZXMgPSBbXTtcXG4nO1xuICAgIHJ1bGVzLmZvckVhY2goKHJ1bGUsIGlpKSA9PiB7XG4gICAgICBsZXQgdGhpc1J1bGUgPSAnICB0aGlzLnJ1bGVzWyc7XG4gICAgICB0aGlzUnVsZSArPSBpaTtcbiAgICAgIHRoaXNSdWxlICs9IFwiXSA9IHtuYW1lOiAnXCI7XG4gICAgICB0aGlzUnVsZSArPSBydWxlLm5hbWU7XG4gICAgICB0aGlzUnVsZSArPSBcIicsIGxvd2VyOiAnXCI7XG4gICAgICB0aGlzUnVsZSArPSBydWxlLmxvd2VyO1xuICAgICAgdGhpc1J1bGUgKz0gXCInLCBpbmRleDogXCI7XG4gICAgICB0aGlzUnVsZSArPSBydWxlLmluZGV4O1xuICAgICAgdGhpc1J1bGUgKz0gJywgaXNCa3I6ICc7XG4gICAgICB0aGlzUnVsZSArPSBydWxlLmlzQmtyO1xuICAgICAgdGhpc1J1bGUgKz0gJ307XFxuJztcbiAgICAgIHNvdXJjZSArPSB0aGlzUnVsZTtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gJ1xcbic7XG4gICAgc291cmNlICs9ICcgIC8qIFVEVFMgKi9cXG4nO1xuICAgIHNvdXJjZSArPSAnICB0aGlzLnVkdHMgPSBbXTtcXG4nO1xuICAgIGlmICh1ZHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHVkdHMuZm9yRWFjaCgodWR0RnVuYywgaWkpID0+IHtcbiAgICAgICAgbGV0IHRoaXNVZHQgPSAnICB0aGlzLnVkdHNbJztcbiAgICAgICAgdGhpc1VkdCArPSBpaTtcbiAgICAgICAgdGhpc1VkdCArPSBcIl0gPSB7bmFtZTogJ1wiO1xuICAgICAgICB0aGlzVWR0ICs9IHVkdEZ1bmMubmFtZTtcbiAgICAgICAgdGhpc1VkdCArPSBcIicsIGxvd2VyOiAnXCI7XG4gICAgICAgIHRoaXNVZHQgKz0gdWR0RnVuYy5sb3dlcjtcbiAgICAgICAgdGhpc1VkdCArPSBcIicsIGluZGV4OiBcIjtcbiAgICAgICAgdGhpc1VkdCArPSB1ZHRGdW5jLmluZGV4O1xuICAgICAgICB0aGlzVWR0ICs9ICcsIGVtcHR5OiAnO1xuICAgICAgICB0aGlzVWR0ICs9IHVkdEZ1bmMuZW1wdHk7XG4gICAgICAgIHRoaXNVZHQgKz0gJywgaXNCa3I6ICc7XG4gICAgICAgIHRoaXNVZHQgKz0gdWR0RnVuYy5pc0JrcjtcbiAgICAgICAgdGhpc1VkdCArPSAnfTtcXG4nO1xuICAgICAgICBzb3VyY2UgKz0gdGhpc1VkdDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzb3VyY2UgKz0gJ1xcbic7XG4gICAgc291cmNlICs9ICcgIC8qIE9QQ09ERVMgKi9cXG4nO1xuICAgIHJ1bGVzLmZvckVhY2goKHJ1bGUsIHJ1bGVJbmRleCkgPT4ge1xuICAgICAgaWYgKHJ1bGVJbmRleCA+IDApIHtcbiAgICAgICAgc291cmNlICs9ICdcXG4nO1xuICAgICAgfVxuICAgICAgc291cmNlICs9IGAgIC8qICR7cnVsZS5uYW1lfSAqL1xcbmA7XG4gICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXMgPSBbXTtcXG5gO1xuICAgICAgcnVsZS5vcGNvZGVzLmZvckVhY2goKG9wLCBvcEluZGV4KSA9PiB7XG4gICAgICAgIGxldCBwcmVmaXg7XG4gICAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICAgIGNhc2UgaWQuQUxUOlxuICAgICAgICAgICAgc291cmNlICs9IGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzWyR7b3BJbmRleH1dID0ge3R5cGU6ICR7XG4gICAgICAgICAgICAgIG9wLnR5cGVcbiAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbJHtvcC5jaGlsZHJlbi50b1N0cmluZygpfV19Oy8vIEFMVFxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkNBVDpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHt0eXBlOiAke1xuICAgICAgICAgICAgICBvcC50eXBlXG4gICAgICAgICAgICB9LCBjaGlsZHJlbjogWyR7b3AuY2hpbGRyZW4udG9TdHJpbmcoKX1dfTsvLyBDQVRcXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5STk06XG4gICAgICAgICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXNbJHtvcEluZGV4fV0gPSB7dHlwZTogJHtvcC50eXBlfSwgaW5kZXg6ICR7b3AuaW5kZXh9fTsvLyBSTk0oJHtcbiAgICAgICAgICAgICAgcnVsZXNbb3AuaW5kZXhdLm5hbWVcbiAgICAgICAgICAgIH0pXFxuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQktSOlxuICAgICAgICAgICAgaWYgKG9wLmluZGV4ID49IHJ1bGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBia3JuYW1lID0gdWR0c1tvcC5pbmRleCAtIHJ1bGVzLmxlbmd0aF0ubmFtZTtcbiAgICAgICAgICAgICAgYmtybG93ZXIgPSB1ZHRzW29wLmluZGV4IC0gcnVsZXMubGVuZ3RoXS5sb3dlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJrcm5hbWUgPSBydWxlc1tvcC5pbmRleF0ubmFtZTtcbiAgICAgICAgICAgICAgYmtybG93ZXIgPSBydWxlc1tvcC5pbmRleF0ubG93ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVmaXggPSAnJWknO1xuICAgICAgICAgICAgaWYgKG9wLmJrckNhc2UgPT09IGlkLkJLUl9NT0RFX0NTKSB7XG4gICAgICAgICAgICAgIHByZWZpeCA9ICclcyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3AuYmtyTW9kZSA9PT0gaWQuQktSX01PREVfVU0pIHtcbiAgICAgICAgICAgICAgcHJlZml4ICs9ICcldSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcmVmaXggKz0gJyVwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJrcm5hbWUgPSBwcmVmaXggKyBia3JuYW1lO1xuICAgICAgICAgICAgc291cmNlICs9XG4gICAgICAgICAgICAgIGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzWyR7b3BJbmRleH1dID0ge3R5cGU6ICR7b3AudHlwZX0sIGluZGV4OiAke29wLmluZGV4fSwgbG93ZXI6ICcke2Jrcmxvd2VyfSdgICtcbiAgICAgICAgICAgICAgYCwgYmtyQ2FzZTogJHtvcC5ia3JDYXNlfSwgYmtyTW9kZTogJHtvcC5ia3JNb2RlfX07Ly8gQktSKFxcXFwke2Jrcm5hbWV9KVxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlVEVDpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHt0eXBlOiAke29wLnR5cGV9LCBlbXB0eTogJHtvcC5lbXB0eX0sIGluZGV4OiAke1xuICAgICAgICAgICAgICBvcC5pbmRleFxuICAgICAgICAgICAgfX07Ly8gVURUKCR7dWR0c1tvcC5pbmRleF0ubmFtZX0pXFxuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuUkVQOlxuICAgICAgICAgICAgc291cmNlICs9IGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzWyR7b3BJbmRleH1dID0ge3R5cGU6ICR7b3AudHlwZX0sIG1pbjogJHtvcC5taW59LCBtYXg6ICR7b3AubWF4fX07Ly8gUkVQXFxuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQU5EOlxuICAgICAgICAgICAgc291cmNlICs9IGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzWyR7b3BJbmRleH1dID0ge3R5cGU6ICR7b3AudHlwZX19Oy8vIEFORFxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLk5PVDpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHt0eXBlOiAke29wLnR5cGV9fTsvLyBOT1RcXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5BQkc6XG4gICAgICAgICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXNbJHtvcEluZGV4fV0gPSB7dHlwZTogJHtvcC50eXBlfX07Ly8gQUJHKCVeKVxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkFFTjpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHt0eXBlOiAke29wLnR5cGV9fTsvLyBBRU4oJSQpXFxuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQktBOlxuICAgICAgICAgICAgc291cmNlICs9IGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzWyR7b3BJbmRleH1dID0ge3R5cGU6ICR7b3AudHlwZX19Oy8vIEJLQVxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkJLTjpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHt0eXBlOiAke29wLnR5cGV9fTsvLyBCS05cXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5UTFM6XG4gICAgICAgICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXNbJHtvcEluZGV4fV0gPSB7dHlwZTogJHtcbiAgICAgICAgICAgICAgb3AudHlwZVxuICAgICAgICAgICAgfSwgc3RyaW5nOiBbJHtvcC5zdHJpbmcudG9TdHJpbmcoKX1dfTsvLyBUTFNcXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5UQlM6XG4gICAgICAgICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXNbJHtvcEluZGV4fV0gPSB7dHlwZTogJHtcbiAgICAgICAgICAgICAgb3AudHlwZVxuICAgICAgICAgICAgfSwgc3RyaW5nOiBbJHtvcC5zdHJpbmcudG9TdHJpbmcoKX1dfTsvLyBUQlNcXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5UUkc6XG4gICAgICAgICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXNbJHtvcEluZGV4fV0gPSB7dHlwZTogJHtvcC50eXBlfSwgbWluOiAke29wLm1pbn0sIG1heDogJHtvcC5tYXh9fTsvLyBUUkdcXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFyc2VyLmpzOiB+MTQzOiB1bnJlY29nbml6ZWQgb3Bjb2RlJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSAnXFxuJztcbiAgICBzb3VyY2UgKz0gJyAgLy8gVGhlIGB0b1N0cmluZygpYCBmdW5jdGlvbiB3aWxsIGRpc3BsYXkgdGhlIG9yaWdpbmFsIGdyYW1tYXIgZmlsZShzKSB0aGF0IHByb2R1Y2VkIHRoZXNlIG9wY29kZXMuXFxuJztcbiAgICBzb3VyY2UgKz0gJyAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCl7XFxuJztcbiAgICBzb3VyY2UgKz0gJyAgICBsZXQgc3RyID0gXCJcIjtcXG4nO1xuICAgIGxldCBzdHI7XG4gICAgbGluZXMuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgY29uc3QgZW5kID0gbGluZS5iZWdpbkNoYXIgKyBsaW5lLmxlbmd0aDtcbiAgICAgIHN0ciA9ICcnO1xuICAgICAgc291cmNlICs9ICcgICAgc3RyICs9IFwiJztcbiAgICAgIGZvciAobGV0IGlpID0gbGluZS5iZWdpbkNoYXI7IGlpIDwgZW5kOyBpaSArPSAxKSB7XG4gICAgICAgIHN3aXRjaCAoY2hhcnNbaWldKSB7XG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgc3RyID0gJyAnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHN0ciA9ICdcXFxcbic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgc3RyID0gJ1xcXFxyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICBzdHIgPSAnXFxcXFwiJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgOTI6XG4gICAgICAgICAgICBzdHIgPSAnXFxcXFxcXFwnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHN0ciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhcnNbaWldKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSArPSBzdHI7XG4gICAgICB9XG4gICAgICBzb3VyY2UgKz0gJ1wiO1xcbic7XG4gICAgfSk7XG4gICAgc291cmNlICs9ICcgICAgcmV0dXJuIHN0cjtcXG4nO1xuICAgIHNvdXJjZSArPSAnICB9XFxuJztcbiAgICBzb3VyY2UgKz0gJ31cXG4nO1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH07XG4gIC8vIEdlbmVyYXRlIGEgZ3JhbW1hciBmaWxlIG9iamVjdC5cbiAgLy8gUmV0dXJucyB0aGUgc2FtZSBvYmplY3QgYXMgaW5zdGFudGlhdGluZyB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24gcmV0dXJuZWQgYnk8YnI+XG4gIC8vIGB0aGlzLmdlbmVyYXRlU291cmNlKClgLjxicj5cbiAgdGhpcy5nZW5lcmF0ZU9iamVjdCA9IGZ1bmN0aW9uIGdlbmVyYXRlT2JqZWN0KHN0cmluZ0FyZywgcnVsZXMsIHVkdHMpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBjb25zdCBydWxlTmFtZXMgPSBbXTtcbiAgICBjb25zdCB1ZHROYW1lcyA9IFtdO1xuICAgIGNvbnN0IHN0cmluZyA9IHN0cmluZ0FyZy5zbGljZSgwKTtcbiAgICBvYmouZ3JhbW1hck9iamVjdCA9ICdncmFtbWFyT2JqZWN0JztcbiAgICBydWxlcy5mb3JFYWNoKChydWxlKSA9PiB7XG4gICAgICBydWxlTmFtZXMucHVzaChydWxlLmxvd2VyKTtcbiAgICB9KTtcbiAgICBydWxlTmFtZXMuc29ydCgpO1xuICAgIGlmICh1ZHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHVkdHMuZm9yRWFjaCgodWR0RnVuYykgPT4ge1xuICAgICAgICB1ZHROYW1lcy5wdXNoKHVkdEZ1bmMubG93ZXIpO1xuICAgICAgfSk7XG4gICAgICB1ZHROYW1lcy5zb3J0KCk7XG4gICAgfVxuICAgIG9iai5jYWxsYmFja3MgPSBbXTtcbiAgICBydWxlTmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgb2JqLmNhbGxiYWNrc1tuYW1lXSA9IGZhbHNlO1xuICAgIH0pO1xuICAgIGlmICh1ZHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHVkdE5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgb2JqLmNhbGxiYWNrc1tuYW1lXSA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIG9iai5ydWxlcyA9IHJ1bGVzO1xuICAgIG9iai51ZHRzID0gdWR0cztcbiAgICBvYmoudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZ0Z1bmMoKSB7XG4gICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH07XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-api/parser.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-api/rule-attributes.js":
/*!************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/rule-attributes.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module does the heavy lifting for attribute generation.\nmodule.exports = (function exportRuleAttributes() {\n  const id = __webpack_require__(/*! ../apg-lib/identifiers */ \"./node_modules/apg-js/src/apg-lib/identifiers.js\");\n  const thisFile = 'rule-attributes.js';\n  let state = null;\n  function isEmptyOnly(attr) {\n    if (attr.left || attr.nested || attr.right || attr.cyclic) {\n      return false;\n    }\n    return attr.empty;\n  }\n  function isRecursive(attr) {\n    if (attr.left || attr.nested || attr.right || attr.cyclic) {\n      return true;\n    }\n    return false;\n  }\n  function isCatNested(attrs, count) {\n    let i = 0;\n    let j = 0;\n    let k = 0;\n    /* 1. if any child is nested, CAT is nested */\n    for (i = 0; i < count; i += 1) {\n      if (attrs[i].nested) {\n        return true;\n      }\n    }\n    /* 2.) the left-most right recursive child\n               is followed by at least one non-empty child */\n    for (i = 0; i < count; i += 1) {\n      if (attrs[i].right && !attrs[i].leaf) {\n        for (j = i + 1; j < count; j += 1) {\n          if (!isEmptyOnly(attrs[j])) {\n            return true;\n          }\n        }\n      }\n    }\n    /* 3.) the right-most left recursive child\n               is preceded by at least one non-empty child */\n    for (i = count - 1; i >= 0; i -= 1) {\n      if (attrs[i].left && !attrs[i].leaf) {\n        for (j = i - 1; j >= 0; j -= 1) {\n          if (!isEmptyOnly(attrs[j])) {\n            return true;\n          }\n        }\n      }\n    }\n    /* 4. there is at lease one recursive child between\n              the left-most and right-most non-recursive, non-empty children */\n    for (i = 0; i < count; i += 1) {\n      if (!attrs[i].empty && !isRecursive(attrs[i])) {\n        for (j = i + 1; j < count; j += 1) {\n          if (isRecursive(attrs[j])) {\n            for (k = j + 1; k < count; k += 1) {\n              if (!attrs[k].empty && !isRecursive(attrs[k])) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    /* none of the above */\n    return false;\n  }\n  function isCatCyclic(attrs, count) {\n    /* if all children are cyclic, CAT is cyclic */\n    for (let i = 0; i < count; i += 1) {\n      if (!attrs[i].cyclic) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function isCatLeft(attrs, count) {\n    /* if the left-most non-empty is left, CAT is left */\n    for (let i = 0; i < count; i += 1) {\n      if (attrs[i].left) {\n        return true;\n      }\n      if (!attrs[i].empty) {\n        return false;\n      }\n      /* keep looking */\n    }\n    return false; /* all left-most are empty */\n  }\n  function isCatRight(attrs, count) {\n    /* if the right-most non-empty is right, CAT is right */\n    for (let i = count - 1; i >= 0; i -= 1) {\n      if (attrs[i].right) {\n        return true;\n      }\n      if (!attrs[i].empty) {\n        return false;\n      }\n      /* keep looking */\n    }\n    return false;\n  }\n  function isCatEmpty(attrs, count) {\n    /* if all children are empty, CAT is empty */\n    for (let i = 0; i < count; i += 1) {\n      if (!attrs[i].empty) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function isCatFinite(attrs, count) {\n    /* if all children are finite, CAT is finite */\n    for (let i = 0; i < count; i += 1) {\n      if (!attrs[i].finite) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function cat(stateArg, opcodes, opIndex, iAttr) {\n    let i = 0;\n    const opCat = opcodes[opIndex];\n    const count = opCat.children.length;\n\n    /* generate an empty array of child attributes */\n    const childAttrs = [];\n    for (i = 0; i < count; i += 1) {\n      childAttrs.push(stateArg.attrGen());\n    }\n    for (i = 0; i < count; i += 1) {\n      // eslint-disable-next-line no-use-before-define\n      opEval(stateArg, opcodes, opCat.children[i], childAttrs[i]);\n    }\n    iAttr.left = isCatLeft(childAttrs, count);\n    iAttr.right = isCatRight(childAttrs, count);\n    iAttr.nested = isCatNested(childAttrs, count);\n    iAttr.empty = isCatEmpty(childAttrs, count);\n    iAttr.finite = isCatFinite(childAttrs, count);\n    iAttr.cyclic = isCatCyclic(childAttrs, count);\n  }\n  function alt(stateArg, opcodes, opIndex, iAttr) {\n    let i = 0;\n    const opAlt = opcodes[opIndex];\n    const count = opAlt.children.length;\n\n    /* generate an empty array of child attributes */\n    const childAttrs = [];\n    for (i = 0; i < count; i += 1) {\n      childAttrs.push(stateArg.attrGen());\n    }\n    for (i = 0; i < count; i += 1) {\n      // eslint-disable-next-line no-use-before-define\n      opEval(stateArg, opcodes, opAlt.children[i], childAttrs[i]);\n    }\n\n    /* if any child attribute is true, ALT is true */\n    iAttr.left = false;\n    iAttr.right = false;\n    iAttr.nested = false;\n    iAttr.empty = false;\n    iAttr.finite = false;\n    iAttr.cyclic = false;\n    for (i = 0; i < count; i += 1) {\n      if (childAttrs[i].left) {\n        iAttr.left = true;\n      }\n      if (childAttrs[i].nested) {\n        iAttr.nested = true;\n      }\n      if (childAttrs[i].right) {\n        iAttr.right = true;\n      }\n      if (childAttrs[i].empty) {\n        iAttr.empty = true;\n      }\n      if (childAttrs[i].finite) {\n        iAttr.finite = true;\n      }\n      if (childAttrs[i].cyclic) {\n        iAttr.cyclic = true;\n      }\n    }\n  }\n  function bkr(stateArg, opcodes, opIndex, iAttr) {\n    const opBkr = opcodes[opIndex];\n    if (opBkr.index >= stateArg.ruleCount) {\n      /* use UDT values */\n      iAttr.empty = stateArg.udts[opBkr.index - stateArg.ruleCount].empty;\n      iAttr.finite = true;\n    } else {\n      /* use the empty and finite values from the back referenced rule */\n      // eslint-disable-next-line no-use-before-define\n      ruleAttrsEval(stateArg, opBkr.index, iAttr);\n\n      /* however, this is a terminal node like TLS */\n      iAttr.left = false;\n      iAttr.nested = false;\n      iAttr.right = false;\n      iAttr.cyclic = false;\n    }\n  }\n\n  function opEval(stateArg, opcodes, opIndex, iAttr) {\n    stateArg.attrInit(iAttr);\n    const opi = opcodes[opIndex];\n    switch (opi.type) {\n      case id.ALT:\n        alt(stateArg, opcodes, opIndex, iAttr);\n        break;\n      case id.CAT:\n        cat(stateArg, opcodes, opIndex, iAttr);\n        break;\n      case id.REP:\n        opEval(stateArg, opcodes, opIndex + 1, iAttr);\n        if (opi.min === 0) {\n          iAttr.empty = true;\n          iAttr.finite = true;\n        }\n        break;\n      case id.RNM:\n        // eslint-disable-next-line no-use-before-define\n        ruleAttrsEval(stateArg, opcodes[opIndex].index, iAttr);\n        break;\n      case id.BKR:\n        bkr(stateArg, opcodes, opIndex, iAttr);\n        break;\n      case id.AND:\n      case id.NOT:\n      case id.BKA:\n      case id.BKN:\n        opEval(stateArg, opcodes, opIndex + 1, iAttr);\n        iAttr.empty = true;\n        break;\n      case id.TLS:\n        iAttr.empty = !opcodes[opIndex].string.length;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      case id.TBS:\n      case id.TRG:\n        iAttr.empty = false;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      case id.UDT:\n        iAttr.empty = opi.empty;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      case id.ABG:\n      case id.AEN:\n        iAttr.empty = true;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      default:\n        throw new Error(`unknown opcode type: ${opi}`);\n    }\n  }\n  // The main logic for handling rules that:\n  //  - have already be evaluated\n  //  - have not been evaluated and is the first occurrence on this branch\n  //  - second occurrence on this branch for the start rule\n  //  - second occurrence on this branch for non-start rules\n  function ruleAttrsEval(stateArg, ruleIndex, iAttr) {\n    const attri = stateArg.attrsWorking[ruleIndex];\n    if (attri.isComplete) {\n      /* just use the completed values */\n      stateArg.attrCopy(iAttr, attri);\n    } else if (!attri.isOpen) {\n      /* open the rule and traverse it */\n      attri.isOpen = true;\n      opEval(stateArg, attri.rule.opcodes, 0, iAttr);\n      /* complete this rule's attributes */\n      attri.left = iAttr.left;\n      attri.right = iAttr.right;\n      attri.nested = iAttr.nested;\n      attri.empty = iAttr.empty;\n      attri.finite = iAttr.finite;\n      attri.cyclic = iAttr.cyclic;\n      attri.leaf = false;\n      attri.isOpen = false;\n      attri.isComplete = true;\n    } else if (ruleIndex === stateArg.startRule) {\n      /* use recursive leaf values */\n      if (ruleIndex === stateArg.startRule) {\n        iAttr.left = true;\n        iAttr.right = true;\n        iAttr.cyclic = true;\n        iAttr.leaf = true;\n      }\n    } else {\n      /* non-start rule terminal leaf */\n      iAttr.finite = true;\n    }\n  }\n  // The main driver for the attribute generation.\n  const ruleAttributes = (stateArg) => {\n    state = stateArg;\n    let i = 0;\n    let j = 0;\n    const iAttr = state.attrGen();\n    for (i = 0; i < state.ruleCount; i += 1) {\n      /* initialize working attributes */\n      for (j = 0; j < state.ruleCount; j += 1) {\n        state.attrInit(state.attrsWorking[j]);\n      }\n      state.startRule = i;\n      ruleAttrsEval(state, i, iAttr);\n\n      /* save off the working attributes for this rule */\n      state.attrCopy(state.attrs[i], state.attrsWorking[i]);\n    }\n    state.attributesComplete = true;\n    let attri = null;\n    for (i = 0; i < state.ruleCount; i += 1) {\n      attri = state.attrs[i];\n      if (attri.left || !attri.finite || attri.cyclic) {\n        const temp = state.attrGen(attri.rule);\n        state.attrCopy(temp, attri);\n        state.attrsErrors.push(temp);\n        state.attrsErrorCount += 1;\n      }\n    }\n  };\n  const truth = (val) => (val ? 't' : 'f');\n  const tError = (val) => (val ? 'e' : 'f');\n  const fError = (val) => (val ? 't' : 'e');\n  const showAttr = (seq, index, attr, dep) => {\n    let str = `${seq}:${index}:`;\n    str += `${tError(attr.left)} `;\n    str += `${truth(attr.nested)} `;\n    str += `${truth(attr.right)} `;\n    str += `${tError(attr.cyclic)} `;\n    str += `${fError(attr.finite)} `;\n    str += `${truth(attr.empty)}:`;\n    str += `${state.typeToString(dep.recursiveType)}:`;\n    str += dep.recursiveType === id.ATTR_MR ? dep.groupNumber : '-';\n    str += `:${attr.rule.name}\\n`;\n    return str;\n  };\n\n  const showLegend = () => {\n    let str = 'LEGEND - t=true, f=false, e=error\\n';\n    str += 'sequence:rule index:left nested right cyclic finite empty:type:group number:rule name\\n';\n    return str;\n  };\n  const showAttributeErrors = () => {\n    let attri = null;\n    let depi = null;\n    let str = '';\n    str += 'RULE ATTRIBUTES WITH ERRORS\\n';\n    str += showLegend();\n    if (state.attrsErrorCount) {\n      for (let i = 0; i < state.attrsErrorCount; i += 1) {\n        attri = state.attrsErrors[i];\n        depi = state.ruleDeps[attri.rule.index];\n        str += showAttr(i, attri.rule.index, attri, depi);\n      }\n    } else {\n      str += '<none>\\n';\n    }\n    return str;\n  };\n\n  const show = (type) => {\n    let i = 0;\n    let ii = 0;\n    let attri = null;\n    let depi = null;\n    let str = '';\n    let { ruleIndexes } = state;\n    // let udtIndexes = state.udtIndexes;\n    if (type === 97) {\n      ruleIndexes = state.ruleAlphaIndexes;\n      // udtIndexes = state.udtAlphaIndexes;\n    } else if (type === 116) {\n      ruleIndexes = state.ruleTypeIndexes;\n      // udtIndexes = state.udtAlphaIndexes;\n    }\n    /* show all attributes */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      ii = ruleIndexes[i];\n      attri = state.attrs[ii];\n      depi = state.ruleDeps[ii];\n      str += showAttr(i, ii, attri, depi);\n    }\n    return str;\n  };\n\n  // Display the rule attributes.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, index order (default)\n  const showAttributes = (order = 'index') => {\n    if (!state.attributesComplete) {\n      throw new Error(`${thisFile}:showAttributes: attributes not available`);\n    }\n    let str = '';\n    const leader = 'RULE ATTRIBUTES\\n';\n    if (order.charCodeAt(0) === 97) {\n      str += 'alphabetical by rule name\\n';\n      str += leader;\n      str += showLegend();\n      str += show(97);\n    } else if (order.charCodeAt(0) === 116) {\n      str += 'ordered by rule type\\n';\n      str += leader;\n      str += showLegend();\n      str += show(116);\n    } else {\n      str += 'ordered by rule index\\n';\n      str += leader;\n      str += showLegend();\n      str += show();\n    }\n    return str;\n  };\n\n  /* Destructuring assignment - see MDN Web Docs */\n  return { ruleAttributes, showAttributes, showAttributeErrors };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3J1bGUtYXR0cmlidXRlcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsZ0ZBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsSUFBSTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFJLEdBQUcsTUFBTTtBQUM5QixjQUFjLG1CQUFtQjtBQUNqQyxjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLG1CQUFtQjtBQUNqQyxjQUFjLHFCQUFxQjtBQUNuQyxjQUFjLHFCQUFxQjtBQUNuQyxjQUFjLGtCQUFrQjtBQUNoQyxjQUFjLHNDQUFzQztBQUNwRDtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvcnVsZS1hdHRyaWJ1dGVzLmpzPzYyZmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgZG9lcyB0aGUgaGVhdnkgbGlmdGluZyBmb3IgYXR0cmlidXRlIGdlbmVyYXRpb24uXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiBleHBvcnRSdWxlQXR0cmlidXRlcygpIHtcbiAgY29uc3QgaWQgPSByZXF1aXJlKCcuLi9hcGctbGliL2lkZW50aWZpZXJzJyk7XG4gIGNvbnN0IHRoaXNGaWxlID0gJ3J1bGUtYXR0cmlidXRlcy5qcyc7XG4gIGxldCBzdGF0ZSA9IG51bGw7XG4gIGZ1bmN0aW9uIGlzRW1wdHlPbmx5KGF0dHIpIHtcbiAgICBpZiAoYXR0ci5sZWZ0IHx8IGF0dHIubmVzdGVkIHx8IGF0dHIucmlnaHQgfHwgYXR0ci5jeWNsaWMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHIuZW1wdHk7XG4gIH1cbiAgZnVuY3Rpb24gaXNSZWN1cnNpdmUoYXR0cikge1xuICAgIGlmIChhdHRyLmxlZnQgfHwgYXR0ci5uZXN0ZWQgfHwgYXR0ci5yaWdodCB8fCBhdHRyLmN5Y2xpYykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBpc0NhdE5lc3RlZChhdHRycywgY291bnQpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGogPSAwO1xuICAgIGxldCBrID0gMDtcbiAgICAvKiAxLiBpZiBhbnkgY2hpbGQgaXMgbmVzdGVkLCBDQVQgaXMgbmVzdGVkICovXG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgIGlmIChhdHRyc1tpXS5uZXN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIDIuKSB0aGUgbGVmdC1tb3N0IHJpZ2h0IHJlY3Vyc2l2ZSBjaGlsZFxuICAgICAgICAgICAgICAgaXMgZm9sbG93ZWQgYnkgYXQgbGVhc3Qgb25lIG5vbi1lbXB0eSBjaGlsZCAqL1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICBpZiAoYXR0cnNbaV0ucmlnaHQgJiYgIWF0dHJzW2ldLmxlYWYpIHtcbiAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBjb3VudDsgaiArPSAxKSB7XG4gICAgICAgICAgaWYgKCFpc0VtcHR5T25seShhdHRyc1tqXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiAzLikgdGhlIHJpZ2h0LW1vc3QgbGVmdCByZWN1cnNpdmUgY2hpbGRcbiAgICAgICAgICAgICAgIGlzIHByZWNlZGVkIGJ5IGF0IGxlYXN0IG9uZSBub24tZW1wdHkgY2hpbGQgKi9cbiAgICBmb3IgKGkgPSBjb3VudCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICBpZiAoYXR0cnNbaV0ubGVmdCAmJiAhYXR0cnNbaV0ubGVhZikge1xuICAgICAgICBmb3IgKGogPSBpIC0gMTsgaiA+PSAwOyBqIC09IDEpIHtcbiAgICAgICAgICBpZiAoIWlzRW1wdHlPbmx5KGF0dHJzW2pdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIDQuIHRoZXJlIGlzIGF0IGxlYXNlIG9uZSByZWN1cnNpdmUgY2hpbGQgYmV0d2VlblxuICAgICAgICAgICAgICB0aGUgbGVmdC1tb3N0IGFuZCByaWdodC1tb3N0IG5vbi1yZWN1cnNpdmUsIG5vbi1lbXB0eSBjaGlsZHJlbiAqL1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICBpZiAoIWF0dHJzW2ldLmVtcHR5ICYmICFpc1JlY3Vyc2l2ZShhdHRyc1tpXSkpIHtcbiAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBjb3VudDsgaiArPSAxKSB7XG4gICAgICAgICAgaWYgKGlzUmVjdXJzaXZlKGF0dHJzW2pdKSkge1xuICAgICAgICAgICAgZm9yIChrID0gaiArIDE7IGsgPCBjb3VudDsgayArPSAxKSB7XG4gICAgICAgICAgICAgIGlmICghYXR0cnNba10uZW1wdHkgJiYgIWlzUmVjdXJzaXZlKGF0dHJzW2tdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogbm9uZSBvZiB0aGUgYWJvdmUgKi9cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gaXNDYXRDeWNsaWMoYXR0cnMsIGNvdW50KSB7XG4gICAgLyogaWYgYWxsIGNoaWxkcmVuIGFyZSBjeWNsaWMsIENBVCBpcyBjeWNsaWMgKi9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgIGlmICghYXR0cnNbaV0uY3ljbGljKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gaXNDYXRMZWZ0KGF0dHJzLCBjb3VudCkge1xuICAgIC8qIGlmIHRoZSBsZWZ0LW1vc3Qgbm9uLWVtcHR5IGlzIGxlZnQsIENBVCBpcyBsZWZ0ICovXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICBpZiAoYXR0cnNbaV0ubGVmdCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghYXR0cnNbaV0uZW1wdHkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLyoga2VlcCBsb29raW5nICovXG4gICAgfVxuICAgIHJldHVybiBmYWxzZTsgLyogYWxsIGxlZnQtbW9zdCBhcmUgZW1wdHkgKi9cbiAgfVxuICBmdW5jdGlvbiBpc0NhdFJpZ2h0KGF0dHJzLCBjb3VudCkge1xuICAgIC8qIGlmIHRoZSByaWdodC1tb3N0IG5vbi1lbXB0eSBpcyByaWdodCwgQ0FUIGlzIHJpZ2h0ICovXG4gICAgZm9yIChsZXQgaSA9IGNvdW50IC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIGlmIChhdHRyc1tpXS5yaWdodCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghYXR0cnNbaV0uZW1wdHkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLyoga2VlcCBsb29raW5nICovXG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBpc0NhdEVtcHR5KGF0dHJzLCBjb3VudCkge1xuICAgIC8qIGlmIGFsbCBjaGlsZHJlbiBhcmUgZW1wdHksIENBVCBpcyBlbXB0eSAqL1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgaWYgKCFhdHRyc1tpXS5lbXB0eSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGlzQ2F0RmluaXRlKGF0dHJzLCBjb3VudCkge1xuICAgIC8qIGlmIGFsbCBjaGlsZHJlbiBhcmUgZmluaXRlLCBDQVQgaXMgZmluaXRlICovXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICBpZiAoIWF0dHJzW2ldLmZpbml0ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGNhdChzdGF0ZUFyZywgb3Bjb2Rlcywgb3BJbmRleCwgaUF0dHIpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3Qgb3BDYXQgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIGNvbnN0IGNvdW50ID0gb3BDYXQuY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgLyogZ2VuZXJhdGUgYW4gZW1wdHkgYXJyYXkgb2YgY2hpbGQgYXR0cmlidXRlcyAqL1xuICAgIGNvbnN0IGNoaWxkQXR0cnMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgY2hpbGRBdHRycy5wdXNoKHN0YXRlQXJnLmF0dHJHZW4oKSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgIG9wRXZhbChzdGF0ZUFyZywgb3Bjb2Rlcywgb3BDYXQuY2hpbGRyZW5baV0sIGNoaWxkQXR0cnNbaV0pO1xuICAgIH1cbiAgICBpQXR0ci5sZWZ0ID0gaXNDYXRMZWZ0KGNoaWxkQXR0cnMsIGNvdW50KTtcbiAgICBpQXR0ci5yaWdodCA9IGlzQ2F0UmlnaHQoY2hpbGRBdHRycywgY291bnQpO1xuICAgIGlBdHRyLm5lc3RlZCA9IGlzQ2F0TmVzdGVkKGNoaWxkQXR0cnMsIGNvdW50KTtcbiAgICBpQXR0ci5lbXB0eSA9IGlzQ2F0RW1wdHkoY2hpbGRBdHRycywgY291bnQpO1xuICAgIGlBdHRyLmZpbml0ZSA9IGlzQ2F0RmluaXRlKGNoaWxkQXR0cnMsIGNvdW50KTtcbiAgICBpQXR0ci5jeWNsaWMgPSBpc0NhdEN5Y2xpYyhjaGlsZEF0dHJzLCBjb3VudCk7XG4gIH1cbiAgZnVuY3Rpb24gYWx0KHN0YXRlQXJnLCBvcGNvZGVzLCBvcEluZGV4LCBpQXR0cikge1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBvcEFsdCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgY29uc3QgY291bnQgPSBvcEFsdC5jaGlsZHJlbi5sZW5ndGg7XG5cbiAgICAvKiBnZW5lcmF0ZSBhbiBlbXB0eSBhcnJheSBvZiBjaGlsZCBhdHRyaWJ1dGVzICovXG4gICAgY29uc3QgY2hpbGRBdHRycyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICBjaGlsZEF0dHJzLnB1c2goc3RhdGVBcmcuYXR0ckdlbigpKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgb3BFdmFsKHN0YXRlQXJnLCBvcGNvZGVzLCBvcEFsdC5jaGlsZHJlbltpXSwgY2hpbGRBdHRyc1tpXSk7XG4gICAgfVxuXG4gICAgLyogaWYgYW55IGNoaWxkIGF0dHJpYnV0ZSBpcyB0cnVlLCBBTFQgaXMgdHJ1ZSAqL1xuICAgIGlBdHRyLmxlZnQgPSBmYWxzZTtcbiAgICBpQXR0ci5yaWdodCA9IGZhbHNlO1xuICAgIGlBdHRyLm5lc3RlZCA9IGZhbHNlO1xuICAgIGlBdHRyLmVtcHR5ID0gZmFsc2U7XG4gICAgaUF0dHIuZmluaXRlID0gZmFsc2U7XG4gICAgaUF0dHIuY3ljbGljID0gZmFsc2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgIGlmIChjaGlsZEF0dHJzW2ldLmxlZnQpIHtcbiAgICAgICAgaUF0dHIubGVmdCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGRBdHRyc1tpXS5uZXN0ZWQpIHtcbiAgICAgICAgaUF0dHIubmVzdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZEF0dHJzW2ldLnJpZ2h0KSB7XG4gICAgICAgIGlBdHRyLnJpZ2h0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZEF0dHJzW2ldLmVtcHR5KSB7XG4gICAgICAgIGlBdHRyLmVtcHR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZEF0dHJzW2ldLmZpbml0ZSkge1xuICAgICAgICBpQXR0ci5maW5pdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkQXR0cnNbaV0uY3ljbGljKSB7XG4gICAgICAgIGlBdHRyLmN5Y2xpYyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGJrcihzdGF0ZUFyZywgb3Bjb2Rlcywgb3BJbmRleCwgaUF0dHIpIHtcbiAgICBjb25zdCBvcEJrciA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgaWYgKG9wQmtyLmluZGV4ID49IHN0YXRlQXJnLnJ1bGVDb3VudCkge1xuICAgICAgLyogdXNlIFVEVCB2YWx1ZXMgKi9cbiAgICAgIGlBdHRyLmVtcHR5ID0gc3RhdGVBcmcudWR0c1tvcEJrci5pbmRleCAtIHN0YXRlQXJnLnJ1bGVDb3VudF0uZW1wdHk7XG4gICAgICBpQXR0ci5maW5pdGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiB1c2UgdGhlIGVtcHR5IGFuZCBmaW5pdGUgdmFsdWVzIGZyb20gdGhlIGJhY2sgcmVmZXJlbmNlZCBydWxlICovXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgIHJ1bGVBdHRyc0V2YWwoc3RhdGVBcmcsIG9wQmtyLmluZGV4LCBpQXR0cik7XG5cbiAgICAgIC8qIGhvd2V2ZXIsIHRoaXMgaXMgYSB0ZXJtaW5hbCBub2RlIGxpa2UgVExTICovXG4gICAgICBpQXR0ci5sZWZ0ID0gZmFsc2U7XG4gICAgICBpQXR0ci5uZXN0ZWQgPSBmYWxzZTtcbiAgICAgIGlBdHRyLnJpZ2h0ID0gZmFsc2U7XG4gICAgICBpQXR0ci5jeWNsaWMgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvcEV2YWwoc3RhdGVBcmcsIG9wY29kZXMsIG9wSW5kZXgsIGlBdHRyKSB7XG4gICAgc3RhdGVBcmcuYXR0ckluaXQoaUF0dHIpO1xuICAgIGNvbnN0IG9waSA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgc3dpdGNoIChvcGkudHlwZSkge1xuICAgICAgY2FzZSBpZC5BTFQ6XG4gICAgICAgIGFsdChzdGF0ZUFyZywgb3Bjb2Rlcywgb3BJbmRleCwgaUF0dHIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuQ0FUOlxuICAgICAgICBjYXQoc3RhdGVBcmcsIG9wY29kZXMsIG9wSW5kZXgsIGlBdHRyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLlJFUDpcbiAgICAgICAgb3BFdmFsKHN0YXRlQXJnLCBvcGNvZGVzLCBvcEluZGV4ICsgMSwgaUF0dHIpO1xuICAgICAgICBpZiAob3BpLm1pbiA9PT0gMCkge1xuICAgICAgICAgIGlBdHRyLmVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICBpQXR0ci5maW5pdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5STk06XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICBydWxlQXR0cnNFdmFsKHN0YXRlQXJnLCBvcGNvZGVzW29wSW5kZXhdLmluZGV4LCBpQXR0cik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5CS1I6XG4gICAgICAgIGJrcihzdGF0ZUFyZywgb3Bjb2Rlcywgb3BJbmRleCwgaUF0dHIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuQU5EOlxuICAgICAgY2FzZSBpZC5OT1Q6XG4gICAgICBjYXNlIGlkLkJLQTpcbiAgICAgIGNhc2UgaWQuQktOOlxuICAgICAgICBvcEV2YWwoc3RhdGVBcmcsIG9wY29kZXMsIG9wSW5kZXggKyAxLCBpQXR0cik7XG4gICAgICAgIGlBdHRyLmVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLlRMUzpcbiAgICAgICAgaUF0dHIuZW1wdHkgPSAhb3Bjb2Rlc1tvcEluZGV4XS5zdHJpbmcubGVuZ3RoO1xuICAgICAgICBpQXR0ci5maW5pdGUgPSB0cnVlO1xuICAgICAgICBpQXR0ci5jeWNsaWMgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLlRCUzpcbiAgICAgIGNhc2UgaWQuVFJHOlxuICAgICAgICBpQXR0ci5lbXB0eSA9IGZhbHNlO1xuICAgICAgICBpQXR0ci5maW5pdGUgPSB0cnVlO1xuICAgICAgICBpQXR0ci5jeWNsaWMgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLlVEVDpcbiAgICAgICAgaUF0dHIuZW1wdHkgPSBvcGkuZW1wdHk7XG4gICAgICAgIGlBdHRyLmZpbml0ZSA9IHRydWU7XG4gICAgICAgIGlBdHRyLmN5Y2xpYyA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuQUJHOlxuICAgICAgY2FzZSBpZC5BRU46XG4gICAgICAgIGlBdHRyLmVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgaUF0dHIuZmluaXRlID0gdHJ1ZTtcbiAgICAgICAgaUF0dHIuY3ljbGljID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIG9wY29kZSB0eXBlOiAke29waX1gKTtcbiAgICB9XG4gIH1cbiAgLy8gVGhlIG1haW4gbG9naWMgZm9yIGhhbmRsaW5nIHJ1bGVzIHRoYXQ6XG4gIC8vICAtIGhhdmUgYWxyZWFkeSBiZSBldmFsdWF0ZWRcbiAgLy8gIC0gaGF2ZSBub3QgYmVlbiBldmFsdWF0ZWQgYW5kIGlzIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9uIHRoaXMgYnJhbmNoXG4gIC8vICAtIHNlY29uZCBvY2N1cnJlbmNlIG9uIHRoaXMgYnJhbmNoIGZvciB0aGUgc3RhcnQgcnVsZVxuICAvLyAgLSBzZWNvbmQgb2NjdXJyZW5jZSBvbiB0aGlzIGJyYW5jaCBmb3Igbm9uLXN0YXJ0IHJ1bGVzXG4gIGZ1bmN0aW9uIHJ1bGVBdHRyc0V2YWwoc3RhdGVBcmcsIHJ1bGVJbmRleCwgaUF0dHIpIHtcbiAgICBjb25zdCBhdHRyaSA9IHN0YXRlQXJnLmF0dHJzV29ya2luZ1tydWxlSW5kZXhdO1xuICAgIGlmIChhdHRyaS5pc0NvbXBsZXRlKSB7XG4gICAgICAvKiBqdXN0IHVzZSB0aGUgY29tcGxldGVkIHZhbHVlcyAqL1xuICAgICAgc3RhdGVBcmcuYXR0ckNvcHkoaUF0dHIsIGF0dHJpKTtcbiAgICB9IGVsc2UgaWYgKCFhdHRyaS5pc09wZW4pIHtcbiAgICAgIC8qIG9wZW4gdGhlIHJ1bGUgYW5kIHRyYXZlcnNlIGl0ICovXG4gICAgICBhdHRyaS5pc09wZW4gPSB0cnVlO1xuICAgICAgb3BFdmFsKHN0YXRlQXJnLCBhdHRyaS5ydWxlLm9wY29kZXMsIDAsIGlBdHRyKTtcbiAgICAgIC8qIGNvbXBsZXRlIHRoaXMgcnVsZSdzIGF0dHJpYnV0ZXMgKi9cbiAgICAgIGF0dHJpLmxlZnQgPSBpQXR0ci5sZWZ0O1xuICAgICAgYXR0cmkucmlnaHQgPSBpQXR0ci5yaWdodDtcbiAgICAgIGF0dHJpLm5lc3RlZCA9IGlBdHRyLm5lc3RlZDtcbiAgICAgIGF0dHJpLmVtcHR5ID0gaUF0dHIuZW1wdHk7XG4gICAgICBhdHRyaS5maW5pdGUgPSBpQXR0ci5maW5pdGU7XG4gICAgICBhdHRyaS5jeWNsaWMgPSBpQXR0ci5jeWNsaWM7XG4gICAgICBhdHRyaS5sZWFmID0gZmFsc2U7XG4gICAgICBhdHRyaS5pc09wZW4gPSBmYWxzZTtcbiAgICAgIGF0dHJpLmlzQ29tcGxldGUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAocnVsZUluZGV4ID09PSBzdGF0ZUFyZy5zdGFydFJ1bGUpIHtcbiAgICAgIC8qIHVzZSByZWN1cnNpdmUgbGVhZiB2YWx1ZXMgKi9cbiAgICAgIGlmIChydWxlSW5kZXggPT09IHN0YXRlQXJnLnN0YXJ0UnVsZSkge1xuICAgICAgICBpQXR0ci5sZWZ0ID0gdHJ1ZTtcbiAgICAgICAgaUF0dHIucmlnaHQgPSB0cnVlO1xuICAgICAgICBpQXR0ci5jeWNsaWMgPSB0cnVlO1xuICAgICAgICBpQXR0ci5sZWFmID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogbm9uLXN0YXJ0IHJ1bGUgdGVybWluYWwgbGVhZiAqL1xuICAgICAgaUF0dHIuZmluaXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gVGhlIG1haW4gZHJpdmVyIGZvciB0aGUgYXR0cmlidXRlIGdlbmVyYXRpb24uXG4gIGNvbnN0IHJ1bGVBdHRyaWJ1dGVzID0gKHN0YXRlQXJnKSA9PiB7XG4gICAgc3RhdGUgPSBzdGF0ZUFyZztcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGogPSAwO1xuICAgIGNvbnN0IGlBdHRyID0gc3RhdGUuYXR0ckdlbigpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGF0ZS5ydWxlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgLyogaW5pdGlhbGl6ZSB3b3JraW5nIGF0dHJpYnV0ZXMgKi9cbiAgICAgIGZvciAoaiA9IDA7IGogPCBzdGF0ZS5ydWxlQ291bnQ7IGogKz0gMSkge1xuICAgICAgICBzdGF0ZS5hdHRySW5pdChzdGF0ZS5hdHRyc1dvcmtpbmdbal0pO1xuICAgICAgfVxuICAgICAgc3RhdGUuc3RhcnRSdWxlID0gaTtcbiAgICAgIHJ1bGVBdHRyc0V2YWwoc3RhdGUsIGksIGlBdHRyKTtcblxuICAgICAgLyogc2F2ZSBvZmYgdGhlIHdvcmtpbmcgYXR0cmlidXRlcyBmb3IgdGhpcyBydWxlICovXG4gICAgICBzdGF0ZS5hdHRyQ29weShzdGF0ZS5hdHRyc1tpXSwgc3RhdGUuYXR0cnNXb3JraW5nW2ldKTtcbiAgICB9XG4gICAgc3RhdGUuYXR0cmlidXRlc0NvbXBsZXRlID0gdHJ1ZTtcbiAgICBsZXQgYXR0cmkgPSBudWxsO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGF0ZS5ydWxlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgYXR0cmkgPSBzdGF0ZS5hdHRyc1tpXTtcbiAgICAgIGlmIChhdHRyaS5sZWZ0IHx8ICFhdHRyaS5maW5pdGUgfHwgYXR0cmkuY3ljbGljKSB7XG4gICAgICAgIGNvbnN0IHRlbXAgPSBzdGF0ZS5hdHRyR2VuKGF0dHJpLnJ1bGUpO1xuICAgICAgICBzdGF0ZS5hdHRyQ29weSh0ZW1wLCBhdHRyaSk7XG4gICAgICAgIHN0YXRlLmF0dHJzRXJyb3JzLnB1c2godGVtcCk7XG4gICAgICAgIHN0YXRlLmF0dHJzRXJyb3JDb3VudCArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgdHJ1dGggPSAodmFsKSA9PiAodmFsID8gJ3QnIDogJ2YnKTtcbiAgY29uc3QgdEVycm9yID0gKHZhbCkgPT4gKHZhbCA/ICdlJyA6ICdmJyk7XG4gIGNvbnN0IGZFcnJvciA9ICh2YWwpID0+ICh2YWwgPyAndCcgOiAnZScpO1xuICBjb25zdCBzaG93QXR0ciA9IChzZXEsIGluZGV4LCBhdHRyLCBkZXApID0+IHtcbiAgICBsZXQgc3RyID0gYCR7c2VxfToke2luZGV4fTpgO1xuICAgIHN0ciArPSBgJHt0RXJyb3IoYXR0ci5sZWZ0KX0gYDtcbiAgICBzdHIgKz0gYCR7dHJ1dGgoYXR0ci5uZXN0ZWQpfSBgO1xuICAgIHN0ciArPSBgJHt0cnV0aChhdHRyLnJpZ2h0KX0gYDtcbiAgICBzdHIgKz0gYCR7dEVycm9yKGF0dHIuY3ljbGljKX0gYDtcbiAgICBzdHIgKz0gYCR7ZkVycm9yKGF0dHIuZmluaXRlKX0gYDtcbiAgICBzdHIgKz0gYCR7dHJ1dGgoYXR0ci5lbXB0eSl9OmA7XG4gICAgc3RyICs9IGAke3N0YXRlLnR5cGVUb1N0cmluZyhkZXAucmVjdXJzaXZlVHlwZSl9OmA7XG4gICAgc3RyICs9IGRlcC5yZWN1cnNpdmVUeXBlID09PSBpZC5BVFRSX01SID8gZGVwLmdyb3VwTnVtYmVyIDogJy0nO1xuICAgIHN0ciArPSBgOiR7YXR0ci5ydWxlLm5hbWV9XFxuYDtcbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIGNvbnN0IHNob3dMZWdlbmQgPSAoKSA9PiB7XG4gICAgbGV0IHN0ciA9ICdMRUdFTkQgLSB0PXRydWUsIGY9ZmFsc2UsIGU9ZXJyb3JcXG4nO1xuICAgIHN0ciArPSAnc2VxdWVuY2U6cnVsZSBpbmRleDpsZWZ0IG5lc3RlZCByaWdodCBjeWNsaWMgZmluaXRlIGVtcHR5OnR5cGU6Z3JvdXAgbnVtYmVyOnJ1bGUgbmFtZVxcbic7XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcbiAgY29uc3Qgc2hvd0F0dHJpYnV0ZUVycm9ycyA9ICgpID0+IHtcbiAgICBsZXQgYXR0cmkgPSBudWxsO1xuICAgIGxldCBkZXBpID0gbnVsbDtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgc3RyICs9ICdSVUxFIEFUVFJJQlVURVMgV0lUSCBFUlJPUlNcXG4nO1xuICAgIHN0ciArPSBzaG93TGVnZW5kKCk7XG4gICAgaWYgKHN0YXRlLmF0dHJzRXJyb3JDb3VudCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5hdHRyc0Vycm9yQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICBhdHRyaSA9IHN0YXRlLmF0dHJzRXJyb3JzW2ldO1xuICAgICAgICBkZXBpID0gc3RhdGUucnVsZURlcHNbYXR0cmkucnVsZS5pbmRleF07XG4gICAgICAgIHN0ciArPSBzaG93QXR0cihpLCBhdHRyaS5ydWxlLmluZGV4LCBhdHRyaSwgZGVwaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnPG5vbmU+XFxuJztcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICBjb25zdCBzaG93ID0gKHR5cGUpID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGlpID0gMDtcbiAgICBsZXQgYXR0cmkgPSBudWxsO1xuICAgIGxldCBkZXBpID0gbnVsbDtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgbGV0IHsgcnVsZUluZGV4ZXMgfSA9IHN0YXRlO1xuICAgIC8vIGxldCB1ZHRJbmRleGVzID0gc3RhdGUudWR0SW5kZXhlcztcbiAgICBpZiAodHlwZSA9PT0gOTcpIHtcbiAgICAgIHJ1bGVJbmRleGVzID0gc3RhdGUucnVsZUFscGhhSW5kZXhlcztcbiAgICAgIC8vIHVkdEluZGV4ZXMgPSBzdGF0ZS51ZHRBbHBoYUluZGV4ZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAxMTYpIHtcbiAgICAgIHJ1bGVJbmRleGVzID0gc3RhdGUucnVsZVR5cGVJbmRleGVzO1xuICAgICAgLy8gdWR0SW5kZXhlcyA9IHN0YXRlLnVkdEFscGhhSW5kZXhlcztcbiAgICB9XG4gICAgLyogc2hvdyBhbGwgYXR0cmlidXRlcyAqL1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGF0ZS5ydWxlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgaWkgPSBydWxlSW5kZXhlc1tpXTtcbiAgICAgIGF0dHJpID0gc3RhdGUuYXR0cnNbaWldO1xuICAgICAgZGVwaSA9IHN0YXRlLnJ1bGVEZXBzW2lpXTtcbiAgICAgIHN0ciArPSBzaG93QXR0cihpLCBpaSwgYXR0cmksIGRlcGkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIC8vIERpc3BsYXkgdGhlIHJ1bGUgYXR0cmlidXRlcy5cbiAgLy8gLSBvcmRlclxuICAvLyAgICAgIC0gXCJpbmRleFwiIG9yIFwiaVwiLCBpbmRleCBvcmRlciAoZGVmYXVsdClcbiAgLy8gICAgICAtIFwiYWxwaGFcIiBvciBcImFcIiwgYWxwaGFiZXRpY2FsIG9yZGVyXG4gIC8vICAgICAgLSBcInR5cGVcIiBvciBcInRcIiwgb3JkZXJlZCBieSB0eXBlIChhbHBoYWJldGljYWwgd2l0aGluIGVhY2ggdHlwZS9ncm91cClcbiAgLy8gICAgICAtIG5vbmUgb2YgYWJvdmUsIGluZGV4IG9yZGVyIChkZWZhdWx0KVxuICBjb25zdCBzaG93QXR0cmlidXRlcyA9IChvcmRlciA9ICdpbmRleCcpID0+IHtcbiAgICBpZiAoIXN0YXRlLmF0dHJpYnV0ZXNDb21wbGV0ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlfTpzaG93QXR0cmlidXRlczogYXR0cmlidXRlcyBub3QgYXZhaWxhYmxlYCk7XG4gICAgfVxuICAgIGxldCBzdHIgPSAnJztcbiAgICBjb25zdCBsZWFkZXIgPSAnUlVMRSBBVFRSSUJVVEVTXFxuJztcbiAgICBpZiAob3JkZXIuY2hhckNvZGVBdCgwKSA9PT0gOTcpIHtcbiAgICAgIHN0ciArPSAnYWxwaGFiZXRpY2FsIGJ5IHJ1bGUgbmFtZVxcbic7XG4gICAgICBzdHIgKz0gbGVhZGVyO1xuICAgICAgc3RyICs9IHNob3dMZWdlbmQoKTtcbiAgICAgIHN0ciArPSBzaG93KDk3KTtcbiAgICB9IGVsc2UgaWYgKG9yZGVyLmNoYXJDb2RlQXQoMCkgPT09IDExNikge1xuICAgICAgc3RyICs9ICdvcmRlcmVkIGJ5IHJ1bGUgdHlwZVxcbic7XG4gICAgICBzdHIgKz0gbGVhZGVyO1xuICAgICAgc3RyICs9IHNob3dMZWdlbmQoKTtcbiAgICAgIHN0ciArPSBzaG93KDExNik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnb3JkZXJlZCBieSBydWxlIGluZGV4XFxuJztcbiAgICAgIHN0ciArPSBsZWFkZXI7XG4gICAgICBzdHIgKz0gc2hvd0xlZ2VuZCgpO1xuICAgICAgc3RyICs9IHNob3coKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICAvKiBEZXN0cnVjdHVyaW5nIGFzc2lnbm1lbnQgLSBzZWUgTUROIFdlYiBEb2NzICovXG4gIHJldHVybiB7IHJ1bGVBdHRyaWJ1dGVzLCBzaG93QXR0cmlidXRlcywgc2hvd0F0dHJpYnV0ZUVycm9ycyB9O1xufSkoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-api/rule-attributes.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-api/rule-dependencies.js":
/*!**************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/rule-dependencies.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// Determine rule dependencies and types.\n// For each rule, determine which other rules it refers to\n// and which of the other rules refer back to it.\n//\n// Rule types are:\n//  - non-recursive - the rule never refers to itself, even indirectly\n//  - recursive - the rule refers to itself, possibly indirectly\n//  - mutually-recursive - belongs to a group of two or more rules, each of which refers to every other rule in the group, including itself.\nmodule.exports = (() => {\n  const id = __webpack_require__(/*! ../apg-lib/identifiers */ \"./node_modules/apg-js/src/apg-lib/identifiers.js\");\n  let state = null; /* keep a global reference to the state for the show functions */\n\n  /* scan the opcodes of the indexed rule and discover which rules it references and which rule refer back to it */\n  const scan = (ruleCount, ruleDeps, index, isScanned) => {\n    let i = 0;\n    let j = 0;\n    const rdi = ruleDeps[index];\n    isScanned[index] = true;\n    const op = rdi.rule.opcodes;\n    for (i = 0; i < op.length; i += 1) {\n      const opi = op[i];\n      if (opi.type === id.RNM) {\n        rdi.refersTo[opi.index] = true;\n        if (!isScanned[opi.index]) {\n          scan(ruleCount, ruleDeps, opi.index, isScanned);\n        }\n        for (j = 0; j < ruleCount; j += 1) {\n          if (ruleDeps[opi.index].refersTo[j]) {\n            rdi.refersTo[j] = true;\n          }\n        }\n      } else if (opi.type === id.UDT) {\n        rdi.refersToUdt[opi.index] = true;\n      } else if (opi.type === id.BKR) {\n        if (opi.index < ruleCount) {\n          rdi.refersTo[opi.index] = true;\n          if (!isScanned[opi.index]) {\n            scan(ruleCount, ruleDeps, opi.index, isScanned);\n          }\n        } else {\n          rdi.refersToUdt[ruleCount - opi.index] = true;\n        }\n      }\n    }\n  };\n  // Determine the rule dependencies, types and mutually recursive groups.\n  const ruleDependencies = (stateArg) => {\n    state = stateArg; /* make it global */\n    let i = 0;\n    let j = 0;\n    let groupCount = 0;\n    let rdi = null;\n    let rdj = null;\n    let newGroup = false;\n    state.dependenciesComplete = false;\n\n    /* make a working array of rule scanned markers */\n    const isScanned = state.falseArray(state.ruleCount);\n\n    /* discover the rule dependencies */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      state.falsifyArray(isScanned);\n      scan(state.ruleCount, state.ruleDeps, i, isScanned);\n    }\n    /* discover all rules referencing each rule */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      for (j = 0; j < state.ruleCount; j += 1) {\n        if (i !== j) {\n          if (state.ruleDeps[j].refersTo[i]) {\n            state.ruleDeps[i].referencedBy[j] = true;\n          }\n        }\n      }\n    }\n    /* find the non-recursive and recursive types */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      state.ruleDeps[i].recursiveType = id.ATTR_N;\n      if (state.ruleDeps[i].refersTo[i]) {\n        state.ruleDeps[i].recursiveType = id.ATTR_R;\n      }\n    }\n\n    /* find the mutually-recursive groups, if any */\n    groupCount = -1;\n    for (i = 0; i < state.ruleCount; i += 1) {\n      rdi = state.ruleDeps[i];\n      if (rdi.recursiveType === id.ATTR_R) {\n        newGroup = true;\n        for (j = 0; j < state.ruleCount; j += 1) {\n          if (i !== j) {\n            rdj = state.ruleDeps[j];\n            if (rdj.recursiveType === id.ATTR_R) {\n              if (rdi.refersTo[j] && rdj.refersTo[i]) {\n                if (newGroup) {\n                  groupCount += 1;\n                  rdi.recursiveType = id.ATTR_MR;\n                  rdi.groupNumber = groupCount;\n                  newGroup = false;\n                }\n                rdj.recursiveType = id.ATTR_MR;\n                rdj.groupNumber = groupCount;\n              }\n            }\n          }\n        }\n      }\n    }\n    state.isMutuallyRecursive = groupCount > -1;\n\n    /* sort the rules/UDTS */\n    state.ruleAlphaIndexes.sort(state.compRulesAlpha);\n    state.ruleTypeIndexes.sort(state.compRulesAlpha);\n    state.ruleTypeIndexes.sort(state.compRulesType);\n    if (state.isMutuallyRecursive) {\n      state.ruleTypeIndexes.sort(state.compRulesGroup);\n    }\n    if (state.udtCount) {\n      state.udtAlphaIndexes.sort(state.compUdtsAlpha);\n    }\n\n    state.dependenciesComplete = true;\n  };\n  const show = (type = null) => {\n    let i = 0;\n    let j = 0;\n    let count = 0;\n    let startSeg = 0;\n    const maxRule = state.ruleCount - 1;\n    const maxUdt = state.udtCount - 1;\n    const lineLength = 100;\n    let str = '';\n    let pre = '';\n    const toArrow = '=> ';\n    const byArrow = '<= ';\n    let first = false;\n    let rdi = null;\n    let { ruleIndexes } = state;\n    let { udtIndexes } = state;\n    if (type === 97) {\n      ruleIndexes = state.ruleAlphaIndexes;\n      udtIndexes = state.udtAlphaIndexes;\n    } else if (type === 116) {\n      ruleIndexes = state.ruleTypeIndexes;\n      udtIndexes = state.udtAlphaIndexes;\n    }\n    for (i = 0; i < state.ruleCount; i += 1) {\n      rdi = state.ruleDeps[ruleIndexes[i]];\n      pre = `${ruleIndexes[i]}:${state.typeToString(rdi.recursiveType)}:`;\n      if (state.isMutuallyRecursive) {\n        pre += rdi.groupNumber > -1 ? rdi.groupNumber : '-';\n        pre += ':';\n      }\n      pre += ' ';\n      str += `${pre + state.rules[ruleIndexes[i]].name}\\n`;\n      first = true;\n      count = 0;\n      startSeg = str.length;\n      str += pre;\n      for (j = 0; j < state.ruleCount; j += 1) {\n        if (rdi.refersTo[ruleIndexes[j]]) {\n          if (first) {\n            str += toArrow;\n            first = false;\n            str += state.ruleDeps[ruleIndexes[j]].rule.name;\n          } else {\n            str += `, ${state.ruleDeps[ruleIndexes[j]].rule.name}`;\n          }\n          count += 1;\n        }\n        if (str.length - startSeg > lineLength && j !== maxRule) {\n          str += `\\n${pre}${toArrow}`;\n          startSeg = str.length;\n        }\n      }\n      if (state.udtCount) {\n        for (j = 0; j < state.udtCount; j += 1) {\n          if (rdi.refersToUdt[udtIndexes[j]]) {\n            if (first) {\n              str += toArrow;\n              first = false;\n              str += state.udts[udtIndexes[j]].name;\n            } else {\n              str += `, ${state.udts[udtIndexes[j]].name}`;\n            }\n            count += 1;\n          }\n          if (str.length - startSeg > lineLength && j !== maxUdt) {\n            str += `\\n${pre}${toArrow}`;\n            startSeg = str.length;\n          }\n        }\n      }\n      if (count === 0) {\n        str += '=> <none>\\n';\n      }\n      if (first === false) {\n        str += '\\n';\n      }\n      first = true;\n      count = 0;\n      startSeg = str.length;\n      str += pre;\n      for (j = 0; j < state.ruleCount; j += 1) {\n        if (rdi.referencedBy[ruleIndexes[j]]) {\n          if (first) {\n            str += byArrow;\n            first = false;\n            str += state.ruleDeps[ruleIndexes[j]].rule.name;\n          } else {\n            str += `, ${state.ruleDeps[ruleIndexes[j]].rule.name}`;\n          }\n          count += 1;\n        }\n        if (str.length - startSeg > lineLength && j !== maxRule) {\n          str += `\\n${pre}${toArrow}`;\n          startSeg = str.length;\n        }\n      }\n      if (count === 0) {\n        str += '<= <none>\\n';\n      }\n      if (first === false) {\n        str += '\\n';\n      }\n      str += '\\n';\n    }\n    return str;\n  };\n  // Display the rule dependencies.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, index order (default)\n  const showRuleDependencies = (order = 'index') => {\n    let str = 'RULE DEPENDENCIES(index:type:[group number:])\\n';\n    str += '=> refers to rule names\\n';\n    str += '<= referenced by rule names\\n';\n    if (!state.dependenciesComplete) {\n      return str;\n    }\n\n    if (order.charCodeAt(0) === 97) {\n      str += 'alphabetical by rule name\\n';\n      str += show(97);\n    } else if (order.charCodeAt(0) === 116) {\n      str += 'ordered by rule type\\n';\n      str += show(116);\n    } else {\n      str += 'ordered by rule index\\n';\n      str += show(null);\n    }\n    return str;\n  };\n\n  /* Destructuring assignment - see MDN Web Docs */\n  return { ruleDependencies, showRuleDependencies };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3J1bGUtZGVwZW5kZW5jaWVzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLGdGQUF3QjtBQUM3QyxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEIsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0EsZUFBZSxlQUFlLEdBQUcsc0NBQXNDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHdCQUF3Qix5Q0FBeUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSSxFQUFFLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsMEJBQTBCLCtCQUErQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixJQUFJLEVBQUUsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHdCQUF3Qix5Q0FBeUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSSxFQUFFLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWFwaS9ydWxlLWRlcGVuZGVuY2llcy5qcz9mYjNlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIERldGVybWluZSBydWxlIGRlcGVuZGVuY2llcyBhbmQgdHlwZXMuXG4vLyBGb3IgZWFjaCBydWxlLCBkZXRlcm1pbmUgd2hpY2ggb3RoZXIgcnVsZXMgaXQgcmVmZXJzIHRvXG4vLyBhbmQgd2hpY2ggb2YgdGhlIG90aGVyIHJ1bGVzIHJlZmVyIGJhY2sgdG8gaXQuXG4vL1xuLy8gUnVsZSB0eXBlcyBhcmU6XG4vLyAgLSBub24tcmVjdXJzaXZlIC0gdGhlIHJ1bGUgbmV2ZXIgcmVmZXJzIHRvIGl0c2VsZiwgZXZlbiBpbmRpcmVjdGx5XG4vLyAgLSByZWN1cnNpdmUgLSB0aGUgcnVsZSByZWZlcnMgdG8gaXRzZWxmLCBwb3NzaWJseSBpbmRpcmVjdGx5XG4vLyAgLSBtdXR1YWxseS1yZWN1cnNpdmUgLSBiZWxvbmdzIHRvIGEgZ3JvdXAgb2YgdHdvIG9yIG1vcmUgcnVsZXMsIGVhY2ggb2Ygd2hpY2ggcmVmZXJzIHRvIGV2ZXJ5IG90aGVyIHJ1bGUgaW4gdGhlIGdyb3VwLCBpbmNsdWRpbmcgaXRzZWxmLlxubW9kdWxlLmV4cG9ydHMgPSAoKCkgPT4ge1xuICBjb25zdCBpZCA9IHJlcXVpcmUoJy4uL2FwZy1saWIvaWRlbnRpZmllcnMnKTtcbiAgbGV0IHN0YXRlID0gbnVsbDsgLyoga2VlcCBhIGdsb2JhbCByZWZlcmVuY2UgdG8gdGhlIHN0YXRlIGZvciB0aGUgc2hvdyBmdW5jdGlvbnMgKi9cblxuICAvKiBzY2FuIHRoZSBvcGNvZGVzIG9mIHRoZSBpbmRleGVkIHJ1bGUgYW5kIGRpc2NvdmVyIHdoaWNoIHJ1bGVzIGl0IHJlZmVyZW5jZXMgYW5kIHdoaWNoIHJ1bGUgcmVmZXIgYmFjayB0byBpdCAqL1xuICBjb25zdCBzY2FuID0gKHJ1bGVDb3VudCwgcnVsZURlcHMsIGluZGV4LCBpc1NjYW5uZWQpID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGogPSAwO1xuICAgIGNvbnN0IHJkaSA9IHJ1bGVEZXBzW2luZGV4XTtcbiAgICBpc1NjYW5uZWRbaW5kZXhdID0gdHJ1ZTtcbiAgICBjb25zdCBvcCA9IHJkaS5ydWxlLm9wY29kZXM7XG4gICAgZm9yIChpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBvcGkgPSBvcFtpXTtcbiAgICAgIGlmIChvcGkudHlwZSA9PT0gaWQuUk5NKSB7XG4gICAgICAgIHJkaS5yZWZlcnNUb1tvcGkuaW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFpc1NjYW5uZWRbb3BpLmluZGV4XSkge1xuICAgICAgICAgIHNjYW4ocnVsZUNvdW50LCBydWxlRGVwcywgb3BpLmluZGV4LCBpc1NjYW5uZWQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBydWxlQ291bnQ7IGogKz0gMSkge1xuICAgICAgICAgIGlmIChydWxlRGVwc1tvcGkuaW5kZXhdLnJlZmVyc1RvW2pdKSB7XG4gICAgICAgICAgICByZGkucmVmZXJzVG9bal0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvcGkudHlwZSA9PT0gaWQuVURUKSB7XG4gICAgICAgIHJkaS5yZWZlcnNUb1VkdFtvcGkuaW5kZXhdID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAob3BpLnR5cGUgPT09IGlkLkJLUikge1xuICAgICAgICBpZiAob3BpLmluZGV4IDwgcnVsZUNvdW50KSB7XG4gICAgICAgICAgcmRpLnJlZmVyc1RvW29waS5pbmRleF0gPSB0cnVlO1xuICAgICAgICAgIGlmICghaXNTY2FubmVkW29waS5pbmRleF0pIHtcbiAgICAgICAgICAgIHNjYW4ocnVsZUNvdW50LCBydWxlRGVwcywgb3BpLmluZGV4LCBpc1NjYW5uZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZGkucmVmZXJzVG9VZHRbcnVsZUNvdW50IC0gb3BpLmluZGV4XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIERldGVybWluZSB0aGUgcnVsZSBkZXBlbmRlbmNpZXMsIHR5cGVzIGFuZCBtdXR1YWxseSByZWN1cnNpdmUgZ3JvdXBzLlxuICBjb25zdCBydWxlRGVwZW5kZW5jaWVzID0gKHN0YXRlQXJnKSA9PiB7XG4gICAgc3RhdGUgPSBzdGF0ZUFyZzsgLyogbWFrZSBpdCBnbG9iYWwgKi9cbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGogPSAwO1xuICAgIGxldCBncm91cENvdW50ID0gMDtcbiAgICBsZXQgcmRpID0gbnVsbDtcbiAgICBsZXQgcmRqID0gbnVsbDtcbiAgICBsZXQgbmV3R3JvdXAgPSBmYWxzZTtcbiAgICBzdGF0ZS5kZXBlbmRlbmNpZXNDb21wbGV0ZSA9IGZhbHNlO1xuXG4gICAgLyogbWFrZSBhIHdvcmtpbmcgYXJyYXkgb2YgcnVsZSBzY2FubmVkIG1hcmtlcnMgKi9cbiAgICBjb25zdCBpc1NjYW5uZWQgPSBzdGF0ZS5mYWxzZUFycmF5KHN0YXRlLnJ1bGVDb3VudCk7XG5cbiAgICAvKiBkaXNjb3ZlciB0aGUgcnVsZSBkZXBlbmRlbmNpZXMgKi9cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhdGUucnVsZUNvdW50OyBpICs9IDEpIHtcbiAgICAgIHN0YXRlLmZhbHNpZnlBcnJheShpc1NjYW5uZWQpO1xuICAgICAgc2NhbihzdGF0ZS5ydWxlQ291bnQsIHN0YXRlLnJ1bGVEZXBzLCBpLCBpc1NjYW5uZWQpO1xuICAgIH1cbiAgICAvKiBkaXNjb3ZlciBhbGwgcnVsZXMgcmVmZXJlbmNpbmcgZWFjaCBydWxlICovXG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXRlLnJ1bGVDb3VudDsgaSArPSAxKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgc3RhdGUucnVsZUNvdW50OyBqICs9IDEpIHtcbiAgICAgICAgaWYgKGkgIT09IGopIHtcbiAgICAgICAgICBpZiAoc3RhdGUucnVsZURlcHNbal0ucmVmZXJzVG9baV0pIHtcbiAgICAgICAgICAgIHN0YXRlLnJ1bGVEZXBzW2ldLnJlZmVyZW5jZWRCeVtqXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIGZpbmQgdGhlIG5vbi1yZWN1cnNpdmUgYW5kIHJlY3Vyc2l2ZSB0eXBlcyAqL1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGF0ZS5ydWxlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgc3RhdGUucnVsZURlcHNbaV0ucmVjdXJzaXZlVHlwZSA9IGlkLkFUVFJfTjtcbiAgICAgIGlmIChzdGF0ZS5ydWxlRGVwc1tpXS5yZWZlcnNUb1tpXSkge1xuICAgICAgICBzdGF0ZS5ydWxlRGVwc1tpXS5yZWN1cnNpdmVUeXBlID0gaWQuQVRUUl9SO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIGZpbmQgdGhlIG11dHVhbGx5LXJlY3Vyc2l2ZSBncm91cHMsIGlmIGFueSAqL1xuICAgIGdyb3VwQ291bnQgPSAtMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhdGUucnVsZUNvdW50OyBpICs9IDEpIHtcbiAgICAgIHJkaSA9IHN0YXRlLnJ1bGVEZXBzW2ldO1xuICAgICAgaWYgKHJkaS5yZWN1cnNpdmVUeXBlID09PSBpZC5BVFRSX1IpIHtcbiAgICAgICAgbmV3R3JvdXAgPSB0cnVlO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgc3RhdGUucnVsZUNvdW50OyBqICs9IDEpIHtcbiAgICAgICAgICBpZiAoaSAhPT0gaikge1xuICAgICAgICAgICAgcmRqID0gc3RhdGUucnVsZURlcHNbal07XG4gICAgICAgICAgICBpZiAocmRqLnJlY3Vyc2l2ZVR5cGUgPT09IGlkLkFUVFJfUikge1xuICAgICAgICAgICAgICBpZiAocmRpLnJlZmVyc1RvW2pdICYmIHJkai5yZWZlcnNUb1tpXSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdHcm91cCkge1xuICAgICAgICAgICAgICAgICAgZ3JvdXBDb3VudCArPSAxO1xuICAgICAgICAgICAgICAgICAgcmRpLnJlY3Vyc2l2ZVR5cGUgPSBpZC5BVFRSX01SO1xuICAgICAgICAgICAgICAgICAgcmRpLmdyb3VwTnVtYmVyID0gZ3JvdXBDb3VudDtcbiAgICAgICAgICAgICAgICAgIG5ld0dyb3VwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJkai5yZWN1cnNpdmVUeXBlID0gaWQuQVRUUl9NUjtcbiAgICAgICAgICAgICAgICByZGouZ3JvdXBOdW1iZXIgPSBncm91cENvdW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLmlzTXV0dWFsbHlSZWN1cnNpdmUgPSBncm91cENvdW50ID4gLTE7XG5cbiAgICAvKiBzb3J0IHRoZSBydWxlcy9VRFRTICovXG4gICAgc3RhdGUucnVsZUFscGhhSW5kZXhlcy5zb3J0KHN0YXRlLmNvbXBSdWxlc0FscGhhKTtcbiAgICBzdGF0ZS5ydWxlVHlwZUluZGV4ZXMuc29ydChzdGF0ZS5jb21wUnVsZXNBbHBoYSk7XG4gICAgc3RhdGUucnVsZVR5cGVJbmRleGVzLnNvcnQoc3RhdGUuY29tcFJ1bGVzVHlwZSk7XG4gICAgaWYgKHN0YXRlLmlzTXV0dWFsbHlSZWN1cnNpdmUpIHtcbiAgICAgIHN0YXRlLnJ1bGVUeXBlSW5kZXhlcy5zb3J0KHN0YXRlLmNvbXBSdWxlc0dyb3VwKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnVkdENvdW50KSB7XG4gICAgICBzdGF0ZS51ZHRBbHBoYUluZGV4ZXMuc29ydChzdGF0ZS5jb21wVWR0c0FscGhhKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5kZXBlbmRlbmNpZXNDb21wbGV0ZSA9IHRydWU7XG4gIH07XG4gIGNvbnN0IHNob3cgPSAodHlwZSA9IG51bGwpID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGogPSAwO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgbGV0IHN0YXJ0U2VnID0gMDtcbiAgICBjb25zdCBtYXhSdWxlID0gc3RhdGUucnVsZUNvdW50IC0gMTtcbiAgICBjb25zdCBtYXhVZHQgPSBzdGF0ZS51ZHRDb3VudCAtIDE7XG4gICAgY29uc3QgbGluZUxlbmd0aCA9IDEwMDtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgbGV0IHByZSA9ICcnO1xuICAgIGNvbnN0IHRvQXJyb3cgPSAnPT4gJztcbiAgICBjb25zdCBieUFycm93ID0gJzw9ICc7XG4gICAgbGV0IGZpcnN0ID0gZmFsc2U7XG4gICAgbGV0IHJkaSA9IG51bGw7XG4gICAgbGV0IHsgcnVsZUluZGV4ZXMgfSA9IHN0YXRlO1xuICAgIGxldCB7IHVkdEluZGV4ZXMgfSA9IHN0YXRlO1xuICAgIGlmICh0eXBlID09PSA5Nykge1xuICAgICAgcnVsZUluZGV4ZXMgPSBzdGF0ZS5ydWxlQWxwaGFJbmRleGVzO1xuICAgICAgdWR0SW5kZXhlcyA9IHN0YXRlLnVkdEFscGhhSW5kZXhlcztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDExNikge1xuICAgICAgcnVsZUluZGV4ZXMgPSBzdGF0ZS5ydWxlVHlwZUluZGV4ZXM7XG4gICAgICB1ZHRJbmRleGVzID0gc3RhdGUudWR0QWxwaGFJbmRleGVzO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhdGUucnVsZUNvdW50OyBpICs9IDEpIHtcbiAgICAgIHJkaSA9IHN0YXRlLnJ1bGVEZXBzW3J1bGVJbmRleGVzW2ldXTtcbiAgICAgIHByZSA9IGAke3J1bGVJbmRleGVzW2ldfToke3N0YXRlLnR5cGVUb1N0cmluZyhyZGkucmVjdXJzaXZlVHlwZSl9OmA7XG4gICAgICBpZiAoc3RhdGUuaXNNdXR1YWxseVJlY3Vyc2l2ZSkge1xuICAgICAgICBwcmUgKz0gcmRpLmdyb3VwTnVtYmVyID4gLTEgPyByZGkuZ3JvdXBOdW1iZXIgOiAnLSc7XG4gICAgICAgIHByZSArPSAnOic7XG4gICAgICB9XG4gICAgICBwcmUgKz0gJyAnO1xuICAgICAgc3RyICs9IGAke3ByZSArIHN0YXRlLnJ1bGVzW3J1bGVJbmRleGVzW2ldXS5uYW1lfVxcbmA7XG4gICAgICBmaXJzdCA9IHRydWU7XG4gICAgICBjb3VudCA9IDA7XG4gICAgICBzdGFydFNlZyA9IHN0ci5sZW5ndGg7XG4gICAgICBzdHIgKz0gcHJlO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHN0YXRlLnJ1bGVDb3VudDsgaiArPSAxKSB7XG4gICAgICAgIGlmIChyZGkucmVmZXJzVG9bcnVsZUluZGV4ZXNbal1dKSB7XG4gICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICBzdHIgKz0gdG9BcnJvdztcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICBzdHIgKz0gc3RhdGUucnVsZURlcHNbcnVsZUluZGV4ZXNbal1dLnJ1bGUubmFtZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyICs9IGAsICR7c3RhdGUucnVsZURlcHNbcnVsZUluZGV4ZXNbal1dLnJ1bGUubmFtZX1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHIubGVuZ3RoIC0gc3RhcnRTZWcgPiBsaW5lTGVuZ3RoICYmIGogIT09IG1heFJ1bGUpIHtcbiAgICAgICAgICBzdHIgKz0gYFxcbiR7cHJlfSR7dG9BcnJvd31gO1xuICAgICAgICAgIHN0YXJ0U2VnID0gc3RyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnVkdENvdW50KSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBzdGF0ZS51ZHRDb3VudDsgaiArPSAxKSB7XG4gICAgICAgICAgaWYgKHJkaS5yZWZlcnNUb1VkdFt1ZHRJbmRleGVzW2pdXSkge1xuICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgIHN0ciArPSB0b0Fycm93O1xuICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICBzdHIgKz0gc3RhdGUudWR0c1t1ZHRJbmRleGVzW2pdXS5uYW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyICs9IGAsICR7c3RhdGUudWR0c1t1ZHRJbmRleGVzW2pdXS5uYW1lfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyLmxlbmd0aCAtIHN0YXJ0U2VnID4gbGluZUxlbmd0aCAmJiBqICE9PSBtYXhVZHQpIHtcbiAgICAgICAgICAgIHN0ciArPSBgXFxuJHtwcmV9JHt0b0Fycm93fWA7XG4gICAgICAgICAgICBzdGFydFNlZyA9IHN0ci5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgc3RyICs9ICc9PiA8bm9uZT5cXG4nO1xuICAgICAgfVxuICAgICAgaWYgKGZpcnN0ID09PSBmYWxzZSkge1xuICAgICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICB9XG4gICAgICBmaXJzdCA9IHRydWU7XG4gICAgICBjb3VudCA9IDA7XG4gICAgICBzdGFydFNlZyA9IHN0ci5sZW5ndGg7XG4gICAgICBzdHIgKz0gcHJlO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHN0YXRlLnJ1bGVDb3VudDsgaiArPSAxKSB7XG4gICAgICAgIGlmIChyZGkucmVmZXJlbmNlZEJ5W3J1bGVJbmRleGVzW2pdXSkge1xuICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgc3RyICs9IGJ5QXJyb3c7XG4gICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgc3RyICs9IHN0YXRlLnJ1bGVEZXBzW3J1bGVJbmRleGVzW2pdXS5ydWxlLm5hbWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciArPSBgLCAke3N0YXRlLnJ1bGVEZXBzW3J1bGVJbmRleGVzW2pdXS5ydWxlLm5hbWV9YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyLmxlbmd0aCAtIHN0YXJ0U2VnID4gbGluZUxlbmd0aCAmJiBqICE9PSBtYXhSdWxlKSB7XG4gICAgICAgICAgc3RyICs9IGBcXG4ke3ByZX0ke3RvQXJyb3d9YDtcbiAgICAgICAgICBzdGFydFNlZyA9IHN0ci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICBzdHIgKz0gJzw9IDxub25lPlxcbic7XG4gICAgICB9XG4gICAgICBpZiAoZmlyc3QgPT09IGZhbHNlKSB7XG4gICAgICAgIHN0ciArPSAnXFxuJztcbiAgICAgIH1cbiAgICAgIHN0ciArPSAnXFxuJztcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcbiAgLy8gRGlzcGxheSB0aGUgcnVsZSBkZXBlbmRlbmNpZXMuXG4gIC8vIC0gb3JkZXJcbiAgLy8gICAgICAtIFwiaW5kZXhcIiBvciBcImlcIiwgaW5kZXggb3JkZXIgKGRlZmF1bHQpXG4gIC8vICAgICAgLSBcImFscGhhXCIgb3IgXCJhXCIsIGFscGhhYmV0aWNhbCBvcmRlclxuICAvLyAgICAgIC0gXCJ0eXBlXCIgb3IgXCJ0XCIsIG9yZGVyZWQgYnkgdHlwZSAoYWxwaGFiZXRpY2FsIHdpdGhpbiBlYWNoIHR5cGUvZ3JvdXApXG4gIC8vICAgICAgLSBub25lIG9mIGFib3ZlLCBpbmRleCBvcmRlciAoZGVmYXVsdClcbiAgY29uc3Qgc2hvd1J1bGVEZXBlbmRlbmNpZXMgPSAob3JkZXIgPSAnaW5kZXgnKSA9PiB7XG4gICAgbGV0IHN0ciA9ICdSVUxFIERFUEVOREVOQ0lFUyhpbmRleDp0eXBlOltncm91cCBudW1iZXI6XSlcXG4nO1xuICAgIHN0ciArPSAnPT4gcmVmZXJzIHRvIHJ1bGUgbmFtZXNcXG4nO1xuICAgIHN0ciArPSAnPD0gcmVmZXJlbmNlZCBieSBydWxlIG5hbWVzXFxuJztcbiAgICBpZiAoIXN0YXRlLmRlcGVuZGVuY2llc0NvbXBsZXRlKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIGlmIChvcmRlci5jaGFyQ29kZUF0KDApID09PSA5Nykge1xuICAgICAgc3RyICs9ICdhbHBoYWJldGljYWwgYnkgcnVsZSBuYW1lXFxuJztcbiAgICAgIHN0ciArPSBzaG93KDk3KTtcbiAgICB9IGVsc2UgaWYgKG9yZGVyLmNoYXJDb2RlQXQoMCkgPT09IDExNikge1xuICAgICAgc3RyICs9ICdvcmRlcmVkIGJ5IHJ1bGUgdHlwZVxcbic7XG4gICAgICBzdHIgKz0gc2hvdygxMTYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJ29yZGVyZWQgYnkgcnVsZSBpbmRleFxcbic7XG4gICAgICBzdHIgKz0gc2hvdyhudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICAvKiBEZXN0cnVjdHVyaW5nIGFzc2lnbm1lbnQgLSBzZWUgTUROIFdlYiBEb2NzICovXG4gIHJldHVybiB7IHJ1bGVEZXBlbmRlbmNpZXMsIHNob3dSdWxlRGVwZW5kZW5jaWVzIH07XG59KSgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-api/rule-dependencies.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-api/sabnf-grammar.js":
/*!**********************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/sabnf-grammar.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved<br>\n//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\n//\n// Generated by apg-js, Version 4.0.0 [apg-js](https://github.com/ldthomas/apg-js)\nmodule.exports = function grammar(){\n  // ```\n  // SUMMARY\n  //      rules = 95\n  //       udts = 0\n  //    opcodes = 372\n  //        ---   ABNF original opcodes\n  //        ALT = 43\n  //        CAT = 48\n  //        REP = 34\n  //        RNM = 149\n  //        TLS = 2\n  //        TBS = 61\n  //        TRG = 35\n  //        ---   SABNF superset opcodes\n  //        UDT = 0\n  //        AND = 0\n  //        NOT = 0\n  //        BKA = 0\n  //        BKN = 0\n  //        BKR = 0\n  //        ABG = 0\n  //        AEN = 0\n  // characters = [9 - 126]\n  // ```\n  /* OBJECT IDENTIFIER (for internal parser use) */\n  this.grammarObject = 'grammarObject';\n\n  /* RULES */\n  this.rules = [];\n  this.rules[0] = {name: 'File', lower: 'file', index: 0, isBkr: false};\n  this.rules[1] = {name: 'BlankLine', lower: 'blankline', index: 1, isBkr: false};\n  this.rules[2] = {name: 'Rule', lower: 'rule', index: 2, isBkr: false};\n  this.rules[3] = {name: 'RuleLookup', lower: 'rulelookup', index: 3, isBkr: false};\n  this.rules[4] = {name: 'RuleNameTest', lower: 'rulenametest', index: 4, isBkr: false};\n  this.rules[5] = {name: 'RuleName', lower: 'rulename', index: 5, isBkr: false};\n  this.rules[6] = {name: 'RuleNameError', lower: 'rulenameerror', index: 6, isBkr: false};\n  this.rules[7] = {name: 'DefinedAsTest', lower: 'definedastest', index: 7, isBkr: false};\n  this.rules[8] = {name: 'DefinedAsError', lower: 'definedaserror', index: 8, isBkr: false};\n  this.rules[9] = {name: 'DefinedAs', lower: 'definedas', index: 9, isBkr: false};\n  this.rules[10] = {name: 'Defined', lower: 'defined', index: 10, isBkr: false};\n  this.rules[11] = {name: 'IncAlt', lower: 'incalt', index: 11, isBkr: false};\n  this.rules[12] = {name: 'RuleError', lower: 'ruleerror', index: 12, isBkr: false};\n  this.rules[13] = {name: 'LineEndError', lower: 'lineenderror', index: 13, isBkr: false};\n  this.rules[14] = {name: 'Alternation', lower: 'alternation', index: 14, isBkr: false};\n  this.rules[15] = {name: 'Concatenation', lower: 'concatenation', index: 15, isBkr: false};\n  this.rules[16] = {name: 'Repetition', lower: 'repetition', index: 16, isBkr: false};\n  this.rules[17] = {name: 'Modifier', lower: 'modifier', index: 17, isBkr: false};\n  this.rules[18] = {name: 'Predicate', lower: 'predicate', index: 18, isBkr: false};\n  this.rules[19] = {name: 'BasicElement', lower: 'basicelement', index: 19, isBkr: false};\n  this.rules[20] = {name: 'BasicElementErr', lower: 'basicelementerr', index: 20, isBkr: false};\n  this.rules[21] = {name: 'Group', lower: 'group', index: 21, isBkr: false};\n  this.rules[22] = {name: 'GroupError', lower: 'grouperror', index: 22, isBkr: false};\n  this.rules[23] = {name: 'GroupOpen', lower: 'groupopen', index: 23, isBkr: false};\n  this.rules[24] = {name: 'GroupClose', lower: 'groupclose', index: 24, isBkr: false};\n  this.rules[25] = {name: 'Option', lower: 'option', index: 25, isBkr: false};\n  this.rules[26] = {name: 'OptionError', lower: 'optionerror', index: 26, isBkr: false};\n  this.rules[27] = {name: 'OptionOpen', lower: 'optionopen', index: 27, isBkr: false};\n  this.rules[28] = {name: 'OptionClose', lower: 'optionclose', index: 28, isBkr: false};\n  this.rules[29] = {name: 'RnmOp', lower: 'rnmop', index: 29, isBkr: false};\n  this.rules[30] = {name: 'BkrOp', lower: 'bkrop', index: 30, isBkr: false};\n  this.rules[31] = {name: 'bkrModifier', lower: 'bkrmodifier', index: 31, isBkr: false};\n  this.rules[32] = {name: 'cs', lower: 'cs', index: 32, isBkr: false};\n  this.rules[33] = {name: 'ci', lower: 'ci', index: 33, isBkr: false};\n  this.rules[34] = {name: 'um', lower: 'um', index: 34, isBkr: false};\n  this.rules[35] = {name: 'pm', lower: 'pm', index: 35, isBkr: false};\n  this.rules[36] = {name: 'bkr-name', lower: 'bkr-name', index: 36, isBkr: false};\n  this.rules[37] = {name: 'rname', lower: 'rname', index: 37, isBkr: false};\n  this.rules[38] = {name: 'uname', lower: 'uname', index: 38, isBkr: false};\n  this.rules[39] = {name: 'ename', lower: 'ename', index: 39, isBkr: false};\n  this.rules[40] = {name: 'UdtOp', lower: 'udtop', index: 40, isBkr: false};\n  this.rules[41] = {name: 'udt-non-empty', lower: 'udt-non-empty', index: 41, isBkr: false};\n  this.rules[42] = {name: 'udt-empty', lower: 'udt-empty', index: 42, isBkr: false};\n  this.rules[43] = {name: 'RepOp', lower: 'repop', index: 43, isBkr: false};\n  this.rules[44] = {name: 'AltOp', lower: 'altop', index: 44, isBkr: false};\n  this.rules[45] = {name: 'CatOp', lower: 'catop', index: 45, isBkr: false};\n  this.rules[46] = {name: 'StarOp', lower: 'starop', index: 46, isBkr: false};\n  this.rules[47] = {name: 'AndOp', lower: 'andop', index: 47, isBkr: false};\n  this.rules[48] = {name: 'NotOp', lower: 'notop', index: 48, isBkr: false};\n  this.rules[49] = {name: 'BkaOp', lower: 'bkaop', index: 49, isBkr: false};\n  this.rules[50] = {name: 'BknOp', lower: 'bknop', index: 50, isBkr: false};\n  this.rules[51] = {name: 'AbgOp', lower: 'abgop', index: 51, isBkr: false};\n  this.rules[52] = {name: 'AenOp', lower: 'aenop', index: 52, isBkr: false};\n  this.rules[53] = {name: 'TrgOp', lower: 'trgop', index: 53, isBkr: false};\n  this.rules[54] = {name: 'TbsOp', lower: 'tbsop', index: 54, isBkr: false};\n  this.rules[55] = {name: 'TlsOp', lower: 'tlsop', index: 55, isBkr: false};\n  this.rules[56] = {name: 'TlsCase', lower: 'tlscase', index: 56, isBkr: false};\n  this.rules[57] = {name: 'TlsOpen', lower: 'tlsopen', index: 57, isBkr: false};\n  this.rules[58] = {name: 'TlsClose', lower: 'tlsclose', index: 58, isBkr: false};\n  this.rules[59] = {name: 'TlsString', lower: 'tlsstring', index: 59, isBkr: false};\n  this.rules[60] = {name: 'StringTab', lower: 'stringtab', index: 60, isBkr: false};\n  this.rules[61] = {name: 'ClsOp', lower: 'clsop', index: 61, isBkr: false};\n  this.rules[62] = {name: 'ClsOpen', lower: 'clsopen', index: 62, isBkr: false};\n  this.rules[63] = {name: 'ClsClose', lower: 'clsclose', index: 63, isBkr: false};\n  this.rules[64] = {name: 'ClsString', lower: 'clsstring', index: 64, isBkr: false};\n  this.rules[65] = {name: 'ProsVal', lower: 'prosval', index: 65, isBkr: false};\n  this.rules[66] = {name: 'ProsValOpen', lower: 'prosvalopen', index: 66, isBkr: false};\n  this.rules[67] = {name: 'ProsValString', lower: 'prosvalstring', index: 67, isBkr: false};\n  this.rules[68] = {name: 'ProsValClose', lower: 'prosvalclose', index: 68, isBkr: false};\n  this.rules[69] = {name: 'rep-min', lower: 'rep-min', index: 69, isBkr: false};\n  this.rules[70] = {name: 'rep-min-max', lower: 'rep-min-max', index: 70, isBkr: false};\n  this.rules[71] = {name: 'rep-max', lower: 'rep-max', index: 71, isBkr: false};\n  this.rules[72] = {name: 'rep-num', lower: 'rep-num', index: 72, isBkr: false};\n  this.rules[73] = {name: 'dString', lower: 'dstring', index: 73, isBkr: false};\n  this.rules[74] = {name: 'xString', lower: 'xstring', index: 74, isBkr: false};\n  this.rules[75] = {name: 'bString', lower: 'bstring', index: 75, isBkr: false};\n  this.rules[76] = {name: 'Dec', lower: 'dec', index: 76, isBkr: false};\n  this.rules[77] = {name: 'Hex', lower: 'hex', index: 77, isBkr: false};\n  this.rules[78] = {name: 'Bin', lower: 'bin', index: 78, isBkr: false};\n  this.rules[79] = {name: 'dmin', lower: 'dmin', index: 79, isBkr: false};\n  this.rules[80] = {name: 'dmax', lower: 'dmax', index: 80, isBkr: false};\n  this.rules[81] = {name: 'bmin', lower: 'bmin', index: 81, isBkr: false};\n  this.rules[82] = {name: 'bmax', lower: 'bmax', index: 82, isBkr: false};\n  this.rules[83] = {name: 'xmin', lower: 'xmin', index: 83, isBkr: false};\n  this.rules[84] = {name: 'xmax', lower: 'xmax', index: 84, isBkr: false};\n  this.rules[85] = {name: 'dnum', lower: 'dnum', index: 85, isBkr: false};\n  this.rules[86] = {name: 'bnum', lower: 'bnum', index: 86, isBkr: false};\n  this.rules[87] = {name: 'xnum', lower: 'xnum', index: 87, isBkr: false};\n  this.rules[88] = {name: 'alphanum', lower: 'alphanum', index: 88, isBkr: false};\n  this.rules[89] = {name: 'owsp', lower: 'owsp', index: 89, isBkr: false};\n  this.rules[90] = {name: 'wsp', lower: 'wsp', index: 90, isBkr: false};\n  this.rules[91] = {name: 'space', lower: 'space', index: 91, isBkr: false};\n  this.rules[92] = {name: 'comment', lower: 'comment', index: 92, isBkr: false};\n  this.rules[93] = {name: 'LineEnd', lower: 'lineend', index: 93, isBkr: false};\n  this.rules[94] = {name: 'LineContinue', lower: 'linecontinue', index: 94, isBkr: false};\n\n  /* UDTS */\n  this.udts = [];\n\n  /* OPCODES */\n  /* File */\n  this.rules[0].opcodes = [];\n  this.rules[0].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[0].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[0].opcodes[2] = {type: 4, index: 1};// RNM(BlankLine)\n  this.rules[0].opcodes[3] = {type: 4, index: 2};// RNM(Rule)\n  this.rules[0].opcodes[4] = {type: 4, index: 12};// RNM(RuleError)\n\n  /* BlankLine */\n  this.rules[1].opcodes = [];\n  this.rules[1].opcodes[0] = {type: 2, children: [1,5,7]};// CAT\n  this.rules[1].opcodes[1] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[1].opcodes[2] = {type: 1, children: [3,4]};// ALT\n  this.rules[1].opcodes[3] = {type: 6, string: [32]};// TBS\n  this.rules[1].opcodes[4] = {type: 6, string: [9]};// TBS\n  this.rules[1].opcodes[5] = {type: 3, min: 0, max: 1};// REP\n  this.rules[1].opcodes[6] = {type: 4, index: 92};// RNM(comment)\n  this.rules[1].opcodes[7] = {type: 4, index: 93};// RNM(LineEnd)\n\n  /* Rule */\n  this.rules[2].opcodes = [];\n  this.rules[2].opcodes[0] = {type: 2, children: [1,2,3,4]};// CAT\n  this.rules[2].opcodes[1] = {type: 4, index: 3};// RNM(RuleLookup)\n  this.rules[2].opcodes[2] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[2].opcodes[3] = {type: 4, index: 14};// RNM(Alternation)\n  this.rules[2].opcodes[4] = {type: 1, children: [5,8]};// ALT\n  this.rules[2].opcodes[5] = {type: 2, children: [6,7]};// CAT\n  this.rules[2].opcodes[6] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[2].opcodes[7] = {type: 4, index: 93};// RNM(LineEnd)\n  this.rules[2].opcodes[8] = {type: 2, children: [9,10]};// CAT\n  this.rules[2].opcodes[9] = {type: 4, index: 13};// RNM(LineEndError)\n  this.rules[2].opcodes[10] = {type: 4, index: 93};// RNM(LineEnd)\n\n  /* RuleLookup */\n  this.rules[3].opcodes = [];\n  this.rules[3].opcodes[0] = {type: 2, children: [1,2,3]};// CAT\n  this.rules[3].opcodes[1] = {type: 4, index: 4};// RNM(RuleNameTest)\n  this.rules[3].opcodes[2] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[3].opcodes[3] = {type: 4, index: 7};// RNM(DefinedAsTest)\n\n  /* RuleNameTest */\n  this.rules[4].opcodes = [];\n  this.rules[4].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[4].opcodes[1] = {type: 4, index: 5};// RNM(RuleName)\n  this.rules[4].opcodes[2] = {type: 4, index: 6};// RNM(RuleNameError)\n\n  /* RuleName */\n  this.rules[5].opcodes = [];\n  this.rules[5].opcodes[0] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* RuleNameError */\n  this.rules[6].opcodes = [];\n  this.rules[6].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[6].opcodes[1] = {type: 1, children: [2,3]};// ALT\n  this.rules[6].opcodes[2] = {type: 5, min: 33, max: 60};// TRG\n  this.rules[6].opcodes[3] = {type: 5, min: 62, max: 126};// TRG\n\n  /* DefinedAsTest */\n  this.rules[7].opcodes = [];\n  this.rules[7].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[7].opcodes[1] = {type: 4, index: 9};// RNM(DefinedAs)\n  this.rules[7].opcodes[2] = {type: 4, index: 8};// RNM(DefinedAsError)\n\n  /* DefinedAsError */\n  this.rules[8].opcodes = [];\n  this.rules[8].opcodes[0] = {type: 3, min: 1, max: 2};// REP\n  this.rules[8].opcodes[1] = {type: 5, min: 33, max: 126};// TRG\n\n  /* DefinedAs */\n  this.rules[9].opcodes = [];\n  this.rules[9].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[9].opcodes[1] = {type: 4, index: 11};// RNM(IncAlt)\n  this.rules[9].opcodes[2] = {type: 4, index: 10};// RNM(Defined)\n\n  /* Defined */\n  this.rules[10].opcodes = [];\n  this.rules[10].opcodes[0] = {type: 6, string: [61]};// TBS\n\n  /* IncAlt */\n  this.rules[11].opcodes = [];\n  this.rules[11].opcodes[0] = {type: 6, string: [61,47]};// TBS\n\n  /* RuleError */\n  this.rules[12].opcodes = [];\n  this.rules[12].opcodes[0] = {type: 2, children: [1,6]};// CAT\n  this.rules[12].opcodes[1] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[12].opcodes[2] = {type: 1, children: [3,4,5]};// ALT\n  this.rules[12].opcodes[3] = {type: 5, min: 32, max: 126};// TRG\n  this.rules[12].opcodes[4] = {type: 6, string: [9]};// TBS\n  this.rules[12].opcodes[5] = {type: 4, index: 94};// RNM(LineContinue)\n  this.rules[12].opcodes[6] = {type: 4, index: 93};// RNM(LineEnd)\n\n  /* LineEndError */\n  this.rules[13].opcodes = [];\n  this.rules[13].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[13].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[13].opcodes[2] = {type: 5, min: 32, max: 126};// TRG\n  this.rules[13].opcodes[3] = {type: 6, string: [9]};// TBS\n  this.rules[13].opcodes[4] = {type: 4, index: 94};// RNM(LineContinue)\n\n  /* Alternation */\n  this.rules[14].opcodes = [];\n  this.rules[14].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[14].opcodes[1] = {type: 4, index: 15};// RNM(Concatenation)\n  this.rules[14].opcodes[2] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[14].opcodes[3] = {type: 2, children: [4,5,6]};// CAT\n  this.rules[14].opcodes[4] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[14].opcodes[5] = {type: 4, index: 44};// RNM(AltOp)\n  this.rules[14].opcodes[6] = {type: 4, index: 15};// RNM(Concatenation)\n\n  /* Concatenation */\n  this.rules[15].opcodes = [];\n  this.rules[15].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[15].opcodes[1] = {type: 4, index: 16};// RNM(Repetition)\n  this.rules[15].opcodes[2] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[15].opcodes[3] = {type: 2, children: [4,5]};// CAT\n  this.rules[15].opcodes[4] = {type: 4, index: 45};// RNM(CatOp)\n  this.rules[15].opcodes[5] = {type: 4, index: 16};// RNM(Repetition)\n\n  /* Repetition */\n  this.rules[16].opcodes = [];\n  this.rules[16].opcodes[0] = {type: 2, children: [1,3]};// CAT\n  this.rules[16].opcodes[1] = {type: 3, min: 0, max: 1};// REP\n  this.rules[16].opcodes[2] = {type: 4, index: 17};// RNM(Modifier)\n  this.rules[16].opcodes[3] = {type: 1, children: [4,5,6,7]};// ALT\n  this.rules[16].opcodes[4] = {type: 4, index: 21};// RNM(Group)\n  this.rules[16].opcodes[5] = {type: 4, index: 25};// RNM(Option)\n  this.rules[16].opcodes[6] = {type: 4, index: 19};// RNM(BasicElement)\n  this.rules[16].opcodes[7] = {type: 4, index: 20};// RNM(BasicElementErr)\n\n  /* Modifier */\n  this.rules[17].opcodes = [];\n  this.rules[17].opcodes[0] = {type: 1, children: [1,5]};// ALT\n  this.rules[17].opcodes[1] = {type: 2, children: [2,3]};// CAT\n  this.rules[17].opcodes[2] = {type: 4, index: 18};// RNM(Predicate)\n  this.rules[17].opcodes[3] = {type: 3, min: 0, max: 1};// REP\n  this.rules[17].opcodes[4] = {type: 4, index: 43};// RNM(RepOp)\n  this.rules[17].opcodes[5] = {type: 4, index: 43};// RNM(RepOp)\n\n  /* Predicate */\n  this.rules[18].opcodes = [];\n  this.rules[18].opcodes[0] = {type: 1, children: [1,2,3,4]};// ALT\n  this.rules[18].opcodes[1] = {type: 4, index: 49};// RNM(BkaOp)\n  this.rules[18].opcodes[2] = {type: 4, index: 50};// RNM(BknOp)\n  this.rules[18].opcodes[3] = {type: 4, index: 47};// RNM(AndOp)\n  this.rules[18].opcodes[4] = {type: 4, index: 48};// RNM(NotOp)\n\n  /* BasicElement */\n  this.rules[19].opcodes = [];\n  this.rules[19].opcodes[0] = {type: 1, children: [1,2,3,4,5,6,7,8,9,10]};// ALT\n  this.rules[19].opcodes[1] = {type: 4, index: 40};// RNM(UdtOp)\n  this.rules[19].opcodes[2] = {type: 4, index: 29};// RNM(RnmOp)\n  this.rules[19].opcodes[3] = {type: 4, index: 53};// RNM(TrgOp)\n  this.rules[19].opcodes[4] = {type: 4, index: 54};// RNM(TbsOp)\n  this.rules[19].opcodes[5] = {type: 4, index: 55};// RNM(TlsOp)\n  this.rules[19].opcodes[6] = {type: 4, index: 61};// RNM(ClsOp)\n  this.rules[19].opcodes[7] = {type: 4, index: 30};// RNM(BkrOp)\n  this.rules[19].opcodes[8] = {type: 4, index: 51};// RNM(AbgOp)\n  this.rules[19].opcodes[9] = {type: 4, index: 52};// RNM(AenOp)\n  this.rules[19].opcodes[10] = {type: 4, index: 65};// RNM(ProsVal)\n\n  /* BasicElementErr */\n  this.rules[20].opcodes = [];\n  this.rules[20].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[20].opcodes[1] = {type: 1, children: [2,3,4,5]};// ALT\n  this.rules[20].opcodes[2] = {type: 5, min: 33, max: 40};// TRG\n  this.rules[20].opcodes[3] = {type: 5, min: 42, max: 46};// TRG\n  this.rules[20].opcodes[4] = {type: 5, min: 48, max: 92};// TRG\n  this.rules[20].opcodes[5] = {type: 5, min: 94, max: 126};// TRG\n\n  /* Group */\n  this.rules[21].opcodes = [];\n  this.rules[21].opcodes[0] = {type: 2, children: [1,2,3]};// CAT\n  this.rules[21].opcodes[1] = {type: 4, index: 23};// RNM(GroupOpen)\n  this.rules[21].opcodes[2] = {type: 4, index: 14};// RNM(Alternation)\n  this.rules[21].opcodes[3] = {type: 1, children: [4,5]};// ALT\n  this.rules[21].opcodes[4] = {type: 4, index: 24};// RNM(GroupClose)\n  this.rules[21].opcodes[5] = {type: 4, index: 22};// RNM(GroupError)\n\n  /* GroupError */\n  this.rules[22].opcodes = [];\n  this.rules[22].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[22].opcodes[1] = {type: 1, children: [2,3,4,5]};// ALT\n  this.rules[22].opcodes[2] = {type: 5, min: 33, max: 40};// TRG\n  this.rules[22].opcodes[3] = {type: 5, min: 42, max: 46};// TRG\n  this.rules[22].opcodes[4] = {type: 5, min: 48, max: 92};// TRG\n  this.rules[22].opcodes[5] = {type: 5, min: 94, max: 126};// TRG\n\n  /* GroupOpen */\n  this.rules[23].opcodes = [];\n  this.rules[23].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[23].opcodes[1] = {type: 6, string: [40]};// TBS\n  this.rules[23].opcodes[2] = {type: 4, index: 89};// RNM(owsp)\n\n  /* GroupClose */\n  this.rules[24].opcodes = [];\n  this.rules[24].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[24].opcodes[1] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[24].opcodes[2] = {type: 6, string: [41]};// TBS\n\n  /* Option */\n  this.rules[25].opcodes = [];\n  this.rules[25].opcodes[0] = {type: 2, children: [1,2,3]};// CAT\n  this.rules[25].opcodes[1] = {type: 4, index: 27};// RNM(OptionOpen)\n  this.rules[25].opcodes[2] = {type: 4, index: 14};// RNM(Alternation)\n  this.rules[25].opcodes[3] = {type: 1, children: [4,5]};// ALT\n  this.rules[25].opcodes[4] = {type: 4, index: 28};// RNM(OptionClose)\n  this.rules[25].opcodes[5] = {type: 4, index: 26};// RNM(OptionError)\n\n  /* OptionError */\n  this.rules[26].opcodes = [];\n  this.rules[26].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[26].opcodes[1] = {type: 1, children: [2,3,4,5]};// ALT\n  this.rules[26].opcodes[2] = {type: 5, min: 33, max: 40};// TRG\n  this.rules[26].opcodes[3] = {type: 5, min: 42, max: 46};// TRG\n  this.rules[26].opcodes[4] = {type: 5, min: 48, max: 92};// TRG\n  this.rules[26].opcodes[5] = {type: 5, min: 94, max: 126};// TRG\n\n  /* OptionOpen */\n  this.rules[27].opcodes = [];\n  this.rules[27].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[27].opcodes[1] = {type: 6, string: [91]};// TBS\n  this.rules[27].opcodes[2] = {type: 4, index: 89};// RNM(owsp)\n\n  /* OptionClose */\n  this.rules[28].opcodes = [];\n  this.rules[28].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[28].opcodes[1] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[28].opcodes[2] = {type: 6, string: [93]};// TBS\n\n  /* RnmOp */\n  this.rules[29].opcodes = [];\n  this.rules[29].opcodes[0] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* BkrOp */\n  this.rules[30].opcodes = [];\n  this.rules[30].opcodes[0] = {type: 2, children: [1,2,4]};// CAT\n  this.rules[30].opcodes[1] = {type: 6, string: [92]};// TBS\n  this.rules[30].opcodes[2] = {type: 3, min: 0, max: 1};// REP\n  this.rules[30].opcodes[3] = {type: 4, index: 31};// RNM(bkrModifier)\n  this.rules[30].opcodes[4] = {type: 4, index: 36};// RNM(bkr-name)\n\n  /* bkrModifier */\n  this.rules[31].opcodes = [];\n  this.rules[31].opcodes[0] = {type: 1, children: [1,7,13,19]};// ALT\n  this.rules[31].opcodes[1] = {type: 2, children: [2,3]};// CAT\n  this.rules[31].opcodes[2] = {type: 4, index: 32};// RNM(cs)\n  this.rules[31].opcodes[3] = {type: 3, min: 0, max: 1};// REP\n  this.rules[31].opcodes[4] = {type: 1, children: [5,6]};// ALT\n  this.rules[31].opcodes[5] = {type: 4, index: 34};// RNM(um)\n  this.rules[31].opcodes[6] = {type: 4, index: 35};// RNM(pm)\n  this.rules[31].opcodes[7] = {type: 2, children: [8,9]};// CAT\n  this.rules[31].opcodes[8] = {type: 4, index: 33};// RNM(ci)\n  this.rules[31].opcodes[9] = {type: 3, min: 0, max: 1};// REP\n  this.rules[31].opcodes[10] = {type: 1, children: [11,12]};// ALT\n  this.rules[31].opcodes[11] = {type: 4, index: 34};// RNM(um)\n  this.rules[31].opcodes[12] = {type: 4, index: 35};// RNM(pm)\n  this.rules[31].opcodes[13] = {type: 2, children: [14,15]};// CAT\n  this.rules[31].opcodes[14] = {type: 4, index: 34};// RNM(um)\n  this.rules[31].opcodes[15] = {type: 3, min: 0, max: 1};// REP\n  this.rules[31].opcodes[16] = {type: 1, children: [17,18]};// ALT\n  this.rules[31].opcodes[17] = {type: 4, index: 32};// RNM(cs)\n  this.rules[31].opcodes[18] = {type: 4, index: 33};// RNM(ci)\n  this.rules[31].opcodes[19] = {type: 2, children: [20,21]};// CAT\n  this.rules[31].opcodes[20] = {type: 4, index: 35};// RNM(pm)\n  this.rules[31].opcodes[21] = {type: 3, min: 0, max: 1};// REP\n  this.rules[31].opcodes[22] = {type: 1, children: [23,24]};// ALT\n  this.rules[31].opcodes[23] = {type: 4, index: 32};// RNM(cs)\n  this.rules[31].opcodes[24] = {type: 4, index: 33};// RNM(ci)\n\n  /* cs */\n  this.rules[32].opcodes = [];\n  this.rules[32].opcodes[0] = {type: 6, string: [37,115]};// TBS\n\n  /* ci */\n  this.rules[33].opcodes = [];\n  this.rules[33].opcodes[0] = {type: 6, string: [37,105]};// TBS\n\n  /* um */\n  this.rules[34].opcodes = [];\n  this.rules[34].opcodes[0] = {type: 6, string: [37,117]};// TBS\n\n  /* pm */\n  this.rules[35].opcodes = [];\n  this.rules[35].opcodes[0] = {type: 6, string: [37,112]};// TBS\n\n  /* bkr-name */\n  this.rules[36].opcodes = [];\n  this.rules[36].opcodes[0] = {type: 1, children: [1,2,3]};// ALT\n  this.rules[36].opcodes[1] = {type: 4, index: 38};// RNM(uname)\n  this.rules[36].opcodes[2] = {type: 4, index: 39};// RNM(ename)\n  this.rules[36].opcodes[3] = {type: 4, index: 37};// RNM(rname)\n\n  /* rname */\n  this.rules[37].opcodes = [];\n  this.rules[37].opcodes[0] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* uname */\n  this.rules[38].opcodes = [];\n  this.rules[38].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[38].opcodes[1] = {type: 6, string: [117,95]};// TBS\n  this.rules[38].opcodes[2] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* ename */\n  this.rules[39].opcodes = [];\n  this.rules[39].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[39].opcodes[1] = {type: 6, string: [101,95]};// TBS\n  this.rules[39].opcodes[2] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* UdtOp */\n  this.rules[40].opcodes = [];\n  this.rules[40].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[40].opcodes[1] = {type: 4, index: 42};// RNM(udt-empty)\n  this.rules[40].opcodes[2] = {type: 4, index: 41};// RNM(udt-non-empty)\n\n  /* udt-non-empty */\n  this.rules[41].opcodes = [];\n  this.rules[41].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[41].opcodes[1] = {type: 6, string: [117,95]};// TBS\n  this.rules[41].opcodes[2] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* udt-empty */\n  this.rules[42].opcodes = [];\n  this.rules[42].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[42].opcodes[1] = {type: 6, string: [101,95]};// TBS\n  this.rules[42].opcodes[2] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* RepOp */\n  this.rules[43].opcodes = [];\n  this.rules[43].opcodes[0] = {type: 1, children: [1,5,8,11,12]};// ALT\n  this.rules[43].opcodes[1] = {type: 2, children: [2,3,4]};// CAT\n  this.rules[43].opcodes[2] = {type: 4, index: 69};// RNM(rep-min)\n  this.rules[43].opcodes[3] = {type: 4, index: 46};// RNM(StarOp)\n  this.rules[43].opcodes[4] = {type: 4, index: 71};// RNM(rep-max)\n  this.rules[43].opcodes[5] = {type: 2, children: [6,7]};// CAT\n  this.rules[43].opcodes[6] = {type: 4, index: 69};// RNM(rep-min)\n  this.rules[43].opcodes[7] = {type: 4, index: 46};// RNM(StarOp)\n  this.rules[43].opcodes[8] = {type: 2, children: [9,10]};// CAT\n  this.rules[43].opcodes[9] = {type: 4, index: 46};// RNM(StarOp)\n  this.rules[43].opcodes[10] = {type: 4, index: 71};// RNM(rep-max)\n  this.rules[43].opcodes[11] = {type: 4, index: 46};// RNM(StarOp)\n  this.rules[43].opcodes[12] = {type: 4, index: 70};// RNM(rep-min-max)\n\n  /* AltOp */\n  this.rules[44].opcodes = [];\n  this.rules[44].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[44].opcodes[1] = {type: 6, string: [47]};// TBS\n  this.rules[44].opcodes[2] = {type: 4, index: 89};// RNM(owsp)\n\n  /* CatOp */\n  this.rules[45].opcodes = [];\n  this.rules[45].opcodes[0] = {type: 4, index: 90};// RNM(wsp)\n\n  /* StarOp */\n  this.rules[46].opcodes = [];\n  this.rules[46].opcodes[0] = {type: 6, string: [42]};// TBS\n\n  /* AndOp */\n  this.rules[47].opcodes = [];\n  this.rules[47].opcodes[0] = {type: 6, string: [38]};// TBS\n\n  /* NotOp */\n  this.rules[48].opcodes = [];\n  this.rules[48].opcodes[0] = {type: 6, string: [33]};// TBS\n\n  /* BkaOp */\n  this.rules[49].opcodes = [];\n  this.rules[49].opcodes[0] = {type: 6, string: [38,38]};// TBS\n\n  /* BknOp */\n  this.rules[50].opcodes = [];\n  this.rules[50].opcodes[0] = {type: 6, string: [33,33]};// TBS\n\n  /* AbgOp */\n  this.rules[51].opcodes = [];\n  this.rules[51].opcodes[0] = {type: 6, string: [37,94]};// TBS\n\n  /* AenOp */\n  this.rules[52].opcodes = [];\n  this.rules[52].opcodes[0] = {type: 6, string: [37,36]};// TBS\n\n  /* TrgOp */\n  this.rules[53].opcodes = [];\n  this.rules[53].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[53].opcodes[1] = {type: 6, string: [37]};// TBS\n  this.rules[53].opcodes[2] = {type: 1, children: [3,8,13]};// ALT\n  this.rules[53].opcodes[3] = {type: 2, children: [4,5,6,7]};// CAT\n  this.rules[53].opcodes[4] = {type: 4, index: 76};// RNM(Dec)\n  this.rules[53].opcodes[5] = {type: 4, index: 79};// RNM(dmin)\n  this.rules[53].opcodes[6] = {type: 6, string: [45]};// TBS\n  this.rules[53].opcodes[7] = {type: 4, index: 80};// RNM(dmax)\n  this.rules[53].opcodes[8] = {type: 2, children: [9,10,11,12]};// CAT\n  this.rules[53].opcodes[9] = {type: 4, index: 77};// RNM(Hex)\n  this.rules[53].opcodes[10] = {type: 4, index: 83};// RNM(xmin)\n  this.rules[53].opcodes[11] = {type: 6, string: [45]};// TBS\n  this.rules[53].opcodes[12] = {type: 4, index: 84};// RNM(xmax)\n  this.rules[53].opcodes[13] = {type: 2, children: [14,15,16,17]};// CAT\n  this.rules[53].opcodes[14] = {type: 4, index: 78};// RNM(Bin)\n  this.rules[53].opcodes[15] = {type: 4, index: 81};// RNM(bmin)\n  this.rules[53].opcodes[16] = {type: 6, string: [45]};// TBS\n  this.rules[53].opcodes[17] = {type: 4, index: 82};// RNM(bmax)\n\n  /* TbsOp */\n  this.rules[54].opcodes = [];\n  this.rules[54].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[54].opcodes[1] = {type: 6, string: [37]};// TBS\n  this.rules[54].opcodes[2] = {type: 1, children: [3,10,17]};// ALT\n  this.rules[54].opcodes[3] = {type: 2, children: [4,5,6]};// CAT\n  this.rules[54].opcodes[4] = {type: 4, index: 76};// RNM(Dec)\n  this.rules[54].opcodes[5] = {type: 4, index: 73};// RNM(dString)\n  this.rules[54].opcodes[6] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[54].opcodes[7] = {type: 2, children: [8,9]};// CAT\n  this.rules[54].opcodes[8] = {type: 6, string: [46]};// TBS\n  this.rules[54].opcodes[9] = {type: 4, index: 73};// RNM(dString)\n  this.rules[54].opcodes[10] = {type: 2, children: [11,12,13]};// CAT\n  this.rules[54].opcodes[11] = {type: 4, index: 77};// RNM(Hex)\n  this.rules[54].opcodes[12] = {type: 4, index: 74};// RNM(xString)\n  this.rules[54].opcodes[13] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[54].opcodes[14] = {type: 2, children: [15,16]};// CAT\n  this.rules[54].opcodes[15] = {type: 6, string: [46]};// TBS\n  this.rules[54].opcodes[16] = {type: 4, index: 74};// RNM(xString)\n  this.rules[54].opcodes[17] = {type: 2, children: [18,19,20]};// CAT\n  this.rules[54].opcodes[18] = {type: 4, index: 78};// RNM(Bin)\n  this.rules[54].opcodes[19] = {type: 4, index: 75};// RNM(bString)\n  this.rules[54].opcodes[20] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[54].opcodes[21] = {type: 2, children: [22,23]};// CAT\n  this.rules[54].opcodes[22] = {type: 6, string: [46]};// TBS\n  this.rules[54].opcodes[23] = {type: 4, index: 75};// RNM(bString)\n\n  /* TlsOp */\n  this.rules[55].opcodes = [];\n  this.rules[55].opcodes[0] = {type: 2, children: [1,2,3,4]};// CAT\n  this.rules[55].opcodes[1] = {type: 4, index: 56};// RNM(TlsCase)\n  this.rules[55].opcodes[2] = {type: 4, index: 57};// RNM(TlsOpen)\n  this.rules[55].opcodes[3] = {type: 4, index: 59};// RNM(TlsString)\n  this.rules[55].opcodes[4] = {type: 4, index: 58};// RNM(TlsClose)\n\n  /* TlsCase */\n  this.rules[56].opcodes = [];\n  this.rules[56].opcodes[0] = {type: 3, min: 0, max: 1};// REP\n  this.rules[56].opcodes[1] = {type: 1, children: [2,3]};// ALT\n  this.rules[56].opcodes[2] = {type: 7, string: [37,105]};// TLS\n  this.rules[56].opcodes[3] = {type: 7, string: [37,115]};// TLS\n\n  /* TlsOpen */\n  this.rules[57].opcodes = [];\n  this.rules[57].opcodes[0] = {type: 6, string: [34]};// TBS\n\n  /* TlsClose */\n  this.rules[58].opcodes = [];\n  this.rules[58].opcodes[0] = {type: 6, string: [34]};// TBS\n\n  /* TlsString */\n  this.rules[59].opcodes = [];\n  this.rules[59].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[59].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[59].opcodes[2] = {type: 5, min: 32, max: 33};// TRG\n  this.rules[59].opcodes[3] = {type: 5, min: 35, max: 126};// TRG\n  this.rules[59].opcodes[4] = {type: 4, index: 60};// RNM(StringTab)\n\n  /* StringTab */\n  this.rules[60].opcodes = [];\n  this.rules[60].opcodes[0] = {type: 6, string: [9]};// TBS\n\n  /* ClsOp */\n  this.rules[61].opcodes = [];\n  this.rules[61].opcodes[0] = {type: 2, children: [1,2,3]};// CAT\n  this.rules[61].opcodes[1] = {type: 4, index: 62};// RNM(ClsOpen)\n  this.rules[61].opcodes[2] = {type: 4, index: 64};// RNM(ClsString)\n  this.rules[61].opcodes[3] = {type: 4, index: 63};// RNM(ClsClose)\n\n  /* ClsOpen */\n  this.rules[62].opcodes = [];\n  this.rules[62].opcodes[0] = {type: 6, string: [39]};// TBS\n\n  /* ClsClose */\n  this.rules[63].opcodes = [];\n  this.rules[63].opcodes[0] = {type: 6, string: [39]};// TBS\n\n  /* ClsString */\n  this.rules[64].opcodes = [];\n  this.rules[64].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[64].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[64].opcodes[2] = {type: 5, min: 32, max: 38};// TRG\n  this.rules[64].opcodes[3] = {type: 5, min: 40, max: 126};// TRG\n  this.rules[64].opcodes[4] = {type: 4, index: 60};// RNM(StringTab)\n\n  /* ProsVal */\n  this.rules[65].opcodes = [];\n  this.rules[65].opcodes[0] = {type: 2, children: [1,2,3]};// CAT\n  this.rules[65].opcodes[1] = {type: 4, index: 66};// RNM(ProsValOpen)\n  this.rules[65].opcodes[2] = {type: 4, index: 67};// RNM(ProsValString)\n  this.rules[65].opcodes[3] = {type: 4, index: 68};// RNM(ProsValClose)\n\n  /* ProsValOpen */\n  this.rules[66].opcodes = [];\n  this.rules[66].opcodes[0] = {type: 6, string: [60]};// TBS\n\n  /* ProsValString */\n  this.rules[67].opcodes = [];\n  this.rules[67].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[67].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[67].opcodes[2] = {type: 5, min: 32, max: 61};// TRG\n  this.rules[67].opcodes[3] = {type: 5, min: 63, max: 126};// TRG\n  this.rules[67].opcodes[4] = {type: 4, index: 60};// RNM(StringTab)\n\n  /* ProsValClose */\n  this.rules[68].opcodes = [];\n  this.rules[68].opcodes[0] = {type: 6, string: [62]};// TBS\n\n  /* rep-min */\n  this.rules[69].opcodes = [];\n  this.rules[69].opcodes[0] = {type: 4, index: 72};// RNM(rep-num)\n\n  /* rep-min-max */\n  this.rules[70].opcodes = [];\n  this.rules[70].opcodes[0] = {type: 4, index: 72};// RNM(rep-num)\n\n  /* rep-max */\n  this.rules[71].opcodes = [];\n  this.rules[71].opcodes[0] = {type: 4, index: 72};// RNM(rep-num)\n\n  /* rep-num */\n  this.rules[72].opcodes = [];\n  this.rules[72].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[72].opcodes[1] = {type: 5, min: 48, max: 57};// TRG\n\n  /* dString */\n  this.rules[73].opcodes = [];\n  this.rules[73].opcodes[0] = {type: 4, index: 85};// RNM(dnum)\n\n  /* xString */\n  this.rules[74].opcodes = [];\n  this.rules[74].opcodes[0] = {type: 4, index: 87};// RNM(xnum)\n\n  /* bString */\n  this.rules[75].opcodes = [];\n  this.rules[75].opcodes[0] = {type: 4, index: 86};// RNM(bnum)\n\n  /* Dec */\n  this.rules[76].opcodes = [];\n  this.rules[76].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[76].opcodes[1] = {type: 6, string: [68]};// TBS\n  this.rules[76].opcodes[2] = {type: 6, string: [100]};// TBS\n\n  /* Hex */\n  this.rules[77].opcodes = [];\n  this.rules[77].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[77].opcodes[1] = {type: 6, string: [88]};// TBS\n  this.rules[77].opcodes[2] = {type: 6, string: [120]};// TBS\n\n  /* Bin */\n  this.rules[78].opcodes = [];\n  this.rules[78].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[78].opcodes[1] = {type: 6, string: [66]};// TBS\n  this.rules[78].opcodes[2] = {type: 6, string: [98]};// TBS\n\n  /* dmin */\n  this.rules[79].opcodes = [];\n  this.rules[79].opcodes[0] = {type: 4, index: 85};// RNM(dnum)\n\n  /* dmax */\n  this.rules[80].opcodes = [];\n  this.rules[80].opcodes[0] = {type: 4, index: 85};// RNM(dnum)\n\n  /* bmin */\n  this.rules[81].opcodes = [];\n  this.rules[81].opcodes[0] = {type: 4, index: 86};// RNM(bnum)\n\n  /* bmax */\n  this.rules[82].opcodes = [];\n  this.rules[82].opcodes[0] = {type: 4, index: 86};// RNM(bnum)\n\n  /* xmin */\n  this.rules[83].opcodes = [];\n  this.rules[83].opcodes[0] = {type: 4, index: 87};// RNM(xnum)\n\n  /* xmax */\n  this.rules[84].opcodes = [];\n  this.rules[84].opcodes[0] = {type: 4, index: 87};// RNM(xnum)\n\n  /* dnum */\n  this.rules[85].opcodes = [];\n  this.rules[85].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[85].opcodes[1] = {type: 5, min: 48, max: 57};// TRG\n\n  /* bnum */\n  this.rules[86].opcodes = [];\n  this.rules[86].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[86].opcodes[1] = {type: 5, min: 48, max: 49};// TRG\n\n  /* xnum */\n  this.rules[87].opcodes = [];\n  this.rules[87].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[87].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[87].opcodes[2] = {type: 5, min: 48, max: 57};// TRG\n  this.rules[87].opcodes[3] = {type: 5, min: 65, max: 70};// TRG\n  this.rules[87].opcodes[4] = {type: 5, min: 97, max: 102};// TRG\n\n  /* alphanum */\n  this.rules[88].opcodes = [];\n  this.rules[88].opcodes[0] = {type: 2, children: [1,4]};// CAT\n  this.rules[88].opcodes[1] = {type: 1, children: [2,3]};// ALT\n  this.rules[88].opcodes[2] = {type: 5, min: 97, max: 122};// TRG\n  this.rules[88].opcodes[3] = {type: 5, min: 65, max: 90};// TRG\n  this.rules[88].opcodes[4] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[88].opcodes[5] = {type: 1, children: [6,7,8,9]};// ALT\n  this.rules[88].opcodes[6] = {type: 5, min: 97, max: 122};// TRG\n  this.rules[88].opcodes[7] = {type: 5, min: 65, max: 90};// TRG\n  this.rules[88].opcodes[8] = {type: 5, min: 48, max: 57};// TRG\n  this.rules[88].opcodes[9] = {type: 6, string: [45]};// TBS\n\n  /* owsp */\n  this.rules[89].opcodes = [];\n  this.rules[89].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[89].opcodes[1] = {type: 4, index: 91};// RNM(space)\n\n  /* wsp */\n  this.rules[90].opcodes = [];\n  this.rules[90].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[90].opcodes[1] = {type: 4, index: 91};// RNM(space)\n\n  /* space */\n  this.rules[91].opcodes = [];\n  this.rules[91].opcodes[0] = {type: 1, children: [1,2,3,4]};// ALT\n  this.rules[91].opcodes[1] = {type: 6, string: [32]};// TBS\n  this.rules[91].opcodes[2] = {type: 6, string: [9]};// TBS\n  this.rules[91].opcodes[3] = {type: 4, index: 92};// RNM(comment)\n  this.rules[91].opcodes[4] = {type: 4, index: 94};// RNM(LineContinue)\n\n  /* comment */\n  this.rules[92].opcodes = [];\n  this.rules[92].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[92].opcodes[1] = {type: 6, string: [59]};// TBS\n  this.rules[92].opcodes[2] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[92].opcodes[3] = {type: 1, children: [4,5]};// ALT\n  this.rules[92].opcodes[4] = {type: 5, min: 32, max: 126};// TRG\n  this.rules[92].opcodes[5] = {type: 6, string: [9]};// TBS\n\n  /* LineEnd */\n  this.rules[93].opcodes = [];\n  this.rules[93].opcodes[0] = {type: 1, children: [1,2,3]};// ALT\n  this.rules[93].opcodes[1] = {type: 6, string: [13,10]};// TBS\n  this.rules[93].opcodes[2] = {type: 6, string: [10]};// TBS\n  this.rules[93].opcodes[3] = {type: 6, string: [13]};// TBS\n\n  /* LineContinue */\n  this.rules[94].opcodes = [];\n  this.rules[94].opcodes[0] = {type: 2, children: [1,5]};// CAT\n  this.rules[94].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[94].opcodes[2] = {type: 6, string: [13,10]};// TBS\n  this.rules[94].opcodes[3] = {type: 6, string: [10]};// TBS\n  this.rules[94].opcodes[4] = {type: 6, string: [13]};// TBS\n  this.rules[94].opcodes[5] = {type: 1, children: [6,7]};// ALT\n  this.rules[94].opcodes[6] = {type: 6, string: [32]};// TBS\n  this.rules[94].opcodes[7] = {type: 6, string: [9]};// TBS\n\n  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\n  this.toString = function toString(){\n    let str = \"\";\n    str += \";\\n\";\n    str += \"; ABNF for JavaScript APG 2.0 SABNF\\n\";\n    str += \"; RFC 5234 with some restrictions and additions.\\n\";\n    str += \"; Updated 11/24/2015 for RFC 7405 case-sensitive literal string notation\\n\";\n    str += \";  - accepts %s\\\"string\\\" as a case-sensitive string\\n\";\n    str += \";  - accepts %i\\\"string\\\" as a case-insensitive string\\n\";\n    str += \";  - accepts \\\"string\\\" as a case-insensitive string\\n\";\n    str += \";\\n\";\n    str += \"; Some restrictions:\\n\";\n    str += \";   1. Rules must begin at first character of each line.\\n\";\n    str += \";      Indentations on first rule and rules thereafter are not allowed.\\n\";\n    str += \";   2. Relaxed line endings. CRLF, LF or CR are accepted as valid line ending.\\n\";\n    str += \";   3. Prose values, i.e. <prose value>, are accepted as valid grammar syntax.\\n\";\n    str += \";      However, a working parser cannot be generated from them.\\n\";\n    str += \";\\n\";\n    str += \"; Super set (SABNF) additions:\\n\";\n    str += \";   1. Look-ahead (syntactic predicate) operators are accepted as element prefixes.\\n\";\n    str += \";      & is the positive look-ahead operator, succeeds and backtracks if the look-ahead phrase is found\\n\";\n    str += \";      ! is the negative look-ahead operator, succeeds and backtracks if the look-ahead phrase is NOT found\\n\";\n    str += \";      e.g. &%d13 or &rule or !(A / B)\\n\";\n    str += \";   2. User-Defined Terminals (UDT) of the form, u_name and e_name are accepted.\\n\";\n    str += \";      'name' is alpha followed by alpha/num/hyphen just like a rule name.\\n\";\n    str += \";      u_name may be used as an element but no rule definition is given.\\n\";\n    str += \";      e.g. rule = A / u_myUdt\\n\";\n    str += \";           A = \\\"a\\\"\\n\";\n    str += \";      would be a valid grammar.\\n\";\n    str += \";   3. Case-sensitive, single-quoted strings are accepted.\\n\";\n    str += \";      e.g. 'abc' would be equivalent to %d97.98.99\\n\";\n    str += \";      (kept for backward compatibility, but superseded by %s\\\"abc\\\")  \\n\";\n    str += \"; New 12/26/2015\\n\";\n    str += \";   4. Look-behind operators are accepted as element prefixes.\\n\";\n    str += \";      && is the positive look-behind operator, succeeds and backtracks if the look-behind phrase is found\\n\";\n    str += \";      !! is the negative look-behind operator, succeeds and backtracks if the look-behind phrase is NOT found\\n\";\n    str += \";      e.g. &&%d13 or &&rule or !!(A / B)\\n\";\n    str += \";   5. Back reference operators, i.e. \\\\rulename, are accepted.\\n\";\n    str += \";      A back reference operator acts like a TLS or TBS terminal except that the phrase it attempts\\n\";\n    str += \";      to match is a phrase previously matched by the rule 'rulename'.\\n\";\n    str += \";      There are two modes of previous phrase matching - the parent-frame mode and the universal mode.\\n\";\n    str += \";      In universal mode, \\\\rulename matches the last match to 'rulename' regardless of where it was found.\\n\";\n    str += \";      In parent-frame mode, \\\\rulename matches only the last match found on the parent's frame or parse tree level.\\n\";\n    str += \";      Back reference modifiers can be used to specify case and mode.\\n\";\n    str += \";      \\\\A defaults to case-insensitive and universal mode, e.g. \\\\A === \\\\%i%uA\\n\";\n    str += \";      Modifiers %i and %s determine case-insensitive and case-sensitive mode, respectively.\\n\";\n    str += \";      Modifiers %u and %p determine universal mode and parent frame mode, respectively.\\n\";\n    str += \";      Case and mode modifiers can appear in any order, e.g. \\\\%s%pA === \\\\%p%sA. \\n\";\n    str += \";   7. String begin anchor, ABG(%^) matches the beginning of the input string location.\\n\";\n    str += \";      Returns EMPTY or NOMATCH. Never consumes any characters.\\n\";\n    str += \";   8. String end anchor, AEN(%$) matches the end of the input string location.\\n\";\n    str += \";      Returns EMPTY or NOMATCH. Never consumes any characters.\\n\";\n    str += \";\\n\";\n    str += \"File            = *(BlankLine / Rule / RuleError)\\n\";\n    str += \"BlankLine       = *(%d32/%d9) [comment] LineEnd\\n\";\n    str += \"Rule            = RuleLookup owsp Alternation ((owsp LineEnd)\\n\";\n    str += \"                / (LineEndError LineEnd))\\n\";\n    str += \"RuleLookup      = RuleNameTest owsp DefinedAsTest\\n\";\n    str += \"RuleNameTest    = RuleName/RuleNameError\\n\";\n    str += \"RuleName        = alphanum\\n\";\n    str += \"RuleNameError   = 1*(%d33-60/%d62-126)\\n\";\n    str += \"DefinedAsTest   = DefinedAs / DefinedAsError\\n\";\n    str += \"DefinedAsError  = 1*2%d33-126\\n\";\n    str += \"DefinedAs       = IncAlt / Defined\\n\";\n    str += \"Defined         = %d61\\n\";\n    str += \"IncAlt          = %d61.47\\n\";\n    str += \"RuleError       = 1*(%d32-126 / %d9  / LineContinue) LineEnd\\n\";\n    str += \"LineEndError    = 1*(%d32-126 / %d9  / LineContinue)\\n\";\n    str += \"Alternation     = Concatenation *(owsp AltOp Concatenation)\\n\";\n    str += \"Concatenation   = Repetition *(CatOp Repetition)\\n\";\n    str += \"Repetition      = [Modifier] (Group / Option / BasicElement / BasicElementErr)\\n\";\n    str += \"Modifier        = (Predicate [RepOp])\\n\";\n    str += \"                / RepOp\\n\";\n    str += \"Predicate       = BkaOp\\n\";\n    str += \"                / BknOp\\n\";\n    str += \"                / AndOp\\n\";\n    str += \"                / NotOp\\n\";\n    str += \"BasicElement    = UdtOp\\n\";\n    str += \"                / RnmOp\\n\";\n    str += \"                / TrgOp\\n\";\n    str += \"                / TbsOp\\n\";\n    str += \"                / TlsOp\\n\";\n    str += \"                / ClsOp\\n\";\n    str += \"                / BkrOp\\n\";\n    str += \"                / AbgOp\\n\";\n    str += \"                / AenOp\\n\";\n    str += \"                / ProsVal\\n\";\n    str += \"BasicElementErr = 1*(%d33-40/%d42-46/%d48-92/%d94-126)\\n\";\n    str += \"Group           = GroupOpen  Alternation (GroupClose / GroupError)\\n\";\n    str += \"GroupError      = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\\n\";\n    str += \"GroupOpen       = %d40 owsp\\n\";\n    str += \"GroupClose      = owsp %d41\\n\";\n    str += \"Option          = OptionOpen Alternation (OptionClose / OptionError)\\n\";\n    str += \"OptionError     = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\\n\";\n    str += \"OptionOpen      = %d91 owsp\\n\";\n    str += \"OptionClose     = owsp %d93\\n\";\n    str += \"RnmOp           = alphanum\\n\";\n    str += \"BkrOp           = %d92 [bkrModifier] bkr-name\\n\";\n    str += \"bkrModifier     = (cs [um / pm]) / (ci [um / pm]) / (um [cs /ci]) / (pm [cs / ci])\\n\";\n    str += \"cs              = '%s'\\n\";\n    str += \"ci              = '%i'\\n\";\n    str += \"um              = '%u'\\n\";\n    str += \"pm              = '%p'\\n\";\n    str += \"bkr-name        = uname / ename / rname\\n\";\n    str += \"rname           = alphanum\\n\";\n    str += \"uname           = %d117.95 alphanum\\n\";\n    str += \"ename           = %d101.95 alphanum\\n\";\n    str += \"UdtOp           = udt-empty\\n\";\n    str += \"                / udt-non-empty\\n\";\n    str += \"udt-non-empty   = %d117.95 alphanum\\n\";\n    str += \"udt-empty       = %d101.95 alphanum\\n\";\n    str += \"RepOp           = (rep-min StarOp rep-max)\\n\";\n    str += \"                / (rep-min StarOp)\\n\";\n    str += \"                / (StarOp rep-max)\\n\";\n    str += \"                / StarOp\\n\";\n    str += \"                / rep-min-max\\n\";\n    str += \"AltOp           = %d47 owsp\\n\";\n    str += \"CatOp           = wsp\\n\";\n    str += \"StarOp          = %d42\\n\";\n    str += \"AndOp           = %d38\\n\";\n    str += \"NotOp           = %d33\\n\";\n    str += \"BkaOp           = %d38.38\\n\";\n    str += \"BknOp           = %d33.33\\n\";\n    str += \"AbgOp           = %d37.94\\n\";\n    str += \"AenOp           = %d37.36\\n\";\n    str += \"TrgOp           = %d37 ((Dec dmin %d45 dmax) / (Hex xmin %d45 xmax) / (Bin bmin %d45 bmax))\\n\";\n    str += \"TbsOp           = %d37 ((Dec dString *(%d46 dString)) / (Hex xString *(%d46 xString)) / (Bin bString *(%d46 bString)))\\n\";\n    str += \"TlsOp           = TlsCase TlsOpen TlsString TlsClose\\n\";\n    str += \"TlsCase         = [\\\"%i\\\" / \\\"%s\\\"]\\n\";\n    str += \"TlsOpen         = %d34\\n\";\n    str += \"TlsClose        = %d34\\n\";\n    str += \"TlsString       = *(%d32-33/%d35-126/StringTab)\\n\";\n    str += \"StringTab       = %d9\\n\";\n    str += \"ClsOp           = ClsOpen ClsString ClsClose\\n\";\n    str += \"ClsOpen         = %d39\\n\";\n    str += \"ClsClose        = %d39\\n\";\n    str += \"ClsString       = *(%d32-38/%d40-126/StringTab)\\n\";\n    str += \"ProsVal         = ProsValOpen ProsValString ProsValClose\\n\";\n    str += \"ProsValOpen     = %d60\\n\";\n    str += \"ProsValString   = *(%d32-61/%d63-126/StringTab)\\n\";\n    str += \"ProsValClose    = %d62\\n\";\n    str += \"rep-min         = rep-num\\n\";\n    str += \"rep-min-max     = rep-num\\n\";\n    str += \"rep-max         = rep-num\\n\";\n    str += \"rep-num         = 1*(%d48-57)\\n\";\n    str += \"dString         = dnum\\n\";\n    str += \"xString         = xnum\\n\";\n    str += \"bString         = bnum\\n\";\n    str += \"Dec             = (%d68/%d100)\\n\";\n    str += \"Hex             = (%d88/%d120)\\n\";\n    str += \"Bin             = (%d66/%d98)\\n\";\n    str += \"dmin            = dnum\\n\";\n    str += \"dmax            = dnum\\n\";\n    str += \"bmin            = bnum\\n\";\n    str += \"bmax            = bnum\\n\";\n    str += \"xmin            = xnum\\n\";\n    str += \"xmax            = xnum\\n\";\n    str += \"dnum            = 1*(%d48-57)\\n\";\n    str += \"bnum            = 1*%d48-49\\n\";\n    str += \"xnum            = 1*(%d48-57 / %d65-70 / %d97-102)\\n\";\n    str += \";\\n\";\n    str += \"; Basics\\n\";\n    str += \"alphanum        = (%d97-122/%d65-90) *(%d97-122/%d65-90/%d48-57/%d45)\\n\";\n    str += \"owsp            = *space\\n\";\n    str += \"wsp             = 1*space\\n\";\n    str += \"space           = %d32\\n\";\n    str += \"                / %d9\\n\";\n    str += \"                / comment\\n\";\n    str += \"                / LineContinue\\n\";\n    str += \"comment         = %d59 *(%d32-126 / %d9)\\n\";\n    str += \"LineEnd         = %d13.10\\n\";\n    str += \"                / %d10\\n\";\n    str += \"                / %d13\\n\";\n    str += \"LineContinue    = (%d13.10 / %d10 / %d13) (%d32 / %d9)\\n\";\n    return str;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NhYm5mLWdyYW1tYXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdDQUFnQztBQUM5RCw4QkFBOEIsNEJBQTRCO0FBQzFELDhCQUE4QixtQkFBbUI7QUFDakQsOEJBQThCLG1CQUFtQjtBQUNqRCw4QkFBOEIsb0JBQW9COztBQUVsRDtBQUNBO0FBQ0EsOEJBQThCLDRCQUE0QjtBQUMxRCw4QkFBOEIsZ0NBQWdDO0FBQzlELDhCQUE4QiwwQkFBMEI7QUFDeEQsOEJBQThCLHVCQUF1QjtBQUNyRCw4QkFBOEIsc0JBQXNCO0FBQ3BELDhCQUE4Qix5QkFBeUI7QUFDdkQsOEJBQThCLG9CQUFvQjtBQUNsRCw4QkFBOEIsb0JBQW9COztBQUVsRDtBQUNBO0FBQ0EsOEJBQThCLDhCQUE4QjtBQUM1RCw4QkFBOEIsbUJBQW1CO0FBQ2pELDhCQUE4QixvQkFBb0I7QUFDbEQsOEJBQThCLG9CQUFvQjtBQUNsRCw4QkFBOEIsMEJBQTBCO0FBQ3hELDhCQUE4QiwwQkFBMEI7QUFDeEQsOEJBQThCLG9CQUFvQjtBQUNsRCw4QkFBOEIsb0JBQW9CO0FBQ2xELDhCQUE4QiwyQkFBMkI7QUFDekQsOEJBQThCLG9CQUFvQjtBQUNsRCwrQkFBK0Isb0JBQW9COztBQUVuRDtBQUNBO0FBQ0EsOEJBQThCLDRCQUE0QjtBQUMxRCw4QkFBOEIsbUJBQW1CO0FBQ2pELDhCQUE4QixvQkFBb0I7QUFDbEQsOEJBQThCLG1CQUFtQjs7QUFFakQ7QUFDQTtBQUNBLDhCQUE4QiwwQkFBMEI7QUFDeEQsOEJBQThCLG1CQUFtQjtBQUNqRCw4QkFBOEIsbUJBQW1COztBQUVqRDtBQUNBO0FBQ0EsOEJBQThCLG9CQUFvQjs7QUFFbEQ7QUFDQTtBQUNBLDhCQUE4QixnQ0FBZ0M7QUFDOUQsOEJBQThCLDBCQUEwQjtBQUN4RCw4QkFBOEIsMkJBQTJCO0FBQ3pELDhCQUE4Qiw0QkFBNEI7O0FBRTFEO0FBQ0E7QUFDQSw4QkFBOEIsMEJBQTBCO0FBQ3hELDhCQUE4QixtQkFBbUI7QUFDakQsOEJBQThCLG1CQUFtQjs7QUFFakQ7QUFDQTtBQUNBLDhCQUE4Qix5QkFBeUI7QUFDdkQsOEJBQThCLDRCQUE0Qjs7QUFFMUQ7QUFDQTtBQUNBLDhCQUE4QiwwQkFBMEI7QUFDeEQsOEJBQThCLG9CQUFvQjtBQUNsRCw4QkFBOEIsb0JBQW9COztBQUVsRDtBQUNBO0FBQ0EsK0JBQStCLHVCQUF1Qjs7QUFFdEQ7QUFDQTtBQUNBLCtCQUErQiwwQkFBMEI7O0FBRXpEO0FBQ0E7QUFDQSwrQkFBK0IsMEJBQTBCO0FBQ3pELCtCQUErQixnQ0FBZ0M7QUFDL0QsK0JBQStCLDRCQUE0QjtBQUMzRCwrQkFBK0IsNEJBQTRCO0FBQzNELCtCQUErQixzQkFBc0I7QUFDckQsK0JBQStCLG9CQUFvQjtBQUNuRCwrQkFBK0Isb0JBQW9COztBQUVuRDtBQUNBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRCwrQkFBK0IsNEJBQTRCO0FBQzNELCtCQUErQiw0QkFBNEI7QUFDM0QsK0JBQStCLHNCQUFzQjtBQUNyRCwrQkFBK0Isb0JBQW9COztBQUVuRDtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RCwrQkFBK0Isb0JBQW9CO0FBQ25ELCtCQUErQixnQ0FBZ0M7QUFDL0QsK0JBQStCLDRCQUE0QjtBQUMzRCwrQkFBK0Isb0JBQW9CO0FBQ25ELCtCQUErQixvQkFBb0I7QUFDbkQsK0JBQStCLG9CQUFvQjs7QUFFbkQ7QUFDQTtBQUNBLCtCQUErQiwwQkFBMEI7QUFDekQsK0JBQStCLG9CQUFvQjtBQUNuRCwrQkFBK0IsZ0NBQWdDO0FBQy9ELCtCQUErQiwwQkFBMEI7QUFDekQsK0JBQStCLG9CQUFvQjtBQUNuRCwrQkFBK0Isb0JBQW9COztBQUVuRDtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RCwrQkFBK0IseUJBQXlCO0FBQ3hELCtCQUErQixvQkFBb0I7QUFDbkQsK0JBQStCLDhCQUE4QjtBQUM3RCwrQkFBK0Isb0JBQW9CO0FBQ25ELCtCQUErQixvQkFBb0I7QUFDbkQsK0JBQStCLG9CQUFvQjtBQUNuRCwrQkFBK0Isb0JBQW9COztBQUVuRDtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RCwrQkFBK0IsMEJBQTBCO0FBQ3pELCtCQUErQixvQkFBb0I7QUFDbkQsK0JBQStCLHlCQUF5QjtBQUN4RCwrQkFBK0Isb0JBQW9CO0FBQ25ELCtCQUErQixvQkFBb0I7O0FBRW5EO0FBQ0E7QUFDQSwrQkFBK0IsOEJBQThCO0FBQzdELCtCQUErQixvQkFBb0I7QUFDbkQsK0JBQStCLG9CQUFvQjtBQUNuRCwrQkFBK0Isb0JBQW9CO0FBQ25ELCtCQUErQixvQkFBb0I7O0FBRW5EO0FBQ0E7QUFDQSwrQkFBK0IsMkNBQTJDO0FBQzFFLCtCQUErQixvQkFBb0I7QUFDbkQsK0JBQStCLG9CQUFvQjtBQUNuRCwrQkFBK0Isb0JBQW9CO0FBQ25ELCtCQUErQixvQkFBb0I7QUFDbkQsK0JBQStCLG9CQUFvQjtBQUNuRCwrQkFBK0Isb0JBQW9CO0FBQ25ELCtCQUErQixvQkFBb0I7QUFDbkQsK0JBQStCLG9CQUFvQjtBQUNuRCwrQkFBK0Isb0JBQW9CO0FBQ25ELGdDQUFnQyxvQkFBb0I7O0FBRXBEO0FBQ0E7QUFDQSwrQkFBK0IsZ0NBQWdDO0FBQy9ELCtCQUErQiw4QkFBOEI7QUFDN0QsK0JBQStCLDJCQUEyQjtBQUMxRCwrQkFBK0IsMkJBQTJCO0FBQzFELCtCQUErQiwyQkFBMkI7QUFDMUQsK0JBQStCLDRCQUE0Qjs7QUFFM0Q7QUFDQTtBQUNBLCtCQUErQiw0QkFBNEI7QUFDM0QsK0JBQStCLG9CQUFvQjtBQUNuRCwrQkFBK0Isb0JBQW9CO0FBQ25ELCtCQUErQiwwQkFBMEI7QUFDekQsK0JBQStCLG9CQUFvQjtBQUNuRCwrQkFBK0Isb0JBQW9COztBQUVuRDtBQUNBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRCwrQkFBK0IsOEJBQThCO0FBQzdELCtCQUErQiwyQkFBMkI7QUFDMUQsK0JBQStCLDJCQUEyQjtBQUMxRCwrQkFBK0IsMkJBQTJCO0FBQzFELCtCQUErQiw0QkFBNEI7O0FBRTNEO0FBQ0E7QUFDQSwrQkFBK0IsMEJBQTBCO0FBQ3pELCtCQUErQix1QkFBdUI7QUFDdEQsK0JBQStCLG9CQUFvQjs7QUFFbkQ7QUFDQTtBQUNBLCtCQUErQiwwQkFBMEI7QUFDekQsK0JBQStCLG9CQUFvQjtBQUNuRCwrQkFBK0IsdUJBQXVCOztBQUV0RDtBQUNBO0FBQ0EsK0JBQStCLDRCQUE0QjtBQUMzRCwrQkFBK0Isb0JBQW9CO0FBQ25ELCtCQUErQixvQkFBb0I7QUFDbkQsK0JBQStCLDBCQUEwQjtBQUN6RCwrQkFBK0Isb0JBQW9CO0FBQ25ELCtCQUErQixvQkFBb0I7O0FBRW5EO0FBQ0E7QUFDQSwrQkFBK0IsZ0NBQWdDO0FBQy9ELCtCQUErQiw4QkFBOEI7QUFDN0QsK0JBQStCLDJCQUEyQjtBQUMxRCwrQkFBK0IsMkJBQTJCO0FBQzFELCtCQUErQiwyQkFBMkI7QUFDMUQsK0JBQStCLDRCQUE0Qjs7QUFFM0Q7QUFDQTtBQUNBLCtCQUErQiwwQkFBMEI7QUFDekQsK0JBQStCLHVCQUF1QjtBQUN0RCwrQkFBK0Isb0JBQW9COztBQUVuRDtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RCwrQkFBK0Isb0JBQW9CO0FBQ25ELCtCQUErQix1QkFBdUI7O0FBRXREO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9COztBQUVuRDtBQUNBO0FBQ0EsK0JBQStCLDRCQUE0QjtBQUMzRCwrQkFBK0IsdUJBQXVCO0FBQ3RELCtCQUErQix5QkFBeUI7QUFDeEQsK0JBQStCLG9CQUFvQjtBQUNuRCwrQkFBK0Isb0JBQW9COztBQUVuRDtBQUNBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRCwrQkFBK0IsMEJBQTBCO0FBQ3pELCtCQUErQixvQkFBb0I7QUFDbkQsK0JBQStCLHlCQUF5QjtBQUN4RCwrQkFBK0IsMEJBQTBCO0FBQ3pELCtCQUErQixvQkFBb0I7QUFDbkQsK0JBQStCLG9CQUFvQjtBQUNuRCwrQkFBK0IsMEJBQTBCO0FBQ3pELCtCQUErQixvQkFBb0I7QUFDbkQsK0JBQStCLHlCQUF5QjtBQUN4RCxnQ0FBZ0MsNEJBQTRCO0FBQzVELGdDQUFnQyxvQkFBb0I7QUFDcEQsZ0NBQWdDLG9CQUFvQjtBQUNwRCxnQ0FBZ0MsNEJBQTRCO0FBQzVELGdDQUFnQyxvQkFBb0I7QUFDcEQsZ0NBQWdDLHlCQUF5QjtBQUN6RCxnQ0FBZ0MsNEJBQTRCO0FBQzVELGdDQUFnQyxvQkFBb0I7QUFDcEQsZ0NBQWdDLG9CQUFvQjtBQUNwRCxnQ0FBZ0MsNEJBQTRCO0FBQzVELGdDQUFnQyxvQkFBb0I7QUFDcEQsZ0NBQWdDLHlCQUF5QjtBQUN6RCxnQ0FBZ0MsNEJBQTRCO0FBQzVELGdDQUFnQyxvQkFBb0I7QUFDcEQsZ0NBQWdDLG9CQUFvQjs7QUFFcEQ7QUFDQTtBQUNBLCtCQUErQiwyQkFBMkI7O0FBRTFEO0FBQ0E7QUFDQSwrQkFBK0IsMkJBQTJCOztBQUUxRDtBQUNBO0FBQ0EsK0JBQStCLDJCQUEyQjs7QUFFMUQ7QUFDQTtBQUNBLCtCQUErQiwyQkFBMkI7O0FBRTFEO0FBQ0E7QUFDQSwrQkFBK0IsNEJBQTRCO0FBQzNELCtCQUErQixvQkFBb0I7QUFDbkQsK0JBQStCLG9CQUFvQjtBQUNuRCwrQkFBK0Isb0JBQW9COztBQUVuRDtBQUNBO0FBQ0EsK0JBQStCLG9CQUFvQjs7QUFFbkQ7QUFDQTtBQUNBLCtCQUErQiwwQkFBMEI7QUFDekQsK0JBQStCLDJCQUEyQjtBQUMxRCwrQkFBK0Isb0JBQW9COztBQUVuRDtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RCwrQkFBK0IsMkJBQTJCO0FBQzFELCtCQUErQixvQkFBb0I7O0FBRW5EO0FBQ0E7QUFDQSwrQkFBK0IsMEJBQTBCO0FBQ3pELCtCQUErQixvQkFBb0I7QUFDbkQsK0JBQStCLG9CQUFvQjs7QUFFbkQ7QUFDQTtBQUNBLCtCQUErQiwwQkFBMEI7QUFDekQsK0JBQStCLDJCQUEyQjtBQUMxRCwrQkFBK0Isb0JBQW9COztBQUVuRDtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RCwrQkFBK0IsMkJBQTJCO0FBQzFELCtCQUErQixvQkFBb0I7O0FBRW5EO0FBQ0E7QUFDQSwrQkFBK0Isa0NBQWtDO0FBQ2pFLCtCQUErQiw0QkFBNEI7QUFDM0QsK0JBQStCLG9CQUFvQjtBQUNuRCwrQkFBK0Isb0JBQW9CO0FBQ25ELCtCQUErQixvQkFBb0I7QUFDbkQsK0JBQStCLDBCQUEwQjtBQUN6RCwrQkFBK0Isb0JBQW9CO0FBQ25ELCtCQUErQixvQkFBb0I7QUFDbkQsK0JBQStCLDJCQUEyQjtBQUMxRCwrQkFBK0Isb0JBQW9CO0FBQ25ELGdDQUFnQyxvQkFBb0I7QUFDcEQsZ0NBQWdDLG9CQUFvQjtBQUNwRCxnQ0FBZ0Msb0JBQW9COztBQUVwRDtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RCwrQkFBK0IsdUJBQXVCO0FBQ3RELCtCQUErQixvQkFBb0I7O0FBRW5EO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9COztBQUVuRDtBQUNBO0FBQ0EsK0JBQStCLHVCQUF1Qjs7QUFFdEQ7QUFDQTtBQUNBLCtCQUErQix1QkFBdUI7O0FBRXREO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCOztBQUV0RDtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjs7QUFFekQ7QUFDQTtBQUNBLCtCQUErQiwwQkFBMEI7O0FBRXpEO0FBQ0E7QUFDQSwrQkFBK0IsMEJBQTBCOztBQUV6RDtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjs7QUFFekQ7QUFDQTtBQUNBLCtCQUErQiwwQkFBMEI7QUFDekQsK0JBQStCLHVCQUF1QjtBQUN0RCwrQkFBK0IsNkJBQTZCO0FBQzVELCtCQUErQiw4QkFBOEI7QUFDN0QsK0JBQStCLG9CQUFvQjtBQUNuRCwrQkFBK0Isb0JBQW9CO0FBQ25ELCtCQUErQix1QkFBdUI7QUFDdEQsK0JBQStCLG9CQUFvQjtBQUNuRCwrQkFBK0IsaUNBQWlDO0FBQ2hFLCtCQUErQixvQkFBb0I7QUFDbkQsZ0NBQWdDLG9CQUFvQjtBQUNwRCxnQ0FBZ0MsdUJBQXVCO0FBQ3ZELGdDQUFnQyxvQkFBb0I7QUFDcEQsZ0NBQWdDLGtDQUFrQztBQUNsRSxnQ0FBZ0Msb0JBQW9CO0FBQ3BELGdDQUFnQyxvQkFBb0I7QUFDcEQsZ0NBQWdDLHVCQUF1QjtBQUN2RCxnQ0FBZ0Msb0JBQW9COztBQUVwRDtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RCwrQkFBK0IsdUJBQXVCO0FBQ3RELCtCQUErQiw4QkFBOEI7QUFDN0QsK0JBQStCLDRCQUE0QjtBQUMzRCwrQkFBK0Isb0JBQW9CO0FBQ25ELCtCQUErQixvQkFBb0I7QUFDbkQsK0JBQStCLGdDQUFnQztBQUMvRCwrQkFBK0IsMEJBQTBCO0FBQ3pELCtCQUErQix1QkFBdUI7QUFDdEQsK0JBQStCLG9CQUFvQjtBQUNuRCxnQ0FBZ0MsK0JBQStCO0FBQy9ELGdDQUFnQyxvQkFBb0I7QUFDcEQsZ0NBQWdDLG9CQUFvQjtBQUNwRCxnQ0FBZ0MsZ0NBQWdDO0FBQ2hFLGdDQUFnQyw0QkFBNEI7QUFDNUQsZ0NBQWdDLHVCQUF1QjtBQUN2RCxnQ0FBZ0Msb0JBQW9CO0FBQ3BELGdDQUFnQywrQkFBK0I7QUFDL0QsZ0NBQWdDLG9CQUFvQjtBQUNwRCxnQ0FBZ0Msb0JBQW9CO0FBQ3BELGdDQUFnQyxnQ0FBZ0M7QUFDaEUsZ0NBQWdDLDRCQUE0QjtBQUM1RCxnQ0FBZ0MsdUJBQXVCO0FBQ3ZELGdDQUFnQyxvQkFBb0I7O0FBRXBEO0FBQ0E7QUFDQSwrQkFBK0IsOEJBQThCO0FBQzdELCtCQUErQixvQkFBb0I7QUFDbkQsK0JBQStCLG9CQUFvQjtBQUNuRCwrQkFBK0Isb0JBQW9CO0FBQ25ELCtCQUErQixvQkFBb0I7O0FBRW5EO0FBQ0E7QUFDQSwrQkFBK0IseUJBQXlCO0FBQ3hELCtCQUErQiwwQkFBMEI7QUFDekQsK0JBQStCLDJCQUEyQjtBQUMxRCwrQkFBK0IsMkJBQTJCOztBQUUxRDtBQUNBO0FBQ0EsK0JBQStCLHVCQUF1Qjs7QUFFdEQ7QUFDQTtBQUNBLCtCQUErQix1QkFBdUI7O0FBRXREO0FBQ0E7QUFDQSwrQkFBK0IsZ0NBQWdDO0FBQy9ELCtCQUErQiw0QkFBNEI7QUFDM0QsK0JBQStCLDJCQUEyQjtBQUMxRCwrQkFBK0IsNEJBQTRCO0FBQzNELCtCQUErQixvQkFBb0I7O0FBRW5EO0FBQ0E7QUFDQSwrQkFBK0Isc0JBQXNCOztBQUVyRDtBQUNBO0FBQ0EsK0JBQStCLDRCQUE0QjtBQUMzRCwrQkFBK0Isb0JBQW9CO0FBQ25ELCtCQUErQixvQkFBb0I7QUFDbkQsK0JBQStCLG9CQUFvQjs7QUFFbkQ7QUFDQTtBQUNBLCtCQUErQix1QkFBdUI7O0FBRXREO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCOztBQUV0RDtBQUNBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRCwrQkFBK0IsNEJBQTRCO0FBQzNELCtCQUErQiwyQkFBMkI7QUFDMUQsK0JBQStCLDRCQUE0QjtBQUMzRCwrQkFBK0Isb0JBQW9COztBQUVuRDtBQUNBO0FBQ0EsK0JBQStCLDRCQUE0QjtBQUMzRCwrQkFBK0Isb0JBQW9CO0FBQ25ELCtCQUErQixvQkFBb0I7QUFDbkQsK0JBQStCLG9CQUFvQjs7QUFFbkQ7QUFDQTtBQUNBLCtCQUErQix1QkFBdUI7O0FBRXREO0FBQ0E7QUFDQSwrQkFBK0IsZ0NBQWdDO0FBQy9ELCtCQUErQiw0QkFBNEI7QUFDM0QsK0JBQStCLDJCQUEyQjtBQUMxRCwrQkFBK0IsNEJBQTRCO0FBQzNELCtCQUErQixvQkFBb0I7O0FBRW5EO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCOztBQUV0RDtBQUNBO0FBQ0EsK0JBQStCLG9CQUFvQjs7QUFFbkQ7QUFDQTtBQUNBLCtCQUErQixvQkFBb0I7O0FBRW5EO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9COztBQUVuRDtBQUNBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRCwrQkFBK0IsMkJBQTJCOztBQUUxRDtBQUNBO0FBQ0EsK0JBQStCLG9CQUFvQjs7QUFFbkQ7QUFDQTtBQUNBLCtCQUErQixvQkFBb0I7O0FBRW5EO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9COztBQUVuRDtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RCwrQkFBK0IsdUJBQXVCO0FBQ3RELCtCQUErQix3QkFBd0I7O0FBRXZEO0FBQ0E7QUFDQSwrQkFBK0IsMEJBQTBCO0FBQ3pELCtCQUErQix1QkFBdUI7QUFDdEQsK0JBQStCLHdCQUF3Qjs7QUFFdkQ7QUFDQTtBQUNBLCtCQUErQiwwQkFBMEI7QUFDekQsK0JBQStCLHVCQUF1QjtBQUN0RCwrQkFBK0IsdUJBQXVCOztBQUV0RDtBQUNBO0FBQ0EsK0JBQStCLG9CQUFvQjs7QUFFbkQ7QUFDQTtBQUNBLCtCQUErQixvQkFBb0I7O0FBRW5EO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9COztBQUVuRDtBQUNBO0FBQ0EsK0JBQStCLG9CQUFvQjs7QUFFbkQ7QUFDQTtBQUNBLCtCQUErQixvQkFBb0I7O0FBRW5EO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9COztBQUVuRDtBQUNBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRCwrQkFBK0IsMkJBQTJCOztBQUUxRDtBQUNBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRCwrQkFBK0IsMkJBQTJCOztBQUUxRDtBQUNBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRCwrQkFBK0IsNEJBQTRCO0FBQzNELCtCQUErQiwyQkFBMkI7QUFDMUQsK0JBQStCLDJCQUEyQjtBQUMxRCwrQkFBK0IsNEJBQTRCOztBQUUzRDtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RCwrQkFBK0IsMEJBQTBCO0FBQ3pELCtCQUErQiw0QkFBNEI7QUFDM0QsK0JBQStCLDJCQUEyQjtBQUMxRCwrQkFBK0IsZ0NBQWdDO0FBQy9ELCtCQUErQiw4QkFBOEI7QUFDN0QsK0JBQStCLDRCQUE0QjtBQUMzRCwrQkFBK0IsMkJBQTJCO0FBQzFELCtCQUErQiwyQkFBMkI7QUFDMUQsK0JBQStCLHVCQUF1Qjs7QUFFdEQ7QUFDQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0QsK0JBQStCLG9CQUFvQjs7QUFFbkQ7QUFDQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0QsK0JBQStCLG9CQUFvQjs7QUFFbkQ7QUFDQTtBQUNBLCtCQUErQiw4QkFBOEI7QUFDN0QsK0JBQStCLHVCQUF1QjtBQUN0RCwrQkFBK0Isc0JBQXNCO0FBQ3JELCtCQUErQixvQkFBb0I7QUFDbkQsK0JBQStCLG9CQUFvQjs7QUFFbkQ7QUFDQTtBQUNBLCtCQUErQiwwQkFBMEI7QUFDekQsK0JBQStCLHVCQUF1QjtBQUN0RCwrQkFBK0IsZ0NBQWdDO0FBQy9ELCtCQUErQiwwQkFBMEI7QUFDekQsK0JBQStCLDRCQUE0QjtBQUMzRCwrQkFBK0Isc0JBQXNCOztBQUVyRDtBQUNBO0FBQ0EsK0JBQStCLDRCQUE0QjtBQUMzRCwrQkFBK0IsMEJBQTBCO0FBQ3pELCtCQUErQix1QkFBdUI7QUFDdEQsK0JBQStCLHVCQUF1Qjs7QUFFdEQ7QUFDQTtBQUNBLCtCQUErQiwwQkFBMEI7QUFDekQsK0JBQStCLDRCQUE0QjtBQUMzRCwrQkFBK0IsMEJBQTBCO0FBQ3pELCtCQUErQix1QkFBdUI7QUFDdEQsK0JBQStCLHVCQUF1QjtBQUN0RCwrQkFBK0IsMEJBQTBCO0FBQ3pELCtCQUErQix1QkFBdUI7QUFDdEQsK0JBQStCLHNCQUFzQjs7QUFFckQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGFBQWE7QUFDYixjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLG1CQUFtQjtBQUNuQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLG1CQUFtQjtBQUNuQixhQUFhO0FBQ2IsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixnQkFBZ0I7QUFDaEIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCLG1CQUFtQjtBQUNuQixnQkFBZ0I7QUFDaEIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLGdCQUFnQjtBQUNoQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsZ0JBQWdCO0FBQ2hCLG1CQUFtQjtBQUNuQixnQkFBZ0I7QUFDaEIsbUJBQW1CO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvc2FibmYtZ3JhbW1hci5qcz9kNjgwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWQ8YnI+XG4vLyAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpPGJyPlxuLy9cbi8vIEdlbmVyYXRlZCBieSBhcGctanMsIFZlcnNpb24gNC4wLjAgW2FwZy1qc10oaHR0cHM6Ly9naXRodWIuY29tL2xkdGhvbWFzL2FwZy1qcylcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ3JhbW1hcigpe1xuICAvLyBgYGBcbiAgLy8gU1VNTUFSWVxuICAvLyAgICAgIHJ1bGVzID0gOTVcbiAgLy8gICAgICAgdWR0cyA9IDBcbiAgLy8gICAgb3Bjb2RlcyA9IDM3MlxuICAvLyAgICAgICAgLS0tICAgQUJORiBvcmlnaW5hbCBvcGNvZGVzXG4gIC8vICAgICAgICBBTFQgPSA0M1xuICAvLyAgICAgICAgQ0FUID0gNDhcbiAgLy8gICAgICAgIFJFUCA9IDM0XG4gIC8vICAgICAgICBSTk0gPSAxNDlcbiAgLy8gICAgICAgIFRMUyA9IDJcbiAgLy8gICAgICAgIFRCUyA9IDYxXG4gIC8vICAgICAgICBUUkcgPSAzNVxuICAvLyAgICAgICAgLS0tICAgU0FCTkYgc3VwZXJzZXQgb3Bjb2Rlc1xuICAvLyAgICAgICAgVURUID0gMFxuICAvLyAgICAgICAgQU5EID0gMFxuICAvLyAgICAgICAgTk9UID0gMFxuICAvLyAgICAgICAgQktBID0gMFxuICAvLyAgICAgICAgQktOID0gMFxuICAvLyAgICAgICAgQktSID0gMFxuICAvLyAgICAgICAgQUJHID0gMFxuICAvLyAgICAgICAgQUVOID0gMFxuICAvLyBjaGFyYWN0ZXJzID0gWzkgLSAxMjZdXG4gIC8vIGBgYFxuICAvKiBPQkpFQ1QgSURFTlRJRklFUiAoZm9yIGludGVybmFsIHBhcnNlciB1c2UpICovXG4gIHRoaXMuZ3JhbW1hck9iamVjdCA9ICdncmFtbWFyT2JqZWN0JztcblxuICAvKiBSVUxFUyAqL1xuICB0aGlzLnJ1bGVzID0gW107XG4gIHRoaXMucnVsZXNbMF0gPSB7bmFtZTogJ0ZpbGUnLCBsb3dlcjogJ2ZpbGUnLCBpbmRleDogMCwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1sxXSA9IHtuYW1lOiAnQmxhbmtMaW5lJywgbG93ZXI6ICdibGFua2xpbmUnLCBpbmRleDogMSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1syXSA9IHtuYW1lOiAnUnVsZScsIGxvd2VyOiAncnVsZScsIGluZGV4OiAyLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzNdID0ge25hbWU6ICdSdWxlTG9va3VwJywgbG93ZXI6ICdydWxlbG9va3VwJywgaW5kZXg6IDMsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNF0gPSB7bmFtZTogJ1J1bGVOYW1lVGVzdCcsIGxvd2VyOiAncnVsZW5hbWV0ZXN0JywgaW5kZXg6IDQsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNV0gPSB7bmFtZTogJ1J1bGVOYW1lJywgbG93ZXI6ICdydWxlbmFtZScsIGluZGV4OiA1LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzZdID0ge25hbWU6ICdSdWxlTmFtZUVycm9yJywgbG93ZXI6ICdydWxlbmFtZWVycm9yJywgaW5kZXg6IDYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbN10gPSB7bmFtZTogJ0RlZmluZWRBc1Rlc3QnLCBsb3dlcjogJ2RlZmluZWRhc3Rlc3QnLCBpbmRleDogNywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s4XSA9IHtuYW1lOiAnRGVmaW5lZEFzRXJyb3InLCBsb3dlcjogJ2RlZmluZWRhc2Vycm9yJywgaW5kZXg6IDgsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbOV0gPSB7bmFtZTogJ0RlZmluZWRBcycsIGxvd2VyOiAnZGVmaW5lZGFzJywgaW5kZXg6IDksIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMTBdID0ge25hbWU6ICdEZWZpbmVkJywgbG93ZXI6ICdkZWZpbmVkJywgaW5kZXg6IDEwLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzExXSA9IHtuYW1lOiAnSW5jQWx0JywgbG93ZXI6ICdpbmNhbHQnLCBpbmRleDogMTEsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMTJdID0ge25hbWU6ICdSdWxlRXJyb3InLCBsb3dlcjogJ3J1bGVlcnJvcicsIGluZGV4OiAxMiwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1sxM10gPSB7bmFtZTogJ0xpbmVFbmRFcnJvcicsIGxvd2VyOiAnbGluZWVuZGVycm9yJywgaW5kZXg6IDEzLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzE0XSA9IHtuYW1lOiAnQWx0ZXJuYXRpb24nLCBsb3dlcjogJ2FsdGVybmF0aW9uJywgaW5kZXg6IDE0LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzE1XSA9IHtuYW1lOiAnQ29uY2F0ZW5hdGlvbicsIGxvd2VyOiAnY29uY2F0ZW5hdGlvbicsIGluZGV4OiAxNSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1sxNl0gPSB7bmFtZTogJ1JlcGV0aXRpb24nLCBsb3dlcjogJ3JlcGV0aXRpb24nLCBpbmRleDogMTYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMTddID0ge25hbWU6ICdNb2RpZmllcicsIGxvd2VyOiAnbW9kaWZpZXInLCBpbmRleDogMTcsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMThdID0ge25hbWU6ICdQcmVkaWNhdGUnLCBsb3dlcjogJ3ByZWRpY2F0ZScsIGluZGV4OiAxOCwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1sxOV0gPSB7bmFtZTogJ0Jhc2ljRWxlbWVudCcsIGxvd2VyOiAnYmFzaWNlbGVtZW50JywgaW5kZXg6IDE5LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzIwXSA9IHtuYW1lOiAnQmFzaWNFbGVtZW50RXJyJywgbG93ZXI6ICdiYXNpY2VsZW1lbnRlcnInLCBpbmRleDogMjAsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMjFdID0ge25hbWU6ICdHcm91cCcsIGxvd2VyOiAnZ3JvdXAnLCBpbmRleDogMjEsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMjJdID0ge25hbWU6ICdHcm91cEVycm9yJywgbG93ZXI6ICdncm91cGVycm9yJywgaW5kZXg6IDIyLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzIzXSA9IHtuYW1lOiAnR3JvdXBPcGVuJywgbG93ZXI6ICdncm91cG9wZW4nLCBpbmRleDogMjMsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMjRdID0ge25hbWU6ICdHcm91cENsb3NlJywgbG93ZXI6ICdncm91cGNsb3NlJywgaW5kZXg6IDI0LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzI1XSA9IHtuYW1lOiAnT3B0aW9uJywgbG93ZXI6ICdvcHRpb24nLCBpbmRleDogMjUsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMjZdID0ge25hbWU6ICdPcHRpb25FcnJvcicsIGxvd2VyOiAnb3B0aW9uZXJyb3InLCBpbmRleDogMjYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMjddID0ge25hbWU6ICdPcHRpb25PcGVuJywgbG93ZXI6ICdvcHRpb25vcGVuJywgaW5kZXg6IDI3LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzI4XSA9IHtuYW1lOiAnT3B0aW9uQ2xvc2UnLCBsb3dlcjogJ29wdGlvbmNsb3NlJywgaW5kZXg6IDI4LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzI5XSA9IHtuYW1lOiAnUm5tT3AnLCBsb3dlcjogJ3JubW9wJywgaW5kZXg6IDI5LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzMwXSA9IHtuYW1lOiAnQmtyT3AnLCBsb3dlcjogJ2Jrcm9wJywgaW5kZXg6IDMwLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzMxXSA9IHtuYW1lOiAnYmtyTW9kaWZpZXInLCBsb3dlcjogJ2Jrcm1vZGlmaWVyJywgaW5kZXg6IDMxLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzMyXSA9IHtuYW1lOiAnY3MnLCBsb3dlcjogJ2NzJywgaW5kZXg6IDMyLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzMzXSA9IHtuYW1lOiAnY2knLCBsb3dlcjogJ2NpJywgaW5kZXg6IDMzLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzM0XSA9IHtuYW1lOiAndW0nLCBsb3dlcjogJ3VtJywgaW5kZXg6IDM0LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzM1XSA9IHtuYW1lOiAncG0nLCBsb3dlcjogJ3BtJywgaW5kZXg6IDM1LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzM2XSA9IHtuYW1lOiAnYmtyLW5hbWUnLCBsb3dlcjogJ2Jrci1uYW1lJywgaW5kZXg6IDM2LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzM3XSA9IHtuYW1lOiAncm5hbWUnLCBsb3dlcjogJ3JuYW1lJywgaW5kZXg6IDM3LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzM4XSA9IHtuYW1lOiAndW5hbWUnLCBsb3dlcjogJ3VuYW1lJywgaW5kZXg6IDM4LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzM5XSA9IHtuYW1lOiAnZW5hbWUnLCBsb3dlcjogJ2VuYW1lJywgaW5kZXg6IDM5LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzQwXSA9IHtuYW1lOiAnVWR0T3AnLCBsb3dlcjogJ3VkdG9wJywgaW5kZXg6IDQwLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzQxXSA9IHtuYW1lOiAndWR0LW5vbi1lbXB0eScsIGxvd2VyOiAndWR0LW5vbi1lbXB0eScsIGluZGV4OiA0MSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s0Ml0gPSB7bmFtZTogJ3VkdC1lbXB0eScsIGxvd2VyOiAndWR0LWVtcHR5JywgaW5kZXg6IDQyLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzQzXSA9IHtuYW1lOiAnUmVwT3AnLCBsb3dlcjogJ3JlcG9wJywgaW5kZXg6IDQzLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzQ0XSA9IHtuYW1lOiAnQWx0T3AnLCBsb3dlcjogJ2FsdG9wJywgaW5kZXg6IDQ0LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzQ1XSA9IHtuYW1lOiAnQ2F0T3AnLCBsb3dlcjogJ2NhdG9wJywgaW5kZXg6IDQ1LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzQ2XSA9IHtuYW1lOiAnU3Rhck9wJywgbG93ZXI6ICdzdGFyb3AnLCBpbmRleDogNDYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNDddID0ge25hbWU6ICdBbmRPcCcsIGxvd2VyOiAnYW5kb3AnLCBpbmRleDogNDcsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNDhdID0ge25hbWU6ICdOb3RPcCcsIGxvd2VyOiAnbm90b3AnLCBpbmRleDogNDgsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNDldID0ge25hbWU6ICdCa2FPcCcsIGxvd2VyOiAnYmthb3AnLCBpbmRleDogNDksIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNTBdID0ge25hbWU6ICdCa25PcCcsIGxvd2VyOiAnYmtub3AnLCBpbmRleDogNTAsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNTFdID0ge25hbWU6ICdBYmdPcCcsIGxvd2VyOiAnYWJnb3AnLCBpbmRleDogNTEsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNTJdID0ge25hbWU6ICdBZW5PcCcsIGxvd2VyOiAnYWVub3AnLCBpbmRleDogNTIsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNTNdID0ge25hbWU6ICdUcmdPcCcsIGxvd2VyOiAndHJnb3AnLCBpbmRleDogNTMsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNTRdID0ge25hbWU6ICdUYnNPcCcsIGxvd2VyOiAndGJzb3AnLCBpbmRleDogNTQsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNTVdID0ge25hbWU6ICdUbHNPcCcsIGxvd2VyOiAndGxzb3AnLCBpbmRleDogNTUsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNTZdID0ge25hbWU6ICdUbHNDYXNlJywgbG93ZXI6ICd0bHNjYXNlJywgaW5kZXg6IDU2LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzU3XSA9IHtuYW1lOiAnVGxzT3BlbicsIGxvd2VyOiAndGxzb3BlbicsIGluZGV4OiA1NywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s1OF0gPSB7bmFtZTogJ1Rsc0Nsb3NlJywgbG93ZXI6ICd0bHNjbG9zZScsIGluZGV4OiA1OCwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s1OV0gPSB7bmFtZTogJ1Rsc1N0cmluZycsIGxvd2VyOiAndGxzc3RyaW5nJywgaW5kZXg6IDU5LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzYwXSA9IHtuYW1lOiAnU3RyaW5nVGFiJywgbG93ZXI6ICdzdHJpbmd0YWInLCBpbmRleDogNjAsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNjFdID0ge25hbWU6ICdDbHNPcCcsIGxvd2VyOiAnY2xzb3AnLCBpbmRleDogNjEsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNjJdID0ge25hbWU6ICdDbHNPcGVuJywgbG93ZXI6ICdjbHNvcGVuJywgaW5kZXg6IDYyLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzYzXSA9IHtuYW1lOiAnQ2xzQ2xvc2UnLCBsb3dlcjogJ2Nsc2Nsb3NlJywgaW5kZXg6IDYzLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzY0XSA9IHtuYW1lOiAnQ2xzU3RyaW5nJywgbG93ZXI6ICdjbHNzdHJpbmcnLCBpbmRleDogNjQsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNjVdID0ge25hbWU6ICdQcm9zVmFsJywgbG93ZXI6ICdwcm9zdmFsJywgaW5kZXg6IDY1LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzY2XSA9IHtuYW1lOiAnUHJvc1ZhbE9wZW4nLCBsb3dlcjogJ3Byb3N2YWxvcGVuJywgaW5kZXg6IDY2LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzY3XSA9IHtuYW1lOiAnUHJvc1ZhbFN0cmluZycsIGxvd2VyOiAncHJvc3ZhbHN0cmluZycsIGluZGV4OiA2NywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s2OF0gPSB7bmFtZTogJ1Byb3NWYWxDbG9zZScsIGxvd2VyOiAncHJvc3ZhbGNsb3NlJywgaW5kZXg6IDY4LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzY5XSA9IHtuYW1lOiAncmVwLW1pbicsIGxvd2VyOiAncmVwLW1pbicsIGluZGV4OiA2OSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s3MF0gPSB7bmFtZTogJ3JlcC1taW4tbWF4JywgbG93ZXI6ICdyZXAtbWluLW1heCcsIGluZGV4OiA3MCwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s3MV0gPSB7bmFtZTogJ3JlcC1tYXgnLCBsb3dlcjogJ3JlcC1tYXgnLCBpbmRleDogNzEsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNzJdID0ge25hbWU6ICdyZXAtbnVtJywgbG93ZXI6ICdyZXAtbnVtJywgaW5kZXg6IDcyLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzczXSA9IHtuYW1lOiAnZFN0cmluZycsIGxvd2VyOiAnZHN0cmluZycsIGluZGV4OiA3MywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s3NF0gPSB7bmFtZTogJ3hTdHJpbmcnLCBsb3dlcjogJ3hzdHJpbmcnLCBpbmRleDogNzQsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNzVdID0ge25hbWU6ICdiU3RyaW5nJywgbG93ZXI6ICdic3RyaW5nJywgaW5kZXg6IDc1LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzc2XSA9IHtuYW1lOiAnRGVjJywgbG93ZXI6ICdkZWMnLCBpbmRleDogNzYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNzddID0ge25hbWU6ICdIZXgnLCBsb3dlcjogJ2hleCcsIGluZGV4OiA3NywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s3OF0gPSB7bmFtZTogJ0JpbicsIGxvd2VyOiAnYmluJywgaW5kZXg6IDc4LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzc5XSA9IHtuYW1lOiAnZG1pbicsIGxvd2VyOiAnZG1pbicsIGluZGV4OiA3OSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s4MF0gPSB7bmFtZTogJ2RtYXgnLCBsb3dlcjogJ2RtYXgnLCBpbmRleDogODAsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbODFdID0ge25hbWU6ICdibWluJywgbG93ZXI6ICdibWluJywgaW5kZXg6IDgxLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzgyXSA9IHtuYW1lOiAnYm1heCcsIGxvd2VyOiAnYm1heCcsIGluZGV4OiA4MiwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s4M10gPSB7bmFtZTogJ3htaW4nLCBsb3dlcjogJ3htaW4nLCBpbmRleDogODMsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbODRdID0ge25hbWU6ICd4bWF4JywgbG93ZXI6ICd4bWF4JywgaW5kZXg6IDg0LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzg1XSA9IHtuYW1lOiAnZG51bScsIGxvd2VyOiAnZG51bScsIGluZGV4OiA4NSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s4Nl0gPSB7bmFtZTogJ2JudW0nLCBsb3dlcjogJ2JudW0nLCBpbmRleDogODYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbODddID0ge25hbWU6ICd4bnVtJywgbG93ZXI6ICd4bnVtJywgaW5kZXg6IDg3LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzg4XSA9IHtuYW1lOiAnYWxwaGFudW0nLCBsb3dlcjogJ2FscGhhbnVtJywgaW5kZXg6IDg4LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzg5XSA9IHtuYW1lOiAnb3dzcCcsIGxvd2VyOiAnb3dzcCcsIGluZGV4OiA4OSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s5MF0gPSB7bmFtZTogJ3dzcCcsIGxvd2VyOiAnd3NwJywgaW5kZXg6IDkwLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzkxXSA9IHtuYW1lOiAnc3BhY2UnLCBsb3dlcjogJ3NwYWNlJywgaW5kZXg6IDkxLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzkyXSA9IHtuYW1lOiAnY29tbWVudCcsIGxvd2VyOiAnY29tbWVudCcsIGluZGV4OiA5MiwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s5M10gPSB7bmFtZTogJ0xpbmVFbmQnLCBsb3dlcjogJ2xpbmVlbmQnLCBpbmRleDogOTMsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbOTRdID0ge25hbWU6ICdMaW5lQ29udGludWUnLCBsb3dlcjogJ2xpbmVjb250aW51ZScsIGluZGV4OiA5NCwgaXNCa3I6IGZhbHNlfTtcblxuICAvKiBVRFRTICovXG4gIHRoaXMudWR0cyA9IFtdO1xuXG4gIC8qIE9QQ09ERVMgKi9cbiAgLyogRmlsZSAqL1xuICB0aGlzLnJ1bGVzWzBdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1swXS5vcGNvZGVzWzBdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzIsMyw0XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogMX07Ly8gUk5NKEJsYW5rTGluZSlcbiAgdGhpcy5ydWxlc1swXS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiAyfTsvLyBSTk0oUnVsZSlcbiAgdGhpcy5ydWxlc1swXS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiAxMn07Ly8gUk5NKFJ1bGVFcnJvcilcblxuICAvKiBCbGFua0xpbmUgKi9cbiAgdGhpcy5ydWxlc1sxXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsNSw3XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMV0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzFdLm9wY29kZXNbMl0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFszLDRdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1sxXS5vcGNvZGVzWzNdID0ge3R5cGU6IDYsIHN0cmluZzogWzMyXX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbMV0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5XX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbMV0ub3Bjb2Rlc1s1XSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMV0ub3Bjb2Rlc1s2XSA9IHt0eXBlOiA0LCBpbmRleDogOTJ9Oy8vIFJOTShjb21tZW50KVxuICB0aGlzLnJ1bGVzWzFdLm9wY29kZXNbN10gPSB7dHlwZTogNCwgaW5kZXg6IDkzfTsvLyBSTk0oTGluZUVuZClcblxuICAvKiBSdWxlICovXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzJdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDIsMyw0XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogM307Ly8gUk5NKFJ1bGVMb29rdXApXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogODl9Oy8vIFJOTShvd3NwKVxuICB0aGlzLnJ1bGVzWzJdLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDE0fTsvLyBSTk0oQWx0ZXJuYXRpb24pXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzUsOF19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzJdLm9wY29kZXNbNV0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFs2LDddfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1syXS5vcGNvZGVzWzZdID0ge3R5cGU6IDQsIGluZGV4OiA4OX07Ly8gUk5NKG93c3ApXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1s3XSA9IHt0eXBlOiA0LCBpbmRleDogOTN9Oy8vIFJOTShMaW5lRW5kKVxuICB0aGlzLnJ1bGVzWzJdLm9wY29kZXNbOF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFs5LDEwXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1s5XSA9IHt0eXBlOiA0LCBpbmRleDogMTN9Oy8vIFJOTShMaW5lRW5kRXJyb3IpXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1sxMF0gPSB7dHlwZTogNCwgaW5kZXg6IDkzfTsvLyBSTk0oTGluZUVuZClcblxuICAvKiBSdWxlTG9va3VwICovXG4gIHRoaXMucnVsZXNbM10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzNdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDIsM119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzNdLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDR9Oy8vIFJOTShSdWxlTmFtZVRlc3QpXG4gIHRoaXMucnVsZXNbM10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogODl9Oy8vIFJOTShvd3NwKVxuICB0aGlzLnJ1bGVzWzNdLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDd9Oy8vIFJOTShEZWZpbmVkQXNUZXN0KVxuXG4gIC8qIFJ1bGVOYW1lVGVzdCAqL1xuICB0aGlzLnJ1bGVzWzRdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogNX07Ly8gUk5NKFJ1bGVOYW1lKVxuICB0aGlzLnJ1bGVzWzRdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDZ9Oy8vIFJOTShSdWxlTmFtZUVycm9yKVxuXG4gIC8qIFJ1bGVOYW1lICovXG4gIHRoaXMucnVsZXNbNV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzVdLm9wY29kZXNbMF0gPSB7dHlwZTogNCwgaW5kZXg6IDg4fTsvLyBSTk0oYWxwaGFudW0pXG5cbiAgLyogUnVsZU5hbWVFcnJvciAqL1xuICB0aGlzLnJ1bGVzWzZdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2XS5vcGNvZGVzWzBdID0ge3R5cGU6IDMsIG1pbjogMSwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbNl0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzIsM119Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzZdLm9wY29kZXNbMl0gPSB7dHlwZTogNSwgbWluOiAzMywgbWF4OiA2MH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbNl0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA1LCBtaW46IDYyLCBtYXg6IDEyNn07Ly8gVFJHXG5cbiAgLyogRGVmaW5lZEFzVGVzdCAqL1xuICB0aGlzLnJ1bGVzWzddLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s3XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbN10ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogOX07Ly8gUk5NKERlZmluZWRBcylcbiAgdGhpcy5ydWxlc1s3XS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiA4fTsvLyBSTk0oRGVmaW5lZEFzRXJyb3IpXG5cbiAgLyogRGVmaW5lZEFzRXJyb3IgKi9cbiAgdGhpcy5ydWxlc1s4XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbOF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDEsIG1heDogMn07Ly8gUkVQXG4gIHRoaXMucnVsZXNbOF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA1LCBtaW46IDMzLCBtYXg6IDEyNn07Ly8gVFJHXG5cbiAgLyogRGVmaW5lZEFzICovXG4gIHRoaXMucnVsZXNbOV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzldLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDJdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s5XS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiAxMX07Ly8gUk5NKEluY0FsdClcbiAgdGhpcy5ydWxlc1s5XS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiAxMH07Ly8gUk5NKERlZmluZWQpXG5cbiAgLyogRGVmaW5lZCAqL1xuICB0aGlzLnJ1bGVzWzEwXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMTBdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNjFdfTsvLyBUQlNcblxuICAvKiBJbmNBbHQgKi9cbiAgdGhpcy5ydWxlc1sxMV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzExXS5vcGNvZGVzWzBdID0ge3R5cGU6IDYsIHN0cmluZzogWzYxLDQ3XX07Ly8gVEJTXG5cbiAgLyogUnVsZUVycm9yICovXG4gIHRoaXMucnVsZXNbMTJdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1sxMl0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsNl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzEyXS5vcGNvZGVzWzFdID0ge3R5cGU6IDMsIG1pbjogMSwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMTJdLm9wY29kZXNbMl0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFszLDQsNV19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzEyXS5vcGNvZGVzWzNdID0ge3R5cGU6IDUsIG1pbjogMzIsIG1heDogMTI2fTsvLyBUUkdcbiAgdGhpcy5ydWxlc1sxMl0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5XX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbMTJdLm9wY29kZXNbNV0gPSB7dHlwZTogNCwgaW5kZXg6IDk0fTsvLyBSTk0oTGluZUNvbnRpbnVlKVxuICB0aGlzLnJ1bGVzWzEyXS5vcGNvZGVzWzZdID0ge3R5cGU6IDQsIGluZGV4OiA5M307Ly8gUk5NKExpbmVFbmQpXG5cbiAgLyogTGluZUVuZEVycm9yICovXG4gIHRoaXMucnVsZXNbMTNdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1sxM10ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDEsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzEzXS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDRdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1sxM10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA1LCBtaW46IDMyLCBtYXg6IDEyNn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbMTNdLm9wY29kZXNbM10gPSB7dHlwZTogNiwgc3RyaW5nOiBbOV19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzEzXS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiA5NH07Ly8gUk5NKExpbmVDb250aW51ZSlcblxuICAvKiBBbHRlcm5hdGlvbiAqL1xuICB0aGlzLnJ1bGVzWzE0XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMTRdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1sxNF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogMTV9Oy8vIFJOTShDb25jYXRlbmF0aW9uKVxuICB0aGlzLnJ1bGVzWzE0XS5vcGNvZGVzWzJdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMTRdLm9wY29kZXNbM10gPSB7dHlwZTogMiwgY2hpbGRyZW46IFs0LDUsNl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzE0XS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiA4OX07Ly8gUk5NKG93c3ApXG4gIHRoaXMucnVsZXNbMTRdLm9wY29kZXNbNV0gPSB7dHlwZTogNCwgaW5kZXg6IDQ0fTsvLyBSTk0oQWx0T3ApXG4gIHRoaXMucnVsZXNbMTRdLm9wY29kZXNbNl0gPSB7dHlwZTogNCwgaW5kZXg6IDE1fTsvLyBSTk0oQ29uY2F0ZW5hdGlvbilcblxuICAvKiBDb25jYXRlbmF0aW9uICovXG4gIHRoaXMucnVsZXNbMTVdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1sxNV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzE1XS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiAxNn07Ly8gUk5NKFJlcGV0aXRpb24pXG4gIHRoaXMucnVsZXNbMTVdLm9wY29kZXNbMl0gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1sxNV0ub3Bjb2Rlc1szXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzQsNV19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzE1XS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiA0NX07Ly8gUk5NKENhdE9wKVxuICB0aGlzLnJ1bGVzWzE1XS5vcGNvZGVzWzVdID0ge3R5cGU6IDQsIGluZGV4OiAxNn07Ly8gUk5NKFJlcGV0aXRpb24pXG5cbiAgLyogUmVwZXRpdGlvbiAqL1xuICB0aGlzLnJ1bGVzWzE2XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMTZdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDNdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1sxNl0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMTZdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDE3fTsvLyBSTk0oTW9kaWZpZXIpXG4gIHRoaXMucnVsZXNbMTZdLm9wY29kZXNbM10gPSB7dHlwZTogMSwgY2hpbGRyZW46IFs0LDUsNiw3XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMTZdLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDIxfTsvLyBSTk0oR3JvdXApXG4gIHRoaXMucnVsZXNbMTZdLm9wY29kZXNbNV0gPSB7dHlwZTogNCwgaW5kZXg6IDI1fTsvLyBSTk0oT3B0aW9uKVxuICB0aGlzLnJ1bGVzWzE2XS5vcGNvZGVzWzZdID0ge3R5cGU6IDQsIGluZGV4OiAxOX07Ly8gUk5NKEJhc2ljRWxlbWVudClcbiAgdGhpcy5ydWxlc1sxNl0ub3Bjb2Rlc1s3XSA9IHt0eXBlOiA0LCBpbmRleDogMjB9Oy8vIFJOTShCYXNpY0VsZW1lbnRFcnIpXG5cbiAgLyogTW9kaWZpZXIgKi9cbiAgdGhpcy5ydWxlc1sxN10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzE3XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSw1XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMTddLm9wY29kZXNbMV0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsyLDNdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1sxN10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogMTh9Oy8vIFJOTShQcmVkaWNhdGUpXG4gIHRoaXMucnVsZXNbMTddLm9wY29kZXNbM10gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IDF9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzE3XS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiA0M307Ly8gUk5NKFJlcE9wKVxuICB0aGlzLnJ1bGVzWzE3XS5vcGNvZGVzWzVdID0ge3R5cGU6IDQsIGluZGV4OiA0M307Ly8gUk5NKFJlcE9wKVxuXG4gIC8qIFByZWRpY2F0ZSAqL1xuICB0aGlzLnJ1bGVzWzE4XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMThdLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDIsMyw0XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMThdLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDQ5fTsvLyBSTk0oQmthT3ApXG4gIHRoaXMucnVsZXNbMThdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDUwfTsvLyBSTk0oQmtuT3ApXG4gIHRoaXMucnVsZXNbMThdLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDQ3fTsvLyBSTk0oQW5kT3ApXG4gIHRoaXMucnVsZXNbMThdLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDQ4fTsvLyBSTk0oTm90T3ApXG5cbiAgLyogQmFzaWNFbGVtZW50ICovXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1sxOV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzEsMiwzLDQsNSw2LDcsOCw5LDEwXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDQwfTsvLyBSTk0oVWR0T3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDI5fTsvLyBSTk0oUm5tT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDUzfTsvLyBSTk0oVHJnT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDU0fTsvLyBSTk0oVGJzT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbNV0gPSB7dHlwZTogNCwgaW5kZXg6IDU1fTsvLyBSTk0oVGxzT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbNl0gPSB7dHlwZTogNCwgaW5kZXg6IDYxfTsvLyBSTk0oQ2xzT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbN10gPSB7dHlwZTogNCwgaW5kZXg6IDMwfTsvLyBSTk0oQmtyT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbOF0gPSB7dHlwZTogNCwgaW5kZXg6IDUxfTsvLyBSTk0oQWJnT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbOV0gPSB7dHlwZTogNCwgaW5kZXg6IDUyfTsvLyBSTk0oQWVuT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbMTBdID0ge3R5cGU6IDQsIGluZGV4OiA2NX07Ly8gUk5NKFByb3NWYWwpXG5cbiAgLyogQmFzaWNFbGVtZW50RXJyICovXG4gIHRoaXMucnVsZXNbMjBdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1syMF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDEsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzIwXS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDQsNV19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzIwXS5vcGNvZGVzWzJdID0ge3R5cGU6IDUsIG1pbjogMzMsIG1heDogNDB9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzIwXS5vcGNvZGVzWzNdID0ge3R5cGU6IDUsIG1pbjogNDIsIG1heDogNDZ9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzIwXS5vcGNvZGVzWzRdID0ge3R5cGU6IDUsIG1pbjogNDgsIG1heDogOTJ9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzIwXS5vcGNvZGVzWzVdID0ge3R5cGU6IDUsIG1pbjogOTQsIG1heDogMTI2fTsvLyBUUkdcblxuICAvKiBHcm91cCAqL1xuICB0aGlzLnJ1bGVzWzIxXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMjFdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDIsM119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzIxXS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiAyM307Ly8gUk5NKEdyb3VwT3BlbilcbiAgdGhpcy5ydWxlc1syMV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogMTR9Oy8vIFJOTShBbHRlcm5hdGlvbilcbiAgdGhpcy5ydWxlc1syMV0ub3Bjb2Rlc1szXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzQsNV19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzIxXS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiAyNH07Ly8gUk5NKEdyb3VwQ2xvc2UpXG4gIHRoaXMucnVsZXNbMjFdLm9wY29kZXNbNV0gPSB7dHlwZTogNCwgaW5kZXg6IDIyfTsvLyBSTk0oR3JvdXBFcnJvcilcblxuICAvKiBHcm91cEVycm9yICovXG4gIHRoaXMucnVsZXNbMjJdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1syMl0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDEsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzIyXS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDQsNV19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzIyXS5vcGNvZGVzWzJdID0ge3R5cGU6IDUsIG1pbjogMzMsIG1heDogNDB9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzIyXS5vcGNvZGVzWzNdID0ge3R5cGU6IDUsIG1pbjogNDIsIG1heDogNDZ9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzIyXS5vcGNvZGVzWzRdID0ge3R5cGU6IDUsIG1pbjogNDgsIG1heDogOTJ9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzIyXS5vcGNvZGVzWzVdID0ge3R5cGU6IDUsIG1pbjogOTQsIG1heDogMTI2fTsvLyBUUkdcblxuICAvKiBHcm91cE9wZW4gKi9cbiAgdGhpcy5ydWxlc1syM10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzIzXS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMjNdLm9wY29kZXNbMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDBdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1syM10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogODl9Oy8vIFJOTShvd3NwKVxuXG4gIC8qIEdyb3VwQ2xvc2UgKi9cbiAgdGhpcy5ydWxlc1syNF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzI0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMjRdLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDg5fTsvLyBSTk0ob3dzcClcbiAgdGhpcy5ydWxlc1syNF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs0MV19Oy8vIFRCU1xuXG4gIC8qIE9wdGlvbiAqL1xuICB0aGlzLnJ1bGVzWzI1XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMjVdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDIsM119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzI1XS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiAyN307Ly8gUk5NKE9wdGlvbk9wZW4pXG4gIHRoaXMucnVsZXNbMjVdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDE0fTsvLyBSTk0oQWx0ZXJuYXRpb24pXG4gIHRoaXMucnVsZXNbMjVdLm9wY29kZXNbM10gPSB7dHlwZTogMSwgY2hpbGRyZW46IFs0LDVdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1syNV0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA0LCBpbmRleDogMjh9Oy8vIFJOTShPcHRpb25DbG9zZSlcbiAgdGhpcy5ydWxlc1syNV0ub3Bjb2Rlc1s1XSA9IHt0eXBlOiA0LCBpbmRleDogMjZ9Oy8vIFJOTShPcHRpb25FcnJvcilcblxuICAvKiBPcHRpb25FcnJvciAqL1xuICB0aGlzLnJ1bGVzWzI2XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMjZdLm9wY29kZXNbMF0gPSB7dHlwZTogMywgbWluOiAxLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1syNl0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzIsMyw0LDVdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1syNl0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA1LCBtaW46IDMzLCBtYXg6IDQwfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1syNl0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA1LCBtaW46IDQyLCBtYXg6IDQ2fTsvLyBUUkdcbiAgdGhpcy5ydWxlc1syNl0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA1LCBtaW46IDQ4LCBtYXg6IDkyfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1syNl0ub3Bjb2Rlc1s1XSA9IHt0eXBlOiA1LCBtaW46IDk0LCBtYXg6IDEyNn07Ly8gVFJHXG5cbiAgLyogT3B0aW9uT3BlbiAqL1xuICB0aGlzLnJ1bGVzWzI3XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMjddLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1syN10ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5MV19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzI3XS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiA4OX07Ly8gUk5NKG93c3ApXG5cbiAgLyogT3B0aW9uQ2xvc2UgKi9cbiAgdGhpcy5ydWxlc1syOF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzI4XS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMjhdLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDg5fTsvLyBSTk0ob3dzcClcbiAgdGhpcy5ydWxlc1syOF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5M119Oy8vIFRCU1xuXG4gIC8qIFJubU9wICovXG4gIHRoaXMucnVsZXNbMjldLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1syOV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogODh9Oy8vIFJOTShhbHBoYW51bSlcblxuICAvKiBCa3JPcCAqL1xuICB0aGlzLnJ1bGVzWzMwXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMzBdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDIsNF19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzMwXS5vcGNvZGVzWzFdID0ge3R5cGU6IDYsIHN0cmluZzogWzkyXX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbMzBdLm9wY29kZXNbMl0gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IDF9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzMwXS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiAzMX07Ly8gUk5NKGJrck1vZGlmaWVyKVxuICB0aGlzLnJ1bGVzWzMwXS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiAzNn07Ly8gUk5NKGJrci1uYW1lKVxuXG4gIC8qIGJrck1vZGlmaWVyICovXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzEsNywxMywxOV19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzFdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMiwzXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDMyfTsvLyBSTk0oY3MpXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbM10gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IDF9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzRdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbNSw2XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbNV0gPSB7dHlwZTogNCwgaW5kZXg6IDM0fTsvLyBSTk0odW0pXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbNl0gPSB7dHlwZTogNCwgaW5kZXg6IDM1fTsvLyBSTk0ocG0pXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbN10gPSB7dHlwZTogMiwgY2hpbGRyZW46IFs4LDldfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1s4XSA9IHt0eXBlOiA0LCBpbmRleDogMzN9Oy8vIFJOTShjaSlcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1s5XSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMTBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMTEsMTJdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1sxMV0gPSB7dHlwZTogNCwgaW5kZXg6IDM0fTsvLyBSTk0odW0pXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMTJdID0ge3R5cGU6IDQsIGluZGV4OiAzNX07Ly8gUk5NKHBtKVxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzEzXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzE0LDE1XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMTRdID0ge3R5cGU6IDQsIGluZGV4OiAzNH07Ly8gUk5NKHVtKVxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzE1XSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMTZdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMTcsMThdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1sxN10gPSB7dHlwZTogNCwgaW5kZXg6IDMyfTsvLyBSTk0oY3MpXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMThdID0ge3R5cGU6IDQsIGluZGV4OiAzM307Ly8gUk5NKGNpKVxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzE5XSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzIwLDIxXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMjBdID0ge3R5cGU6IDQsIGluZGV4OiAzNX07Ly8gUk5NKHBtKVxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzIxXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMjJdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMjMsMjRdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1syM10gPSB7dHlwZTogNCwgaW5kZXg6IDMyfTsvLyBSTk0oY3MpXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMjRdID0ge3R5cGU6IDQsIGluZGV4OiAzM307Ly8gUk5NKGNpKVxuXG4gIC8qIGNzICovXG4gIHRoaXMucnVsZXNbMzJdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szMl0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszNywxMTVdfTsvLyBUQlNcblxuICAvKiBjaSAqL1xuICB0aGlzLnJ1bGVzWzMzXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMzNdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzcsMTA1XX07Ly8gVEJTXG5cbiAgLyogdW0gKi9cbiAgdGhpcy5ydWxlc1szNF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzM0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDYsIHN0cmluZzogWzM3LDExN119Oy8vIFRCU1xuXG4gIC8qIHBtICovXG4gIHRoaXMucnVsZXNbMzVdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szNV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszNywxMTJdfTsvLyBUQlNcblxuICAvKiBia3ItbmFtZSAqL1xuICB0aGlzLnJ1bGVzWzM2XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMzZdLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDIsM119Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzM2XS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiAzOH07Ly8gUk5NKHVuYW1lKVxuICB0aGlzLnJ1bGVzWzM2XS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiAzOX07Ly8gUk5NKGVuYW1lKVxuICB0aGlzLnJ1bGVzWzM2XS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiAzN307Ly8gUk5NKHJuYW1lKVxuXG4gIC8qIHJuYW1lICovXG4gIHRoaXMucnVsZXNbMzddLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szN10ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogODh9Oy8vIFJOTShhbHBoYW51bSlcblxuICAvKiB1bmFtZSAqL1xuICB0aGlzLnJ1bGVzWzM4XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMzhdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1szOF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxMTcsOTVdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1szOF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogODh9Oy8vIFJOTShhbHBoYW51bSlcblxuICAvKiBlbmFtZSAqL1xuICB0aGlzLnJ1bGVzWzM5XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMzldLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1szOV0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxMDEsOTVdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1szOV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogODh9Oy8vIFJOTShhbHBoYW51bSlcblxuICAvKiBVZHRPcCAqL1xuICB0aGlzLnJ1bGVzWzQwXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDBdLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDJdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s0MF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogNDJ9Oy8vIFJOTSh1ZHQtZW1wdHkpXG4gIHRoaXMucnVsZXNbNDBdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDQxfTsvLyBSTk0odWR0LW5vbi1lbXB0eSlcblxuICAvKiB1ZHQtbm9uLWVtcHR5ICovXG4gIHRoaXMucnVsZXNbNDFdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0MV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzQxXS5vcGNvZGVzWzFdID0ge3R5cGU6IDYsIHN0cmluZzogWzExNyw5NV19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzQxXS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiA4OH07Ly8gUk5NKGFscGhhbnVtKVxuXG4gIC8qIHVkdC1lbXB0eSAqL1xuICB0aGlzLnJ1bGVzWzQyXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDJdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s0Ml0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxMDEsOTVdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s0Ml0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogODh9Oy8vIFJOTShhbHBoYW51bSlcblxuICAvKiBSZXBPcCAqL1xuICB0aGlzLnJ1bGVzWzQzXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDUsOCwxMSwxMl19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzQzXS5vcGNvZGVzWzFdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMiwzLDRdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s0M10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogNjl9Oy8vIFJOTShyZXAtbWluKVxuICB0aGlzLnJ1bGVzWzQzXS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiA0Nn07Ly8gUk5NKFN0YXJPcClcbiAgdGhpcy5ydWxlc1s0M10ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA0LCBpbmRleDogNzF9Oy8vIFJOTShyZXAtbWF4KVxuICB0aGlzLnJ1bGVzWzQzXS5vcGNvZGVzWzVdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbNiw3XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbNl0gPSB7dHlwZTogNCwgaW5kZXg6IDY5fTsvLyBSTk0ocmVwLW1pbilcbiAgdGhpcy5ydWxlc1s0M10ub3Bjb2Rlc1s3XSA9IHt0eXBlOiA0LCBpbmRleDogNDZ9Oy8vIFJOTShTdGFyT3ApXG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbOF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFs5LDEwXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbOV0gPSB7dHlwZTogNCwgaW5kZXg6IDQ2fTsvLyBSTk0oU3Rhck9wKVxuICB0aGlzLnJ1bGVzWzQzXS5vcGNvZGVzWzEwXSA9IHt0eXBlOiA0LCBpbmRleDogNzF9Oy8vIFJOTShyZXAtbWF4KVxuICB0aGlzLnJ1bGVzWzQzXS5vcGNvZGVzWzExXSA9IHt0eXBlOiA0LCBpbmRleDogNDZ9Oy8vIFJOTShTdGFyT3ApXG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbMTJdID0ge3R5cGU6IDQsIGluZGV4OiA3MH07Ly8gUk5NKHJlcC1taW4tbWF4KVxuXG4gIC8qIEFsdE9wICovXG4gIHRoaXMucnVsZXNbNDRdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0NF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzQ0XS5vcGNvZGVzWzFdID0ge3R5cGU6IDYsIHN0cmluZzogWzQ3XX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbNDRdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDg5fTsvLyBSTk0ob3dzcClcblxuICAvKiBDYXRPcCAqL1xuICB0aGlzLnJ1bGVzWzQ1XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDVdLm9wY29kZXNbMF0gPSB7dHlwZTogNCwgaW5kZXg6IDkwfTsvLyBSTk0od3NwKVxuXG4gIC8qIFN0YXJPcCAqL1xuICB0aGlzLnJ1bGVzWzQ2XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDZdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDJdfTsvLyBUQlNcblxuICAvKiBBbmRPcCAqL1xuICB0aGlzLnJ1bGVzWzQ3XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDddLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzhdfTsvLyBUQlNcblxuICAvKiBOb3RPcCAqL1xuICB0aGlzLnJ1bGVzWzQ4XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDhdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzNdfTsvLyBUQlNcblxuICAvKiBCa2FPcCAqL1xuICB0aGlzLnJ1bGVzWzQ5XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDldLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzgsMzhdfTsvLyBUQlNcblxuICAvKiBCa25PcCAqL1xuICB0aGlzLnJ1bGVzWzUwXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNTBdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzMsMzNdfTsvLyBUQlNcblxuICAvKiBBYmdPcCAqL1xuICB0aGlzLnJ1bGVzWzUxXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNTFdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzcsOTRdfTsvLyBUQlNcblxuICAvKiBBZW5PcCAqL1xuICB0aGlzLnJ1bGVzWzUyXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNTJdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzcsMzZdfTsvLyBUQlNcblxuICAvKiBUcmdPcCAqL1xuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszN119Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzJdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMyw4LDEzXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbM10gPSB7dHlwZTogMiwgY2hpbGRyZW46IFs0LDUsNiw3XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDc2fTsvLyBSTk0oRGVjKVxuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzVdID0ge3R5cGU6IDQsIGluZGV4OiA3OX07Ly8gUk5NKGRtaW4pXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbNl0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDVdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1s3XSA9IHt0eXBlOiA0LCBpbmRleDogODB9Oy8vIFJOTShkbWF4KVxuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzhdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbOSwxMCwxMSwxMl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzldID0ge3R5cGU6IDQsIGluZGV4OiA3N307Ly8gUk5NKEhleClcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1sxMF0gPSB7dHlwZTogNCwgaW5kZXg6IDgzfTsvLyBSTk0oeG1pbilcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1sxMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDVdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1sxMl0gPSB7dHlwZTogNCwgaW5kZXg6IDg0fTsvLyBSTk0oeG1heClcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1sxM10gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxNCwxNSwxNiwxN119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzE0XSA9IHt0eXBlOiA0LCBpbmRleDogNzh9Oy8vIFJOTShCaW4pXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbMTVdID0ge3R5cGU6IDQsIGluZGV4OiA4MX07Ly8gUk5NKGJtaW4pXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbMTZdID0ge3R5cGU6IDYsIHN0cmluZzogWzQ1XX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbMTddID0ge3R5cGU6IDQsIGluZGV4OiA4Mn07Ly8gUk5NKGJtYXgpXG5cbiAgLyogVGJzT3AgKi9cbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzddfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzMsMTAsMTddfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1szXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzQsNSw2XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDc2fTsvLyBSTk0oRGVjKVxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzVdID0ge3R5cGU6IDQsIGluZGV4OiA3M307Ly8gUk5NKGRTdHJpbmcpXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbNl0gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1s3XSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzgsOV19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzhdID0ge3R5cGU6IDYsIHN0cmluZzogWzQ2XX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbOV0gPSB7dHlwZTogNCwgaW5kZXg6IDczfTsvLyBSTk0oZFN0cmluZylcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1sxMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxMSwxMiwxM119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzExXSA9IHt0eXBlOiA0LCBpbmRleDogNzd9Oy8vIFJOTShIZXgpXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMTJdID0ge3R5cGU6IDQsIGluZGV4OiA3NH07Ly8gUk5NKHhTdHJpbmcpXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMTNdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMTRdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMTUsMTZdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1sxNV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDZdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1sxNl0gPSB7dHlwZTogNCwgaW5kZXg6IDc0fTsvLyBSTk0oeFN0cmluZylcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1sxN10gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxOCwxOSwyMF19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzE4XSA9IHt0eXBlOiA0LCBpbmRleDogNzh9Oy8vIFJOTShCaW4pXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMTldID0ge3R5cGU6IDQsIGluZGV4OiA3NX07Ly8gUk5NKGJTdHJpbmcpXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMjBdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMjFdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMjIsMjNdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1syMl0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDZdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1syM10gPSB7dHlwZTogNCwgaW5kZXg6IDc1fTsvLyBSTk0oYlN0cmluZylcblxuICAvKiBUbHNPcCAqL1xuICB0aGlzLnJ1bGVzWzU1XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNTVdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDIsMyw0XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNTVdLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDU2fTsvLyBSTk0oVGxzQ2FzZSlcbiAgdGhpcy5ydWxlc1s1NV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogNTd9Oy8vIFJOTShUbHNPcGVuKVxuICB0aGlzLnJ1bGVzWzU1XS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiA1OX07Ly8gUk5NKFRsc1N0cmluZylcbiAgdGhpcy5ydWxlc1s1NV0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA0LCBpbmRleDogNTh9Oy8vIFJOTShUbHNDbG9zZSlcblxuICAvKiBUbHNDYXNlICovXG4gIHRoaXMucnVsZXNbNTZdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s1Nl0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbNTZdLm9wY29kZXNbMV0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsyLDNdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s1Nl0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA3LCBzdHJpbmc6IFszNywxMDVdfTsvLyBUTFNcbiAgdGhpcy5ydWxlc1s1Nl0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA3LCBzdHJpbmc6IFszNywxMTVdfTsvLyBUTFNcblxuICAvKiBUbHNPcGVuICovXG4gIHRoaXMucnVsZXNbNTddLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s1N10ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszNF19Oy8vIFRCU1xuXG4gIC8qIFRsc0Nsb3NlICovXG4gIHRoaXMucnVsZXNbNThdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s1OF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszNF19Oy8vIFRCU1xuXG4gIC8qIFRsc1N0cmluZyAqL1xuICB0aGlzLnJ1bGVzWzU5XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNTldLm9wY29kZXNbMF0gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s1OV0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzIsMyw0XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNTldLm9wY29kZXNbMl0gPSB7dHlwZTogNSwgbWluOiAzMiwgbWF4OiAzM307Ly8gVFJHXG4gIHRoaXMucnVsZXNbNTldLm9wY29kZXNbM10gPSB7dHlwZTogNSwgbWluOiAzNSwgbWF4OiAxMjZ9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzU5XS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiA2MH07Ly8gUk5NKFN0cmluZ1RhYilcblxuICAvKiBTdHJpbmdUYWIgKi9cbiAgdGhpcy5ydWxlc1s2MF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzYwXS5vcGNvZGVzWzBdID0ge3R5cGU6IDYsIHN0cmluZzogWzldfTsvLyBUQlNcblxuICAvKiBDbHNPcCAqL1xuICB0aGlzLnJ1bGVzWzYxXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNjFdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDIsM119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzYxXS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiA2Mn07Ly8gUk5NKENsc09wZW4pXG4gIHRoaXMucnVsZXNbNjFdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDY0fTsvLyBSTk0oQ2xzU3RyaW5nKVxuICB0aGlzLnJ1bGVzWzYxXS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiA2M307Ly8gUk5NKENsc0Nsb3NlKVxuXG4gIC8qIENsc09wZW4gKi9cbiAgdGhpcy5ydWxlc1s2Ml0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzYyXS5vcGNvZGVzWzBdID0ge3R5cGU6IDYsIHN0cmluZzogWzM5XX07Ly8gVEJTXG5cbiAgLyogQ2xzQ2xvc2UgKi9cbiAgdGhpcy5ydWxlc1s2M10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzYzXS5vcGNvZGVzWzBdID0ge3R5cGU6IDYsIHN0cmluZzogWzM5XX07Ly8gVEJTXG5cbiAgLyogQ2xzU3RyaW5nICovXG4gIHRoaXMucnVsZXNbNjRdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2NF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzY0XS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDRdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s2NF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA1LCBtaW46IDMyLCBtYXg6IDM4fTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s2NF0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA1LCBtaW46IDQwLCBtYXg6IDEyNn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbNjRdLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDYwfTsvLyBSTk0oU3RyaW5nVGFiKVxuXG4gIC8qIFByb3NWYWwgKi9cbiAgdGhpcy5ydWxlc1s2NV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzY1XS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSwyLDNdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s2NV0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogNjZ9Oy8vIFJOTShQcm9zVmFsT3BlbilcbiAgdGhpcy5ydWxlc1s2NV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogNjd9Oy8vIFJOTShQcm9zVmFsU3RyaW5nKVxuICB0aGlzLnJ1bGVzWzY1XS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiA2OH07Ly8gUk5NKFByb3NWYWxDbG9zZSlcblxuICAvKiBQcm9zVmFsT3BlbiAqL1xuICB0aGlzLnJ1bGVzWzY2XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNjZdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNjBdfTsvLyBUQlNcblxuICAvKiBQcm9zVmFsU3RyaW5nICovXG4gIHRoaXMucnVsZXNbNjddLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2N10ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzY3XS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDRdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s2N10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA1LCBtaW46IDMyLCBtYXg6IDYxfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s2N10ub3Bjb2Rlc1szXSA9IHt0eXBlOiA1LCBtaW46IDYzLCBtYXg6IDEyNn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbNjddLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDYwfTsvLyBSTk0oU3RyaW5nVGFiKVxuXG4gIC8qIFByb3NWYWxDbG9zZSAqL1xuICB0aGlzLnJ1bGVzWzY4XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNjhdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNjJdfTsvLyBUQlNcblxuICAvKiByZXAtbWluICovXG4gIHRoaXMucnVsZXNbNjldLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2OV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogNzJ9Oy8vIFJOTShyZXAtbnVtKVxuXG4gIC8qIHJlcC1taW4tbWF4ICovXG4gIHRoaXMucnVsZXNbNzBdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s3MF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogNzJ9Oy8vIFJOTShyZXAtbnVtKVxuXG4gIC8qIHJlcC1tYXggKi9cbiAgdGhpcy5ydWxlc1s3MV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzcxXS5vcGNvZGVzWzBdID0ge3R5cGU6IDQsIGluZGV4OiA3Mn07Ly8gUk5NKHJlcC1udW0pXG5cbiAgLyogcmVwLW51bSAqL1xuICB0aGlzLnJ1bGVzWzcyXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNzJdLm9wY29kZXNbMF0gPSB7dHlwZTogMywgbWluOiAxLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s3Ml0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA1LCBtaW46IDQ4LCBtYXg6IDU3fTsvLyBUUkdcblxuICAvKiBkU3RyaW5nICovXG4gIHRoaXMucnVsZXNbNzNdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s3M10ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogODV9Oy8vIFJOTShkbnVtKVxuXG4gIC8qIHhTdHJpbmcgKi9cbiAgdGhpcy5ydWxlc1s3NF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzc0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDQsIGluZGV4OiA4N307Ly8gUk5NKHhudW0pXG5cbiAgLyogYlN0cmluZyAqL1xuICB0aGlzLnJ1bGVzWzc1XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNzVdLm9wY29kZXNbMF0gPSB7dHlwZTogNCwgaW5kZXg6IDg2fTsvLyBSTk0oYm51bSlcblxuICAvKiBEZWMgKi9cbiAgdGhpcy5ydWxlc1s3Nl0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzc2XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNzZdLm9wY29kZXNbMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNjhdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s3Nl0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxMDBdfTsvLyBUQlNcblxuICAvKiBIZXggKi9cbiAgdGhpcy5ydWxlc1s3N10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzc3XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNzddLm9wY29kZXNbMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbODhdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s3N10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxMjBdfTsvLyBUQlNcblxuICAvKiBCaW4gKi9cbiAgdGhpcy5ydWxlc1s3OF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzc4XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNzhdLm9wY29kZXNbMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNjZdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s3OF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5OF19Oy8vIFRCU1xuXG4gIC8qIGRtaW4gKi9cbiAgdGhpcy5ydWxlc1s3OV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzc5XS5vcGNvZGVzWzBdID0ge3R5cGU6IDQsIGluZGV4OiA4NX07Ly8gUk5NKGRudW0pXG5cbiAgLyogZG1heCAqL1xuICB0aGlzLnJ1bGVzWzgwXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbODBdLm9wY29kZXNbMF0gPSB7dHlwZTogNCwgaW5kZXg6IDg1fTsvLyBSTk0oZG51bSlcblxuICAvKiBibWluICovXG4gIHRoaXMucnVsZXNbODFdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s4MV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogODZ9Oy8vIFJOTShibnVtKVxuXG4gIC8qIGJtYXggKi9cbiAgdGhpcy5ydWxlc1s4Ml0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzgyXS5vcGNvZGVzWzBdID0ge3R5cGU6IDQsIGluZGV4OiA4Nn07Ly8gUk5NKGJudW0pXG5cbiAgLyogeG1pbiAqL1xuICB0aGlzLnJ1bGVzWzgzXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbODNdLm9wY29kZXNbMF0gPSB7dHlwZTogNCwgaW5kZXg6IDg3fTsvLyBSTk0oeG51bSlcblxuICAvKiB4bWF4ICovXG4gIHRoaXMucnVsZXNbODRdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s4NF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogODd9Oy8vIFJOTSh4bnVtKVxuXG4gIC8qIGRudW0gKi9cbiAgdGhpcy5ydWxlc1s4NV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzg1XS5vcGNvZGVzWzBdID0ge3R5cGU6IDMsIG1pbjogMSwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbODVdLm9wY29kZXNbMV0gPSB7dHlwZTogNSwgbWluOiA0OCwgbWF4OiA1N307Ly8gVFJHXG5cbiAgLyogYm51bSAqL1xuICB0aGlzLnJ1bGVzWzg2XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbODZdLm9wY29kZXNbMF0gPSB7dHlwZTogMywgbWluOiAxLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s4Nl0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA1LCBtaW46IDQ4LCBtYXg6IDQ5fTsvLyBUUkdcblxuICAvKiB4bnVtICovXG4gIHRoaXMucnVsZXNbODddLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s4N10ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDEsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzg3XS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDRdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s4N10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA1LCBtaW46IDQ4LCBtYXg6IDU3fTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s4N10ub3Bjb2Rlc1szXSA9IHt0eXBlOiA1LCBtaW46IDY1LCBtYXg6IDcwfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s4N10ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA1LCBtaW46IDk3LCBtYXg6IDEwMn07Ly8gVFJHXG5cbiAgLyogYWxwaGFudW0gKi9cbiAgdGhpcy5ydWxlc1s4OF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzg4XS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSw0XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbODhdLm9wY29kZXNbMV0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsyLDNdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s4OF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA1LCBtaW46IDk3LCBtYXg6IDEyMn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbODhdLm9wY29kZXNbM10gPSB7dHlwZTogNSwgbWluOiA2NSwgbWF4OiA5MH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbODhdLm9wY29kZXNbNF0gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s4OF0ub3Bjb2Rlc1s1XSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzYsNyw4LDldfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s4OF0ub3Bjb2Rlc1s2XSA9IHt0eXBlOiA1LCBtaW46IDk3LCBtYXg6IDEyMn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbODhdLm9wY29kZXNbN10gPSB7dHlwZTogNSwgbWluOiA2NSwgbWF4OiA5MH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbODhdLm9wY29kZXNbOF0gPSB7dHlwZTogNSwgbWluOiA0OCwgbWF4OiA1N307Ly8gVFJHXG4gIHRoaXMucnVsZXNbODhdLm9wY29kZXNbOV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDVdfTsvLyBUQlNcblxuICAvKiBvd3NwICovXG4gIHRoaXMucnVsZXNbODldLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s4OV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzg5XS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiA5MX07Ly8gUk5NKHNwYWNlKVxuXG4gIC8qIHdzcCAqL1xuICB0aGlzLnJ1bGVzWzkwXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbOTBdLm9wY29kZXNbMF0gPSB7dHlwZTogMywgbWluOiAxLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s5MF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogOTF9Oy8vIFJOTShzcGFjZSlcblxuICAvKiBzcGFjZSAqL1xuICB0aGlzLnJ1bGVzWzkxXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbOTFdLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDIsMyw0XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbOTFdLm9wY29kZXNbMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzJdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s5MV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5XX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbOTFdLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDkyfTsvLyBSTk0oY29tbWVudClcbiAgdGhpcy5ydWxlc1s5MV0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA0LCBpbmRleDogOTR9Oy8vIFJOTShMaW5lQ29udGludWUpXG5cbiAgLyogY29tbWVudCAqL1xuICB0aGlzLnJ1bGVzWzkyXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbOTJdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s5Ml0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs1OV19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzkyXS5vcGNvZGVzWzJdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbOTJdLm9wY29kZXNbM10gPSB7dHlwZTogMSwgY2hpbGRyZW46IFs0LDVdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s5Ml0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA1LCBtaW46IDMyLCBtYXg6IDEyNn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbOTJdLm9wY29kZXNbNV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbOV19Oy8vIFRCU1xuXG4gIC8qIExpbmVFbmQgKi9cbiAgdGhpcy5ydWxlc1s5M10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzkzXS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyLDNdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s5M10ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxMywxMF19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzkzXS5vcGNvZGVzWzJdID0ge3R5cGU6IDYsIHN0cmluZzogWzEwXX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbOTNdLm9wY29kZXNbM10gPSB7dHlwZTogNiwgc3RyaW5nOiBbMTNdfTsvLyBUQlNcblxuICAvKiBMaW5lQ29udGludWUgKi9cbiAgdGhpcy5ydWxlc1s5NF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzk0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSw1XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbOTRdLm9wY29kZXNbMV0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsyLDMsNF19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzk0XS5vcGNvZGVzWzJdID0ge3R5cGU6IDYsIHN0cmluZzogWzEzLDEwXX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbOTRdLm9wY29kZXNbM10gPSB7dHlwZTogNiwgc3RyaW5nOiBbMTBdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s5NF0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxM119Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzk0XS5vcGNvZGVzWzVdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbNiw3XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbOTRdLm9wY29kZXNbNl0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzJdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s5NF0ub3Bjb2Rlc1s3XSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5XX07Ly8gVEJTXG5cbiAgLy8gVGhlIGB0b1N0cmluZygpYCBmdW5jdGlvbiB3aWxsIGRpc3BsYXkgdGhlIG9yaWdpbmFsIGdyYW1tYXIgZmlsZShzKSB0aGF0IHByb2R1Y2VkIHRoZXNlIG9wY29kZXMuXG4gIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIGxldCBzdHIgPSBcIlwiO1xuICAgIHN0ciArPSBcIjtcXG5cIjtcbiAgICBzdHIgKz0gXCI7IEFCTkYgZm9yIEphdmFTY3JpcHQgQVBHIDIuMCBTQUJORlxcblwiO1xuICAgIHN0ciArPSBcIjsgUkZDIDUyMzQgd2l0aCBzb21lIHJlc3RyaWN0aW9ucyBhbmQgYWRkaXRpb25zLlxcblwiO1xuICAgIHN0ciArPSBcIjsgVXBkYXRlZCAxMS8yNC8yMDE1IGZvciBSRkMgNzQwNSBjYXNlLXNlbnNpdGl2ZSBsaXRlcmFsIHN0cmluZyBub3RhdGlvblxcblwiO1xuICAgIHN0ciArPSBcIjsgIC0gYWNjZXB0cyAlc1xcXCJzdHJpbmdcXFwiIGFzIGEgY2FzZS1zZW5zaXRpdmUgc3RyaW5nXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgLSBhY2NlcHRzICVpXFxcInN0cmluZ1xcXCIgYXMgYSBjYXNlLWluc2Vuc2l0aXZlIHN0cmluZ1xcblwiO1xuICAgIHN0ciArPSBcIjsgIC0gYWNjZXB0cyBcXFwic3RyaW5nXFxcIiBhcyBhIGNhc2UtaW5zZW5zaXRpdmUgc3RyaW5nXFxuXCI7XG4gICAgc3RyICs9IFwiO1xcblwiO1xuICAgIHN0ciArPSBcIjsgU29tZSByZXN0cmljdGlvbnM6XFxuXCI7XG4gICAgc3RyICs9IFwiOyAgIDEuIFJ1bGVzIG11c3QgYmVnaW4gYXQgZmlyc3QgY2hhcmFjdGVyIG9mIGVhY2ggbGluZS5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgSW5kZW50YXRpb25zIG9uIGZpcnN0IHJ1bGUgYW5kIHJ1bGVzIHRoZXJlYWZ0ZXIgYXJlIG5vdCBhbGxvd2VkLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAyLiBSZWxheGVkIGxpbmUgZW5kaW5ncy4gQ1JMRiwgTEYgb3IgQ1IgYXJlIGFjY2VwdGVkIGFzIHZhbGlkIGxpbmUgZW5kaW5nLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAzLiBQcm9zZSB2YWx1ZXMsIGkuZS4gPHByb3NlIHZhbHVlPiwgYXJlIGFjY2VwdGVkIGFzIHZhbGlkIGdyYW1tYXIgc3ludGF4LlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBIb3dldmVyLCBhIHdvcmtpbmcgcGFyc2VyIGNhbm5vdCBiZSBnZW5lcmF0ZWQgZnJvbSB0aGVtLlxcblwiO1xuICAgIHN0ciArPSBcIjtcXG5cIjtcbiAgICBzdHIgKz0gXCI7IFN1cGVyIHNldCAoU0FCTkYpIGFkZGl0aW9uczpcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgMS4gTG9vay1haGVhZCAoc3ludGFjdGljIHByZWRpY2F0ZSkgb3BlcmF0b3JzIGFyZSBhY2NlcHRlZCBhcyBlbGVtZW50IHByZWZpeGVzLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICAmIGlzIHRoZSBwb3NpdGl2ZSBsb29rLWFoZWFkIG9wZXJhdG9yLCBzdWNjZWVkcyBhbmQgYmFja3RyYWNrcyBpZiB0aGUgbG9vay1haGVhZCBwaHJhc2UgaXMgZm91bmRcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgISBpcyB0aGUgbmVnYXRpdmUgbG9vay1haGVhZCBvcGVyYXRvciwgc3VjY2VlZHMgYW5kIGJhY2t0cmFja3MgaWYgdGhlIGxvb2stYWhlYWQgcGhyYXNlIGlzIE5PVCBmb3VuZFxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBlLmcuICYlZDEzIG9yICZydWxlIG9yICEoQSAvIEIpXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgIDIuIFVzZXItRGVmaW5lZCBUZXJtaW5hbHMgKFVEVCkgb2YgdGhlIGZvcm0sIHVfbmFtZSBhbmQgZV9uYW1lIGFyZSBhY2NlcHRlZC5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgJ25hbWUnIGlzIGFscGhhIGZvbGxvd2VkIGJ5IGFscGhhL251bS9oeXBoZW4ganVzdCBsaWtlIGEgcnVsZSBuYW1lLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICB1X25hbWUgbWF5IGJlIHVzZWQgYXMgYW4gZWxlbWVudCBidXQgbm8gcnVsZSBkZWZpbml0aW9uIGlzIGdpdmVuLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBlLmcuIHJ1bGUgPSBBIC8gdV9teVVkdFxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICAgICAgIEEgPSBcXFwiYVxcXCJcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgd291bGQgYmUgYSB2YWxpZCBncmFtbWFyLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAzLiBDYXNlLXNlbnNpdGl2ZSwgc2luZ2xlLXF1b3RlZCBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgZS5nLiAnYWJjJyB3b3VsZCBiZSBlcXVpdmFsZW50IHRvICVkOTcuOTguOTlcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgKGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIGJ1dCBzdXBlcnNlZGVkIGJ5ICVzXFxcImFiY1xcXCIpICBcXG5cIjtcbiAgICBzdHIgKz0gXCI7IE5ldyAxMi8yNi8yMDE1XFxuXCI7XG4gICAgc3RyICs9IFwiOyAgIDQuIExvb2stYmVoaW5kIG9wZXJhdG9ycyBhcmUgYWNjZXB0ZWQgYXMgZWxlbWVudCBwcmVmaXhlcy5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgJiYgaXMgdGhlIHBvc2l0aXZlIGxvb2stYmVoaW5kIG9wZXJhdG9yLCBzdWNjZWVkcyBhbmQgYmFja3RyYWNrcyBpZiB0aGUgbG9vay1iZWhpbmQgcGhyYXNlIGlzIGZvdW5kXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgICEhIGlzIHRoZSBuZWdhdGl2ZSBsb29rLWJlaGluZCBvcGVyYXRvciwgc3VjY2VlZHMgYW5kIGJhY2t0cmFja3MgaWYgdGhlIGxvb2stYmVoaW5kIHBocmFzZSBpcyBOT1QgZm91bmRcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgZS5nLiAmJiVkMTMgb3IgJiZydWxlIG9yICEhKEEgLyBCKVxcblwiO1xuICAgIHN0ciArPSBcIjsgICA1LiBCYWNrIHJlZmVyZW5jZSBvcGVyYXRvcnMsIGkuZS4gXFxcXHJ1bGVuYW1lLCBhcmUgYWNjZXB0ZWQuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIEEgYmFjayByZWZlcmVuY2Ugb3BlcmF0b3IgYWN0cyBsaWtlIGEgVExTIG9yIFRCUyB0ZXJtaW5hbCBleGNlcHQgdGhhdCB0aGUgcGhyYXNlIGl0IGF0dGVtcHRzXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIHRvIG1hdGNoIGlzIGEgcGhyYXNlIHByZXZpb3VzbHkgbWF0Y2hlZCBieSB0aGUgcnVsZSAncnVsZW5hbWUnLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBUaGVyZSBhcmUgdHdvIG1vZGVzIG9mIHByZXZpb3VzIHBocmFzZSBtYXRjaGluZyAtIHRoZSBwYXJlbnQtZnJhbWUgbW9kZSBhbmQgdGhlIHVuaXZlcnNhbCBtb2RlLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBJbiB1bml2ZXJzYWwgbW9kZSwgXFxcXHJ1bGVuYW1lIG1hdGNoZXMgdGhlIGxhc3QgbWF0Y2ggdG8gJ3J1bGVuYW1lJyByZWdhcmRsZXNzIG9mIHdoZXJlIGl0IHdhcyBmb3VuZC5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgSW4gcGFyZW50LWZyYW1lIG1vZGUsIFxcXFxydWxlbmFtZSBtYXRjaGVzIG9ubHkgdGhlIGxhc3QgbWF0Y2ggZm91bmQgb24gdGhlIHBhcmVudCdzIGZyYW1lIG9yIHBhcnNlIHRyZWUgbGV2ZWwuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIEJhY2sgcmVmZXJlbmNlIG1vZGlmaWVycyBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGNhc2UgYW5kIG1vZGUuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIFxcXFxBIGRlZmF1bHRzIHRvIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHVuaXZlcnNhbCBtb2RlLCBlLmcuIFxcXFxBID09PSBcXFxcJWkldUFcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgTW9kaWZpZXJzICVpIGFuZCAlcyBkZXRlcm1pbmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FzZS1zZW5zaXRpdmUgbW9kZSwgcmVzcGVjdGl2ZWx5LlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBNb2RpZmllcnMgJXUgYW5kICVwIGRldGVybWluZSB1bml2ZXJzYWwgbW9kZSBhbmQgcGFyZW50IGZyYW1lIG1vZGUsIHJlc3BlY3RpdmVseS5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgQ2FzZSBhbmQgbW9kZSBtb2RpZmllcnMgY2FuIGFwcGVhciBpbiBhbnkgb3JkZXIsIGUuZy4gXFxcXCVzJXBBID09PSBcXFxcJXAlc0EuIFxcblwiO1xuICAgIHN0ciArPSBcIjsgICA3LiBTdHJpbmcgYmVnaW4gYW5jaG9yLCBBQkcoJV4pIG1hdGNoZXMgdGhlIGJlZ2lubmluZyBvZiB0aGUgaW5wdXQgc3RyaW5nIGxvY2F0aW9uLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBSZXR1cm5zIEVNUFRZIG9yIE5PTUFUQ0guIE5ldmVyIGNvbnN1bWVzIGFueSBjaGFyYWN0ZXJzLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICA4LiBTdHJpbmcgZW5kIGFuY2hvciwgQUVOKCUkKSBtYXRjaGVzIHRoZSBlbmQgb2YgdGhlIGlucHV0IHN0cmluZyBsb2NhdGlvbi5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgUmV0dXJucyBFTVBUWSBvciBOT01BVENILiBOZXZlciBjb25zdW1lcyBhbnkgY2hhcmFjdGVycy5cXG5cIjtcbiAgICBzdHIgKz0gXCI7XFxuXCI7XG4gICAgc3RyICs9IFwiRmlsZSAgICAgICAgICAgID0gKihCbGFua0xpbmUgLyBSdWxlIC8gUnVsZUVycm9yKVxcblwiO1xuICAgIHN0ciArPSBcIkJsYW5rTGluZSAgICAgICA9ICooJWQzMi8lZDkpIFtjb21tZW50XSBMaW5lRW5kXFxuXCI7XG4gICAgc3RyICs9IFwiUnVsZSAgICAgICAgICAgID0gUnVsZUxvb2t1cCBvd3NwIEFsdGVybmF0aW9uICgob3dzcCBMaW5lRW5kKVxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIChMaW5lRW5kRXJyb3IgTGluZUVuZCkpXFxuXCI7XG4gICAgc3RyICs9IFwiUnVsZUxvb2t1cCAgICAgID0gUnVsZU5hbWVUZXN0IG93c3AgRGVmaW5lZEFzVGVzdFxcblwiO1xuICAgIHN0ciArPSBcIlJ1bGVOYW1lVGVzdCAgICA9IFJ1bGVOYW1lL1J1bGVOYW1lRXJyb3JcXG5cIjtcbiAgICBzdHIgKz0gXCJSdWxlTmFtZSAgICAgICAgPSBhbHBoYW51bVxcblwiO1xuICAgIHN0ciArPSBcIlJ1bGVOYW1lRXJyb3IgICA9IDEqKCVkMzMtNjAvJWQ2Mi0xMjYpXFxuXCI7XG4gICAgc3RyICs9IFwiRGVmaW5lZEFzVGVzdCAgID0gRGVmaW5lZEFzIC8gRGVmaW5lZEFzRXJyb3JcXG5cIjtcbiAgICBzdHIgKz0gXCJEZWZpbmVkQXNFcnJvciAgPSAxKjIlZDMzLTEyNlxcblwiO1xuICAgIHN0ciArPSBcIkRlZmluZWRBcyAgICAgICA9IEluY0FsdCAvIERlZmluZWRcXG5cIjtcbiAgICBzdHIgKz0gXCJEZWZpbmVkICAgICAgICAgPSAlZDYxXFxuXCI7XG4gICAgc3RyICs9IFwiSW5jQWx0ICAgICAgICAgID0gJWQ2MS40N1xcblwiO1xuICAgIHN0ciArPSBcIlJ1bGVFcnJvciAgICAgICA9IDEqKCVkMzItMTI2IC8gJWQ5ICAvIExpbmVDb250aW51ZSkgTGluZUVuZFxcblwiO1xuICAgIHN0ciArPSBcIkxpbmVFbmRFcnJvciAgICA9IDEqKCVkMzItMTI2IC8gJWQ5ICAvIExpbmVDb250aW51ZSlcXG5cIjtcbiAgICBzdHIgKz0gXCJBbHRlcm5hdGlvbiAgICAgPSBDb25jYXRlbmF0aW9uICoob3dzcCBBbHRPcCBDb25jYXRlbmF0aW9uKVxcblwiO1xuICAgIHN0ciArPSBcIkNvbmNhdGVuYXRpb24gICA9IFJlcGV0aXRpb24gKihDYXRPcCBSZXBldGl0aW9uKVxcblwiO1xuICAgIHN0ciArPSBcIlJlcGV0aXRpb24gICAgICA9IFtNb2RpZmllcl0gKEdyb3VwIC8gT3B0aW9uIC8gQmFzaWNFbGVtZW50IC8gQmFzaWNFbGVtZW50RXJyKVxcblwiO1xuICAgIHN0ciArPSBcIk1vZGlmaWVyICAgICAgICA9IChQcmVkaWNhdGUgW1JlcE9wXSlcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBSZXBPcFxcblwiO1xuICAgIHN0ciArPSBcIlByZWRpY2F0ZSAgICAgICA9IEJrYU9wXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gQmtuT3BcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBBbmRPcFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIE5vdE9wXFxuXCI7XG4gICAgc3RyICs9IFwiQmFzaWNFbGVtZW50ICAgID0gVWR0T3BcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBSbm1PcFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIFRyZ09wXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gVGJzT3BcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBUbHNPcFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIENsc09wXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gQmtyT3BcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBBYmdPcFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIEFlbk9wXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gUHJvc1ZhbFxcblwiO1xuICAgIHN0ciArPSBcIkJhc2ljRWxlbWVudEVyciA9IDEqKCVkMzMtNDAvJWQ0Mi00Ni8lZDQ4LTkyLyVkOTQtMTI2KVxcblwiO1xuICAgIHN0ciArPSBcIkdyb3VwICAgICAgICAgICA9IEdyb3VwT3BlbiAgQWx0ZXJuYXRpb24gKEdyb3VwQ2xvc2UgLyBHcm91cEVycm9yKVxcblwiO1xuICAgIHN0ciArPSBcIkdyb3VwRXJyb3IgICAgICA9IDEqKCVkMzMtNDAvJWQ0Mi00Ni8lZDQ4LTkyLyVkOTQtMTI2KSA7IHNhbWUgYXMgQmFzaWNFbGVtZW50RXJyXFxuXCI7XG4gICAgc3RyICs9IFwiR3JvdXBPcGVuICAgICAgID0gJWQ0MCBvd3NwXFxuXCI7XG4gICAgc3RyICs9IFwiR3JvdXBDbG9zZSAgICAgID0gb3dzcCAlZDQxXFxuXCI7XG4gICAgc3RyICs9IFwiT3B0aW9uICAgICAgICAgID0gT3B0aW9uT3BlbiBBbHRlcm5hdGlvbiAoT3B0aW9uQ2xvc2UgLyBPcHRpb25FcnJvcilcXG5cIjtcbiAgICBzdHIgKz0gXCJPcHRpb25FcnJvciAgICAgPSAxKiglZDMzLTQwLyVkNDItNDYvJWQ0OC05Mi8lZDk0LTEyNikgOyBzYW1lIGFzIEJhc2ljRWxlbWVudEVyclxcblwiO1xuICAgIHN0ciArPSBcIk9wdGlvbk9wZW4gICAgICA9ICVkOTEgb3dzcFxcblwiO1xuICAgIHN0ciArPSBcIk9wdGlvbkNsb3NlICAgICA9IG93c3AgJWQ5M1xcblwiO1xuICAgIHN0ciArPSBcIlJubU9wICAgICAgICAgICA9IGFscGhhbnVtXFxuXCI7XG4gICAgc3RyICs9IFwiQmtyT3AgICAgICAgICAgID0gJWQ5MiBbYmtyTW9kaWZpZXJdIGJrci1uYW1lXFxuXCI7XG4gICAgc3RyICs9IFwiYmtyTW9kaWZpZXIgICAgID0gKGNzIFt1bSAvIHBtXSkgLyAoY2kgW3VtIC8gcG1dKSAvICh1bSBbY3MgL2NpXSkgLyAocG0gW2NzIC8gY2ldKVxcblwiO1xuICAgIHN0ciArPSBcImNzICAgICAgICAgICAgICA9ICclcydcXG5cIjtcbiAgICBzdHIgKz0gXCJjaSAgICAgICAgICAgICAgPSAnJWknXFxuXCI7XG4gICAgc3RyICs9IFwidW0gICAgICAgICAgICAgID0gJyV1J1xcblwiO1xuICAgIHN0ciArPSBcInBtICAgICAgICAgICAgICA9ICclcCdcXG5cIjtcbiAgICBzdHIgKz0gXCJia3ItbmFtZSAgICAgICAgPSB1bmFtZSAvIGVuYW1lIC8gcm5hbWVcXG5cIjtcbiAgICBzdHIgKz0gXCJybmFtZSAgICAgICAgICAgPSBhbHBoYW51bVxcblwiO1xuICAgIHN0ciArPSBcInVuYW1lICAgICAgICAgICA9ICVkMTE3Ljk1IGFscGhhbnVtXFxuXCI7XG4gICAgc3RyICs9IFwiZW5hbWUgICAgICAgICAgID0gJWQxMDEuOTUgYWxwaGFudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJVZHRPcCAgICAgICAgICAgPSB1ZHQtZW1wdHlcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyB1ZHQtbm9uLWVtcHR5XFxuXCI7XG4gICAgc3RyICs9IFwidWR0LW5vbi1lbXB0eSAgID0gJWQxMTcuOTUgYWxwaGFudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJ1ZHQtZW1wdHkgICAgICAgPSAlZDEwMS45NSBhbHBoYW51bVxcblwiO1xuICAgIHN0ciArPSBcIlJlcE9wICAgICAgICAgICA9IChyZXAtbWluIFN0YXJPcCByZXAtbWF4KVxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIChyZXAtbWluIFN0YXJPcClcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyAoU3Rhck9wIHJlcC1tYXgpXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gU3Rhck9wXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gcmVwLW1pbi1tYXhcXG5cIjtcbiAgICBzdHIgKz0gXCJBbHRPcCAgICAgICAgICAgPSAlZDQ3IG93c3BcXG5cIjtcbiAgICBzdHIgKz0gXCJDYXRPcCAgICAgICAgICAgPSB3c3BcXG5cIjtcbiAgICBzdHIgKz0gXCJTdGFyT3AgICAgICAgICAgPSAlZDQyXFxuXCI7XG4gICAgc3RyICs9IFwiQW5kT3AgICAgICAgICAgID0gJWQzOFxcblwiO1xuICAgIHN0ciArPSBcIk5vdE9wICAgICAgICAgICA9ICVkMzNcXG5cIjtcbiAgICBzdHIgKz0gXCJCa2FPcCAgICAgICAgICAgPSAlZDM4LjM4XFxuXCI7XG4gICAgc3RyICs9IFwiQmtuT3AgICAgICAgICAgID0gJWQzMy4zM1xcblwiO1xuICAgIHN0ciArPSBcIkFiZ09wICAgICAgICAgICA9ICVkMzcuOTRcXG5cIjtcbiAgICBzdHIgKz0gXCJBZW5PcCAgICAgICAgICAgPSAlZDM3LjM2XFxuXCI7XG4gICAgc3RyICs9IFwiVHJnT3AgICAgICAgICAgID0gJWQzNyAoKERlYyBkbWluICVkNDUgZG1heCkgLyAoSGV4IHhtaW4gJWQ0NSB4bWF4KSAvIChCaW4gYm1pbiAlZDQ1IGJtYXgpKVxcblwiO1xuICAgIHN0ciArPSBcIlRic09wICAgICAgICAgICA9ICVkMzcgKChEZWMgZFN0cmluZyAqKCVkNDYgZFN0cmluZykpIC8gKEhleCB4U3RyaW5nICooJWQ0NiB4U3RyaW5nKSkgLyAoQmluIGJTdHJpbmcgKiglZDQ2IGJTdHJpbmcpKSlcXG5cIjtcbiAgICBzdHIgKz0gXCJUbHNPcCAgICAgICAgICAgPSBUbHNDYXNlIFRsc09wZW4gVGxzU3RyaW5nIFRsc0Nsb3NlXFxuXCI7XG4gICAgc3RyICs9IFwiVGxzQ2FzZSAgICAgICAgID0gW1xcXCIlaVxcXCIgLyBcXFwiJXNcXFwiXVxcblwiO1xuICAgIHN0ciArPSBcIlRsc09wZW4gICAgICAgICA9ICVkMzRcXG5cIjtcbiAgICBzdHIgKz0gXCJUbHNDbG9zZSAgICAgICAgPSAlZDM0XFxuXCI7XG4gICAgc3RyICs9IFwiVGxzU3RyaW5nICAgICAgID0gKiglZDMyLTMzLyVkMzUtMTI2L1N0cmluZ1RhYilcXG5cIjtcbiAgICBzdHIgKz0gXCJTdHJpbmdUYWIgICAgICAgPSAlZDlcXG5cIjtcbiAgICBzdHIgKz0gXCJDbHNPcCAgICAgICAgICAgPSBDbHNPcGVuIENsc1N0cmluZyBDbHNDbG9zZVxcblwiO1xuICAgIHN0ciArPSBcIkNsc09wZW4gICAgICAgICA9ICVkMzlcXG5cIjtcbiAgICBzdHIgKz0gXCJDbHNDbG9zZSAgICAgICAgPSAlZDM5XFxuXCI7XG4gICAgc3RyICs9IFwiQ2xzU3RyaW5nICAgICAgID0gKiglZDMyLTM4LyVkNDAtMTI2L1N0cmluZ1RhYilcXG5cIjtcbiAgICBzdHIgKz0gXCJQcm9zVmFsICAgICAgICAgPSBQcm9zVmFsT3BlbiBQcm9zVmFsU3RyaW5nIFByb3NWYWxDbG9zZVxcblwiO1xuICAgIHN0ciArPSBcIlByb3NWYWxPcGVuICAgICA9ICVkNjBcXG5cIjtcbiAgICBzdHIgKz0gXCJQcm9zVmFsU3RyaW5nICAgPSAqKCVkMzItNjEvJWQ2My0xMjYvU3RyaW5nVGFiKVxcblwiO1xuICAgIHN0ciArPSBcIlByb3NWYWxDbG9zZSAgICA9ICVkNjJcXG5cIjtcbiAgICBzdHIgKz0gXCJyZXAtbWluICAgICAgICAgPSByZXAtbnVtXFxuXCI7XG4gICAgc3RyICs9IFwicmVwLW1pbi1tYXggICAgID0gcmVwLW51bVxcblwiO1xuICAgIHN0ciArPSBcInJlcC1tYXggICAgICAgICA9IHJlcC1udW1cXG5cIjtcbiAgICBzdHIgKz0gXCJyZXAtbnVtICAgICAgICAgPSAxKiglZDQ4LTU3KVxcblwiO1xuICAgIHN0ciArPSBcImRTdHJpbmcgICAgICAgICA9IGRudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJ4U3RyaW5nICAgICAgICAgPSB4bnVtXFxuXCI7XG4gICAgc3RyICs9IFwiYlN0cmluZyAgICAgICAgID0gYm51bVxcblwiO1xuICAgIHN0ciArPSBcIkRlYyAgICAgICAgICAgICA9ICglZDY4LyVkMTAwKVxcblwiO1xuICAgIHN0ciArPSBcIkhleCAgICAgICAgICAgICA9ICglZDg4LyVkMTIwKVxcblwiO1xuICAgIHN0ciArPSBcIkJpbiAgICAgICAgICAgICA9ICglZDY2LyVkOTgpXFxuXCI7XG4gICAgc3RyICs9IFwiZG1pbiAgICAgICAgICAgID0gZG51bVxcblwiO1xuICAgIHN0ciArPSBcImRtYXggICAgICAgICAgICA9IGRudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJibWluICAgICAgICAgICAgPSBibnVtXFxuXCI7XG4gICAgc3RyICs9IFwiYm1heCAgICAgICAgICAgID0gYm51bVxcblwiO1xuICAgIHN0ciArPSBcInhtaW4gICAgICAgICAgICA9IHhudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJ4bWF4ICAgICAgICAgICAgPSB4bnVtXFxuXCI7XG4gICAgc3RyICs9IFwiZG51bSAgICAgICAgICAgID0gMSooJWQ0OC01NylcXG5cIjtcbiAgICBzdHIgKz0gXCJibnVtICAgICAgICAgICAgPSAxKiVkNDgtNDlcXG5cIjtcbiAgICBzdHIgKz0gXCJ4bnVtICAgICAgICAgICAgPSAxKiglZDQ4LTU3IC8gJWQ2NS03MCAvICVkOTctMTAyKVxcblwiO1xuICAgIHN0ciArPSBcIjtcXG5cIjtcbiAgICBzdHIgKz0gXCI7IEJhc2ljc1xcblwiO1xuICAgIHN0ciArPSBcImFscGhhbnVtICAgICAgICA9ICglZDk3LTEyMi8lZDY1LTkwKSAqKCVkOTctMTIyLyVkNjUtOTAvJWQ0OC01Ny8lZDQ1KVxcblwiO1xuICAgIHN0ciArPSBcIm93c3AgICAgICAgICAgICA9ICpzcGFjZVxcblwiO1xuICAgIHN0ciArPSBcIndzcCAgICAgICAgICAgICA9IDEqc3BhY2VcXG5cIjtcbiAgICBzdHIgKz0gXCJzcGFjZSAgICAgICAgICAgPSAlZDMyXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gJWQ5XFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gY29tbWVudFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIExpbmVDb250aW51ZVxcblwiO1xuICAgIHN0ciArPSBcImNvbW1lbnQgICAgICAgICA9ICVkNTkgKiglZDMyLTEyNiAvICVkOSlcXG5cIjtcbiAgICBzdHIgKz0gXCJMaW5lRW5kICAgICAgICAgPSAlZDEzLjEwXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gJWQxMFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvICVkMTNcXG5cIjtcbiAgICBzdHIgKz0gXCJMaW5lQ29udGludWUgICAgPSAoJWQxMy4xMCAvICVkMTAgLyAlZDEzKSAoJWQzMiAvICVkOSlcXG5cIjtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-api/sabnf-grammar.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-api/scanner-callbacks.js":
/*!**************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/scanner-callbacks.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// These are the AST translation callback functions used by the scanner\n// to analyze the characters and lines.\nconst ids = __webpack_require__(/*! ../apg-lib/identifiers */ \"./node_modules/apg-js/src/apg-lib/identifiers.js\");\nconst utils = __webpack_require__(/*! ../apg-lib/utilities */ \"./node_modules/apg-js/src/apg-lib/utilities.js\");\n\nfunction semLine(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endLength = 0;\n    data.textLength = 0;\n    data.invalidCount = 0;\n  } else {\n    data.lines.push({\n      lineNo: data.lines.length,\n      beginChar: phraseIndex,\n      length: phraseCount,\n      textLength: data.textLength,\n      endType: data.endType,\n      invalidChars: data.invalidCount,\n    });\n  }\n  return ids.SEM_OK;\n}\nfunction semLineText(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.textLength = phraseCount;\n  }\n  return ids.SEM_OK;\n}\nfunction semLastLine(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endLength = 0;\n    data.textLength = 0;\n    data.invalidCount = 0;\n  } else if (data.strict) {\n    data.lines.push({\n      lineNo: data.lines.length,\n      beginChar: phraseIndex,\n      length: phraseCount,\n      textLength: phraseCount,\n      endType: 'none',\n      invalidChars: data.invalidCount,\n    });\n    data.errors.push({\n      line: data.lineNo,\n      char: phraseIndex + phraseCount,\n      msg: 'no line end on last line - strict ABNF specifies CRLF(\\\\r\\\\n, \\\\x0D\\\\x0A)',\n    });\n  } else {\n    /* add a line ender */\n    chars.push(10);\n    data.lines.push({\n      lineNo: data.lines.length,\n      beginChar: phraseIndex,\n      length: phraseCount + 1,\n      textLength: phraseCount,\n      endType: 'LF',\n      invalidChars: data.invalidCount,\n    });\n  }\n  return ids.SEM_OK;\n}\nfunction semInvalid(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.errors.push({\n      line: data.lineNo,\n      char: phraseIndex,\n      msg: `invalid character found '\\\\x${utils.charToHex(chars[phraseIndex])}'`,\n    });\n  }\n  return ids.SEM_OK;\n}\nfunction semEnd(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_POST) {\n    data.lineNo += 1;\n  }\n  return ids.SEM_OK;\n}\nfunction semLF(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endType = 'LF';\n    if (data.strict) {\n      data.errors.push({\n        line: data.lineNo,\n        char: phraseIndex,\n        msg: 'line end character LF(\\\\n, \\\\x0A) - strict ABNF specifies CRLF(\\\\r\\\\n, \\\\x0D\\\\x0A)',\n      });\n    }\n  }\n  return ids.SEM_OK;\n}\nfunction semCR(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endType = 'CR';\n    if (data.strict) {\n      data.errors.push({\n        line: data.lineNo,\n        char: phraseIndex,\n        msg: 'line end character CR(\\\\r, \\\\x0D) - strict ABNF specifies CRLF(\\\\r\\\\n, \\\\x0D\\\\x0A)',\n      });\n    }\n  }\n  return ids.SEM_OK;\n}\nfunction semCRLF(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endType = 'CRLF';\n  }\n  return ids.SEM_OK;\n}\nconst callbacks = [];\ncallbacks.line = semLine;\ncallbacks['line-text'] = semLineText;\ncallbacks['last-line'] = semLastLine;\ncallbacks.invalid = semInvalid;\ncallbacks.end = semEnd;\ncallbacks.lf = semLF;\ncallbacks.cr = semCR;\ncallbacks.crlf = semCRLF;\nexports.callbacks = callbacks;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NjYW5uZXItY2FsbGJhY2tzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQU8sQ0FBQyxnRkFBd0I7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLDRFQUFzQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvQ0FBb0M7QUFDOUUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvc2Nhbm5lci1jYWxsYmFja3MuanM/ZDM3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGVzZSBhcmUgdGhlIEFTVCB0cmFuc2xhdGlvbiBjYWxsYmFjayBmdW5jdGlvbnMgdXNlZCBieSB0aGUgc2Nhbm5lclxuLy8gdG8gYW5hbHl6ZSB0aGUgY2hhcmFjdGVycyBhbmQgbGluZXMuXG5jb25zdCBpZHMgPSByZXF1aXJlKCcuLi9hcGctbGliL2lkZW50aWZpZXJzJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL2FwZy1saWIvdXRpbGl0aWVzJyk7XG5cbmZ1bmN0aW9uIHNlbUxpbmUoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgaWYgKHN0YXRlID09PSBpZHMuU0VNX1BSRSkge1xuICAgIGRhdGEuZW5kTGVuZ3RoID0gMDtcbiAgICBkYXRhLnRleHRMZW5ndGggPSAwO1xuICAgIGRhdGEuaW52YWxpZENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICBkYXRhLmxpbmVzLnB1c2goe1xuICAgICAgbGluZU5vOiBkYXRhLmxpbmVzLmxlbmd0aCxcbiAgICAgIGJlZ2luQ2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICBsZW5ndGg6IHBocmFzZUNvdW50LFxuICAgICAgdGV4dExlbmd0aDogZGF0YS50ZXh0TGVuZ3RoLFxuICAgICAgZW5kVHlwZTogZGF0YS5lbmRUeXBlLFxuICAgICAgaW52YWxpZENoYXJzOiBkYXRhLmludmFsaWRDb3VudCxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaWRzLlNFTV9PSztcbn1cbmZ1bmN0aW9uIHNlbUxpbmVUZXh0KHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gIGlmIChzdGF0ZSA9PT0gaWRzLlNFTV9QUkUpIHtcbiAgICBkYXRhLnRleHRMZW5ndGggPSBwaHJhc2VDb3VudDtcbiAgfVxuICByZXR1cm4gaWRzLlNFTV9PSztcbn1cbmZ1bmN0aW9uIHNlbUxhc3RMaW5lKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gIGlmIChzdGF0ZSA9PT0gaWRzLlNFTV9QUkUpIHtcbiAgICBkYXRhLmVuZExlbmd0aCA9IDA7XG4gICAgZGF0YS50ZXh0TGVuZ3RoID0gMDtcbiAgICBkYXRhLmludmFsaWRDb3VudCA9IDA7XG4gIH0gZWxzZSBpZiAoZGF0YS5zdHJpY3QpIHtcbiAgICBkYXRhLmxpbmVzLnB1c2goe1xuICAgICAgbGluZU5vOiBkYXRhLmxpbmVzLmxlbmd0aCxcbiAgICAgIGJlZ2luQ2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICBsZW5ndGg6IHBocmFzZUNvdW50LFxuICAgICAgdGV4dExlbmd0aDogcGhyYXNlQ291bnQsXG4gICAgICBlbmRUeXBlOiAnbm9uZScsXG4gICAgICBpbnZhbGlkQ2hhcnM6IGRhdGEuaW52YWxpZENvdW50LFxuICAgIH0pO1xuICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgbGluZTogZGF0YS5saW5lTm8sXG4gICAgICBjaGFyOiBwaHJhc2VJbmRleCArIHBocmFzZUNvdW50LFxuICAgICAgbXNnOiAnbm8gbGluZSBlbmQgb24gbGFzdCBsaW5lIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVzIENSTEYoXFxcXHJcXFxcbiwgXFxcXHgwRFxcXFx4MEEpJyxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvKiBhZGQgYSBsaW5lIGVuZGVyICovXG4gICAgY2hhcnMucHVzaCgxMCk7XG4gICAgZGF0YS5saW5lcy5wdXNoKHtcbiAgICAgIGxpbmVObzogZGF0YS5saW5lcy5sZW5ndGgsXG4gICAgICBiZWdpbkNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgbGVuZ3RoOiBwaHJhc2VDb3VudCArIDEsXG4gICAgICB0ZXh0TGVuZ3RoOiBwaHJhc2VDb3VudCxcbiAgICAgIGVuZFR5cGU6ICdMRicsXG4gICAgICBpbnZhbGlkQ2hhcnM6IGRhdGEuaW52YWxpZENvdW50LFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBpZHMuU0VNX09LO1xufVxuZnVuY3Rpb24gc2VtSW52YWxpZChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICBpZiAoc3RhdGUgPT09IGlkcy5TRU1fUFJFKSB7XG4gICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICBsaW5lOiBkYXRhLmxpbmVObyxcbiAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgbXNnOiBgaW52YWxpZCBjaGFyYWN0ZXIgZm91bmQgJ1xcXFx4JHt1dGlscy5jaGFyVG9IZXgoY2hhcnNbcGhyYXNlSW5kZXhdKX0nYCxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaWRzLlNFTV9PSztcbn1cbmZ1bmN0aW9uIHNlbUVuZChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICBpZiAoc3RhdGUgPT09IGlkcy5TRU1fUE9TVCkge1xuICAgIGRhdGEubGluZU5vICs9IDE7XG4gIH1cbiAgcmV0dXJuIGlkcy5TRU1fT0s7XG59XG5mdW5jdGlvbiBzZW1MRihzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICBpZiAoc3RhdGUgPT09IGlkcy5TRU1fUFJFKSB7XG4gICAgZGF0YS5lbmRUeXBlID0gJ0xGJztcbiAgICBpZiAoZGF0YS5zdHJpY3QpIHtcbiAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICBsaW5lOiBkYXRhLmxpbmVObyxcbiAgICAgICAgY2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICAgIG1zZzogJ2xpbmUgZW5kIGNoYXJhY3RlciBMRihcXFxcbiwgXFxcXHgwQSkgLSBzdHJpY3QgQUJORiBzcGVjaWZpZXMgQ1JMRihcXFxcclxcXFxuLCBcXFxceDBEXFxcXHgwQSknLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpZHMuU0VNX09LO1xufVxuZnVuY3Rpb24gc2VtQ1Ioc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgaWYgKHN0YXRlID09PSBpZHMuU0VNX1BSRSkge1xuICAgIGRhdGEuZW5kVHlwZSA9ICdDUic7XG4gICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgbGluZTogZGF0YS5saW5lTm8sXG4gICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICBtc2c6ICdsaW5lIGVuZCBjaGFyYWN0ZXIgQ1IoXFxcXHIsIFxcXFx4MEQpIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVzIENSTEYoXFxcXHJcXFxcbiwgXFxcXHgwRFxcXFx4MEEpJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaWRzLlNFTV9PSztcbn1cbmZ1bmN0aW9uIHNlbUNSTEYoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgaWYgKHN0YXRlID09PSBpZHMuU0VNX1BSRSkge1xuICAgIGRhdGEuZW5kVHlwZSA9ICdDUkxGJztcbiAgfVxuICByZXR1cm4gaWRzLlNFTV9PSztcbn1cbmNvbnN0IGNhbGxiYWNrcyA9IFtdO1xuY2FsbGJhY2tzLmxpbmUgPSBzZW1MaW5lO1xuY2FsbGJhY2tzWydsaW5lLXRleHQnXSA9IHNlbUxpbmVUZXh0O1xuY2FsbGJhY2tzWydsYXN0LWxpbmUnXSA9IHNlbUxhc3RMaW5lO1xuY2FsbGJhY2tzLmludmFsaWQgPSBzZW1JbnZhbGlkO1xuY2FsbGJhY2tzLmVuZCA9IHNlbUVuZDtcbmNhbGxiYWNrcy5sZiA9IHNlbUxGO1xuY2FsbGJhY2tzLmNyID0gc2VtQ1I7XG5jYWxsYmFja3MuY3JsZiA9IHNlbUNSTEY7XG5leHBvcnRzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-api/scanner-callbacks.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-api/scanner-grammar.js":
/*!************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/scanner-grammar.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved<br>\n//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\n//\n// Generated by apg-js, Version 4.0.0 [apg-js](https://github.com/ldthomas/apg-js)\nmodule.exports = function grammar(){\n  // ```\n  // SUMMARY\n  //      rules = 10\n  //       udts = 0\n  //    opcodes = 31\n  //        ---   ABNF original opcodes\n  //        ALT = 5\n  //        CAT = 2\n  //        REP = 4\n  //        RNM = 11\n  //        TLS = 0\n  //        TBS = 4\n  //        TRG = 5\n  //        ---   SABNF superset opcodes\n  //        UDT = 0\n  //        AND = 0\n  //        NOT = 0\n  //        BKA = 0\n  //        BKN = 0\n  //        BKR = 0\n  //        ABG = 0\n  //        AEN = 0\n  // characters = [0 - 4294967295]\n  // ```\n  /* OBJECT IDENTIFIER (for internal parser use) */\n  this.grammarObject = 'grammarObject';\n\n  /* RULES */\n  this.rules = [];\n  this.rules[0] = {name: 'file', lower: 'file', index: 0, isBkr: false};\n  this.rules[1] = {name: 'line', lower: 'line', index: 1, isBkr: false};\n  this.rules[2] = {name: 'line-text', lower: 'line-text', index: 2, isBkr: false};\n  this.rules[3] = {name: 'last-line', lower: 'last-line', index: 3, isBkr: false};\n  this.rules[4] = {name: 'valid', lower: 'valid', index: 4, isBkr: false};\n  this.rules[5] = {name: 'invalid', lower: 'invalid', index: 5, isBkr: false};\n  this.rules[6] = {name: 'end', lower: 'end', index: 6, isBkr: false};\n  this.rules[7] = {name: 'CRLF', lower: 'crlf', index: 7, isBkr: false};\n  this.rules[8] = {name: 'LF', lower: 'lf', index: 8, isBkr: false};\n  this.rules[9] = {name: 'CR', lower: 'cr', index: 9, isBkr: false};\n\n  /* UDTS */\n  this.udts = [];\n\n  /* OPCODES */\n  /* file */\n  this.rules[0].opcodes = [];\n  this.rules[0].opcodes[0] = {type: 2, children: [1,3]};// CAT\n  this.rules[0].opcodes[1] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[0].opcodes[2] = {type: 4, index: 1};// RNM(line)\n  this.rules[0].opcodes[3] = {type: 3, min: 0, max: 1};// REP\n  this.rules[0].opcodes[4] = {type: 4, index: 3};// RNM(last-line)\n\n  /* line */\n  this.rules[1].opcodes = [];\n  this.rules[1].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[1].opcodes[1] = {type: 4, index: 2};// RNM(line-text)\n  this.rules[1].opcodes[2] = {type: 4, index: 6};// RNM(end)\n\n  /* line-text */\n  this.rules[2].opcodes = [];\n  this.rules[2].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[2].opcodes[1] = {type: 1, children: [2,3]};// ALT\n  this.rules[2].opcodes[2] = {type: 4, index: 4};// RNM(valid)\n  this.rules[2].opcodes[3] = {type: 4, index: 5};// RNM(invalid)\n\n  /* last-line */\n  this.rules[3].opcodes = [];\n  this.rules[3].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[3].opcodes[1] = {type: 1, children: [2,3]};// ALT\n  this.rules[3].opcodes[2] = {type: 4, index: 4};// RNM(valid)\n  this.rules[3].opcodes[3] = {type: 4, index: 5};// RNM(invalid)\n\n  /* valid */\n  this.rules[4].opcodes = [];\n  this.rules[4].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[4].opcodes[1] = {type: 5, min: 32, max: 126};// TRG\n  this.rules[4].opcodes[2] = {type: 6, string: [9]};// TBS\n\n  /* invalid */\n  this.rules[5].opcodes = [];\n  this.rules[5].opcodes[0] = {type: 1, children: [1,2,3,4]};// ALT\n  this.rules[5].opcodes[1] = {type: 5, min: 0, max: 8};// TRG\n  this.rules[5].opcodes[2] = {type: 5, min: 11, max: 12};// TRG\n  this.rules[5].opcodes[3] = {type: 5, min: 14, max: 31};// TRG\n  this.rules[5].opcodes[4] = {type: 5, min: 127, max: 4294967295};// TRG\n\n  /* end */\n  this.rules[6].opcodes = [];\n  this.rules[6].opcodes[0] = {type: 1, children: [1,2,3]};// ALT\n  this.rules[6].opcodes[1] = {type: 4, index: 7};// RNM(CRLF)\n  this.rules[6].opcodes[2] = {type: 4, index: 8};// RNM(LF)\n  this.rules[6].opcodes[3] = {type: 4, index: 9};// RNM(CR)\n\n  /* CRLF */\n  this.rules[7].opcodes = [];\n  this.rules[7].opcodes[0] = {type: 6, string: [13,10]};// TBS\n\n  /* LF */\n  this.rules[8].opcodes = [];\n  this.rules[8].opcodes[0] = {type: 6, string: [10]};// TBS\n\n  /* CR */\n  this.rules[9].opcodes = [];\n  this.rules[9].opcodes[0] = {type: 6, string: [13]};// TBS\n\n  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\n  this.toString = function toString(){\n    let str = \"\";\n    str += \"file = *line [last-line]\\n\";\n    str += \"line = line-text end\\n\";\n    str += \"line-text = *(valid/invalid)\\n\";\n    str += \"last-line = 1*(valid/invalid)\\n\";\n    str += \"valid = %d32-126 / %d9\\n\";\n    str += \"invalid = %d0-8 / %d11-12 /%d14-31 / %x7f-ffffffff\\n\";\n    str += \"end = CRLF / LF / CR\\n\";\n    str += \"CRLF = %d13.10\\n\";\n    str += \"LF = %d10\\n\";\n    str += \"CR = %d13\\n\";\n    return str;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NjYW5uZXItZ3JhbW1hci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwQkFBMEI7QUFDeEQsOEJBQThCLGdDQUFnQztBQUM5RCw4QkFBOEIsbUJBQW1CO0FBQ2pELDhCQUE4Qix5QkFBeUI7QUFDdkQsOEJBQThCLG1CQUFtQjs7QUFFakQ7QUFDQTtBQUNBLDhCQUE4QiwwQkFBMEI7QUFDeEQsOEJBQThCLG1CQUFtQjtBQUNqRCw4QkFBOEIsbUJBQW1COztBQUVqRDtBQUNBO0FBQ0EsOEJBQThCLGdDQUFnQztBQUM5RCw4QkFBOEIsMEJBQTBCO0FBQ3hELDhCQUE4QixtQkFBbUI7QUFDakQsOEJBQThCLG1CQUFtQjs7QUFFakQ7QUFDQTtBQUNBLDhCQUE4QixnQ0FBZ0M7QUFDOUQsOEJBQThCLDBCQUEwQjtBQUN4RCw4QkFBOEIsbUJBQW1CO0FBQ2pELDhCQUE4QixtQkFBbUI7O0FBRWpEO0FBQ0E7QUFDQSw4QkFBOEIsMEJBQTBCO0FBQ3hELDhCQUE4Qiw0QkFBNEI7QUFDMUQsOEJBQThCLHNCQUFzQjs7QUFFcEQ7QUFDQTtBQUNBLDhCQUE4Qiw4QkFBOEI7QUFDNUQsOEJBQThCLHlCQUF5QjtBQUN2RCw4QkFBOEIsMkJBQTJCO0FBQ3pELDhCQUE4QiwyQkFBMkI7QUFDekQsOEJBQThCLG9DQUFvQzs7QUFFbEU7QUFDQTtBQUNBLDhCQUE4Qiw0QkFBNEI7QUFDMUQsOEJBQThCLG1CQUFtQjtBQUNqRCw4QkFBOEIsbUJBQW1CO0FBQ2pELDhCQUE4QixtQkFBbUI7O0FBRWpEO0FBQ0E7QUFDQSw4QkFBOEIsMEJBQTBCOztBQUV4RDtBQUNBO0FBQ0EsOEJBQThCLHVCQUF1Qjs7QUFFckQ7QUFDQTtBQUNBLDhCQUE4Qix1QkFBdUI7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvc2Nhbm5lci1ncmFtbWFyLmpzPzJlZDMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZDxicj5cbi8vICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSk8YnI+XG4vL1xuLy8gR2VuZXJhdGVkIGJ5IGFwZy1qcywgVmVyc2lvbiA0LjAuMCBbYXBnLWpzXShodHRwczovL2dpdGh1Yi5jb20vbGR0aG9tYXMvYXBnLWpzKVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBncmFtbWFyKCl7XG4gIC8vIGBgYFxuICAvLyBTVU1NQVJZXG4gIC8vICAgICAgcnVsZXMgPSAxMFxuICAvLyAgICAgICB1ZHRzID0gMFxuICAvLyAgICBvcGNvZGVzID0gMzFcbiAgLy8gICAgICAgIC0tLSAgIEFCTkYgb3JpZ2luYWwgb3Bjb2Rlc1xuICAvLyAgICAgICAgQUxUID0gNVxuICAvLyAgICAgICAgQ0FUID0gMlxuICAvLyAgICAgICAgUkVQID0gNFxuICAvLyAgICAgICAgUk5NID0gMTFcbiAgLy8gICAgICAgIFRMUyA9IDBcbiAgLy8gICAgICAgIFRCUyA9IDRcbiAgLy8gICAgICAgIFRSRyA9IDVcbiAgLy8gICAgICAgIC0tLSAgIFNBQk5GIHN1cGVyc2V0IG9wY29kZXNcbiAgLy8gICAgICAgIFVEVCA9IDBcbiAgLy8gICAgICAgIEFORCA9IDBcbiAgLy8gICAgICAgIE5PVCA9IDBcbiAgLy8gICAgICAgIEJLQSA9IDBcbiAgLy8gICAgICAgIEJLTiA9IDBcbiAgLy8gICAgICAgIEJLUiA9IDBcbiAgLy8gICAgICAgIEFCRyA9IDBcbiAgLy8gICAgICAgIEFFTiA9IDBcbiAgLy8gY2hhcmFjdGVycyA9IFswIC0gNDI5NDk2NzI5NV1cbiAgLy8gYGBgXG4gIC8qIE9CSkVDVCBJREVOVElGSUVSIChmb3IgaW50ZXJuYWwgcGFyc2VyIHVzZSkgKi9cbiAgdGhpcy5ncmFtbWFyT2JqZWN0ID0gJ2dyYW1tYXJPYmplY3QnO1xuXG4gIC8qIFJVTEVTICovXG4gIHRoaXMucnVsZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1swXSA9IHtuYW1lOiAnZmlsZScsIGxvd2VyOiAnZmlsZScsIGluZGV4OiAwLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzFdID0ge25hbWU6ICdsaW5lJywgbG93ZXI6ICdsaW5lJywgaW5kZXg6IDEsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMl0gPSB7bmFtZTogJ2xpbmUtdGV4dCcsIGxvd2VyOiAnbGluZS10ZXh0JywgaW5kZXg6IDIsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbM10gPSB7bmFtZTogJ2xhc3QtbGluZScsIGxvd2VyOiAnbGFzdC1saW5lJywgaW5kZXg6IDMsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNF0gPSB7bmFtZTogJ3ZhbGlkJywgbG93ZXI6ICd2YWxpZCcsIGluZGV4OiA0LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzVdID0ge25hbWU6ICdpbnZhbGlkJywgbG93ZXI6ICdpbnZhbGlkJywgaW5kZXg6IDUsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNl0gPSB7bmFtZTogJ2VuZCcsIGxvd2VyOiAnZW5kJywgaW5kZXg6IDYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbN10gPSB7bmFtZTogJ0NSTEYnLCBsb3dlcjogJ2NybGYnLCBpbmRleDogNywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s4XSA9IHtuYW1lOiAnTEYnLCBsb3dlcjogJ2xmJywgaW5kZXg6IDgsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbOV0gPSB7bmFtZTogJ0NSJywgbG93ZXI6ICdjcicsIGluZGV4OiA5LCBpc0JrcjogZmFsc2V9O1xuXG4gIC8qIFVEVFMgKi9cbiAgdGhpcy51ZHRzID0gW107XG5cbiAgLyogT1BDT0RFUyAqL1xuICAvKiBmaWxlICovXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzBdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDNdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1swXS5vcGNvZGVzWzFdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogMX07Ly8gUk5NKGxpbmUpXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2Rlc1szXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA0LCBpbmRleDogM307Ly8gUk5NKGxhc3QtbGluZSlcblxuICAvKiBsaW5lICovXG4gIHRoaXMucnVsZXNbMV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzFdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1sxXS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiAyfTsvLyBSTk0obGluZS10ZXh0KVxuICB0aGlzLnJ1bGVzWzFdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDZ9Oy8vIFJOTShlbmQpXG5cbiAgLyogbGluZS10ZXh0ICovXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzJdLm9wY29kZXNbMF0gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1syXS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogNH07Ly8gUk5NKHZhbGlkKVxuICB0aGlzLnJ1bGVzWzJdLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDV9Oy8vIFJOTShpbnZhbGlkKVxuXG4gIC8qIGxhc3QtbGluZSAqL1xuICB0aGlzLnJ1bGVzWzNdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szXS5vcGNvZGVzWzBdID0ge3R5cGU6IDMsIG1pbjogMSwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbM10ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzIsM119Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzNdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDR9Oy8vIFJOTSh2YWxpZClcbiAgdGhpcy5ydWxlc1szXS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiA1fTsvLyBSTk0oaW52YWxpZClcblxuICAvKiB2YWxpZCAqL1xuICB0aGlzLnJ1bGVzWzRdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA1LCBtaW46IDMyLCBtYXg6IDEyNn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbNF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5XX07Ly8gVEJTXG5cbiAgLyogaW52YWxpZCAqL1xuICB0aGlzLnJ1bGVzWzVdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s1XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyLDMsNF19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzVdLm9wY29kZXNbMV0gPSB7dHlwZTogNSwgbWluOiAwLCBtYXg6IDh9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzVdLm9wY29kZXNbMl0gPSB7dHlwZTogNSwgbWluOiAxMSwgbWF4OiAxMn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbNV0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA1LCBtaW46IDE0LCBtYXg6IDMxfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s1XS5vcGNvZGVzWzRdID0ge3R5cGU6IDUsIG1pbjogMTI3LCBtYXg6IDQyOTQ5NjcyOTV9Oy8vIFRSR1xuXG4gIC8qIGVuZCAqL1xuICB0aGlzLnJ1bGVzWzZdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyLDNdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s2XS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiA3fTsvLyBSTk0oQ1JMRilcbiAgdGhpcy5ydWxlc1s2XS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiA4fTsvLyBSTk0oTEYpXG4gIHRoaXMucnVsZXNbNl0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA0LCBpbmRleDogOX07Ly8gUk5NKENSKVxuXG4gIC8qIENSTEYgKi9cbiAgdGhpcy5ydWxlc1s3XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbN10ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxMywxMF19Oy8vIFRCU1xuXG4gIC8qIExGICovXG4gIHRoaXMucnVsZXNbOF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzhdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMTBdfTsvLyBUQlNcblxuICAvKiBDUiAqL1xuICB0aGlzLnJ1bGVzWzldLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s5XS5vcGNvZGVzWzBdID0ge3R5cGU6IDYsIHN0cmluZzogWzEzXX07Ly8gVEJTXG5cbiAgLy8gVGhlIGB0b1N0cmluZygpYCBmdW5jdGlvbiB3aWxsIGRpc3BsYXkgdGhlIG9yaWdpbmFsIGdyYW1tYXIgZmlsZShzKSB0aGF0IHByb2R1Y2VkIHRoZXNlIG9wY29kZXMuXG4gIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIGxldCBzdHIgPSBcIlwiO1xuICAgIHN0ciArPSBcImZpbGUgPSAqbGluZSBbbGFzdC1saW5lXVxcblwiO1xuICAgIHN0ciArPSBcImxpbmUgPSBsaW5lLXRleHQgZW5kXFxuXCI7XG4gICAgc3RyICs9IFwibGluZS10ZXh0ID0gKih2YWxpZC9pbnZhbGlkKVxcblwiO1xuICAgIHN0ciArPSBcImxhc3QtbGluZSA9IDEqKHZhbGlkL2ludmFsaWQpXFxuXCI7XG4gICAgc3RyICs9IFwidmFsaWQgPSAlZDMyLTEyNiAvICVkOVxcblwiO1xuICAgIHN0ciArPSBcImludmFsaWQgPSAlZDAtOCAvICVkMTEtMTIgLyVkMTQtMzEgLyAleDdmLWZmZmZmZmZmXFxuXCI7XG4gICAgc3RyICs9IFwiZW5kID0gQ1JMRiAvIExGIC8gQ1JcXG5cIjtcbiAgICBzdHIgKz0gXCJDUkxGID0gJWQxMy4xMFxcblwiO1xuICAgIHN0ciArPSBcIkxGID0gJWQxMFxcblwiO1xuICAgIHN0ciArPSBcIkNSID0gJWQxM1xcblwiO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-api/scanner-grammar.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-api/scanner.js":
/*!****************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/scanner.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module reads the input grammar file and does a preliminary analysis\n// before attempting to parse it into a grammar object.\n// See:<br>\n// `./dist/scanner-grammar.bnf`<br>\n// for the grammar file this parser is based on.\n//\n// It has two primary functions.\n// - verify the character codes - no non-printing ASCII characters\n// - catalog the lines - create an array with a line object for each line.\n// The object carries information about the line number and character length which is used\n// by the parser generator primarily for error reporting.\nmodule.exports = function exfn(chars, errors, strict, trace) {\n  const thisFileName = 'scanner.js: ';\n  const apglib = __webpack_require__(/*! ../apg-lib/node-exports */ \"./node_modules/apg-js/src/apg-lib/node-exports.js\");\n  const grammar = new (__webpack_require__(/*! ./scanner-grammar */ \"./node_modules/apg-js/src/apg-api/scanner-grammar.js\"))();\n  const { callbacks } = __webpack_require__(/*! ./scanner-callbacks */ \"./node_modules/apg-js/src/apg-api/scanner-callbacks.js\");\n\n  /* Scan the grammar for character code errors and catalog the lines. */\n  const lines = [];\n  // eslint-disable-next-line new-cap\n  const parser = new apglib.parser();\n  // eslint-disable-next-line new-cap\n  parser.ast = new apglib.ast();\n  parser.ast.callbacks = callbacks;\n  if (trace) {\n    if (trace.traceObject !== 'traceObject') {\n      throw new TypeError(`${thisFileName}trace argument is not a trace object`);\n    }\n    parser.trace = trace;\n  }\n\n  /* parse the input SABNF grammar */\n  const test = parser.parse(grammar, 'file', chars);\n  if (test.success !== true) {\n    errors.push({\n      line: 0,\n      char: 0,\n      msg: 'syntax analysis error analyzing input SABNF grammar',\n    });\n    return;\n  }\n  const data = {\n    lines,\n    lineNo: 0,\n    errors,\n    strict: !!strict,\n  };\n\n  /* translate (analyze) the input SABNF grammar */\n  parser.ast.translate(data);\n  // eslint-disable-next-line consistent-return\n  return lines;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NjYW5uZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLGtGQUF5QjtBQUNsRCx1QkFBdUIsbUJBQU8sQ0FBQywrRUFBbUI7QUFDbEQsVUFBVSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxtRkFBcUI7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixhQUFhO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWFwaS9zY2FubmVyLmpzP2IwODAiXSwic291cmNlc0NvbnRlbnQiOlsiLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgcmVhZHMgdGhlIGlucHV0IGdyYW1tYXIgZmlsZSBhbmQgZG9lcyBhIHByZWxpbWluYXJ5IGFuYWx5c2lzXG4vLyBiZWZvcmUgYXR0ZW1wdGluZyB0byBwYXJzZSBpdCBpbnRvIGEgZ3JhbW1hciBvYmplY3QuXG4vLyBTZWU6PGJyPlxuLy8gYC4vZGlzdC9zY2FubmVyLWdyYW1tYXIuYm5mYDxicj5cbi8vIGZvciB0aGUgZ3JhbW1hciBmaWxlIHRoaXMgcGFyc2VyIGlzIGJhc2VkIG9uLlxuLy9cbi8vIEl0IGhhcyB0d28gcHJpbWFyeSBmdW5jdGlvbnMuXG4vLyAtIHZlcmlmeSB0aGUgY2hhcmFjdGVyIGNvZGVzIC0gbm8gbm9uLXByaW50aW5nIEFTQ0lJIGNoYXJhY3RlcnNcbi8vIC0gY2F0YWxvZyB0aGUgbGluZXMgLSBjcmVhdGUgYW4gYXJyYXkgd2l0aCBhIGxpbmUgb2JqZWN0IGZvciBlYWNoIGxpbmUuXG4vLyBUaGUgb2JqZWN0IGNhcnJpZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxpbmUgbnVtYmVyIGFuZCBjaGFyYWN0ZXIgbGVuZ3RoIHdoaWNoIGlzIHVzZWRcbi8vIGJ5IHRoZSBwYXJzZXIgZ2VuZXJhdG9yIHByaW1hcmlseSBmb3IgZXJyb3IgcmVwb3J0aW5nLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleGZuKGNoYXJzLCBlcnJvcnMsIHN0cmljdCwgdHJhY2UpIHtcbiAgY29uc3QgdGhpc0ZpbGVOYW1lID0gJ3NjYW5uZXIuanM6ICc7XG4gIGNvbnN0IGFwZ2xpYiA9IHJlcXVpcmUoJy4uL2FwZy1saWIvbm9kZS1leHBvcnRzJyk7XG4gIGNvbnN0IGdyYW1tYXIgPSBuZXcgKHJlcXVpcmUoJy4vc2Nhbm5lci1ncmFtbWFyJykpKCk7XG4gIGNvbnN0IHsgY2FsbGJhY2tzIH0gPSByZXF1aXJlKCcuL3NjYW5uZXItY2FsbGJhY2tzJyk7XG5cbiAgLyogU2NhbiB0aGUgZ3JhbW1hciBmb3IgY2hhcmFjdGVyIGNvZGUgZXJyb3JzIGFuZCBjYXRhbG9nIHRoZSBsaW5lcy4gKi9cbiAgY29uc3QgbGluZXMgPSBbXTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXBcbiAgY29uc3QgcGFyc2VyID0gbmV3IGFwZ2xpYi5wYXJzZXIoKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXBcbiAgcGFyc2VyLmFzdCA9IG5ldyBhcGdsaWIuYXN0KCk7XG4gIHBhcnNlci5hc3QuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICBpZiAodHJhY2UpIHtcbiAgICBpZiAodHJhY2UudHJhY2VPYmplY3QgIT09ICd0cmFjZU9iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXRyYWNlIGFyZ3VtZW50IGlzIG5vdCBhIHRyYWNlIG9iamVjdGApO1xuICAgIH1cbiAgICBwYXJzZXIudHJhY2UgPSB0cmFjZTtcbiAgfVxuXG4gIC8qIHBhcnNlIHRoZSBpbnB1dCBTQUJORiBncmFtbWFyICovXG4gIGNvbnN0IHRlc3QgPSBwYXJzZXIucGFyc2UoZ3JhbW1hciwgJ2ZpbGUnLCBjaGFycyk7XG4gIGlmICh0ZXN0LnN1Y2Nlc3MgIT09IHRydWUpIHtcbiAgICBlcnJvcnMucHVzaCh7XG4gICAgICBsaW5lOiAwLFxuICAgICAgY2hhcjogMCxcbiAgICAgIG1zZzogJ3N5bnRheCBhbmFseXNpcyBlcnJvciBhbmFseXppbmcgaW5wdXQgU0FCTkYgZ3JhbW1hcicsXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgbGluZXMsXG4gICAgbGluZU5vOiAwLFxuICAgIGVycm9ycyxcbiAgICBzdHJpY3Q6ICEhc3RyaWN0LFxuICB9O1xuXG4gIC8qIHRyYW5zbGF0ZSAoYW5hbHl6ZSkgdGhlIGlucHV0IFNBQk5GIGdyYW1tYXIgKi9cbiAgcGFyc2VyLmFzdC50cmFuc2xhdGUoZGF0YSk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICByZXR1cm4gbGluZXM7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-api/scanner.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-api/semantic-callbacks.js":
/*!***************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/semantic-callbacks.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module has all of the AST translation callback functions for the semantic analysis\n// phase of the generator.\n// See:<br>\n// `./dist/abnf-for-sabnf-grammar.bnf`<br>\n// for the grammar file these callback functions are based on.\nmodule.exports = function exfn() {\n  const apglib = __webpack_require__(/*! ../apg-lib/node-exports */ \"./node_modules/apg-js/src/apg-lib/node-exports.js\");\n  const id = apglib.ids;\n\n  /* Some helper functions. */\n  const NameList = function NameList() {\n    this.names = [];\n    /* Adds a new rule name object to the list. Returns -1 if the name already exists. */\n    /* Returns the added name object if the name does not already exist. */\n    this.add = function add(name) {\n      let ret = -1;\n      const find = this.get(name);\n      if (find === -1) {\n        ret = {\n          name,\n          lower: name.toLowerCase(),\n          index: this.names.length,\n        };\n        this.names.push(ret);\n      }\n      return ret;\n    };\n    /* Brute-force look up. */\n    this.get = function get(name) {\n      let ret = -1;\n      const lower = name.toLowerCase();\n      for (let i = 0; i < this.names.length; i += 1) {\n        if (this.names[i].lower === lower) {\n          ret = this.names[i];\n          break;\n        }\n      }\n      return ret;\n    };\n  };\n  /* converts text decimal numbers from, e.g. %d99, to an integer */\n  const decnum = function decnum(chars, beg, len) {\n    let num = 0;\n    for (let i = beg; i < beg + len; i += 1) {\n      num = 10 * num + chars[i] - 48;\n    }\n    return num;\n  };\n  /* converts text binary numbers from, e.g. %b10, to an integer */\n  const binnum = function binnum(chars, beg, len) {\n    let num = 0;\n    for (let i = beg; i < beg + len; i += 1) {\n      num = 2 * num + chars[i] - 48;\n    }\n    return num;\n  };\n  /* converts text hexadecimal numbers from, e.g. %xff, to an integer */\n  const hexnum = function hexnum(chars, beg, len) {\n    let num = 0;\n    for (let i = beg; i < beg + len; i += 1) {\n      let digit = chars[i];\n      if (digit >= 48 && digit <= 57) {\n        digit -= 48;\n      } else if (digit >= 65 && digit <= 70) {\n        digit -= 55;\n      } else if (digit >= 97 && digit <= 102) {\n        digit -= 87;\n      } else {\n        throw new Error('hexnum out of range');\n      }\n      num = 16 * num + digit;\n    }\n    return num;\n  };\n\n  // This is the prototype for all semantic analysis callback functions.\n  // ````\n  // state - the translator state\n  //   id.SEM_PRE for downward (pre-branch) traversal of the AST\n  //   id.SEM_POST for upward (post branch) traversal of the AST\n  // chars - the array of character codes for the input string\n  // phraseIndex - index into the chars array to the first\n  //               character of the phrase\n  // phraseCount - the number of characters in the phrase\n  // data - user-defined data passed to the translator\n  //        for use by the callback functions.\n  // @return id.SEM_OK, normal return.\n  //         id.SEM_SKIP in state id.SEM_PRE will\n  //         skip the branch below.\n  //         Any thing else is an error which will\n  //         stop the translation.\n  // ````\n  /*\n  function semCallbackPrototype(state, chars, phraseIndex, phraseCount, data) {\n    let ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n    } else if (state === id.SEM_POST) {\n    }\n    return ret;\n  }\n  */\n  // The AST callback functions.\n  function semFile(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ruleNames = new NameList();\n      data.udtNames = new NameList();\n      data.rules = [];\n      data.udts = [];\n      data.rulesLineMap = [];\n      data.opcodes = [];\n      data.altStack = [];\n      data.topStack = null;\n      data.topRule = null;\n    } else if (state === id.SEM_POST) {\n      /* validate RNM rule names and set opcode rule index */\n      let nameObj;\n      data.rules.forEach((rule) => {\n        rule.isBkr = false;\n        rule.opcodes.forEach((op) => {\n          if (op.type === id.RNM) {\n            nameObj = data.ruleNames.get(op.index.name);\n            if (nameObj === -1) {\n              data.errors.push({\n                line: data.findLine(data.lines, op.index.phraseIndex, data.charsLength),\n                char: op.index.phraseIndex,\n                msg: `Rule name '${op.index.name}' used but not defined.`,\n              });\n              op.index = -1;\n            } else {\n              op.index = nameObj.index;\n            }\n          }\n        });\n      });\n      /* validate BKR rule names and set opcode rule index */\n      data.udts.forEach((udt) => {\n        udt.isBkr = false;\n      });\n      data.rules.forEach((rule) => {\n        rule.opcodes.forEach((op) => {\n          if (op.type === id.BKR) {\n            rule.hasBkr = true;\n            nameObj = data.ruleNames.get(op.index.name);\n            if (nameObj !== -1) {\n              data.rules[nameObj.index].isBkr = true;\n              op.index = nameObj.index;\n            } else {\n              nameObj = data.udtNames.get(op.index.name);\n              if (nameObj !== -1) {\n                data.udts[nameObj.index].isBkr = true;\n                op.index = data.rules.length + nameObj.index;\n              } else {\n                data.errors.push({\n                  line: data.findLine(data.lines, op.index.phraseIndex, data.charsLength),\n                  char: op.index.phraseIndex,\n                  msg: `Back reference name '${op.index.name}' refers to undefined rule or unamed UDT.`,\n                });\n                op.index = -1;\n              }\n            }\n          }\n        });\n      });\n    }\n    return ret;\n  }\n  function semRule(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.altStack.length = 0;\n      data.topStack = null;\n      data.rulesLineMap.push({\n        line: data.findLine(data.lines, phraseIndex, data.charsLength),\n        char: phraseIndex,\n      });\n    }\n    return ret;\n  }\n  function semRuleLookup(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ruleName = '';\n      data.definedas = '';\n    } else if (state === id.SEM_POST) {\n      let ruleName;\n      if (data.definedas === '=') {\n        ruleName = data.ruleNames.add(data.ruleName);\n        if (ruleName === -1) {\n          data.definedas = null;\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Rule name '${data.ruleName}' previously defined.`,\n          });\n        } else {\n          /* start a new rule */\n          data.topRule = {\n            name: ruleName.name,\n            lower: ruleName.lower,\n            opcodes: [],\n            index: ruleName.index,\n          };\n          data.rules.push(data.topRule);\n          data.opcodes = data.topRule.opcodes;\n        }\n      } else {\n        ruleName = data.ruleNames.get(data.ruleName);\n        if (ruleName === -1) {\n          data.definedas = null;\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Rule name '${data.ruleName}' for incremental alternate not previously defined.`,\n          });\n        } else {\n          data.topRule = data.rules[ruleName.index];\n          data.opcodes = data.topRule.opcodes;\n        }\n      }\n    }\n    return ret;\n  }\n  function semAlternation(state, chars, phraseIndex, phraseCount, data) {\n    let ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      const TRUE = true;\n      while (TRUE) {\n        if (data.definedas === null) {\n          /* rule error - skip opcode generation */\n          ret = id.SEM_SKIP;\n          break;\n        }\n        if (data.topStack === null) {\n          /* top-level ALT */\n          if (data.definedas === '=') {\n            /* \"=\" new rule */\n            data.topStack = {\n              alt: {\n                type: id.ALT,\n                children: [],\n              },\n              cat: null,\n            };\n            data.altStack.push(data.topStack);\n            data.opcodes.push(data.topStack.alt);\n            break;\n          }\n          /* \"=/\" incremental alternate */\n          data.topStack = {\n            alt: data.opcodes[0],\n            cat: null,\n          };\n          data.altStack.push(data.topStack);\n          break;\n        }\n        /* lower-level ALT */\n        data.topStack = {\n          alt: {\n            type: id.ALT,\n            children: [],\n          },\n          cat: null,\n        };\n        data.altStack.push(data.topStack);\n        data.opcodes.push(data.topStack.alt);\n        break;\n      }\n    } else if (state === id.SEM_POST) {\n      data.altStack.pop();\n      if (data.altStack.length > 0) {\n        data.topStack = data.altStack[data.altStack.length - 1];\n      } else {\n        data.topStack = null;\n      }\n    }\n    return ret;\n  }\n  function semConcatenation(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.topStack.alt.children.push(data.opcodes.length);\n      data.topStack.cat = {\n        type: id.CAT,\n        children: [],\n      };\n      data.opcodes.push(data.topStack.cat);\n    } else if (state === id.SEM_POST) {\n      data.topStack.cat = null;\n    }\n    return ret;\n  }\n  function semRepetition(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.topStack.cat.children.push(data.opcodes.length);\n    }\n    return ret;\n  }\n  function semOptionOpen(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.REP,\n        min: 0,\n        max: 1,\n        char: phraseIndex,\n      });\n    }\n    return ret;\n  }\n  function semRuleName(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ruleName = apglib.utils.charsToString(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semDefined(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.definedas = '=';\n    }\n    return ret;\n  }\n  function semIncAlt(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.definedas = '=/';\n    }\n    return ret;\n  }\n  function semRepOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.min = 0;\n      data.max = Infinity;\n      data.topRep = {\n        type: id.REP,\n        min: 0,\n        max: Infinity,\n      };\n      data.opcodes.push(data.topRep);\n    } else if (state === id.SEM_POST) {\n      if (data.min > data.max) {\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: `repetition min cannot be greater than max: min: ${data.min}: max: ${data.max}`,\n        });\n      }\n      data.topRep.min = data.min;\n      data.topRep.max = data.max;\n    }\n    return ret;\n  }\n  function semRepMin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semRepMax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semRepMinMax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = decnum(chars, phraseIndex, phraseCount);\n      data.min = data.max;\n    }\n    return ret;\n  }\n  function semAndOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.AND,\n      });\n    }\n    return ret;\n  }\n  function semNotOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.NOT,\n      });\n    }\n    return ret;\n  }\n  function semRnmOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.RNM,\n        /* NOTE: this is temporary info, index will be replaced with integer later. */\n        /* Probably not the best coding practice but here you go. */\n        index: {\n          phraseIndex,\n          name: apglib.utils.charsToString(chars, phraseIndex, phraseCount),\n        },\n      });\n    }\n    return ret;\n  }\n  function semAbgOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.ABG,\n      });\n    }\n    return ret;\n  }\n  function semAenOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.AEN,\n      });\n    }\n    return ret;\n  }\n  function semBkaOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.BKA,\n      });\n    }\n    return ret;\n  }\n  function semBknOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.BKN,\n      });\n    }\n    return ret;\n  }\n  function semBkrOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ci = true; /* default to case insensitive */\n      data.cs = false;\n      data.um = true;\n      data.pm = false;\n    } else if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.BKR,\n        bkrCase: data.cs === true ? id.BKR_MODE_CS : id.BKR_MODE_CI,\n        bkrMode: data.pm === true ? id.BKR_MODE_PM : id.BKR_MODE_UM,\n        /* NOTE: this is temporary info, index will be replaced with integer later. */\n        /* Probably not the best coding practice but here you go. */\n        index: {\n          phraseIndex: data.bkrname.phraseIndex,\n          name: apglib.utils.charsToString(chars, data.bkrname.phraseIndex, data.bkrname.phraseLength),\n        },\n      });\n    }\n    return ret;\n  }\n  function semBkrCi(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.ci = true;\n    }\n    return ret;\n  }\n  function semBkrCs(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.cs = true;\n    }\n    return ret;\n  }\n  function semBkrUm(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.um = true;\n    }\n    return ret;\n  }\n  function semBkrPm(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.pm = true;\n    }\n    return ret;\n  }\n  function semBkrName(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.bkrname = {\n        phraseIndex,\n        phraseLength: phraseCount,\n      };\n    }\n    return ret;\n  }\n  function semUdtEmpty(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      const name = apglib.utils.charsToString(chars, phraseIndex, phraseCount);\n      let udtName = data.udtNames.add(name);\n      if (udtName === -1) {\n        udtName = data.udtNames.get(name);\n        if (udtName === -1) {\n          throw new Error('semUdtEmpty: name look up error');\n        }\n      } else {\n        data.udts.push({\n          name: udtName.name,\n          lower: udtName.lower,\n          index: udtName.index,\n          empty: true,\n        });\n      }\n      data.opcodes.push({\n        type: id.UDT,\n        empty: true,\n        index: udtName.index,\n      });\n    }\n    return ret;\n  }\n  function semUdtNonEmpty(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      const name = apglib.utils.charsToString(chars, phraseIndex, phraseCount);\n      let udtName = data.udtNames.add(name);\n      if (udtName === -1) {\n        udtName = data.udtNames.get(name);\n        if (udtName === -1) {\n          throw new Error('semUdtNonEmpty: name look up error');\n        }\n      } else {\n        data.udts.push({\n          name: udtName.name,\n          lower: udtName.lower,\n          index: udtName.index,\n          empty: false,\n        });\n      }\n      data.opcodes.push({\n        type: id.UDT,\n        empty: false,\n        index: udtName.index,\n        syntax: null,\n        semantic: null,\n      });\n    }\n    return ret;\n  }\n  function semTlsOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.tlscase = true; /* default to case insensitive */\n    }\n    return ret;\n  }\n  function semTlsCase(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      if (phraseCount > 0 && (chars[phraseIndex + 1] === 83 || chars[phraseIndex + 1] === 115)) {\n        data.tlscase = false; /* set to case sensitive */\n      }\n    }\n    return ret;\n  }\n  function semTlsString(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      if (data.tlscase) {\n        const str = chars.slice(phraseIndex, phraseIndex + phraseCount);\n        for (let i = 0; i < str.length; i += 1) {\n          if (str[i] >= 65 && str[i] <= 90) {\n            str[i] += 32;\n          }\n        }\n        data.opcodes.push({\n          type: id.TLS,\n          string: str,\n        });\n      } else {\n        data.opcodes.push({\n          type: id.TBS,\n          string: chars.slice(phraseIndex, phraseIndex + phraseCount),\n        });\n      }\n    }\n    return ret;\n  }\n  function semClsOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      if (phraseCount <= 2) {\n        /* only TLS is allowed to be empty */\n        data.opcodes.push({\n          type: id.TLS,\n          string: [],\n        });\n      } else {\n        data.opcodes.push({\n          type: id.TBS,\n          string: chars.slice(phraseIndex + 1, phraseIndex + phraseCount - 1),\n        });\n      }\n    }\n    return ret;\n  }\n  function semTbsOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.tbsstr = [];\n    } else if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.TBS,\n        string: data.tbsstr,\n      });\n    }\n    return ret;\n  }\n  function semTrgOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.min = 0;\n      data.max = 0;\n    } else if (state === id.SEM_POST) {\n      if (data.min > data.max) {\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: `TRG, (%dmin-max), min cannot be greater than max: min: ${data.min}: max: ${data.max}`,\n        });\n      }\n      data.opcodes.push({\n        type: id.TRG,\n        min: data.min,\n        max: data.max,\n      });\n    }\n    return ret;\n  }\n  function semDmin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semDmax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semBmin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = binnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semBmax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = binnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semXmin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = hexnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semXmax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = hexnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semDstring(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.tbsstr.push(decnum(chars, phraseIndex, phraseCount));\n    }\n    return ret;\n  }\n  function semBstring(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.tbsstr.push(binnum(chars, phraseIndex, phraseCount));\n    }\n    return ret;\n  }\n  function semXstring(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.tbsstr.push(hexnum(chars, phraseIndex, phraseCount));\n    }\n    return ret;\n  }\n  // Define the callback functions to the AST object.\n  this.callbacks = [];\n  this.callbacks.abgop = semAbgOp;\n  this.callbacks.aenop = semAenOp;\n  this.callbacks.alternation = semAlternation;\n  this.callbacks.andop = semAndOp;\n  this.callbacks.bmax = semBmax;\n  this.callbacks.bmin = semBmin;\n  this.callbacks.bkaop = semBkaOp;\n  this.callbacks.bknop = semBknOp;\n  this.callbacks.bkrop = semBkrOp;\n  this.callbacks['bkr-name'] = semBkrName;\n  this.callbacks.bstring = semBstring;\n  this.callbacks.clsop = semClsOp;\n  this.callbacks.ci = semBkrCi;\n  this.callbacks.cs = semBkrCs;\n  this.callbacks.um = semBkrUm;\n  this.callbacks.pm = semBkrPm;\n  this.callbacks.concatenation = semConcatenation;\n  this.callbacks.defined = semDefined;\n  this.callbacks.dmax = semDmax;\n  this.callbacks.dmin = semDmin;\n  this.callbacks.dstring = semDstring;\n  this.callbacks.file = semFile;\n  this.callbacks.incalt = semIncAlt;\n  this.callbacks.notop = semNotOp;\n  this.callbacks.optionopen = semOptionOpen;\n  this.callbacks['rep-max'] = semRepMax;\n  this.callbacks['rep-min'] = semRepMin;\n  this.callbacks['rep-min-max'] = semRepMinMax;\n  this.callbacks.repetition = semRepetition;\n  this.callbacks.repop = semRepOp;\n  this.callbacks.rnmop = semRnmOp;\n  this.callbacks.rule = semRule;\n  this.callbacks.rulelookup = semRuleLookup;\n  this.callbacks.rulename = semRuleName;\n  this.callbacks.tbsop = semTbsOp;\n  this.callbacks.tlscase = semTlsCase;\n  this.callbacks.tlsstring = semTlsString;\n  this.callbacks.tlsop = semTlsOp;\n  this.callbacks.trgop = semTrgOp;\n  this.callbacks['udt-empty'] = semUdtEmpty;\n  this.callbacks['udt-non-empty'] = semUdtNonEmpty;\n  this.callbacks.xmax = semXmax;\n  this.callbacks.xmin = semXmin;\n  this.callbacks.xstring = semXstring;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NlbWFudGljLWNhbGxiYWNrcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLGtGQUF5QjtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRCxlQUFlO0FBQ2Y7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0MsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QyxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFNBQVMsU0FBUyxTQUFTO0FBQzdGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxTQUFTLFNBQVMsU0FBUztBQUNwRyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvc2VtYW50aWMtY2FsbGJhY2tzLmpzPzhiN2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgaGFzIGFsbCBvZiB0aGUgQVNUIHRyYW5zbGF0aW9uIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgdGhlIHNlbWFudGljIGFuYWx5c2lzXG4vLyBwaGFzZSBvZiB0aGUgZ2VuZXJhdG9yLlxuLy8gU2VlOjxicj5cbi8vIGAuL2Rpc3QvYWJuZi1mb3Itc2FibmYtZ3JhbW1hci5ibmZgPGJyPlxuLy8gZm9yIHRoZSBncmFtbWFyIGZpbGUgdGhlc2UgY2FsbGJhY2sgZnVuY3Rpb25zIGFyZSBiYXNlZCBvbi5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXhmbigpIHtcbiAgY29uc3QgYXBnbGliID0gcmVxdWlyZSgnLi4vYXBnLWxpYi9ub2RlLWV4cG9ydHMnKTtcbiAgY29uc3QgaWQgPSBhcGdsaWIuaWRzO1xuXG4gIC8qIFNvbWUgaGVscGVyIGZ1bmN0aW9ucy4gKi9cbiAgY29uc3QgTmFtZUxpc3QgPSBmdW5jdGlvbiBOYW1lTGlzdCgpIHtcbiAgICB0aGlzLm5hbWVzID0gW107XG4gICAgLyogQWRkcyBhIG5ldyBydWxlIG5hbWUgb2JqZWN0IHRvIHRoZSBsaXN0LiBSZXR1cm5zIC0xIGlmIHRoZSBuYW1lIGFscmVhZHkgZXhpc3RzLiAqL1xuICAgIC8qIFJldHVybnMgdGhlIGFkZGVkIG5hbWUgb2JqZWN0IGlmIHRoZSBuYW1lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QuICovXG4gICAgdGhpcy5hZGQgPSBmdW5jdGlvbiBhZGQobmFtZSkge1xuICAgICAgbGV0IHJldCA9IC0xO1xuICAgICAgY29uc3QgZmluZCA9IHRoaXMuZ2V0KG5hbWUpO1xuICAgICAgaWYgKGZpbmQgPT09IC0xKSB7XG4gICAgICAgIHJldCA9IHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGxvd2VyOiBuYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgaW5kZXg6IHRoaXMubmFtZXMubGVuZ3RoLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5hbWVzLnB1c2gocmV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICAvKiBCcnV0ZS1mb3JjZSBsb29rIHVwLiAqL1xuICAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICAgIGxldCByZXQgPSAtMTtcbiAgICAgIGNvbnN0IGxvd2VyID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLm5hbWVzW2ldLmxvd2VyID09PSBsb3dlcikge1xuICAgICAgICAgIHJldCA9IHRoaXMubmFtZXNbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgfTtcbiAgLyogY29udmVydHMgdGV4dCBkZWNpbWFsIG51bWJlcnMgZnJvbSwgZS5nLiAlZDk5LCB0byBhbiBpbnRlZ2VyICovXG4gIGNvbnN0IGRlY251bSA9IGZ1bmN0aW9uIGRlY251bShjaGFycywgYmVnLCBsZW4pIHtcbiAgICBsZXQgbnVtID0gMDtcbiAgICBmb3IgKGxldCBpID0gYmVnOyBpIDwgYmVnICsgbGVuOyBpICs9IDEpIHtcbiAgICAgIG51bSA9IDEwICogbnVtICsgY2hhcnNbaV0gLSA0ODtcbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcbiAgLyogY29udmVydHMgdGV4dCBiaW5hcnkgbnVtYmVycyBmcm9tLCBlLmcuICViMTAsIHRvIGFuIGludGVnZXIgKi9cbiAgY29uc3QgYmlubnVtID0gZnVuY3Rpb24gYmlubnVtKGNoYXJzLCBiZWcsIGxlbikge1xuICAgIGxldCBudW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSBiZWc7IGkgPCBiZWcgKyBsZW47IGkgKz0gMSkge1xuICAgICAgbnVtID0gMiAqIG51bSArIGNoYXJzW2ldIC0gNDg7XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG4gIC8qIGNvbnZlcnRzIHRleHQgaGV4YWRlY2ltYWwgbnVtYmVycyBmcm9tLCBlLmcuICV4ZmYsIHRvIGFuIGludGVnZXIgKi9cbiAgY29uc3QgaGV4bnVtID0gZnVuY3Rpb24gaGV4bnVtKGNoYXJzLCBiZWcsIGxlbikge1xuICAgIGxldCBudW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSBiZWc7IGkgPCBiZWcgKyBsZW47IGkgKz0gMSkge1xuICAgICAgbGV0IGRpZ2l0ID0gY2hhcnNbaV07XG4gICAgICBpZiAoZGlnaXQgPj0gNDggJiYgZGlnaXQgPD0gNTcpIHtcbiAgICAgICAgZGlnaXQgLT0gNDg7XG4gICAgICB9IGVsc2UgaWYgKGRpZ2l0ID49IDY1ICYmIGRpZ2l0IDw9IDcwKSB7XG4gICAgICAgIGRpZ2l0IC09IDU1O1xuICAgICAgfSBlbHNlIGlmIChkaWdpdCA+PSA5NyAmJiBkaWdpdCA8PSAxMDIpIHtcbiAgICAgICAgZGlnaXQgLT0gODc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleG51bSBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgIH1cbiAgICAgIG51bSA9IDE2ICogbnVtICsgZGlnaXQ7XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG5cbiAgLy8gVGhpcyBpcyB0aGUgcHJvdG90eXBlIGZvciBhbGwgc2VtYW50aWMgYW5hbHlzaXMgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICAvLyBgYGBgXG4gIC8vIHN0YXRlIC0gdGhlIHRyYW5zbGF0b3Igc3RhdGVcbiAgLy8gICBpZC5TRU1fUFJFIGZvciBkb3dud2FyZCAocHJlLWJyYW5jaCkgdHJhdmVyc2FsIG9mIHRoZSBBU1RcbiAgLy8gICBpZC5TRU1fUE9TVCBmb3IgdXB3YXJkIChwb3N0IGJyYW5jaCkgdHJhdmVyc2FsIG9mIHRoZSBBU1RcbiAgLy8gY2hhcnMgLSB0aGUgYXJyYXkgb2YgY2hhcmFjdGVyIGNvZGVzIGZvciB0aGUgaW5wdXQgc3RyaW5nXG4gIC8vIHBocmFzZUluZGV4IC0gaW5kZXggaW50byB0aGUgY2hhcnMgYXJyYXkgdG8gdGhlIGZpcnN0XG4gIC8vICAgICAgICAgICAgICAgY2hhcmFjdGVyIG9mIHRoZSBwaHJhc2VcbiAgLy8gcGhyYXNlQ291bnQgLSB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgaW4gdGhlIHBocmFzZVxuICAvLyBkYXRhIC0gdXNlci1kZWZpbmVkIGRhdGEgcGFzc2VkIHRvIHRoZSB0cmFuc2xhdG9yXG4gIC8vICAgICAgICBmb3IgdXNlIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbnMuXG4gIC8vIEByZXR1cm4gaWQuU0VNX09LLCBub3JtYWwgcmV0dXJuLlxuICAvLyAgICAgICAgIGlkLlNFTV9TS0lQIGluIHN0YXRlIGlkLlNFTV9QUkUgd2lsbFxuICAvLyAgICAgICAgIHNraXAgdGhlIGJyYW5jaCBiZWxvdy5cbiAgLy8gICAgICAgICBBbnkgdGhpbmcgZWxzZSBpcyBhbiBlcnJvciB3aGljaCB3aWxsXG4gIC8vICAgICAgICAgc3RvcCB0aGUgdHJhbnNsYXRpb24uXG4gIC8vIGBgYGBcbiAgLypcbiAgZnVuY3Rpb24gc2VtQ2FsbGJhY2tQcm90b3R5cGUoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBsZXQgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgKi9cbiAgLy8gVGhlIEFTVCBjYWxsYmFjayBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIHNlbUZpbGUoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICBkYXRhLnJ1bGVOYW1lcyA9IG5ldyBOYW1lTGlzdCgpO1xuICAgICAgZGF0YS51ZHROYW1lcyA9IG5ldyBOYW1lTGlzdCgpO1xuICAgICAgZGF0YS5ydWxlcyA9IFtdO1xuICAgICAgZGF0YS51ZHRzID0gW107XG4gICAgICBkYXRhLnJ1bGVzTGluZU1hcCA9IFtdO1xuICAgICAgZGF0YS5vcGNvZGVzID0gW107XG4gICAgICBkYXRhLmFsdFN0YWNrID0gW107XG4gICAgICBkYXRhLnRvcFN0YWNrID0gbnVsbDtcbiAgICAgIGRhdGEudG9wUnVsZSA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIC8qIHZhbGlkYXRlIFJOTSBydWxlIG5hbWVzIGFuZCBzZXQgb3Bjb2RlIHJ1bGUgaW5kZXggKi9cbiAgICAgIGxldCBuYW1lT2JqO1xuICAgICAgZGF0YS5ydWxlcy5mb3JFYWNoKChydWxlKSA9PiB7XG4gICAgICAgIHJ1bGUuaXNCa3IgPSBmYWxzZTtcbiAgICAgICAgcnVsZS5vcGNvZGVzLmZvckVhY2goKG9wKSA9PiB7XG4gICAgICAgICAgaWYgKG9wLnR5cGUgPT09IGlkLlJOTSkge1xuICAgICAgICAgICAgbmFtZU9iaiA9IGRhdGEucnVsZU5hbWVzLmdldChvcC5pbmRleC5uYW1lKTtcbiAgICAgICAgICAgIGlmIChuYW1lT2JqID09PSAtMSkge1xuICAgICAgICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIG9wLmluZGV4LnBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBjaGFyOiBvcC5pbmRleC5waHJhc2VJbmRleCxcbiAgICAgICAgICAgICAgICBtc2c6IGBSdWxlIG5hbWUgJyR7b3AuaW5kZXgubmFtZX0nIHVzZWQgYnV0IG5vdCBkZWZpbmVkLmAsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBvcC5pbmRleCA9IC0xO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3AuaW5kZXggPSBuYW1lT2JqLmluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8qIHZhbGlkYXRlIEJLUiBydWxlIG5hbWVzIGFuZCBzZXQgb3Bjb2RlIHJ1bGUgaW5kZXggKi9cbiAgICAgIGRhdGEudWR0cy5mb3JFYWNoKCh1ZHQpID0+IHtcbiAgICAgICAgdWR0LmlzQmtyID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIGRhdGEucnVsZXMuZm9yRWFjaCgocnVsZSkgPT4ge1xuICAgICAgICBydWxlLm9wY29kZXMuZm9yRWFjaCgob3ApID0+IHtcbiAgICAgICAgICBpZiAob3AudHlwZSA9PT0gaWQuQktSKSB7XG4gICAgICAgICAgICBydWxlLmhhc0JrciA9IHRydWU7XG4gICAgICAgICAgICBuYW1lT2JqID0gZGF0YS5ydWxlTmFtZXMuZ2V0KG9wLmluZGV4Lm5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWVPYmogIT09IC0xKSB7XG4gICAgICAgICAgICAgIGRhdGEucnVsZXNbbmFtZU9iai5pbmRleF0uaXNCa3IgPSB0cnVlO1xuICAgICAgICAgICAgICBvcC5pbmRleCA9IG5hbWVPYmouaW5kZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuYW1lT2JqID0gZGF0YS51ZHROYW1lcy5nZXQob3AuaW5kZXgubmFtZSk7XG4gICAgICAgICAgICAgIGlmIChuYW1lT2JqICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGRhdGEudWR0c1tuYW1lT2JqLmluZGV4XS5pc0JrciA9IHRydWU7XG4gICAgICAgICAgICAgICAgb3AuaW5kZXggPSBkYXRhLnJ1bGVzLmxlbmd0aCArIG5hbWVPYmouaW5kZXg7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIG9wLmluZGV4LnBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgIGNoYXI6IG9wLmluZGV4LnBocmFzZUluZGV4LFxuICAgICAgICAgICAgICAgICAgbXNnOiBgQmFjayByZWZlcmVuY2UgbmFtZSAnJHtvcC5pbmRleC5uYW1lfScgcmVmZXJzIHRvIHVuZGVmaW5lZCBydWxlIG9yIHVuYW1lZCBVRFQuYCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvcC5pbmRleCA9IC0xO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVJ1bGUoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICBkYXRhLmFsdFN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICBkYXRhLnRvcFN0YWNrID0gbnVsbDtcbiAgICAgIGRhdGEucnVsZXNMaW5lTWFwLnB1c2goe1xuICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgY2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1SdWxlTG9va3VwKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgZGF0YS5ydWxlTmFtZSA9ICcnO1xuICAgICAgZGF0YS5kZWZpbmVkYXMgPSAnJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgbGV0IHJ1bGVOYW1lO1xuICAgICAgaWYgKGRhdGEuZGVmaW5lZGFzID09PSAnPScpIHtcbiAgICAgICAgcnVsZU5hbWUgPSBkYXRhLnJ1bGVOYW1lcy5hZGQoZGF0YS5ydWxlTmFtZSk7XG4gICAgICAgIGlmIChydWxlTmFtZSA9PT0gLTEpIHtcbiAgICAgICAgICBkYXRhLmRlZmluZWRhcyA9IG51bGw7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiBgUnVsZSBuYW1lICcke2RhdGEucnVsZU5hbWV9JyBwcmV2aW91c2x5IGRlZmluZWQuYCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBzdGFydCBhIG5ldyBydWxlICovXG4gICAgICAgICAgZGF0YS50b3BSdWxlID0ge1xuICAgICAgICAgICAgbmFtZTogcnVsZU5hbWUubmFtZSxcbiAgICAgICAgICAgIGxvd2VyOiBydWxlTmFtZS5sb3dlcixcbiAgICAgICAgICAgIG9wY29kZXM6IFtdLFxuICAgICAgICAgICAgaW5kZXg6IHJ1bGVOYW1lLmluZGV4LFxuICAgICAgICAgIH07XG4gICAgICAgICAgZGF0YS5ydWxlcy5wdXNoKGRhdGEudG9wUnVsZSk7XG4gICAgICAgICAgZGF0YS5vcGNvZGVzID0gZGF0YS50b3BSdWxlLm9wY29kZXM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ1bGVOYW1lID0gZGF0YS5ydWxlTmFtZXMuZ2V0KGRhdGEucnVsZU5hbWUpO1xuICAgICAgICBpZiAocnVsZU5hbWUgPT09IC0xKSB7XG4gICAgICAgICAgZGF0YS5kZWZpbmVkYXMgPSBudWxsO1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogYFJ1bGUgbmFtZSAnJHtkYXRhLnJ1bGVOYW1lfScgZm9yIGluY3JlbWVudGFsIGFsdGVybmF0ZSBub3QgcHJldmlvdXNseSBkZWZpbmVkLmAsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YS50b3BSdWxlID0gZGF0YS5ydWxlc1tydWxlTmFtZS5pbmRleF07XG4gICAgICAgICAgZGF0YS5vcGNvZGVzID0gZGF0YS50b3BSdWxlLm9wY29kZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1BbHRlcm5hdGlvbihzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGxldCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICBjb25zdCBUUlVFID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICAgIGlmIChkYXRhLmRlZmluZWRhcyA9PT0gbnVsbCkge1xuICAgICAgICAgIC8qIHJ1bGUgZXJyb3IgLSBza2lwIG9wY29kZSBnZW5lcmF0aW9uICovXG4gICAgICAgICAgcmV0ID0gaWQuU0VNX1NLSVA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEudG9wU3RhY2sgPT09IG51bGwpIHtcbiAgICAgICAgICAvKiB0b3AtbGV2ZWwgQUxUICovXG4gICAgICAgICAgaWYgKGRhdGEuZGVmaW5lZGFzID09PSAnPScpIHtcbiAgICAgICAgICAgIC8qIFwiPVwiIG5ldyBydWxlICovXG4gICAgICAgICAgICBkYXRhLnRvcFN0YWNrID0ge1xuICAgICAgICAgICAgICBhbHQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBpZC5BTFQsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBjYXQ6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGF0YS5hbHRTdGFjay5wdXNoKGRhdGEudG9wU3RhY2spO1xuICAgICAgICAgICAgZGF0YS5vcGNvZGVzLnB1c2goZGF0YS50b3BTdGFjay5hbHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qIFwiPS9cIiBpbmNyZW1lbnRhbCBhbHRlcm5hdGUgKi9cbiAgICAgICAgICBkYXRhLnRvcFN0YWNrID0ge1xuICAgICAgICAgICAgYWx0OiBkYXRhLm9wY29kZXNbMF0sXG4gICAgICAgICAgICBjYXQ6IG51bGwsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBkYXRhLmFsdFN0YWNrLnB1c2goZGF0YS50b3BTdGFjayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLyogbG93ZXItbGV2ZWwgQUxUICovXG4gICAgICAgIGRhdGEudG9wU3RhY2sgPSB7XG4gICAgICAgICAgYWx0OiB7XG4gICAgICAgICAgICB0eXBlOiBpZC5BTFQsXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYXQ6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIGRhdGEuYWx0U3RhY2sucHVzaChkYXRhLnRvcFN0YWNrKTtcbiAgICAgICAgZGF0YS5vcGNvZGVzLnB1c2goZGF0YS50b3BTdGFjay5hbHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5hbHRTdGFjay5wb3AoKTtcbiAgICAgIGlmIChkYXRhLmFsdFN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGF0YS50b3BTdGFjayA9IGRhdGEuYWx0U3RhY2tbZGF0YS5hbHRTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEudG9wU3RhY2sgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUNvbmNhdGVuYXRpb24oc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICBkYXRhLnRvcFN0YWNrLmFsdC5jaGlsZHJlbi5wdXNoKGRhdGEub3Bjb2Rlcy5sZW5ndGgpO1xuICAgICAgZGF0YS50b3BTdGFjay5jYXQgPSB7XG4gICAgICAgIHR5cGU6IGlkLkNBVCxcbiAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgfTtcbiAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKGRhdGEudG9wU3RhY2suY2F0KTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS50b3BTdGFjay5jYXQgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVJlcGV0aXRpb24oc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICBkYXRhLnRvcFN0YWNrLmNhdC5jaGlsZHJlbi5wdXNoKGRhdGEub3Bjb2Rlcy5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbU9wdGlvbk9wZW4oc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBpZC5SRVAsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiAxLFxuICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVJ1bGVOYW1lKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgZGF0YS5ydWxlTmFtZSA9IGFwZ2xpYi51dGlscy5jaGFyc1RvU3RyaW5nKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbURlZmluZWQoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5kZWZpbmVkYXMgPSAnPSc7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtSW5jQWx0KHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEuZGVmaW5lZGFzID0gJz0vJztcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1SZXBPcChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgIGRhdGEubWluID0gMDtcbiAgICAgIGRhdGEubWF4ID0gSW5maW5pdHk7XG4gICAgICBkYXRhLnRvcFJlcCA9IHtcbiAgICAgICAgdHlwZTogaWQuUkVQLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogSW5maW5pdHksXG4gICAgICB9O1xuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goZGF0YS50b3BSZXApO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBpZiAoZGF0YS5taW4gPiBkYXRhLm1heCkge1xuICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICBtc2c6IGByZXBldGl0aW9uIG1pbiBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIG1heDogbWluOiAke2RhdGEubWlufTogbWF4OiAke2RhdGEubWF4fWAsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGF0YS50b3BSZXAubWluID0gZGF0YS5taW47XG4gICAgICBkYXRhLnRvcFJlcC5tYXggPSBkYXRhLm1heDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1SZXBNaW4oc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5taW4gPSBkZWNudW0oY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtUmVwTWF4KHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEubWF4ID0gZGVjbnVtKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVJlcE1pbk1heChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm1heCA9IGRlY251bShjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KTtcbiAgICAgIGRhdGEubWluID0gZGF0YS5tYXg7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQW5kT3Aoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBpZC5BTkQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Ob3RPcChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGlkLk5PVCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVJubU9wKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogaWQuUk5NLFxuICAgICAgICAvKiBOT1RFOiB0aGlzIGlzIHRlbXBvcmFyeSBpbmZvLCBpbmRleCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggaW50ZWdlciBsYXRlci4gKi9cbiAgICAgICAgLyogUHJvYmFibHkgbm90IHRoZSBiZXN0IGNvZGluZyBwcmFjdGljZSBidXQgaGVyZSB5b3UgZ28uICovXG4gICAgICAgIGluZGV4OiB7XG4gICAgICAgICAgcGhyYXNlSW5kZXgsXG4gICAgICAgICAgbmFtZTogYXBnbGliLnV0aWxzLmNoYXJzVG9TdHJpbmcoY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCksXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1BYmdPcChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGlkLkFCRyxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUFlbk9wKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogaWQuQUVOLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQmthT3Aoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBpZC5CS0EsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Ca25PcChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGlkLkJLTixcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUJrck9wKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgZGF0YS5jaSA9IHRydWU7IC8qIGRlZmF1bHQgdG8gY2FzZSBpbnNlbnNpdGl2ZSAqL1xuICAgICAgZGF0YS5jcyA9IGZhbHNlO1xuICAgICAgZGF0YS51bSA9IHRydWU7XG4gICAgICBkYXRhLnBtID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogaWQuQktSLFxuICAgICAgICBia3JDYXNlOiBkYXRhLmNzID09PSB0cnVlID8gaWQuQktSX01PREVfQ1MgOiBpZC5CS1JfTU9ERV9DSSxcbiAgICAgICAgYmtyTW9kZTogZGF0YS5wbSA9PT0gdHJ1ZSA/IGlkLkJLUl9NT0RFX1BNIDogaWQuQktSX01PREVfVU0sXG4gICAgICAgIC8qIE5PVEU6IHRoaXMgaXMgdGVtcG9yYXJ5IGluZm8sIGluZGV4IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBpbnRlZ2VyIGxhdGVyLiAqL1xuICAgICAgICAvKiBQcm9iYWJseSBub3QgdGhlIGJlc3QgY29kaW5nIHByYWN0aWNlIGJ1dCBoZXJlIHlvdSBnby4gKi9cbiAgICAgICAgaW5kZXg6IHtcbiAgICAgICAgICBwaHJhc2VJbmRleDogZGF0YS5ia3JuYW1lLnBocmFzZUluZGV4LFxuICAgICAgICAgIG5hbWU6IGFwZ2xpYi51dGlscy5jaGFyc1RvU3RyaW5nKGNoYXJzLCBkYXRhLmJrcm5hbWUucGhyYXNlSW5kZXgsIGRhdGEuYmtybmFtZS5waHJhc2VMZW5ndGgpLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQmtyQ2koc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5jaSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQmtyQ3Moc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5jcyA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQmtyVW0oc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS51bSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQmtyUG0oc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5wbSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQmtyTmFtZShzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLmJrcm5hbWUgPSB7XG4gICAgICAgIHBocmFzZUluZGV4LFxuICAgICAgICBwaHJhc2VMZW5ndGg6IHBocmFzZUNvdW50LFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1VZHRFbXB0eShzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBjb25zdCBuYW1lID0gYXBnbGliLnV0aWxzLmNoYXJzVG9TdHJpbmcoY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCk7XG4gICAgICBsZXQgdWR0TmFtZSA9IGRhdGEudWR0TmFtZXMuYWRkKG5hbWUpO1xuICAgICAgaWYgKHVkdE5hbWUgPT09IC0xKSB7XG4gICAgICAgIHVkdE5hbWUgPSBkYXRhLnVkdE5hbWVzLmdldChuYW1lKTtcbiAgICAgICAgaWYgKHVkdE5hbWUgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZW1VZHRFbXB0eTogbmFtZSBsb29rIHVwIGVycm9yJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEudWR0cy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiB1ZHROYW1lLm5hbWUsXG4gICAgICAgICAgbG93ZXI6IHVkdE5hbWUubG93ZXIsXG4gICAgICAgICAgaW5kZXg6IHVkdE5hbWUuaW5kZXgsXG4gICAgICAgICAgZW1wdHk6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBpZC5VRFQsXG4gICAgICAgIGVtcHR5OiB0cnVlLFxuICAgICAgICBpbmRleDogdWR0TmFtZS5pbmRleCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVVkdE5vbkVtcHR5KHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBhcGdsaWIudXRpbHMuY2hhcnNUb1N0cmluZyhjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KTtcbiAgICAgIGxldCB1ZHROYW1lID0gZGF0YS51ZHROYW1lcy5hZGQobmFtZSk7XG4gICAgICBpZiAodWR0TmFtZSA9PT0gLTEpIHtcbiAgICAgICAgdWR0TmFtZSA9IGRhdGEudWR0TmFtZXMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAodWR0TmFtZSA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlbVVkdE5vbkVtcHR5OiBuYW1lIGxvb2sgdXAgZXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS51ZHRzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IHVkdE5hbWUubmFtZSxcbiAgICAgICAgICBsb3dlcjogdWR0TmFtZS5sb3dlcixcbiAgICAgICAgICBpbmRleDogdWR0TmFtZS5pbmRleCxcbiAgICAgICAgICBlbXB0eTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBpZC5VRFQsXG4gICAgICAgIGVtcHR5OiBmYWxzZSxcbiAgICAgICAgaW5kZXg6IHVkdE5hbWUuaW5kZXgsXG4gICAgICAgIHN5bnRheDogbnVsbCxcbiAgICAgICAgc2VtYW50aWM6IG51bGwsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1UbHNPcChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgIGRhdGEudGxzY2FzZSA9IHRydWU7IC8qIGRlZmF1bHQgdG8gY2FzZSBpbnNlbnNpdGl2ZSAqL1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVRsc0Nhc2Uoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgaWYgKHBocmFzZUNvdW50ID4gMCAmJiAoY2hhcnNbcGhyYXNlSW5kZXggKyAxXSA9PT0gODMgfHwgY2hhcnNbcGhyYXNlSW5kZXggKyAxXSA9PT0gMTE1KSkge1xuICAgICAgICBkYXRhLnRsc2Nhc2UgPSBmYWxzZTsgLyogc2V0IHRvIGNhc2Ugc2Vuc2l0aXZlICovXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtVGxzU3RyaW5nKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGlmIChkYXRhLnRsc2Nhc2UpIHtcbiAgICAgICAgY29uc3Qgc3RyID0gY2hhcnMuc2xpY2UocGhyYXNlSW5kZXgsIHBocmFzZUluZGV4ICsgcGhyYXNlQ291bnQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChzdHJbaV0gPj0gNjUgJiYgc3RyW2ldIDw9IDkwKSB7XG4gICAgICAgICAgICBzdHJbaV0gKz0gMzI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBpZC5UTFMsXG4gICAgICAgICAgc3RyaW5nOiBzdHIsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IGlkLlRCUyxcbiAgICAgICAgICBzdHJpbmc6IGNoYXJzLnNsaWNlKHBocmFzZUluZGV4LCBwaHJhc2VJbmRleCArIHBocmFzZUNvdW50KSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQ2xzT3Aoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgaWYgKHBocmFzZUNvdW50IDw9IDIpIHtcbiAgICAgICAgLyogb25seSBUTFMgaXMgYWxsb3dlZCB0byBiZSBlbXB0eSAqL1xuICAgICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogaWQuVExTLFxuICAgICAgICAgIHN0cmluZzogW10sXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IGlkLlRCUyxcbiAgICAgICAgICBzdHJpbmc6IGNoYXJzLnNsaWNlKHBocmFzZUluZGV4ICsgMSwgcGhyYXNlSW5kZXggKyBwaHJhc2VDb3VudCAtIDEpLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1UYnNPcChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgIGRhdGEudGJzc3RyID0gW107XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogaWQuVEJTLFxuICAgICAgICBzdHJpbmc6IGRhdGEudGJzc3RyLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtVHJnT3Aoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICBkYXRhLm1pbiA9IDA7XG4gICAgICBkYXRhLm1heCA9IDA7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGlmIChkYXRhLm1pbiA+IGRhdGEubWF4KSB7XG4gICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgcGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgIG1zZzogYFRSRywgKCVkbWluLW1heCksIG1pbiBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIG1heDogbWluOiAke2RhdGEubWlufTogbWF4OiAke2RhdGEubWF4fWAsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBpZC5UUkcsXG4gICAgICAgIG1pbjogZGF0YS5taW4sXG4gICAgICAgIG1heDogZGF0YS5tYXgsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1EbWluKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEubWluID0gZGVjbnVtKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbURtYXgoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5tYXggPSBkZWNudW0oY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQm1pbihzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm1pbiA9IGJpbm51bShjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1CbWF4KHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEubWF4ID0gYmlubnVtKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVhtaW4oc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5taW4gPSBoZXhudW0oY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtWG1heChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm1heCA9IGhleG51bShjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Ec3RyaW5nKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEudGJzc3RyLnB1c2goZGVjbnVtKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Cc3RyaW5nKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEudGJzc3RyLnB1c2goYmlubnVtKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Yc3RyaW5nKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEudGJzc3RyLnB1c2goaGV4bnVtKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICAvLyBEZWZpbmUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucyB0byB0aGUgQVNUIG9iamVjdC5cbiAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbiAgdGhpcy5jYWxsYmFja3MuYWJnb3AgPSBzZW1BYmdPcDtcbiAgdGhpcy5jYWxsYmFja3MuYWVub3AgPSBzZW1BZW5PcDtcbiAgdGhpcy5jYWxsYmFja3MuYWx0ZXJuYXRpb24gPSBzZW1BbHRlcm5hdGlvbjtcbiAgdGhpcy5jYWxsYmFja3MuYW5kb3AgPSBzZW1BbmRPcDtcbiAgdGhpcy5jYWxsYmFja3MuYm1heCA9IHNlbUJtYXg7XG4gIHRoaXMuY2FsbGJhY2tzLmJtaW4gPSBzZW1CbWluO1xuICB0aGlzLmNhbGxiYWNrcy5ia2FvcCA9IHNlbUJrYU9wO1xuICB0aGlzLmNhbGxiYWNrcy5ia25vcCA9IHNlbUJrbk9wO1xuICB0aGlzLmNhbGxiYWNrcy5ia3JvcCA9IHNlbUJrck9wO1xuICB0aGlzLmNhbGxiYWNrc1snYmtyLW5hbWUnXSA9IHNlbUJrck5hbWU7XG4gIHRoaXMuY2FsbGJhY2tzLmJzdHJpbmcgPSBzZW1Cc3RyaW5nO1xuICB0aGlzLmNhbGxiYWNrcy5jbHNvcCA9IHNlbUNsc09wO1xuICB0aGlzLmNhbGxiYWNrcy5jaSA9IHNlbUJrckNpO1xuICB0aGlzLmNhbGxiYWNrcy5jcyA9IHNlbUJrckNzO1xuICB0aGlzLmNhbGxiYWNrcy51bSA9IHNlbUJrclVtO1xuICB0aGlzLmNhbGxiYWNrcy5wbSA9IHNlbUJrclBtO1xuICB0aGlzLmNhbGxiYWNrcy5jb25jYXRlbmF0aW9uID0gc2VtQ29uY2F0ZW5hdGlvbjtcbiAgdGhpcy5jYWxsYmFja3MuZGVmaW5lZCA9IHNlbURlZmluZWQ7XG4gIHRoaXMuY2FsbGJhY2tzLmRtYXggPSBzZW1EbWF4O1xuICB0aGlzLmNhbGxiYWNrcy5kbWluID0gc2VtRG1pbjtcbiAgdGhpcy5jYWxsYmFja3MuZHN0cmluZyA9IHNlbURzdHJpbmc7XG4gIHRoaXMuY2FsbGJhY2tzLmZpbGUgPSBzZW1GaWxlO1xuICB0aGlzLmNhbGxiYWNrcy5pbmNhbHQgPSBzZW1JbmNBbHQ7XG4gIHRoaXMuY2FsbGJhY2tzLm5vdG9wID0gc2VtTm90T3A7XG4gIHRoaXMuY2FsbGJhY2tzLm9wdGlvbm9wZW4gPSBzZW1PcHRpb25PcGVuO1xuICB0aGlzLmNhbGxiYWNrc1sncmVwLW1heCddID0gc2VtUmVwTWF4O1xuICB0aGlzLmNhbGxiYWNrc1sncmVwLW1pbiddID0gc2VtUmVwTWluO1xuICB0aGlzLmNhbGxiYWNrc1sncmVwLW1pbi1tYXgnXSA9IHNlbVJlcE1pbk1heDtcbiAgdGhpcy5jYWxsYmFja3MucmVwZXRpdGlvbiA9IHNlbVJlcGV0aXRpb247XG4gIHRoaXMuY2FsbGJhY2tzLnJlcG9wID0gc2VtUmVwT3A7XG4gIHRoaXMuY2FsbGJhY2tzLnJubW9wID0gc2VtUm5tT3A7XG4gIHRoaXMuY2FsbGJhY2tzLnJ1bGUgPSBzZW1SdWxlO1xuICB0aGlzLmNhbGxiYWNrcy5ydWxlbG9va3VwID0gc2VtUnVsZUxvb2t1cDtcbiAgdGhpcy5jYWxsYmFja3MucnVsZW5hbWUgPSBzZW1SdWxlTmFtZTtcbiAgdGhpcy5jYWxsYmFja3MudGJzb3AgPSBzZW1UYnNPcDtcbiAgdGhpcy5jYWxsYmFja3MudGxzY2FzZSA9IHNlbVRsc0Nhc2U7XG4gIHRoaXMuY2FsbGJhY2tzLnRsc3N0cmluZyA9IHNlbVRsc1N0cmluZztcbiAgdGhpcy5jYWxsYmFja3MudGxzb3AgPSBzZW1UbHNPcDtcbiAgdGhpcy5jYWxsYmFja3MudHJnb3AgPSBzZW1UcmdPcDtcbiAgdGhpcy5jYWxsYmFja3NbJ3VkdC1lbXB0eSddID0gc2VtVWR0RW1wdHk7XG4gIHRoaXMuY2FsbGJhY2tzWyd1ZHQtbm9uLWVtcHR5J10gPSBzZW1VZHROb25FbXB0eTtcbiAgdGhpcy5jYWxsYmFja3MueG1heCA9IHNlbVhtYXg7XG4gIHRoaXMuY2FsbGJhY2tzLnhtaW4gPSBzZW1YbWluO1xuICB0aGlzLmNhbGxiYWNrcy54c3RyaW5nID0gc2VtWHN0cmluZztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-api/semantic-callbacks.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-api/show-rules.js":
/*!*******************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/show-rules.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\nmodule.exports = (function exfn() {\n  const thisFileName = 'show-rules.js';\n  // Display the rules.\n  // This function may be called before the attributes calculation.\n  // Sorting is done independently from the attributes.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - none of above, index order (default)\n  const showRules = function showRules(rulesIn = [], udtsIn = [], order = 'index') {\n    const thisFuncName = 'showRules';\n    let alphaArray = [];\n    let udtAlphaArray = [];\n    const indexArray = [];\n    const udtIndexArray = [];\n    const rules = rulesIn;\n    const udts = udtsIn;\n    const ruleCount = rulesIn.length;\n    const udtCount = udtsIn.length;\n    let str = 'RULE/UDT NAMES';\n    let i;\n    function compRulesAlpha(left, right) {\n      if (rules[left].lower < rules[right].lower) {\n        return -1;\n      }\n      if (rules[left].lower > rules[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n    function compUdtsAlpha(left, right) {\n      if (udts[left].lower < udts[right].lower) {\n        return -1;\n      }\n      if (udts[left].lower > udts[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n    if (!(Array.isArray(rulesIn) && rulesIn.length)) {\n      throw new Error(`${thisFileName}:${thisFuncName}: rules arg must be array with length > 0`);\n    }\n    if (!Array.isArray(udtsIn)) {\n      throw new Error(`${thisFileName}:${thisFuncName}: udts arg must be array`);\n    }\n\n    for (i = 0; i < ruleCount; i += 1) {\n      indexArray.push(i);\n    }\n    alphaArray = indexArray.slice(0);\n    alphaArray.sort(compRulesAlpha);\n    if (udtCount) {\n      for (i = 0; i < udtCount; i += 1) {\n        udtIndexArray.push(i);\n      }\n      udtAlphaArray = udtIndexArray.slice(0);\n      udtAlphaArray.sort(compUdtsAlpha);\n    }\n    if (order.charCodeAt(0) === 97) {\n      str += ' - alphabetical by rule/UDT name\\n';\n      for (i = 0; i < ruleCount; i += 1) {\n        str += `${i}: ${alphaArray[i]}: ${rules[alphaArray[i]].name}\\n`;\n      }\n      if (udtCount) {\n        for (i = 0; i < udtCount; i += 1) {\n          str += `${i}: ${udtAlphaArray[i]}: ${udts[udtAlphaArray[i]].name}\\n`;\n        }\n      }\n    } else {\n      str += ' - ordered by rule/UDT index\\n';\n      for (i = 0; i < ruleCount; i += 1) {\n        str += `${i}: ${rules[i].name}\\n`;\n      }\n      if (udtCount) {\n        for (i = 0; i < udtCount; i += 1) {\n          str += `${i}: ${udts[i].name}\\n`;\n        }\n      }\n    }\n    return str;\n  };\n  return showRules;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3Nob3ctcnVsZXMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhLEdBQUcsYUFBYTtBQUN0RDtBQUNBO0FBQ0EseUJBQXlCLGFBQWEsR0FBRyxhQUFhO0FBQ3REOztBQUVBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDLGtCQUFrQixFQUFFLElBQUksY0FBYyxJQUFJLDBCQUEwQjtBQUNwRTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEMsb0JBQW9CLEVBQUUsSUFBSSxpQkFBaUIsSUFBSSw0QkFBNEI7QUFDM0U7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDLGtCQUFrQixFQUFFLElBQUksY0FBYztBQUN0QztBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEMsb0JBQW9CLEVBQUUsSUFBSSxhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWFwaS9zaG93LXJ1bGVzLmpzPzJhZGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gZXhmbigpIHtcbiAgY29uc3QgdGhpc0ZpbGVOYW1lID0gJ3Nob3ctcnVsZXMuanMnO1xuICAvLyBEaXNwbGF5IHRoZSBydWxlcy5cbiAgLy8gVGhpcyBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGJlZm9yZSB0aGUgYXR0cmlidXRlcyBjYWxjdWxhdGlvbi5cbiAgLy8gU29ydGluZyBpcyBkb25lIGluZGVwZW5kZW50bHkgZnJvbSB0aGUgYXR0cmlidXRlcy5cbiAgLy8gLSBvcmRlclxuICAvLyAgICAgIC0gXCJpbmRleFwiIG9yIFwiaVwiLCBpbmRleCBvcmRlciAoZGVmYXVsdClcbiAgLy8gICAgICAtIFwiYWxwaGFcIiBvciBcImFcIiwgYWxwaGFiZXRpY2FsIG9yZGVyXG4gIC8vICAgICAgLSBub25lIG9mIGFib3ZlLCBpbmRleCBvcmRlciAoZGVmYXVsdClcbiAgY29uc3Qgc2hvd1J1bGVzID0gZnVuY3Rpb24gc2hvd1J1bGVzKHJ1bGVzSW4gPSBbXSwgdWR0c0luID0gW10sIG9yZGVyID0gJ2luZGV4Jykge1xuICAgIGNvbnN0IHRoaXNGdW5jTmFtZSA9ICdzaG93UnVsZXMnO1xuICAgIGxldCBhbHBoYUFycmF5ID0gW107XG4gICAgbGV0IHVkdEFscGhhQXJyYXkgPSBbXTtcbiAgICBjb25zdCBpbmRleEFycmF5ID0gW107XG4gICAgY29uc3QgdWR0SW5kZXhBcnJheSA9IFtdO1xuICAgIGNvbnN0IHJ1bGVzID0gcnVsZXNJbjtcbiAgICBjb25zdCB1ZHRzID0gdWR0c0luO1xuICAgIGNvbnN0IHJ1bGVDb3VudCA9IHJ1bGVzSW4ubGVuZ3RoO1xuICAgIGNvbnN0IHVkdENvdW50ID0gdWR0c0luLmxlbmd0aDtcbiAgICBsZXQgc3RyID0gJ1JVTEUvVURUIE5BTUVTJztcbiAgICBsZXQgaTtcbiAgICBmdW5jdGlvbiBjb21wUnVsZXNBbHBoYShsZWZ0LCByaWdodCkge1xuICAgICAgaWYgKHJ1bGVzW2xlZnRdLmxvd2VyIDwgcnVsZXNbcmlnaHRdLmxvd2VyKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChydWxlc1tsZWZ0XS5sb3dlciA+IHJ1bGVzW3JpZ2h0XS5sb3dlcikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wVWR0c0FscGhhKGxlZnQsIHJpZ2h0KSB7XG4gICAgICBpZiAodWR0c1tsZWZ0XS5sb3dlciA8IHVkdHNbcmlnaHRdLmxvd2VyKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmICh1ZHRzW2xlZnRdLmxvd2VyID4gdWR0c1tyaWdodF0ubG93ZXIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKCEoQXJyYXkuaXNBcnJheShydWxlc0luKSAmJiBydWxlc0luLmxlbmd0aCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9OiR7dGhpc0Z1bmNOYW1lfTogcnVsZXMgYXJnIG11c3QgYmUgYXJyYXkgd2l0aCBsZW5ndGggPiAwYCk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheSh1ZHRzSW4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfToke3RoaXNGdW5jTmFtZX06IHVkdHMgYXJnIG11c3QgYmUgYXJyYXlgKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZUNvdW50OyBpICs9IDEpIHtcbiAgICAgIGluZGV4QXJyYXkucHVzaChpKTtcbiAgICB9XG4gICAgYWxwaGFBcnJheSA9IGluZGV4QXJyYXkuc2xpY2UoMCk7XG4gICAgYWxwaGFBcnJheS5zb3J0KGNvbXBSdWxlc0FscGhhKTtcbiAgICBpZiAodWR0Q291bnQpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB1ZHRDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIHVkdEluZGV4QXJyYXkucHVzaChpKTtcbiAgICAgIH1cbiAgICAgIHVkdEFscGhhQXJyYXkgPSB1ZHRJbmRleEFycmF5LnNsaWNlKDApO1xuICAgICAgdWR0QWxwaGFBcnJheS5zb3J0KGNvbXBVZHRzQWxwaGEpO1xuICAgIH1cbiAgICBpZiAob3JkZXIuY2hhckNvZGVBdCgwKSA9PT0gOTcpIHtcbiAgICAgIHN0ciArPSAnIC0gYWxwaGFiZXRpY2FsIGJ5IHJ1bGUvVURUIG5hbWVcXG4nO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHJ1bGVDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIHN0ciArPSBgJHtpfTogJHthbHBoYUFycmF5W2ldfTogJHtydWxlc1thbHBoYUFycmF5W2ldXS5uYW1lfVxcbmA7XG4gICAgICB9XG4gICAgICBpZiAodWR0Q291bnQpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHVkdENvdW50OyBpICs9IDEpIHtcbiAgICAgICAgICBzdHIgKz0gYCR7aX06ICR7dWR0QWxwaGFBcnJheVtpXX06ICR7dWR0c1t1ZHRBbHBoYUFycmF5W2ldXS5uYW1lfVxcbmA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgLSBvcmRlcmVkIGJ5IHJ1bGUvVURUIGluZGV4XFxuJztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBydWxlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICBzdHIgKz0gYCR7aX06ICR7cnVsZXNbaV0ubmFtZX1cXG5gO1xuICAgICAgfVxuICAgICAgaWYgKHVkdENvdW50KSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB1ZHRDb3VudDsgaSArPSAxKSB7XG4gICAgICAgICAgc3RyICs9IGAke2l9OiAke3VkdHNbaV0ubmFtZX1cXG5gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07XG4gIHJldHVybiBzaG93UnVsZXM7XG59KSgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-api/show-rules.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-api/syntax-callbacks.js":
/*!*************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/syntax-callbacks.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* eslint-disable func-names */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module has all of the callback functions for the syntax phase of the generation.\n// See:<br>\n// `./dist/abnf-for-sabnf-grammar.bnf`<br>\n// for the grammar file these callback functions are based on.\nmodule.exports = function exfn() {\n  const thisFileName = 'syntax-callbacks.js: ';\n  const apglib = __webpack_require__(/*! ../apg-lib/node-exports */ \"./node_modules/apg-js/src/apg-lib/node-exports.js\");\n  const id = apglib.ids;\n  let topAlt;\n  /* syntax, RNM, callback functions */\n  const synFile = function synFile(result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.altStack = [];\n        data.repCount = 0;\n        break;\n      case id.EMPTY:\n        data.errors.push({\n          line: 0,\n          char: 0,\n          msg: 'grammar file is empty',\n        });\n        break;\n      case id.MATCH:\n        if (data.ruleCount === 0) {\n          data.errors.push({\n            line: 0,\n            char: 0,\n            msg: 'no rules defined',\n          });\n        }\n        break;\n      case id.NOMATCH:\n        throw new Error(`${thisFileName}synFile: grammar file NOMATCH: design error: should never happen.`);\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  // eslint-disable-next-line func-names\n  const synRule = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.altStack.length = 0;\n        topAlt = {\n          groupOpen: null,\n          groupError: false,\n          optionOpen: null,\n          optionError: false,\n          tlsOpen: null,\n          clsOpen: null,\n          prosValOpen: null,\n          basicError: false,\n        };\n        data.altStack.push(topAlt);\n        break;\n      case id.EMPTY:\n        throw new Error(`${thisFileName}synRule: EMPTY: rule cannot be empty`);\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.ruleCount += 1;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synRuleError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: 'Unrecognized SABNF line. Invalid rule, comment or blank line.',\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synRuleNameError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: 'Rule names must be alphanum and begin with alphabetic character.',\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synDefinedAsError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: \"Expected '=' or '=/'. Not found.\",\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synAndOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'AND operator(&) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synNotOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'NOT operator(!) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBkaOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Positive look-behind operator(&&) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBknOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Negative look-behind operator(!!) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synAbgOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Beginning of string anchor(%^) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synAenOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'End of string anchor(%$) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBkrOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          const name = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Back reference operator(${name}) found - strict ABNF specified.`,\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synUdtOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          const name = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `UDT operator found(${name}) - strict ABNF specified.`,\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synTlsOpen = function (result, chars, phraseIndex) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt.tlsOpen = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synTlsString = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.stringTabChar = false;\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.stringTabChar !== false) {\n          data.errors.push({\n            line: data.findLine(data.lines, data.stringTabChar),\n            char: data.stringTabChar,\n            msg: \"Tab character (\\\\t, x09) not allowed in literal string (see 'quoted-string' definition, RFC 7405.)\",\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synStringTab = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.stringTabChar = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synTlsClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.tlsOpen),\n          char: topAlt.tlsOpen,\n          msg: 'Case-insensitive literal string(\"...\") opened but not closed.',\n        });\n        topAlt.basicError = true;\n        topAlt.tlsOpen = null;\n        break;\n      case id.MATCH:\n        topAlt.tlsOpen = null;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synClsOpen = function (result, chars, phraseIndex) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt.clsOpen = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synClsString = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.stringTabChar = false;\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.stringTabChar !== false) {\n          data.errors.push({\n            line: data.findLine(data.lines, data.stringTabChar),\n            char: data.stringTabChar,\n            msg: 'Tab character (\\\\t, x09) not allowed in literal string.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synClsClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.clsOpen),\n          char: topAlt.clsOpen,\n          msg: \"Case-sensitive literal string('...') opened but not closed.\",\n        });\n        topAlt.clsOpen = null;\n        topAlt.basicError = true;\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, topAlt.clsOpen),\n            char: topAlt.clsOpen,\n            msg: \"Case-sensitive string operator('...') found - strict ABNF specified.\",\n          });\n        }\n        topAlt.clsOpen = null;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synProsValOpen = function (result, chars, phraseIndex) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt.prosValOpen = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synProsValString = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.stringTabChar = false;\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.stringTabChar !== false) {\n          data.errors.push({\n            line: data.findLine(data.lines, data.stringTabChar),\n            char: data.stringTabChar,\n            msg: 'Tab character (\\\\t, x09) not allowed in prose value string.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synProsValClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.prosValOpen),\n          char: topAlt.prosValOpen,\n          msg: 'Prose value operator(<...>) opened but not closed.',\n        });\n        topAlt.basicError = true;\n        topAlt.prosValOpen = null;\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.prosValOpen),\n          char: topAlt.prosValOpen,\n          msg: 'Prose value operator(<...>) found. The ABNF syntax is valid, but a parser cannot be generated from this grammar.',\n        });\n        topAlt.prosValOpen = null;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synGroupOpen = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt = {\n          groupOpen: phraseIndex,\n          groupError: false,\n          optionOpen: null,\n          optionError: false,\n          tlsOpen: null,\n          clsOpen: null,\n          prosValOpen: null,\n          basicError: false,\n        };\n        data.altStack.push(topAlt);\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synGroupClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.groupOpen),\n          char: topAlt.groupOpen,\n          msg: 'Group \"(...)\" opened but not closed.',\n        });\n        topAlt = data.altStack.pop();\n        topAlt.groupError = true;\n        break;\n      case id.MATCH:\n        topAlt = data.altStack.pop();\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synOptionOpen = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt = {\n          groupOpen: null,\n          groupError: false,\n          optionOpen: phraseIndex,\n          optionError: false,\n          tlsOpen: null,\n          clsOpen: null,\n          prosValOpen: null,\n          basicError: false,\n        };\n        data.altStack.push(topAlt);\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synOptionClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.optionOpen),\n          char: topAlt.optionOpen,\n          msg: 'Option \"[...]\" opened but not closed.',\n        });\n        topAlt = data.altStack.pop();\n        topAlt.optionError = true;\n        break;\n      case id.MATCH:\n        topAlt = data.altStack.pop();\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBasicElementError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (topAlt.basicError === false) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Unrecognized SABNF element.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synLineEnd = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (result.phraseLength === 1 && data.strict) {\n          const end = chars[phraseIndex] === 13 ? 'CR' : 'LF';\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Line end '${end}' found - strict ABNF specified, only CRLF allowed.`,\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synLineEndError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: 'Unrecognized grammar element or characters.',\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synRepetition = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.repCount += 1;\n        break;\n      case id.MATCH:\n        data.repCount += 1;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  // Define the list of callback functions.\n  this.callbacks = [];\n  this.callbacks.andop = synAndOp;\n  this.callbacks.basicelementerr = synBasicElementError;\n  this.callbacks.clsclose = synClsClose;\n  this.callbacks.clsopen = synClsOpen;\n  this.callbacks.clsstring = synClsString;\n  this.callbacks.definedaserror = synDefinedAsError;\n  this.callbacks.file = synFile;\n  this.callbacks.groupclose = synGroupClose;\n  this.callbacks.groupopen = synGroupOpen;\n  this.callbacks.lineenderror = synLineEndError;\n  this.callbacks.lineend = synLineEnd;\n  this.callbacks.notop = synNotOp;\n  this.callbacks.optionclose = synOptionClose;\n  this.callbacks.optionopen = synOptionOpen;\n  this.callbacks.prosvalclose = synProsValClose;\n  this.callbacks.prosvalopen = synProsValOpen;\n  this.callbacks.prosvalstring = synProsValString;\n  this.callbacks.repetition = synRepetition;\n  this.callbacks.rule = synRule;\n  this.callbacks.ruleerror = synRuleError;\n  this.callbacks.rulenameerror = synRuleNameError;\n  this.callbacks.stringtab = synStringTab;\n  this.callbacks.tlsclose = synTlsClose;\n  this.callbacks.tlsopen = synTlsOpen;\n  this.callbacks.tlsstring = synTlsString;\n  this.callbacks.udtop = synUdtOp;\n  this.callbacks.bkaop = synBkaOp;\n  this.callbacks.bknop = synBknOp;\n  this.callbacks.bkrop = synBkrOp;\n  this.callbacks.abgop = synAbgOp;\n  this.callbacks.aenop = synAenOp;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3N5bnRheC1jYWxsYmFja3MuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLGtGQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEtBQUs7QUFDakQsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEtBQUs7QUFDNUMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLElBQUk7QUFDbEMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvc3ludGF4LWNhbGxiYWNrcy5qcz8xYTkxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGZ1bmMtbmFtZXMgKi9cbi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIGhhcyBhbGwgb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgdGhlIHN5bnRheCBwaGFzZSBvZiB0aGUgZ2VuZXJhdGlvbi5cbi8vIFNlZTo8YnI+XG4vLyBgLi9kaXN0L2FibmYtZm9yLXNhYm5mLWdyYW1tYXIuYm5mYDxicj5cbi8vIGZvciB0aGUgZ3JhbW1hciBmaWxlIHRoZXNlIGNhbGxiYWNrIGZ1bmN0aW9ucyBhcmUgYmFzZWQgb24uXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4Zm4oKSB7XG4gIGNvbnN0IHRoaXNGaWxlTmFtZSA9ICdzeW50YXgtY2FsbGJhY2tzLmpzOiAnO1xuICBjb25zdCBhcGdsaWIgPSByZXF1aXJlKCcuLi9hcGctbGliL25vZGUtZXhwb3J0cycpO1xuICBjb25zdCBpZCA9IGFwZ2xpYi5pZHM7XG4gIGxldCB0b3BBbHQ7XG4gIC8qIHN5bnRheCwgUk5NLCBjYWxsYmFjayBmdW5jdGlvbnMgKi9cbiAgY29uc3Qgc3luRmlsZSA9IGZ1bmN0aW9uIHN5bkZpbGUocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGRhdGEuYWx0U3RhY2sgPSBbXTtcbiAgICAgICAgZGF0YS5yZXBDb3VudCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgbGluZTogMCxcbiAgICAgICAgICBjaGFyOiAwLFxuICAgICAgICAgIG1zZzogJ2dyYW1tYXIgZmlsZSBpcyBlbXB0eScsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnJ1bGVDb3VudCA9PT0gMCkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogMCxcbiAgICAgICAgICAgIGNoYXI6IDAsXG4gICAgICAgICAgICBtc2c6ICdubyBydWxlcyBkZWZpbmVkJyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiBncmFtbWFyIGZpbGUgTk9NQVRDSDogZGVzaWduIGVycm9yOiBzaG91bGQgbmV2ZXIgaGFwcGVuLmApO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIGNvbnN0IHN5blJ1bGUgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGRhdGEuYWx0U3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgdG9wQWx0ID0ge1xuICAgICAgICAgIGdyb3VwT3BlbjogbnVsbCxcbiAgICAgICAgICBncm91cEVycm9yOiBmYWxzZSxcbiAgICAgICAgICBvcHRpb25PcGVuOiBudWxsLFxuICAgICAgICAgIG9wdGlvbkVycm9yOiBmYWxzZSxcbiAgICAgICAgICB0bHNPcGVuOiBudWxsLFxuICAgICAgICAgIGNsc09wZW46IG51bGwsXG4gICAgICAgICAgcHJvc1ZhbE9wZW46IG51bGwsXG4gICAgICAgICAgYmFzaWNFcnJvcjogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIGRhdGEuYWx0U3RhY2sucHVzaCh0b3BBbHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luUnVsZTogRU1QVFk6IHJ1bGUgY2Fubm90IGJlIGVtcHR5YCk7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgZGF0YS5ydWxlQ291bnQgKz0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luUnVsZUVycm9yID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgcGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgIG1zZzogJ1VucmVjb2duaXplZCBTQUJORiBsaW5lLiBJbnZhbGlkIHJ1bGUsIGNvbW1lbnQgb3IgYmxhbmsgbGluZS4nLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luUnVsZU5hbWVFcnJvciA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICBtc2c6ICdSdWxlIG5hbWVzIG11c3QgYmUgYWxwaGFudW0gYW5kIGJlZ2luIHdpdGggYWxwaGFiZXRpYyBjaGFyYWN0ZXIuJyxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkRlZmluZWRBc0Vycm9yID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgcGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgIG1zZzogXCJFeHBlY3RlZCAnPScgb3IgJz0vJy4gTm90IGZvdW5kLlwiLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQW5kT3AgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnQU5EIG9wZXJhdG9yKCYpIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luTm90T3AgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnTk9UIG9wZXJhdG9yKCEpIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQmthT3AgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnUG9zaXRpdmUgbG9vay1iZWhpbmQgb3BlcmF0b3IoJiYpIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQmtuT3AgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnTmVnYXRpdmUgbG9vay1iZWhpbmQgb3BlcmF0b3IoISEpIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQWJnT3AgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnQmVnaW5uaW5nIG9mIHN0cmluZyBhbmNob3IoJV4pIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQWVuT3AgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnRW5kIG9mIHN0cmluZyBhbmNob3IoJSQpIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQmtyT3AgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IGFwZ2xpYi51dGlscy5jaGFyc1RvU3RyaW5nKGNoYXJzLCBwaHJhc2VJbmRleCwgcmVzdWx0LnBocmFzZUxlbmd0aCk7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiBgQmFjayByZWZlcmVuY2Ugb3BlcmF0b3IoJHtuYW1lfSkgZm91bmQgLSBzdHJpY3QgQUJORiBzcGVjaWZpZWQuYCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5VZHRPcCA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBpZiAoZGF0YS5zdHJpY3QpIHtcbiAgICAgICAgICBjb25zdCBuYW1lID0gYXBnbGliLnV0aWxzLmNoYXJzVG9TdHJpbmcoY2hhcnMsIHBocmFzZUluZGV4LCByZXN1bHQucGhyYXNlTGVuZ3RoKTtcbiAgICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgcGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgICAgY2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICAgICAgICBtc2c6IGBVRFQgb3BlcmF0b3IgZm91bmQoJHtuYW1lfSkgLSBzdHJpY3QgQUJORiBzcGVjaWZpZWQuYCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5UbHNPcGVuID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4KSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHRvcEFsdC50bHNPcGVuID0gcGhyYXNlSW5kZXg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5blRsc1N0cmluZyA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgZGF0YS5zdHJpbmdUYWJDaGFyID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaW5nVGFiQ2hhciAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgZGF0YS5zdHJpbmdUYWJDaGFyKSxcbiAgICAgICAgICAgIGNoYXI6IGRhdGEuc3RyaW5nVGFiQ2hhcixcbiAgICAgICAgICAgIG1zZzogXCJUYWIgY2hhcmFjdGVyIChcXFxcdCwgeDA5KSBub3QgYWxsb3dlZCBpbiBsaXRlcmFsIHN0cmluZyAoc2VlICdxdW90ZWQtc3RyaW5nJyBkZWZpbml0aW9uLCBSRkMgNzQwNS4pXCIsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luU3RyaW5nVGFiID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGRhdGEuc3RyaW5nVGFiQ2hhciA9IHBocmFzZUluZGV4O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5UbHNDbG9zZSA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCB0b3BBbHQudGxzT3BlbiksXG4gICAgICAgICAgY2hhcjogdG9wQWx0LnRsc09wZW4sXG4gICAgICAgICAgbXNnOiAnQ2FzZS1pbnNlbnNpdGl2ZSBsaXRlcmFsIHN0cmluZyhcIi4uLlwiKSBvcGVuZWQgYnV0IG5vdCBjbG9zZWQuJyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRvcEFsdC5iYXNpY0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgdG9wQWx0LnRsc09wZW4gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHRvcEFsdC50bHNPcGVuID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQ2xzT3BlbiA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICB0b3BBbHQuY2xzT3BlbiA9IHBocmFzZUluZGV4O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5DbHNTdHJpbmcgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGRhdGEuc3RyaW5nVGFiQ2hhciA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmluZ1RhYkNoYXIgIT09IGZhbHNlKSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIGRhdGEuc3RyaW5nVGFiQ2hhciksXG4gICAgICAgICAgICBjaGFyOiBkYXRhLnN0cmluZ1RhYkNoYXIsXG4gICAgICAgICAgICBtc2c6ICdUYWIgY2hhcmFjdGVyIChcXFxcdCwgeDA5KSBub3QgYWxsb3dlZCBpbiBsaXRlcmFsIHN0cmluZy4nLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkNsc0Nsb3NlID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHRvcEFsdC5jbHNPcGVuKSxcbiAgICAgICAgICBjaGFyOiB0b3BBbHQuY2xzT3BlbixcbiAgICAgICAgICBtc2c6IFwiQ2FzZS1zZW5zaXRpdmUgbGl0ZXJhbCBzdHJpbmcoJy4uLicpIG9wZW5lZCBidXQgbm90IGNsb3NlZC5cIixcbiAgICAgICAgfSk7XG4gICAgICAgIHRvcEFsdC5jbHNPcGVuID0gbnVsbDtcbiAgICAgICAgdG9wQWx0LmJhc2ljRXJyb3IgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmljdCkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCB0b3BBbHQuY2xzT3BlbiksXG4gICAgICAgICAgICBjaGFyOiB0b3BBbHQuY2xzT3BlbixcbiAgICAgICAgICAgIG1zZzogXCJDYXNlLXNlbnNpdGl2ZSBzdHJpbmcgb3BlcmF0b3IoJy4uLicpIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLlwiLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRvcEFsdC5jbHNPcGVuID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luUHJvc1ZhbE9wZW4gPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgdG9wQWx0LnByb3NWYWxPcGVuID0gcGhyYXNlSW5kZXg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5blByb3NWYWxTdHJpbmcgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGRhdGEuc3RyaW5nVGFiQ2hhciA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmluZ1RhYkNoYXIgIT09IGZhbHNlKSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIGRhdGEuc3RyaW5nVGFiQ2hhciksXG4gICAgICAgICAgICBjaGFyOiBkYXRhLnN0cmluZ1RhYkNoYXIsXG4gICAgICAgICAgICBtc2c6ICdUYWIgY2hhcmFjdGVyIChcXFxcdCwgeDA5KSBub3QgYWxsb3dlZCBpbiBwcm9zZSB2YWx1ZSBzdHJpbmcuJyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5Qcm9zVmFsQ2xvc2UgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgdG9wQWx0LnByb3NWYWxPcGVuKSxcbiAgICAgICAgICBjaGFyOiB0b3BBbHQucHJvc1ZhbE9wZW4sXG4gICAgICAgICAgbXNnOiAnUHJvc2UgdmFsdWUgb3BlcmF0b3IoPC4uLj4pIG9wZW5lZCBidXQgbm90IGNsb3NlZC4nLFxuICAgICAgICB9KTtcbiAgICAgICAgdG9wQWx0LmJhc2ljRXJyb3IgPSB0cnVlO1xuICAgICAgICB0b3BBbHQucHJvc1ZhbE9wZW4gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgdG9wQWx0LnByb3NWYWxPcGVuKSxcbiAgICAgICAgICBjaGFyOiB0b3BBbHQucHJvc1ZhbE9wZW4sXG4gICAgICAgICAgbXNnOiAnUHJvc2UgdmFsdWUgb3BlcmF0b3IoPC4uLj4pIGZvdW5kLiBUaGUgQUJORiBzeW50YXggaXMgdmFsaWQsIGJ1dCBhIHBhcnNlciBjYW5ub3QgYmUgZ2VuZXJhdGVkIGZyb20gdGhpcyBncmFtbWFyLicsXG4gICAgICAgIH0pO1xuICAgICAgICB0b3BBbHQucHJvc1ZhbE9wZW4gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5Hcm91cE9wZW4gPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgdG9wQWx0ID0ge1xuICAgICAgICAgIGdyb3VwT3BlbjogcGhyYXNlSW5kZXgsXG4gICAgICAgICAgZ3JvdXBFcnJvcjogZmFsc2UsXG4gICAgICAgICAgb3B0aW9uT3BlbjogbnVsbCxcbiAgICAgICAgICBvcHRpb25FcnJvcjogZmFsc2UsXG4gICAgICAgICAgdGxzT3BlbjogbnVsbCxcbiAgICAgICAgICBjbHNPcGVuOiBudWxsLFxuICAgICAgICAgIHByb3NWYWxPcGVuOiBudWxsLFxuICAgICAgICAgIGJhc2ljRXJyb3I6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBkYXRhLmFsdFN0YWNrLnB1c2godG9wQWx0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luR3JvdXBDbG9zZSA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCB0b3BBbHQuZ3JvdXBPcGVuKSxcbiAgICAgICAgICBjaGFyOiB0b3BBbHQuZ3JvdXBPcGVuLFxuICAgICAgICAgIG1zZzogJ0dyb3VwIFwiKC4uLilcIiBvcGVuZWQgYnV0IG5vdCBjbG9zZWQuJyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRvcEFsdCA9IGRhdGEuYWx0U3RhY2sucG9wKCk7XG4gICAgICAgIHRvcEFsdC5ncm91cEVycm9yID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICB0b3BBbHQgPSBkYXRhLmFsdFN0YWNrLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5PcHRpb25PcGVuID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHRvcEFsdCA9IHtcbiAgICAgICAgICBncm91cE9wZW46IG51bGwsXG4gICAgICAgICAgZ3JvdXBFcnJvcjogZmFsc2UsXG4gICAgICAgICAgb3B0aW9uT3BlbjogcGhyYXNlSW5kZXgsXG4gICAgICAgICAgb3B0aW9uRXJyb3I6IGZhbHNlLFxuICAgICAgICAgIHRsc09wZW46IG51bGwsXG4gICAgICAgICAgY2xzT3BlbjogbnVsbCxcbiAgICAgICAgICBwcm9zVmFsT3BlbjogbnVsbCxcbiAgICAgICAgICBiYXNpY0Vycm9yOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgZGF0YS5hbHRTdGFjay5wdXNoKHRvcEFsdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bk9wdGlvbkNsb3NlID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHRvcEFsdC5vcHRpb25PcGVuKSxcbiAgICAgICAgICBjaGFyOiB0b3BBbHQub3B0aW9uT3BlbixcbiAgICAgICAgICBtc2c6ICdPcHRpb24gXCJbLi4uXVwiIG9wZW5lZCBidXQgbm90IGNsb3NlZC4nLFxuICAgICAgICB9KTtcbiAgICAgICAgdG9wQWx0ID0gZGF0YS5hbHRTdGFjay5wb3AoKTtcbiAgICAgICAgdG9wQWx0Lm9wdGlvbkVycm9yID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICB0b3BBbHQgPSBkYXRhLmFsdFN0YWNrLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5CYXNpY0VsZW1lbnRFcnJvciA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBpZiAodG9wQWx0LmJhc2ljRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnVW5yZWNvZ25pemVkIFNBQk5GIGVsZW1lbnQuJyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5MaW5lRW5kID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChyZXN1bHQucGhyYXNlTGVuZ3RoID09PSAxICYmIGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgY29uc3QgZW5kID0gY2hhcnNbcGhyYXNlSW5kZXhdID09PSAxMyA/ICdDUicgOiAnTEYnO1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogYExpbmUgZW5kICcke2VuZH0nIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLCBvbmx5IENSTEYgYWxsb3dlZC5gLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkxpbmVFbmRFcnJvciA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICBtc2c6ICdVbnJlY29nbml6ZWQgZ3JhbW1hciBlbGVtZW50IG9yIGNoYXJhY3RlcnMuJyxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5blJlcGV0aXRpb24gPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGRhdGEucmVwQ291bnQgKz0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBkYXRhLnJlcENvdW50ICs9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIC8vIERlZmluZSB0aGUgbGlzdCBvZiBjYWxsYmFjayBmdW5jdGlvbnMuXG4gIHRoaXMuY2FsbGJhY2tzID0gW107XG4gIHRoaXMuY2FsbGJhY2tzLmFuZG9wID0gc3luQW5kT3A7XG4gIHRoaXMuY2FsbGJhY2tzLmJhc2ljZWxlbWVudGVyciA9IHN5bkJhc2ljRWxlbWVudEVycm9yO1xuICB0aGlzLmNhbGxiYWNrcy5jbHNjbG9zZSA9IHN5bkNsc0Nsb3NlO1xuICB0aGlzLmNhbGxiYWNrcy5jbHNvcGVuID0gc3luQ2xzT3BlbjtcbiAgdGhpcy5jYWxsYmFja3MuY2xzc3RyaW5nID0gc3luQ2xzU3RyaW5nO1xuICB0aGlzLmNhbGxiYWNrcy5kZWZpbmVkYXNlcnJvciA9IHN5bkRlZmluZWRBc0Vycm9yO1xuICB0aGlzLmNhbGxiYWNrcy5maWxlID0gc3luRmlsZTtcbiAgdGhpcy5jYWxsYmFja3MuZ3JvdXBjbG9zZSA9IHN5bkdyb3VwQ2xvc2U7XG4gIHRoaXMuY2FsbGJhY2tzLmdyb3Vwb3BlbiA9IHN5bkdyb3VwT3BlbjtcbiAgdGhpcy5jYWxsYmFja3MubGluZWVuZGVycm9yID0gc3luTGluZUVuZEVycm9yO1xuICB0aGlzLmNhbGxiYWNrcy5saW5lZW5kID0gc3luTGluZUVuZDtcbiAgdGhpcy5jYWxsYmFja3Mubm90b3AgPSBzeW5Ob3RPcDtcbiAgdGhpcy5jYWxsYmFja3Mub3B0aW9uY2xvc2UgPSBzeW5PcHRpb25DbG9zZTtcbiAgdGhpcy5jYWxsYmFja3Mub3B0aW9ub3BlbiA9IHN5bk9wdGlvbk9wZW47XG4gIHRoaXMuY2FsbGJhY2tzLnByb3N2YWxjbG9zZSA9IHN5blByb3NWYWxDbG9zZTtcbiAgdGhpcy5jYWxsYmFja3MucHJvc3ZhbG9wZW4gPSBzeW5Qcm9zVmFsT3BlbjtcbiAgdGhpcy5jYWxsYmFja3MucHJvc3ZhbHN0cmluZyA9IHN5blByb3NWYWxTdHJpbmc7XG4gIHRoaXMuY2FsbGJhY2tzLnJlcGV0aXRpb24gPSBzeW5SZXBldGl0aW9uO1xuICB0aGlzLmNhbGxiYWNrcy5ydWxlID0gc3luUnVsZTtcbiAgdGhpcy5jYWxsYmFja3MucnVsZWVycm9yID0gc3luUnVsZUVycm9yO1xuICB0aGlzLmNhbGxiYWNrcy5ydWxlbmFtZWVycm9yID0gc3luUnVsZU5hbWVFcnJvcjtcbiAgdGhpcy5jYWxsYmFja3Muc3RyaW5ndGFiID0gc3luU3RyaW5nVGFiO1xuICB0aGlzLmNhbGxiYWNrcy50bHNjbG9zZSA9IHN5blRsc0Nsb3NlO1xuICB0aGlzLmNhbGxiYWNrcy50bHNvcGVuID0gc3luVGxzT3BlbjtcbiAgdGhpcy5jYWxsYmFja3MudGxzc3RyaW5nID0gc3luVGxzU3RyaW5nO1xuICB0aGlzLmNhbGxiYWNrcy51ZHRvcCA9IHN5blVkdE9wO1xuICB0aGlzLmNhbGxiYWNrcy5ia2FvcCA9IHN5bkJrYU9wO1xuICB0aGlzLmNhbGxiYWNrcy5ia25vcCA9IHN5bkJrbk9wO1xuICB0aGlzLmNhbGxiYWNrcy5ia3JvcCA9IHN5bkJrck9wO1xuICB0aGlzLmNhbGxiYWNrcy5hYmdvcCA9IHN5bkFiZ09wO1xuICB0aGlzLmNhbGxiYWNrcy5hZW5vcCA9IHN5bkFlbk9wO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-api/syntax-callbacks.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-conv-api/converter.js":
/*!***********************************************************!*\
  !*** ./node_modules/apg-js/src/apg-conv-api/converter.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module exposes the public encoding, decoding and conversion functions.\n// Its private functions provide the disassembling and interpetation of the source and destination encoding types.\n// In the case of Unicode encodings, private functions determine the presence of Byte Order Marks (BOMs), if any.\n//\n// Throws \"TypeError\" exceptions on input errors.\n//\n\n'use strict;';\n\nconst thisThis = this;\nconst trans = __webpack_require__(/*! ./transformers */ \"./node_modules/apg-js/src/apg-conv-api/transformers.js\");\n\n/* types */\nconst UTF8 = 'UTF8';\nconst UTF16 = 'UTF16';\nconst UTF16BE = 'UTF16BE';\nconst UTF16LE = 'UTF16LE';\nconst UTF32 = 'UTF32';\nconst UTF32BE = 'UTF32BE';\nconst UTF32LE = 'UTF32LE';\nconst UINT7 = 'UINT7';\nconst ASCII = 'ASCII';\nconst BINARY = 'BINARY';\nconst UINT8 = 'UINT8';\nconst UINT16 = 'UINT16';\nconst UINT16LE = 'UINT16LE';\nconst UINT16BE = 'UINT16BE';\nconst UINT32 = 'UINT32';\nconst UINT32LE = 'UINT32LE';\nconst UINT32BE = 'UINT32BE';\nconst ESCAPED = 'ESCAPED';\nconst STRING = 'STRING';\n\n/* private functions */\n// Find the UTF8 BOM, if any.\nconst bom8 = function bom8(src) {\n  src.type = UTF8;\n  const buf = src.data;\n  src.bom = 0;\n  if (buf.length >= 3) {\n    if (buf[0] === 0xef && buf[1] === 0xbb && buf[2] === 0xbf) {\n      src.bom = 3;\n    }\n  }\n};\n// Find the UTF16 BOM, if any, and determine the UTF16 type.\n// Defaults to UTF16BE.\n// Throws TypeError exception if BOM does not match the specified type.\nconst bom16 = function bom16(src) {\n  const buf = src.data;\n  src.bom = 0;\n  switch (src.type) {\n    case UTF16:\n      src.type = UTF16BE;\n      if (buf.length >= 2) {\n        if (buf[0] === 0xfe && buf[1] === 0xff) {\n          src.bom = 2;\n        } else if (buf[0] === 0xff && buf[1] === 0xfe) {\n          src.type = UTF16LE;\n          src.bom = 2;\n        }\n      }\n      break;\n    case UTF16BE:\n      src.type = UTF16BE;\n      if (buf.length >= 2) {\n        if (buf[0] === 0xfe && buf[1] === 0xff) {\n          src.bom = 2;\n        } else if (buf[0] === 0xff && buf[1] === 0xfe) {\n          throw new TypeError(`src type: \"${UTF16BE}\" specified but BOM is for \"${UTF16LE}\"`);\n        }\n      }\n      break;\n    case UTF16LE:\n      src.type = UTF16LE;\n      if (buf.length >= 0) {\n        if (buf[0] === 0xfe && buf[1] === 0xff) {\n          throw new TypeError(`src type: \"${UTF16LE}\" specified but BOM is for \"${UTF16BE}\"`);\n        } else if (buf[0] === 0xff && buf[1] === 0xfe) {\n          src.bom = 2;\n        }\n      }\n      break;\n    default:\n      throw new TypeError(`UTF16 BOM: src type \"${src.type}\" unrecognized`);\n  }\n};\n// Find the UTF32 BOM, if any, and determine the UTF32 type.\n// Defaults to UTF32BE.\n// Throws exception if BOM does not match the specified type.\nconst bom32 = function bom32(src) {\n  const buf = src.data;\n  src.bom = 0;\n  switch (src.type) {\n    case UTF32:\n      src.type = UTF32BE;\n      if (buf.length >= 4) {\n        if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0xfe && buf[3] === 0xff) {\n          src.bom = 4;\n        }\n        if (buf[0] === 0xff && buf[1] === 0xfe && buf[2] === 0 && buf[3] === 0) {\n          src.type = UTF32LE;\n          src.bom = 4;\n        }\n      }\n      break;\n    case UTF32BE:\n      src.type = UTF32BE;\n      if (buf.length >= 4) {\n        if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0xfe && buf[3] === 0xff) {\n          src.bom = 4;\n        }\n        if (buf[0] === 0xff && buf[1] === 0xfe && buf[2] === 0 && buf[3] === 0) {\n          throw new TypeError(`src type: ${UTF32BE} specified but BOM is for ${UTF32LE}\"`);\n        }\n      }\n      break;\n    case UTF32LE:\n      src.type = UTF32LE;\n      if (buf.length >= 4) {\n        if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0xfe && buf[3] === 0xff) {\n          throw new TypeError(`src type: \"${UTF32LE}\" specified but BOM is for \"${UTF32BE}\"`);\n        }\n        if (buf[0] === 0xff && buf[1] === 0xfe && buf[2] === 0 && buf[3] === 0) {\n          src.bom = 4;\n        }\n      }\n      break;\n    default:\n      throw new TypeError(`UTF32 BOM: src type \"${src.type}\" unrecognized`);\n  }\n};\n// Validates the source encoding type and matching data.\n// If the BASE64: prefix is present, the base 64 decoding is done here as the initial step.\n// - For type STRING, data must be a JavaScript string.\n// - For type BASE64:*, data may be a string or Buffer.\n// - For all other types, data must be a Buffer.\n// - The BASE64: prefix is not allowed for type STRING.\nconst validateSrc = function validateSrc(type, data) {\n  function getType(typeArg) {\n    const ret = {\n      type: '',\n      base64: false,\n    };\n    const rx = /^(base64:)?([a-zA-Z0-9]+)$/i;\n    const result = rx.exec(typeArg);\n    if (result) {\n      if (result[2]) {\n        ret.type = result[2].toUpperCase();\n      }\n      if (result[1]) {\n        ret.base64 = true;\n      }\n    }\n    return ret;\n  }\n  if (typeof type !== 'string' || type === '') {\n    throw new TypeError(`type: \"${type}\" not recognized`);\n  }\n  const ret = getType(type.toUpperCase());\n  if (ret.base64) {\n    /* handle base 64 */\n    if (ret.type === STRING) {\n      throw new TypeError(`type: \"${type} \"BASE64:\" prefix not allowed with type ${STRING}`);\n    }\n    if (Buffer.isBuffer(data)) {\n      ret.data = trans.base64.decode(data);\n    } else if (typeof data === 'string') {\n      const buf = Buffer.from(data, 'ascii');\n      ret.data = trans.base64.decode(buf);\n    } else {\n      throw new TypeError(`type: \"${type} unrecognized data type: typeof(data): ${typeof data}`);\n    }\n  } else {\n    ret.data = data;\n  }\n  switch (ret.type) {\n    case UTF8:\n      bom8(ret);\n      break;\n    case UTF16:\n    case UTF16BE:\n    case UTF16LE:\n      bom16(ret);\n      break;\n    case UTF32:\n    case UTF32BE:\n    case UTF32LE:\n      bom32(ret);\n      break;\n    case UINT16:\n      ret.type = UINT16BE;\n      break;\n    case UINT32:\n      ret.type = UINT32BE;\n      break;\n    case ASCII:\n      ret.type = UINT7;\n      break;\n    case BINARY:\n      ret.type = UINT8;\n      break;\n    case UINT7:\n    case UINT8:\n    case UINT16LE:\n    case UINT16BE:\n    case UINT32LE:\n    case UINT32BE:\n    case STRING:\n    case ESCAPED:\n      break;\n    default:\n      throw new TypeError(`type: \"${type}\" not recognized`);\n  }\n  if (ret.type === STRING) {\n    if (typeof ret.data !== 'string') {\n      throw new TypeError(`type: \"${type}\" but data is not a string`);\n    }\n  } else if (!Buffer.isBuffer(ret.data)) {\n    throw new TypeError(`type: \"${type}\" but data is not a Buffer`);\n  }\n  return ret;\n};\n// Disassembles and validates the destination type.\n// `chars` must be an Array of integers.\n// The :BASE64 suffix is not allowed for type STRING.\nconst validateDst = function validateDst(type, chars) {\n  function getType(typeArg) {\n    let fix;\n    let rem;\n    const ret = {\n      crlf: false,\n      lf: false,\n      base64: false,\n      type: '',\n    };\n    /* prefix, if any */\n    const TRUE = true;\n    while (TRUE) {\n      rem = typeArg;\n      fix = typeArg.slice(0, 5);\n      if (fix === 'CRLF:') {\n        ret.crlf = true;\n        rem = typeArg.slice(5);\n        break;\n      }\n      fix = typeArg.slice(0, 3);\n      if (fix === 'LF:') {\n        ret.lf = true;\n        rem = typeArg.slice(3);\n        break;\n      }\n      break;\n    }\n    /* suffix, if any */\n    fix = rem.split(':');\n    if (fix.length === 1) {\n      // eslint-disable-next-line prefer-destructuring\n      ret.type = fix[0];\n    } else if (fix.length === 2 && fix[1] === 'BASE64') {\n      ret.base64 = true;\n      // eslint-disable-next-line prefer-destructuring\n      ret.type = fix[0];\n    }\n    return ret;\n  }\n  if (!Array.isArray(chars)) {\n    throw new TypeError(`dst chars: not array: \"${typeof chars}`);\n  }\n  if (typeof type !== 'string') {\n    throw new TypeError(`dst type: not string: \"${typeof type}`);\n  }\n  const ret = getType(type.toUpperCase());\n  switch (ret.type) {\n    case UTF8:\n    case UTF16BE:\n    case UTF16LE:\n    case UTF32BE:\n    case UTF32LE:\n    case UINT7:\n    case UINT8:\n    case UINT16LE:\n    case UINT16BE:\n    case UINT32LE:\n    case UINT32BE:\n    case ESCAPED:\n      break;\n    case STRING:\n      if (ret.base64) {\n        throw new TypeError(`\":BASE64\" suffix not allowed with type ${STRING}`);\n      }\n      break;\n    case ASCII:\n      ret.type = UINT7;\n      break;\n    case BINARY:\n      ret.type = UINT8;\n      break;\n    case UTF16:\n      ret.type = UTF16BE;\n      break;\n    case UTF32:\n      ret.type = UTF32BE;\n      break;\n    case UINT16:\n      ret.type = UINT16BE;\n      break;\n    case UINT32:\n      ret.type = UINT32BE;\n      break;\n    default:\n      throw new TypeError(`dst type unrecognized: \"${type}\" : must have form [crlf:|lf:]type[:base64]`);\n  }\n  return ret;\n};\n// Select and call the requested encoding function.\nconst encode = function encode(type, chars) {\n  switch (type) {\n    case UTF8:\n      return trans.utf8.encode(chars);\n    case UTF16BE:\n      return trans.utf16be.encode(chars);\n    case UTF16LE:\n      return trans.utf16le.encode(chars);\n    case UTF32BE:\n      return trans.utf32be.encode(chars);\n    case UTF32LE:\n      return trans.utf32le.encode(chars);\n    case UINT7:\n      return trans.uint7.encode(chars);\n    case UINT8:\n      return trans.uint8.encode(chars);\n    case UINT16BE:\n      return trans.uint16be.encode(chars);\n    case UINT16LE:\n      return trans.uint16le.encode(chars);\n    case UINT32BE:\n      return trans.uint32be.encode(chars);\n    case UINT32LE:\n      return trans.uint32le.encode(chars);\n    case STRING:\n      return trans.string.encode(chars);\n    case ESCAPED:\n      return trans.escaped.encode(chars);\n    default:\n      throw new TypeError(`encode type \"${type}\" not recognized`);\n  }\n};\n// Select and call the requested decoding function.\n// `src` contains BOM information as well as the source type and data.\nconst decode = function decode(src) {\n  switch (src.type) {\n    case UTF8:\n      return trans.utf8.decode(src.data, src.bom);\n    case UTF16LE:\n      return trans.utf16le.decode(src.data, src.bom);\n    case UTF16BE:\n      return trans.utf16be.decode(src.data, src.bom);\n    case UTF32BE:\n      return trans.utf32be.decode(src.data, src.bom);\n    case UTF32LE:\n      return trans.utf32le.decode(src.data, src.bom);\n    case UINT7:\n      return trans.uint7.decode(src.data);\n    case UINT8:\n      return trans.uint8.decode(src.data);\n    case UINT16BE:\n      return trans.uint16be.decode(src.data);\n    case UINT16LE:\n      return trans.uint16le.decode(src.data);\n    case UINT32BE:\n      return trans.uint32be.decode(src.data);\n    case UINT32LE:\n      return trans.uint32le.decode(src.data);\n    case STRING:\n      return trans.string.decode(src.data);\n    case ESCAPED:\n      return trans.escaped.decode(src.data);\n    default:\n      throw new TypeError(`decode type \"${src.type}\" not recognized`);\n  }\n};\n\n// The public decoding function. Returns an array of integers.\nexports.decode = function exportsDecode(type, data) {\n  const src = validateSrc(type, data);\n  return decode(src);\n};\n// The public encoding function. Returns a Buffer-typed byte array.\nexports.encode = function exportsEncode(type, chars) {\n  let c;\n  let buf;\n  const dst = validateDst(type, chars);\n  if (dst.crlf) {\n    /* prefix with CRLF line end conversion, don't contaminate caller's chars array */\n    c = trans.lineEnds.crlf(chars);\n    buf = encode(dst.type, c);\n  } else if (dst.lf) {\n    /* prefix with LF line end conversion, don't contaminate caller's chars array */\n    c = trans.lineEnds.lf(chars);\n    buf = encode(dst.type, c);\n  } else {\n    buf = encode(dst.type, chars);\n  }\n  if (dst.base64) {\n    /* post base 64 encoding */\n    buf = trans.base64.encode(buf);\n  }\n  return buf;\n};\n// Converts data of type `srcType` to data of type `dstType`.\n// `srcData` may be a JavaScript String, or node.js Buffer, depending on the corresponding type.\nexports.convert = function convert(srcType, srcData, dstType) {\n  return thisThis.encode(dstType, thisThis.decode(srcType, srcData));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctY29udi1hcGkvY29udmVydGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZOztBQUVaO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLDhFQUFnQjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNENBQTRDLFFBQVEsOEJBQThCLFFBQVE7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUSw4QkFBOEIsUUFBUTtBQUMxRixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVMsMkJBQTJCLFFBQVE7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUSw4QkFBOEIsUUFBUTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxLQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTSx5Q0FBeUMsT0FBTztBQUMxRjtBQUNBLFFBQVEsTUFBTTtBQUNkO0FBQ0EsTUFBTTtBQUNOLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0EsTUFBTTtBQUNOLG9DQUFvQyxNQUFNLHdDQUF3QyxZQUFZO0FBQzlGO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSztBQUN6QztBQUNBLElBQUksVUFBVSxNQUFNO0FBQ3BCLGtDQUFrQyxLQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxhQUFhO0FBQy9EO0FBQ0E7QUFDQSxrREFBa0QsWUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsT0FBTztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsS0FBSztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1jb252LWFwaS9jb252ZXJ0ZXIuanM/NzU0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSBleHBvc2VzIHRoZSBwdWJsaWMgZW5jb2RpbmcsIGRlY29kaW5nIGFuZCBjb252ZXJzaW9uIGZ1bmN0aW9ucy5cbi8vIEl0cyBwcml2YXRlIGZ1bmN0aW9ucyBwcm92aWRlIHRoZSBkaXNhc3NlbWJsaW5nIGFuZCBpbnRlcnBldGF0aW9uIG9mIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGVuY29kaW5nIHR5cGVzLlxuLy8gSW4gdGhlIGNhc2Ugb2YgVW5pY29kZSBlbmNvZGluZ3MsIHByaXZhdGUgZnVuY3Rpb25zIGRldGVybWluZSB0aGUgcHJlc2VuY2Ugb2YgQnl0ZSBPcmRlciBNYXJrcyAoQk9NcyksIGlmIGFueS5cbi8vXG4vLyBUaHJvd3MgXCJUeXBlRXJyb3JcIiBleGNlcHRpb25zIG9uIGlucHV0IGVycm9ycy5cbi8vXG5cbid1c2Ugc3RyaWN0Oyc7XG5cbmNvbnN0IHRoaXNUaGlzID0gdGhpcztcbmNvbnN0IHRyYW5zID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1lcnMnKTtcblxuLyogdHlwZXMgKi9cbmNvbnN0IFVURjggPSAnVVRGOCc7XG5jb25zdCBVVEYxNiA9ICdVVEYxNic7XG5jb25zdCBVVEYxNkJFID0gJ1VURjE2QkUnO1xuY29uc3QgVVRGMTZMRSA9ICdVVEYxNkxFJztcbmNvbnN0IFVURjMyID0gJ1VURjMyJztcbmNvbnN0IFVURjMyQkUgPSAnVVRGMzJCRSc7XG5jb25zdCBVVEYzMkxFID0gJ1VURjMyTEUnO1xuY29uc3QgVUlOVDcgPSAnVUlOVDcnO1xuY29uc3QgQVNDSUkgPSAnQVNDSUknO1xuY29uc3QgQklOQVJZID0gJ0JJTkFSWSc7XG5jb25zdCBVSU5UOCA9ICdVSU5UOCc7XG5jb25zdCBVSU5UMTYgPSAnVUlOVDE2JztcbmNvbnN0IFVJTlQxNkxFID0gJ1VJTlQxNkxFJztcbmNvbnN0IFVJTlQxNkJFID0gJ1VJTlQxNkJFJztcbmNvbnN0IFVJTlQzMiA9ICdVSU5UMzInO1xuY29uc3QgVUlOVDMyTEUgPSAnVUlOVDMyTEUnO1xuY29uc3QgVUlOVDMyQkUgPSAnVUlOVDMyQkUnO1xuY29uc3QgRVNDQVBFRCA9ICdFU0NBUEVEJztcbmNvbnN0IFNUUklORyA9ICdTVFJJTkcnO1xuXG4vKiBwcml2YXRlIGZ1bmN0aW9ucyAqL1xuLy8gRmluZCB0aGUgVVRGOCBCT00sIGlmIGFueS5cbmNvbnN0IGJvbTggPSBmdW5jdGlvbiBib204KHNyYykge1xuICBzcmMudHlwZSA9IFVURjg7XG4gIGNvbnN0IGJ1ZiA9IHNyYy5kYXRhO1xuICBzcmMuYm9tID0gMDtcbiAgaWYgKGJ1Zi5sZW5ndGggPj0gMykge1xuICAgIGlmIChidWZbMF0gPT09IDB4ZWYgJiYgYnVmWzFdID09PSAweGJiICYmIGJ1ZlsyXSA9PT0gMHhiZikge1xuICAgICAgc3JjLmJvbSA9IDM7XG4gICAgfVxuICB9XG59O1xuLy8gRmluZCB0aGUgVVRGMTYgQk9NLCBpZiBhbnksIGFuZCBkZXRlcm1pbmUgdGhlIFVURjE2IHR5cGUuXG4vLyBEZWZhdWx0cyB0byBVVEYxNkJFLlxuLy8gVGhyb3dzIFR5cGVFcnJvciBleGNlcHRpb24gaWYgQk9NIGRvZXMgbm90IG1hdGNoIHRoZSBzcGVjaWZpZWQgdHlwZS5cbmNvbnN0IGJvbTE2ID0gZnVuY3Rpb24gYm9tMTYoc3JjKSB7XG4gIGNvbnN0IGJ1ZiA9IHNyYy5kYXRhO1xuICBzcmMuYm9tID0gMDtcbiAgc3dpdGNoIChzcmMudHlwZSkge1xuICAgIGNhc2UgVVRGMTY6XG4gICAgICBzcmMudHlwZSA9IFVURjE2QkU7XG4gICAgICBpZiAoYnVmLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIGlmIChidWZbMF0gPT09IDB4ZmUgJiYgYnVmWzFdID09PSAweGZmKSB7XG4gICAgICAgICAgc3JjLmJvbSA9IDI7XG4gICAgICAgIH0gZWxzZSBpZiAoYnVmWzBdID09PSAweGZmICYmIGJ1ZlsxXSA9PT0gMHhmZSkge1xuICAgICAgICAgIHNyYy50eXBlID0gVVRGMTZMRTtcbiAgICAgICAgICBzcmMuYm9tID0gMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVVEYxNkJFOlxuICAgICAgc3JjLnR5cGUgPSBVVEYxNkJFO1xuICAgICAgaWYgKGJ1Zi5sZW5ndGggPj0gMikge1xuICAgICAgICBpZiAoYnVmWzBdID09PSAweGZlICYmIGJ1ZlsxXSA9PT0gMHhmZikge1xuICAgICAgICAgIHNyYy5ib20gPSAyO1xuICAgICAgICB9IGVsc2UgaWYgKGJ1ZlswXSA9PT0gMHhmZiAmJiBidWZbMV0gPT09IDB4ZmUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzcmMgdHlwZTogXCIke1VURjE2QkV9XCIgc3BlY2lmaWVkIGJ1dCBCT00gaXMgZm9yIFwiJHtVVEYxNkxFfVwiYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVVRGMTZMRTpcbiAgICAgIHNyYy50eXBlID0gVVRGMTZMRTtcbiAgICAgIGlmIChidWYubGVuZ3RoID49IDApIHtcbiAgICAgICAgaWYgKGJ1ZlswXSA9PT0gMHhmZSAmJiBidWZbMV0gPT09IDB4ZmYpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzcmMgdHlwZTogXCIke1VURjE2TEV9XCIgc3BlY2lmaWVkIGJ1dCBCT00gaXMgZm9yIFwiJHtVVEYxNkJFfVwiYCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYnVmWzBdID09PSAweGZmICYmIGJ1ZlsxXSA9PT0gMHhmZSkge1xuICAgICAgICAgIHNyYy5ib20gPSAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVVRGMTYgQk9NOiBzcmMgdHlwZSBcIiR7c3JjLnR5cGV9XCIgdW5yZWNvZ25pemVkYCk7XG4gIH1cbn07XG4vLyBGaW5kIHRoZSBVVEYzMiBCT00sIGlmIGFueSwgYW5kIGRldGVybWluZSB0aGUgVVRGMzIgdHlwZS5cbi8vIERlZmF1bHRzIHRvIFVURjMyQkUuXG4vLyBUaHJvd3MgZXhjZXB0aW9uIGlmIEJPTSBkb2VzIG5vdCBtYXRjaCB0aGUgc3BlY2lmaWVkIHR5cGUuXG5jb25zdCBib20zMiA9IGZ1bmN0aW9uIGJvbTMyKHNyYykge1xuICBjb25zdCBidWYgPSBzcmMuZGF0YTtcbiAgc3JjLmJvbSA9IDA7XG4gIHN3aXRjaCAoc3JjLnR5cGUpIHtcbiAgICBjYXNlIFVURjMyOlxuICAgICAgc3JjLnR5cGUgPSBVVEYzMkJFO1xuICAgICAgaWYgKGJ1Zi5sZW5ndGggPj0gNCkge1xuICAgICAgICBpZiAoYnVmWzBdID09PSAwICYmIGJ1ZlsxXSA9PT0gMCAmJiBidWZbMl0gPT09IDB4ZmUgJiYgYnVmWzNdID09PSAweGZmKSB7XG4gICAgICAgICAgc3JjLmJvbSA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZlswXSA9PT0gMHhmZiAmJiBidWZbMV0gPT09IDB4ZmUgJiYgYnVmWzJdID09PSAwICYmIGJ1ZlszXSA9PT0gMCkge1xuICAgICAgICAgIHNyYy50eXBlID0gVVRGMzJMRTtcbiAgICAgICAgICBzcmMuYm9tID0gNDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVVEYzMkJFOlxuICAgICAgc3JjLnR5cGUgPSBVVEYzMkJFO1xuICAgICAgaWYgKGJ1Zi5sZW5ndGggPj0gNCkge1xuICAgICAgICBpZiAoYnVmWzBdID09PSAwICYmIGJ1ZlsxXSA9PT0gMCAmJiBidWZbMl0gPT09IDB4ZmUgJiYgYnVmWzNdID09PSAweGZmKSB7XG4gICAgICAgICAgc3JjLmJvbSA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZlswXSA9PT0gMHhmZiAmJiBidWZbMV0gPT09IDB4ZmUgJiYgYnVmWzJdID09PSAwICYmIGJ1ZlszXSA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHNyYyB0eXBlOiAke1VURjMyQkV9IHNwZWNpZmllZCBidXQgQk9NIGlzIGZvciAke1VURjMyTEV9XCJgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVVEYzMkxFOlxuICAgICAgc3JjLnR5cGUgPSBVVEYzMkxFO1xuICAgICAgaWYgKGJ1Zi5sZW5ndGggPj0gNCkge1xuICAgICAgICBpZiAoYnVmWzBdID09PSAwICYmIGJ1ZlsxXSA9PT0gMCAmJiBidWZbMl0gPT09IDB4ZmUgJiYgYnVmWzNdID09PSAweGZmKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgc3JjIHR5cGU6IFwiJHtVVEYzMkxFfVwiIHNwZWNpZmllZCBidXQgQk9NIGlzIGZvciBcIiR7VVRGMzJCRX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZbMF0gPT09IDB4ZmYgJiYgYnVmWzFdID09PSAweGZlICYmIGJ1ZlsyXSA9PT0gMCAmJiBidWZbM10gPT09IDApIHtcbiAgICAgICAgICBzcmMuYm9tID0gNDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVURjMyIEJPTTogc3JjIHR5cGUgXCIke3NyYy50eXBlfVwiIHVucmVjb2duaXplZGApO1xuICB9XG59O1xuLy8gVmFsaWRhdGVzIHRoZSBzb3VyY2UgZW5jb2RpbmcgdHlwZSBhbmQgbWF0Y2hpbmcgZGF0YS5cbi8vIElmIHRoZSBCQVNFNjQ6IHByZWZpeCBpcyBwcmVzZW50LCB0aGUgYmFzZSA2NCBkZWNvZGluZyBpcyBkb25lIGhlcmUgYXMgdGhlIGluaXRpYWwgc3RlcC5cbi8vIC0gRm9yIHR5cGUgU1RSSU5HLCBkYXRhIG11c3QgYmUgYSBKYXZhU2NyaXB0IHN0cmluZy5cbi8vIC0gRm9yIHR5cGUgQkFTRTY0OiosIGRhdGEgbWF5IGJlIGEgc3RyaW5nIG9yIEJ1ZmZlci5cbi8vIC0gRm9yIGFsbCBvdGhlciB0eXBlcywgZGF0YSBtdXN0IGJlIGEgQnVmZmVyLlxuLy8gLSBUaGUgQkFTRTY0OiBwcmVmaXggaXMgbm90IGFsbG93ZWQgZm9yIHR5cGUgU1RSSU5HLlxuY29uc3QgdmFsaWRhdGVTcmMgPSBmdW5jdGlvbiB2YWxpZGF0ZVNyYyh0eXBlLCBkYXRhKSB7XG4gIGZ1bmN0aW9uIGdldFR5cGUodHlwZUFyZykge1xuICAgIGNvbnN0IHJldCA9IHtcbiAgICAgIHR5cGU6ICcnLFxuICAgICAgYmFzZTY0OiBmYWxzZSxcbiAgICB9O1xuICAgIGNvbnN0IHJ4ID0gL14oYmFzZTY0Oik/KFthLXpBLVowLTldKykkL2k7XG4gICAgY29uc3QgcmVzdWx0ID0gcnguZXhlYyh0eXBlQXJnKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBpZiAocmVzdWx0WzJdKSB7XG4gICAgICAgIHJldC50eXBlID0gcmVzdWx0WzJdLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0WzFdKSB7XG4gICAgICAgIHJldC5iYXNlNjQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0eXBlOiBcIiR7dHlwZX1cIiBub3QgcmVjb2duaXplZGApO1xuICB9XG4gIGNvbnN0IHJldCA9IGdldFR5cGUodHlwZS50b1VwcGVyQ2FzZSgpKTtcbiAgaWYgKHJldC5iYXNlNjQpIHtcbiAgICAvKiBoYW5kbGUgYmFzZSA2NCAqL1xuICAgIGlmIChyZXQudHlwZSA9PT0gU1RSSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0eXBlOiBcIiR7dHlwZX0gXCJCQVNFNjQ6XCIgcHJlZml4IG5vdCBhbGxvd2VkIHdpdGggdHlwZSAke1NUUklOR31gKTtcbiAgICB9XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgcmV0LmRhdGEgPSB0cmFucy5iYXNlNjQuZGVjb2RlKGRhdGEpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBidWYgPSBCdWZmZXIuZnJvbShkYXRhLCAnYXNjaWknKTtcbiAgICAgIHJldC5kYXRhID0gdHJhbnMuYmFzZTY0LmRlY29kZShidWYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0eXBlOiBcIiR7dHlwZX0gdW5yZWNvZ25pemVkIGRhdGEgdHlwZTogdHlwZW9mKGRhdGEpOiAke3R5cGVvZiBkYXRhfWApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXQuZGF0YSA9IGRhdGE7XG4gIH1cbiAgc3dpdGNoIChyZXQudHlwZSkge1xuICAgIGNhc2UgVVRGODpcbiAgICAgIGJvbTgocmV0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVVRGMTY6XG4gICAgY2FzZSBVVEYxNkJFOlxuICAgIGNhc2UgVVRGMTZMRTpcbiAgICAgIGJvbTE2KHJldCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVURjMyOlxuICAgIGNhc2UgVVRGMzJCRTpcbiAgICBjYXNlIFVURjMyTEU6XG4gICAgICBib20zMihyZXQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVSU5UMTY6XG4gICAgICByZXQudHlwZSA9IFVJTlQxNkJFO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVSU5UMzI6XG4gICAgICByZXQudHlwZSA9IFVJTlQzMkJFO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBU0NJSTpcbiAgICAgIHJldC50eXBlID0gVUlOVDc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJJTkFSWTpcbiAgICAgIHJldC50eXBlID0gVUlOVDg7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVJTlQ3OlxuICAgIGNhc2UgVUlOVDg6XG4gICAgY2FzZSBVSU5UMTZMRTpcbiAgICBjYXNlIFVJTlQxNkJFOlxuICAgIGNhc2UgVUlOVDMyTEU6XG4gICAgY2FzZSBVSU5UMzJCRTpcbiAgICBjYXNlIFNUUklORzpcbiAgICBjYXNlIEVTQ0FQRUQ6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdHlwZTogXCIke3R5cGV9XCIgbm90IHJlY29nbml6ZWRgKTtcbiAgfVxuICBpZiAocmV0LnR5cGUgPT09IFNUUklORykge1xuICAgIGlmICh0eXBlb2YgcmV0LmRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0eXBlOiBcIiR7dHlwZX1cIiBidXQgZGF0YSBpcyBub3QgYSBzdHJpbmdgKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihyZXQuZGF0YSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0eXBlOiBcIiR7dHlwZX1cIiBidXQgZGF0YSBpcyBub3QgYSBCdWZmZXJgKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbi8vIERpc2Fzc2VtYmxlcyBhbmQgdmFsaWRhdGVzIHRoZSBkZXN0aW5hdGlvbiB0eXBlLlxuLy8gYGNoYXJzYCBtdXN0IGJlIGFuIEFycmF5IG9mIGludGVnZXJzLlxuLy8gVGhlIDpCQVNFNjQgc3VmZml4IGlzIG5vdCBhbGxvd2VkIGZvciB0eXBlIFNUUklORy5cbmNvbnN0IHZhbGlkYXRlRHN0ID0gZnVuY3Rpb24gdmFsaWRhdGVEc3QodHlwZSwgY2hhcnMpIHtcbiAgZnVuY3Rpb24gZ2V0VHlwZSh0eXBlQXJnKSB7XG4gICAgbGV0IGZpeDtcbiAgICBsZXQgcmVtO1xuICAgIGNvbnN0IHJldCA9IHtcbiAgICAgIGNybGY6IGZhbHNlLFxuICAgICAgbGY6IGZhbHNlLFxuICAgICAgYmFzZTY0OiBmYWxzZSxcbiAgICAgIHR5cGU6ICcnLFxuICAgIH07XG4gICAgLyogcHJlZml4LCBpZiBhbnkgKi9cbiAgICBjb25zdCBUUlVFID0gdHJ1ZTtcbiAgICB3aGlsZSAoVFJVRSkge1xuICAgICAgcmVtID0gdHlwZUFyZztcbiAgICAgIGZpeCA9IHR5cGVBcmcuc2xpY2UoMCwgNSk7XG4gICAgICBpZiAoZml4ID09PSAnQ1JMRjonKSB7XG4gICAgICAgIHJldC5jcmxmID0gdHJ1ZTtcbiAgICAgICAgcmVtID0gdHlwZUFyZy5zbGljZSg1KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBmaXggPSB0eXBlQXJnLnNsaWNlKDAsIDMpO1xuICAgICAgaWYgKGZpeCA9PT0gJ0xGOicpIHtcbiAgICAgICAgcmV0LmxmID0gdHJ1ZTtcbiAgICAgICAgcmVtID0gdHlwZUFyZy5zbGljZSgzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLyogc3VmZml4LCBpZiBhbnkgKi9cbiAgICBmaXggPSByZW0uc3BsaXQoJzonKTtcbiAgICBpZiAoZml4Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICByZXQudHlwZSA9IGZpeFswXTtcbiAgICB9IGVsc2UgaWYgKGZpeC5sZW5ndGggPT09IDIgJiYgZml4WzFdID09PSAnQkFTRTY0Jykge1xuICAgICAgcmV0LmJhc2U2NCA9IHRydWU7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgIHJldC50eXBlID0gZml4WzBdO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShjaGFycykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBkc3QgY2hhcnM6IG5vdCBhcnJheTogXCIke3R5cGVvZiBjaGFyc31gKTtcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZHN0IHR5cGU6IG5vdCBzdHJpbmc6IFwiJHt0eXBlb2YgdHlwZX1gKTtcbiAgfVxuICBjb25zdCByZXQgPSBnZXRUeXBlKHR5cGUudG9VcHBlckNhc2UoKSk7XG4gIHN3aXRjaCAocmV0LnR5cGUpIHtcbiAgICBjYXNlIFVURjg6XG4gICAgY2FzZSBVVEYxNkJFOlxuICAgIGNhc2UgVVRGMTZMRTpcbiAgICBjYXNlIFVURjMyQkU6XG4gICAgY2FzZSBVVEYzMkxFOlxuICAgIGNhc2UgVUlOVDc6XG4gICAgY2FzZSBVSU5UODpcbiAgICBjYXNlIFVJTlQxNkxFOlxuICAgIGNhc2UgVUlOVDE2QkU6XG4gICAgY2FzZSBVSU5UMzJMRTpcbiAgICBjYXNlIFVJTlQzMkJFOlxuICAgIGNhc2UgRVNDQVBFRDpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU1RSSU5HOlxuICAgICAgaWYgKHJldC5iYXNlNjQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCI6QkFTRTY0XCIgc3VmZml4IG5vdCBhbGxvd2VkIHdpdGggdHlwZSAke1NUUklOR31gKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQVNDSUk6XG4gICAgICByZXQudHlwZSA9IFVJTlQ3O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCSU5BUlk6XG4gICAgICByZXQudHlwZSA9IFVJTlQ4O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVVEYxNjpcbiAgICAgIHJldC50eXBlID0gVVRGMTZCRTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVVRGMzI6XG4gICAgICByZXQudHlwZSA9IFVURjMyQkU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVJTlQxNjpcbiAgICAgIHJldC50eXBlID0gVUlOVDE2QkU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVJTlQzMjpcbiAgICAgIHJldC50eXBlID0gVUlOVDMyQkU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZHN0IHR5cGUgdW5yZWNvZ25pemVkOiBcIiR7dHlwZX1cIiA6IG11c3QgaGF2ZSBmb3JtIFtjcmxmOnxsZjpddHlwZVs6YmFzZTY0XWApO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuLy8gU2VsZWN0IGFuZCBjYWxsIHRoZSByZXF1ZXN0ZWQgZW5jb2RpbmcgZnVuY3Rpb24uXG5jb25zdCBlbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUodHlwZSwgY2hhcnMpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBVVEY4OlxuICAgICAgcmV0dXJuIHRyYW5zLnV0ZjguZW5jb2RlKGNoYXJzKTtcbiAgICBjYXNlIFVURjE2QkU6XG4gICAgICByZXR1cm4gdHJhbnMudXRmMTZiZS5lbmNvZGUoY2hhcnMpO1xuICAgIGNhc2UgVVRGMTZMRTpcbiAgICAgIHJldHVybiB0cmFucy51dGYxNmxlLmVuY29kZShjaGFycyk7XG4gICAgY2FzZSBVVEYzMkJFOlxuICAgICAgcmV0dXJuIHRyYW5zLnV0ZjMyYmUuZW5jb2RlKGNoYXJzKTtcbiAgICBjYXNlIFVURjMyTEU6XG4gICAgICByZXR1cm4gdHJhbnMudXRmMzJsZS5lbmNvZGUoY2hhcnMpO1xuICAgIGNhc2UgVUlOVDc6XG4gICAgICByZXR1cm4gdHJhbnMudWludDcuZW5jb2RlKGNoYXJzKTtcbiAgICBjYXNlIFVJTlQ4OlxuICAgICAgcmV0dXJuIHRyYW5zLnVpbnQ4LmVuY29kZShjaGFycyk7XG4gICAgY2FzZSBVSU5UMTZCRTpcbiAgICAgIHJldHVybiB0cmFucy51aW50MTZiZS5lbmNvZGUoY2hhcnMpO1xuICAgIGNhc2UgVUlOVDE2TEU6XG4gICAgICByZXR1cm4gdHJhbnMudWludDE2bGUuZW5jb2RlKGNoYXJzKTtcbiAgICBjYXNlIFVJTlQzMkJFOlxuICAgICAgcmV0dXJuIHRyYW5zLnVpbnQzMmJlLmVuY29kZShjaGFycyk7XG4gICAgY2FzZSBVSU5UMzJMRTpcbiAgICAgIHJldHVybiB0cmFucy51aW50MzJsZS5lbmNvZGUoY2hhcnMpO1xuICAgIGNhc2UgU1RSSU5HOlxuICAgICAgcmV0dXJuIHRyYW5zLnN0cmluZy5lbmNvZGUoY2hhcnMpO1xuICAgIGNhc2UgRVNDQVBFRDpcbiAgICAgIHJldHVybiB0cmFucy5lc2NhcGVkLmVuY29kZShjaGFycyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGVuY29kZSB0eXBlIFwiJHt0eXBlfVwiIG5vdCByZWNvZ25pemVkYCk7XG4gIH1cbn07XG4vLyBTZWxlY3QgYW5kIGNhbGwgdGhlIHJlcXVlc3RlZCBkZWNvZGluZyBmdW5jdGlvbi5cbi8vIGBzcmNgIGNvbnRhaW5zIEJPTSBpbmZvcm1hdGlvbiBhcyB3ZWxsIGFzIHRoZSBzb3VyY2UgdHlwZSBhbmQgZGF0YS5cbmNvbnN0IGRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShzcmMpIHtcbiAgc3dpdGNoIChzcmMudHlwZSkge1xuICAgIGNhc2UgVVRGODpcbiAgICAgIHJldHVybiB0cmFucy51dGY4LmRlY29kZShzcmMuZGF0YSwgc3JjLmJvbSk7XG4gICAgY2FzZSBVVEYxNkxFOlxuICAgICAgcmV0dXJuIHRyYW5zLnV0ZjE2bGUuZGVjb2RlKHNyYy5kYXRhLCBzcmMuYm9tKTtcbiAgICBjYXNlIFVURjE2QkU6XG4gICAgICByZXR1cm4gdHJhbnMudXRmMTZiZS5kZWNvZGUoc3JjLmRhdGEsIHNyYy5ib20pO1xuICAgIGNhc2UgVVRGMzJCRTpcbiAgICAgIHJldHVybiB0cmFucy51dGYzMmJlLmRlY29kZShzcmMuZGF0YSwgc3JjLmJvbSk7XG4gICAgY2FzZSBVVEYzMkxFOlxuICAgICAgcmV0dXJuIHRyYW5zLnV0ZjMybGUuZGVjb2RlKHNyYy5kYXRhLCBzcmMuYm9tKTtcbiAgICBjYXNlIFVJTlQ3OlxuICAgICAgcmV0dXJuIHRyYW5zLnVpbnQ3LmRlY29kZShzcmMuZGF0YSk7XG4gICAgY2FzZSBVSU5UODpcbiAgICAgIHJldHVybiB0cmFucy51aW50OC5kZWNvZGUoc3JjLmRhdGEpO1xuICAgIGNhc2UgVUlOVDE2QkU6XG4gICAgICByZXR1cm4gdHJhbnMudWludDE2YmUuZGVjb2RlKHNyYy5kYXRhKTtcbiAgICBjYXNlIFVJTlQxNkxFOlxuICAgICAgcmV0dXJuIHRyYW5zLnVpbnQxNmxlLmRlY29kZShzcmMuZGF0YSk7XG4gICAgY2FzZSBVSU5UMzJCRTpcbiAgICAgIHJldHVybiB0cmFucy51aW50MzJiZS5kZWNvZGUoc3JjLmRhdGEpO1xuICAgIGNhc2UgVUlOVDMyTEU6XG4gICAgICByZXR1cm4gdHJhbnMudWludDMybGUuZGVjb2RlKHNyYy5kYXRhKTtcbiAgICBjYXNlIFNUUklORzpcbiAgICAgIHJldHVybiB0cmFucy5zdHJpbmcuZGVjb2RlKHNyYy5kYXRhKTtcbiAgICBjYXNlIEVTQ0FQRUQ6XG4gICAgICByZXR1cm4gdHJhbnMuZXNjYXBlZC5kZWNvZGUoc3JjLmRhdGEpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBkZWNvZGUgdHlwZSBcIiR7c3JjLnR5cGV9XCIgbm90IHJlY29nbml6ZWRgKTtcbiAgfVxufTtcblxuLy8gVGhlIHB1YmxpYyBkZWNvZGluZyBmdW5jdGlvbi4gUmV0dXJucyBhbiBhcnJheSBvZiBpbnRlZ2Vycy5cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gZXhwb3J0c0RlY29kZSh0eXBlLCBkYXRhKSB7XG4gIGNvbnN0IHNyYyA9IHZhbGlkYXRlU3JjKHR5cGUsIGRhdGEpO1xuICByZXR1cm4gZGVjb2RlKHNyYyk7XG59O1xuLy8gVGhlIHB1YmxpYyBlbmNvZGluZyBmdW5jdGlvbi4gUmV0dXJucyBhIEJ1ZmZlci10eXBlZCBieXRlIGFycmF5LlxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBleHBvcnRzRW5jb2RlKHR5cGUsIGNoYXJzKSB7XG4gIGxldCBjO1xuICBsZXQgYnVmO1xuICBjb25zdCBkc3QgPSB2YWxpZGF0ZURzdCh0eXBlLCBjaGFycyk7XG4gIGlmIChkc3QuY3JsZikge1xuICAgIC8qIHByZWZpeCB3aXRoIENSTEYgbGluZSBlbmQgY29udmVyc2lvbiwgZG9uJ3QgY29udGFtaW5hdGUgY2FsbGVyJ3MgY2hhcnMgYXJyYXkgKi9cbiAgICBjID0gdHJhbnMubGluZUVuZHMuY3JsZihjaGFycyk7XG4gICAgYnVmID0gZW5jb2RlKGRzdC50eXBlLCBjKTtcbiAgfSBlbHNlIGlmIChkc3QubGYpIHtcbiAgICAvKiBwcmVmaXggd2l0aCBMRiBsaW5lIGVuZCBjb252ZXJzaW9uLCBkb24ndCBjb250YW1pbmF0ZSBjYWxsZXIncyBjaGFycyBhcnJheSAqL1xuICAgIGMgPSB0cmFucy5saW5lRW5kcy5sZihjaGFycyk7XG4gICAgYnVmID0gZW5jb2RlKGRzdC50eXBlLCBjKTtcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBlbmNvZGUoZHN0LnR5cGUsIGNoYXJzKTtcbiAgfVxuICBpZiAoZHN0LmJhc2U2NCkge1xuICAgIC8qIHBvc3QgYmFzZSA2NCBlbmNvZGluZyAqL1xuICAgIGJ1ZiA9IHRyYW5zLmJhc2U2NC5lbmNvZGUoYnVmKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufTtcbi8vIENvbnZlcnRzIGRhdGEgb2YgdHlwZSBgc3JjVHlwZWAgdG8gZGF0YSBvZiB0eXBlIGBkc3RUeXBlYC5cbi8vIGBzcmNEYXRhYCBtYXkgYmUgYSBKYXZhU2NyaXB0IFN0cmluZywgb3Igbm9kZS5qcyBCdWZmZXIsIGRlcGVuZGluZyBvbiB0aGUgY29ycmVzcG9uZGluZyB0eXBlLlxuZXhwb3J0cy5jb252ZXJ0ID0gZnVuY3Rpb24gY29udmVydChzcmNUeXBlLCBzcmNEYXRhLCBkc3RUeXBlKSB7XG4gIHJldHVybiB0aGlzVGhpcy5lbmNvZGUoZHN0VHlwZSwgdGhpc1RoaXMuZGVjb2RlKHNyY1R5cGUsIHNyY0RhdGEpKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-conv-api/converter.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-conv-api/transformers.js":
/*!**************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-conv-api/transformers.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* eslint-disable prefer-destructuring */\n/* eslint-disable no-plusplus */\n/* eslint-disable no-bitwise */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module contains the actual encoding and decoding algorithms.\n// Throws \"RangeError\" exceptions on characters or bytes out of range for the given encoding.\n\n'use strict;';\n\nconst thisThis = this;\n\n/* decoding error codes */\nconst NON_SHORTEST = 0xfffffffc;\nconst TRAILING = 0xfffffffd;\nconst RANGE = 0xfffffffe;\nconst ILL_FORMED = 0xffffffff;\n\n/* mask[n] = 2**n - 1, ie. mask[n] = n bits on. e.g. mask[6] = %b111111 */\nconst mask = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023];\n\n/* ascii[n] = 'HH', where 0xHH = n, eg. ascii[254] = 'FE' */\nconst ascii = [\n  '00',\n  '01',\n  '02',\n  '03',\n  '04',\n  '05',\n  '06',\n  '07',\n  '08',\n  '09',\n  '0A',\n  '0B',\n  '0C',\n  '0D',\n  '0E',\n  '0F',\n  '10',\n  '11',\n  '12',\n  '13',\n  '14',\n  '15',\n  '16',\n  '17',\n  '18',\n  '19',\n  '1A',\n  '1B',\n  '1C',\n  '1D',\n  '1E',\n  '1F',\n  '20',\n  '21',\n  '22',\n  '23',\n  '24',\n  '25',\n  '26',\n  '27',\n  '28',\n  '29',\n  '2A',\n  '2B',\n  '2C',\n  '2D',\n  '2E',\n  '2F',\n  '30',\n  '31',\n  '32',\n  '33',\n  '34',\n  '35',\n  '36',\n  '37',\n  '38',\n  '39',\n  '3A',\n  '3B',\n  '3C',\n  '3D',\n  '3E',\n  '3F',\n  '40',\n  '41',\n  '42',\n  '43',\n  '44',\n  '45',\n  '46',\n  '47',\n  '48',\n  '49',\n  '4A',\n  '4B',\n  '4C',\n  '4D',\n  '4E',\n  '4F',\n  '50',\n  '51',\n  '52',\n  '53',\n  '54',\n  '55',\n  '56',\n  '57',\n  '58',\n  '59',\n  '5A',\n  '5B',\n  '5C',\n  '5D',\n  '5E',\n  '5F',\n  '60',\n  '61',\n  '62',\n  '63',\n  '64',\n  '65',\n  '66',\n  '67',\n  '68',\n  '69',\n  '6A',\n  '6B',\n  '6C',\n  '6D',\n  '6E',\n  '6F',\n  '70',\n  '71',\n  '72',\n  '73',\n  '74',\n  '75',\n  '76',\n  '77',\n  '78',\n  '79',\n  '7A',\n  '7B',\n  '7C',\n  '7D',\n  '7E',\n  '7F',\n  '80',\n  '81',\n  '82',\n  '83',\n  '84',\n  '85',\n  '86',\n  '87',\n  '88',\n  '89',\n  '8A',\n  '8B',\n  '8C',\n  '8D',\n  '8E',\n  '8F',\n  '90',\n  '91',\n  '92',\n  '93',\n  '94',\n  '95',\n  '96',\n  '97',\n  '98',\n  '99',\n  '9A',\n  '9B',\n  '9C',\n  '9D',\n  '9E',\n  '9F',\n  'A0',\n  'A1',\n  'A2',\n  'A3',\n  'A4',\n  'A5',\n  'A6',\n  'A7',\n  'A8',\n  'A9',\n  'AA',\n  'AB',\n  'AC',\n  'AD',\n  'AE',\n  'AF',\n  'B0',\n  'B1',\n  'B2',\n  'B3',\n  'B4',\n  'B5',\n  'B6',\n  'B7',\n  'B8',\n  'B9',\n  'BA',\n  'BB',\n  'BC',\n  'BD',\n  'BE',\n  'BF',\n  'C0',\n  'C1',\n  'C2',\n  'C3',\n  'C4',\n  'C5',\n  'C6',\n  'C7',\n  'C8',\n  'C9',\n  'CA',\n  'CB',\n  'CC',\n  'CD',\n  'CE',\n  'CF',\n  'D0',\n  'D1',\n  'D2',\n  'D3',\n  'D4',\n  'D5',\n  'D6',\n  'D7',\n  'D8',\n  'D9',\n  'DA',\n  'DB',\n  'DC',\n  'DD',\n  'DE',\n  'DF',\n  'E0',\n  'E1',\n  'E2',\n  'E3',\n  'E4',\n  'E5',\n  'E6',\n  'E7',\n  'E8',\n  'E9',\n  'EA',\n  'EB',\n  'EC',\n  'ED',\n  'EE',\n  'EF',\n  'F0',\n  'F1',\n  'F2',\n  'F3',\n  'F4',\n  'F5',\n  'F6',\n  'F7',\n  'F8',\n  'F9',\n  'FA',\n  'FB',\n  'FC',\n  'FD',\n  'FE',\n  'FF',\n];\n\n/* vector of base 64 characters */\nconst base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split('');\n\n/* vector of base 64 character codes */\nconst base64codes = [];\nbase64chars.forEach((char) => {\n  base64codes.push(char.charCodeAt(0));\n});\n\n// The UTF8 algorithms.\nexports.utf8 = {\n  encode(chars) {\n    const bytes = [];\n    chars.forEach((char) => {\n      if (char >= 0 && char <= 0x7f) {\n        bytes.push(char);\n      } else if (char <= 0x7ff) {\n        bytes.push(0xc0 + ((char >> 6) & mask[5]));\n        bytes.push(0x80 + (char & mask[6]));\n      } else if (char < 0xd800 || (char > 0xdfff && char <= 0xffff)) {\n        bytes.push(0xe0 + ((char >> 12) & mask[4]));\n        bytes.push(0x80 + ((char >> 6) & mask[6]));\n        bytes.push(0x80 + (char & mask[6]));\n      } else if (char >= 0x10000 && char <= 0x10ffff) {\n        const u = (char >> 16) & mask[5];\n        bytes.push(0xf0 + (u >> 2));\n        bytes.push(0x80 + ((u & mask[2]) << 4) + ((char >> 12) & mask[4]));\n        bytes.push(0x80 + ((char >> 6) & mask[6]));\n        bytes.push(0x80 + (char & mask[6]));\n      } else {\n        throw new RangeError(`utf8.encode: character out of range: char: ${char}`);\n      }\n    });\n    return Buffer.from(bytes);\n  },\n  decode(buf, bom) {\n    /* bytes functions return error for non-shortest forms & values out of range */\n    function bytes2(b1, b2) {\n      /* U+0080..U+07FF */\n      /* 00000000 00000yyy yyxxxxxx | 110yyyyy 10xxxxxx */\n      if ((b2 & 0xc0) !== 0x80) {\n        return TRAILING;\n      }\n      const x = ((b1 & mask[5]) << 6) + (b2 & mask[6]);\n      if (x < 0x80) {\n        return NON_SHORTEST;\n      }\n      return x;\n    }\n    function bytes3(b1, b2, b3) {\n      /* U+0800..U+FFFF */\n      /* 00000000 zzzzyyyy yyxxxxxx | 1110zzzz 10yyyyyy 10xxxxxx */\n      if ((b3 & 0xc0) !== 0x80 || (b2 & 0xc0) !== 0x80) {\n        return TRAILING;\n      }\n      const x = ((b1 & mask[4]) << 12) + ((b2 & mask[6]) << 6) + (b3 & mask[6]);\n      if (x < 0x800) {\n        return NON_SHORTEST;\n      }\n      if (x >= 0xd800 && x <= 0xdfff) {\n        return RANGE;\n      }\n      return x;\n    }\n    function bytes4(b1, b2, b3, b4) {\n      /* U+10000..U+10FFFF */\n      /* 000uuuuu zzzzyyyy yyxxxxxx | 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx */\n      if ((b4 & 0xc0) !== 0x80 || (b3 & 0xc0) !== 0x80 || (b2 & 0xc0) !== 0x80) {\n        return TRAILING;\n      }\n      const x =\n        ((((b1 & mask[3]) << 2) + ((b2 >> 4) & mask[2])) << 16) +\n        ((b2 & mask[4]) << 12) +\n        ((b3 & mask[6]) << 6) +\n        (b4 & mask[6]);\n      if (x < 0x10000) {\n        return NON_SHORTEST;\n      }\n      if (x > 0x10ffff) {\n        return RANGE;\n      }\n      return x;\n    }\n    let c;\n    let b1;\n    let i1;\n    let i2;\n    let i3;\n    let inc;\n    const len = buf.length;\n    let i = bom ? 3 : 0;\n    const chars = [];\n    while (i < len) {\n      b1 = buf[i];\n      c = ILL_FORMED;\n      const TRUE = true;\n      while (TRUE) {\n        if (b1 >= 0 && b1 <= 0x7f) {\n          /* U+0000..U+007F 00..7F */\n          c = b1;\n          inc = 1;\n          break;\n        }\n        i1 = i + 1;\n        if (i1 < len && b1 >= 0xc2 && b1 <= 0xdf) {\n          /* U+0080..U+07FF C2..DF 80..BF */\n          c = bytes2(b1, buf[i1]);\n          inc = 2;\n          break;\n        }\n        i2 = i + 2;\n        if (i2 < len && b1 >= 0xe0 && b1 <= 0xef) {\n          /* U+0800..U+FFFF */\n          c = bytes3(b1, buf[i1], buf[i2]);\n          inc = 3;\n          break;\n        }\n        i3 = i + 3;\n        if (i3 < len && b1 >= 0xf0 && b1 <= 0xf4) {\n          /* U+10000..U+10FFFF */\n          c = bytes4(b1, buf[i1], buf[i2], buf[i3]);\n          inc = 4;\n          break;\n        }\n        /* if we fall through to here, it is an ill-formed sequence */\n        break;\n      }\n      if (c > 0x10ffff) {\n        const at = `byte[${i}]`;\n        if (c === ILL_FORMED) {\n          throw new RangeError(`utf8.decode: ill-formed UTF8 byte sequence found at: ${at}`);\n        }\n        if (c === TRAILING) {\n          throw new RangeError(`utf8.decode: illegal trailing byte found at: ${at}`);\n        }\n        if (c === RANGE) {\n          throw new RangeError(`utf8.decode: code point out of range found at: ${at}`);\n        }\n        if (c === NON_SHORTEST) {\n          throw new RangeError(`utf8.decode: non-shortest form found at: ${at}`);\n        }\n        throw new RangeError(`utf8.decode: unrecognized error found at: ${at}`);\n      }\n      chars.push(c);\n      i += inc;\n    }\n    return chars;\n  },\n};\n\n// The UTF16BE algorithms.\nexports.utf16be = {\n  encode(chars) {\n    const bytes = [];\n    let char;\n    let h;\n    let l;\n    for (let i = 0; i < chars.length; i += 1) {\n      char = chars[i];\n      if ((char >= 0 && char <= 0xd7ff) || (char >= 0xe000 && char <= 0xffff)) {\n        bytes.push((char >> 8) & mask[8]);\n        bytes.push(char & mask[8]);\n      } else if (char >= 0x10000 && char <= 0x10ffff) {\n        l = char - 0x10000;\n        h = 0xd800 + (l >> 10);\n        l = 0xdc00 + (l & mask[10]);\n        bytes.push((h >> 8) & mask[8]);\n        bytes.push(h & mask[8]);\n        bytes.push((l >> 8) & mask[8]);\n        bytes.push(l & mask[8]);\n      } else {\n        throw new RangeError(`utf16be.encode: UTF16BE value out of range: char[${i}]: ${char}`);\n      }\n    }\n    return Buffer.from(bytes);\n  },\n  decode(buf, bom) {\n    /* assumes caller has insured that buf is a Buffer of bytes */\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`utf16be.decode: data length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    const len = buf.length;\n    let i = bom ? 2 : 0;\n    let j = 0;\n    let c;\n    let inc;\n    let i1;\n    let i3;\n    let high;\n    let low;\n    while (i < len) {\n      const TRUE = true;\n      while (TRUE) {\n        i1 = i + 1;\n        if (i1 < len) {\n          high = (buf[i] << 8) + buf[i1];\n          if (high < 0xd800 || high > 0xdfff) {\n            c = high;\n            inc = 2;\n            break;\n          }\n          i3 = i + 3;\n          if (i3 < len) {\n            low = (buf[i + 2] << 8) + buf[i3];\n            if (high <= 0xdbff && low >= 0xdc00 && low <= 0xdfff) {\n              c = 0x10000 + ((high - 0xd800) << 10) + (low - 0xdc00);\n              inc = 4;\n              break;\n            }\n          }\n        }\n        /* if we fall through to here, it is an ill-formed sequence */\n        throw new RangeError(`utf16be.decode: ill-formed UTF16BE byte sequence found: byte[${i}]`);\n      }\n      chars[j++] = c;\n      i += inc;\n    }\n    return chars;\n  },\n};\n\n// The UTF16LE algorithms.\nexports.utf16le = {\n  encode(chars) {\n    const bytes = [];\n    let char;\n    let h;\n    let l;\n    for (let i = 0; i < chars.length; i += 1) {\n      char = chars[i];\n      if ((char >= 0 && char <= 0xd7ff) || (char >= 0xe000 && char <= 0xffff)) {\n        bytes.push(char & mask[8]);\n        bytes.push((char >> 8) & mask[8]);\n      } else if (char >= 0x10000 && char <= 0x10ffff) {\n        l = char - 0x10000;\n        h = 0xd800 + (l >> 10);\n        l = 0xdc00 + (l & mask[10]);\n        bytes.push(h & mask[8]);\n        bytes.push((h >> 8) & mask[8]);\n        bytes.push(l & mask[8]);\n        bytes.push((l >> 8) & mask[8]);\n      } else {\n        throw new RangeError(`utf16le.encode: UTF16LE value out of range: char[${i}]: ${char}`);\n      }\n    }\n    return Buffer.from(bytes);\n  },\n  decode(buf, bom) {\n    /* assumes caller has insured that buf is a Buffer of bytes */\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`utf16le.decode: data length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    const len = buf.length;\n    let i = bom ? 2 : 0;\n    let j = 0;\n    let c;\n    let inc;\n    let i1;\n    let i3;\n    let high;\n    let low;\n    while (i < len) {\n      const TRUE = true;\n      while (TRUE) {\n        i1 = i + 1;\n        if (i1 < len) {\n          high = (buf[i1] << 8) + buf[i];\n          if (high < 0xd800 || high > 0xdfff) {\n            c = high;\n            inc = 2;\n            break;\n          }\n          i3 = i + 3;\n          if (i3 < len) {\n            low = (buf[i3] << 8) + buf[i + 2];\n            if (high <= 0xdbff && low >= 0xdc00 && low <= 0xdfff) {\n              c = 0x10000 + ((high - 0xd800) << 10) + (low - 0xdc00);\n              inc = 4;\n              break;\n            }\n          }\n        }\n        /* if we fall through to here, it is an ill-formed sequence */\n        throw new RangeError(`utf16le.decode: ill-formed UTF16LE byte sequence found: byte[${i}]`);\n      }\n      chars[j++] = c;\n      i += inc;\n    }\n    return chars;\n  },\n};\n\n// The UTF32BE algorithms.\nexports.utf32be = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32be.encode: UTF32BE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      buf[i++] = (char >> 24) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = char & mask[8];\n    });\n    return buf;\n  },\n  decode(buf, bom) {\n    /* caller to insure buf is a Buffer of bytes */\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`utf32be.decode: UTF32BE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    let i = bom ? 4 : 0;\n    for (; i < buf.length; i += 4) {\n      const char = (buf[i] << 24) + (buf[i + 1] << 16) + (buf[i + 2] << 8) + buf[i + 3];\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32be.decode: UTF32BE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      chars.push(char);\n    }\n    return chars;\n  },\n};\n\n// The UTF32LE algorithms.\nexports.utf32le = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      buf[i++] = char & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 24) & mask[8];\n    });\n    return buf;\n  },\n  decode(buf, bom) {\n    /* caller to insure buf is a Buffer of bytes */\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`utf32be.decode: UTF32LE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    let i = bom ? 4 : 0;\n    for (; i < buf.length; i += 4) {\n      const char = (buf[i + 3] << 24) + (buf[i + 2] << 16) + (buf[i + 1] << 8) + buf[i];\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      chars.push(char);\n    }\n    return chars;\n  },\n};\n\n// The UINT7 algorithms. ASCII or 7-bit unsigned integers.\nexports.uint7 = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length);\n    for (let i = 0; i < chars.length; i += 1) {\n      if (chars[i] > 0x7f) {\n        throw new RangeError(`uint7.encode: UINT7 character code out of range: char[${i}]: ${chars[i]}`);\n      }\n      buf[i] = chars[i];\n    }\n    return buf;\n  },\n  decode(buf) {\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 1) {\n      if (buf[i] > 0x7f) {\n        throw new RangeError(`uint7.decode: UINT7 character code out of range: byte[${i}]: ${buf[i]}`);\n      }\n      chars[i] = buf[i];\n    }\n    return chars;\n  },\n};\n\n// The UINT8 algorithms. BINARY, Latin 1 or 8-bit unsigned integers.\nexports.uint8 = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length);\n    for (let i = 0; i < chars.length; i += 1) {\n      if (chars[i] > 0xff) {\n        throw new RangeError(`uint8.encode: UINT8 character code out of range: char[${i}]: ${chars[i]}`);\n      }\n      buf[i] = chars[i];\n    }\n    return buf;\n  },\n  decode(buf) {\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 1) {\n      chars[i] = buf[i];\n    }\n    return chars;\n  },\n};\n\n// The UINT16BE algorithms. Big-endian 16-bit unsigned integers.\nexports.uint16be = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 2);\n    let i = 0;\n    chars.forEach((char) => {\n      if (char > 0xffff) {\n        throw new RangeError(`uint16be.encode: UINT16BE character code out of range: char[${i / 2}]: ${char}`);\n      }\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = char & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`uint16be.decode: UINT16BE byte length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 2) {\n      chars.push((buf[i] << 8) + buf[i + 1]);\n    }\n    return chars;\n  },\n};\n\n// The UINT16LE algorithms. Little-endian 16-bit unsigned integers.\nexports.uint16le = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 2);\n    let i = 0;\n    chars.forEach((char) => {\n      if (char > 0xffff) {\n        throw new RangeError(`uint16le.encode: UINT16LE character code out of range: char[${i / 2}]: ${char}`);\n      }\n      buf[i++] = char & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`uint16le.decode: UINT16LE byte length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 2) {\n      chars.push((buf[i + 1] << 8) + buf[i]);\n    }\n    return chars;\n  },\n};\n\n// The UINT32BE algorithms. Big-endian 32-bit unsigned integers.\nexports.uint32be = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      buf[i++] = (char >> 24) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = char & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`uint32be.decode: UINT32BE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 4) {\n      chars.push((buf[i] << 24) + (buf[i + 1] << 16) + (buf[i + 2] << 8) + buf[i + 3]);\n    }\n    return chars;\n  },\n};\n\n// The UINT32LE algorithms. Little-endian 32-bit unsigned integers.\nexports.uint32le = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      buf[i++] = char & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 24) & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    /* caller to insure buf is a Buffer of bytes */\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`uint32le.decode: UINT32LE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 4) {\n      chars.push((buf[i + 3] << 24) + (buf[i + 2] << 16) + (buf[i + 1] << 8) + buf[i]);\n    }\n    return chars;\n  },\n};\n\n// The STRING algorithms. Converts JavaScript strings to Array of 32-bit integers and vice versa.\n// Uses the node.js Buffer's native \"utf16le\" capabilites.\nexports.string = {\n  encode(chars) {\n    return thisThis.utf16le.encode(chars).toString('utf16le');\n  },\n  decode(str) {\n    return thisThis.utf16le.decode(Buffer.from(str, 'utf16le'), 0);\n  },\n};\n\n// The ESCAPED algorithms.\n// Note that ESCAPED format contains only ASCII characters.\n// The characters are always in the form of a Buffer of bytes.\nexports.escaped = {\n  // Encodes an Array of 32-bit integers into ESCAPED format.\n  encode(chars) {\n    const bytes = [];\n    for (let i = 0; i < chars.length; i += 1) {\n      const char = chars[i];\n      if (char === 96) {\n        bytes.push(char);\n        bytes.push(char);\n      } else if (char === 10) {\n        bytes.push(char);\n      } else if (char >= 32 && char <= 126) {\n        bytes.push(char);\n      } else {\n        let str = '';\n        if (char >= 0 && char <= 31) {\n          str += `\\`x${ascii[char]}`;\n        } else if (char >= 127 && char <= 255) {\n          str += `\\`x${ascii[char]}`;\n        } else if (char >= 0x100 && char <= 0xffff) {\n          str += `\\`u${ascii[(char >> 8) & mask[8]]}${ascii[char & mask[8]]}`;\n        } else if (char >= 0x10000 && char <= 0xffffffff) {\n          str += '`u{';\n          const digit = (char >> 24) & mask[8];\n          if (digit > 0) {\n            str += ascii[digit];\n          }\n          str += `${ascii[(char >> 16) & mask[8]] + ascii[(char >> 8) & mask[8]] + ascii[char & mask[8]]}}`;\n        } else {\n          throw new Error('escape.encode(char): char > 0xffffffff not allowed');\n        }\n        const buf = Buffer.from(str);\n        buf.forEach((b) => {\n          bytes.push(b);\n        });\n      }\n    }\n    return Buffer.from(bytes);\n  },\n  // Decodes ESCAPED format from a Buffer of bytes to an Array of 32-bit integers.\n  decode(buf) {\n    function isHex(hex) {\n      if ((hex >= 48 && hex <= 57) || (hex >= 65 && hex <= 70) || (hex >= 97 && hex <= 102)) {\n        return true;\n      }\n      return false;\n    }\n    function getx(i, len, bufArg) {\n      const ret = { char: null, nexti: i + 2, error: true };\n      if (i + 1 < len) {\n        if (isHex(bufArg[i]) && isHex(bufArg[i + 1])) {\n          const str = String.fromCodePoint(bufArg[i], bufArg[i + 1]);\n          ret.char = parseInt(str, 16);\n          if (!Number.isNaN(ret.char)) {\n            ret.error = false;\n          }\n        }\n      }\n      return ret;\n    }\n    function getu(i, len, bufArg) {\n      const ret = { char: null, nexti: i + 4, error: true };\n      if (i + 3 < len) {\n        if (isHex(bufArg[i]) && isHex(bufArg[i + 1]) && isHex(bufArg[i + 2]) && isHex(bufArg[i + 3])) {\n          const str = String.fromCodePoint(bufArg[i], bufArg[i + 1], bufArg[i + 2], bufArg[i + 3]);\n          ret.char = parseInt(str, 16);\n          if (!Number.isNaN(ret.char)) {\n            ret.error = false;\n          }\n        }\n      }\n      return ret;\n    }\n    function getU(i, len, bufArg) {\n      const ret = { char: null, nexti: i + 4, error: true };\n      let str = '';\n      while (i < len && isHex(bufArg[i])) {\n        str += String.fromCodePoint(bufArg[i]);\n        // eslint-disable-next-line no-param-reassign\n        i += 1;\n      }\n      ret.char = parseInt(str, 16);\n      if (bufArg[i] === 125 && !Number.isNaN(ret.char)) {\n        ret.error = false;\n      }\n      ret.nexti = i + 1;\n      return ret;\n    }\n    const chars = [];\n    const len = buf.length;\n    let i1;\n    let ret;\n    let error;\n    let i = 0;\n    while (i < len) {\n      const TRUE = true;\n      while (TRUE) {\n        error = true;\n        if (buf[i] !== 96) {\n          /* unescaped character */\n          chars.push(buf[i]);\n          i += 1;\n          error = false;\n          break;\n        }\n        i1 = i + 1;\n        if (i1 >= len) {\n          break;\n        }\n        if (buf[i1] === 96) {\n          /* escaped grave accent */\n          chars.push(96);\n          i += 2;\n          error = false;\n          break;\n        }\n        if (buf[i1] === 120) {\n          ret = getx(i1 + 1, len, buf);\n          if (ret.error) {\n            break;\n          }\n          /* escaped hex */\n          chars.push(ret.char);\n          i = ret.nexti;\n          error = false;\n          break;\n        }\n        if (buf[i1] === 117) {\n          if (buf[i1 + 1] === 123) {\n            ret = getU(i1 + 2, len, buf);\n            if (ret.error) {\n              break;\n            }\n            /* escaped utf-32 */\n            chars.push(ret.char);\n            i = ret.nexti;\n            error = false;\n            break;\n          }\n          ret = getu(i1 + 1, len, buf);\n          if (ret.error) {\n            break;\n          }\n          /* escaped utf-16 */\n          chars.push(ret.char);\n          i = ret.nexti;\n          error = false;\n          break;\n        }\n        break;\n      }\n      if (error) {\n        throw new Error(`escaped.decode: ill-formed escape sequence at buf[${i}]`);\n      }\n    }\n    return chars;\n  },\n};\n\n// The line end conversion algorigthms.\nconst CR = 13;\nconst LF = 10;\nexports.lineEnds = {\n  crlf(chars) {\n    const lfchars = [];\n    let i = 0;\n    while (i < chars.length) {\n      switch (chars[i]) {\n        case CR:\n          if (i + 1 < chars.length && chars[i + 1] === LF) {\n            i += 2;\n          } else {\n            i += 1;\n          }\n          lfchars.push(CR);\n          lfchars.push(LF);\n          break;\n        case LF:\n          lfchars.push(CR);\n          lfchars.push(LF);\n          i += 1;\n          break;\n        default:\n          lfchars.push(chars[i]);\n          i += 1;\n          break;\n      }\n    }\n    if (lfchars.length > 0 && lfchars[lfchars.length - 1] !== LF) {\n      lfchars.push(CR);\n      lfchars.push(LF);\n    }\n    return lfchars;\n  },\n  lf(chars) {\n    const lfchars = [];\n    let i = 0;\n    while (i < chars.length) {\n      switch (chars[i]) {\n        case CR:\n          if (i + 1 < chars.length && chars[i + 1] === LF) {\n            i += 2;\n          } else {\n            i += 1;\n          }\n          lfchars.push(LF);\n          break;\n        case LF:\n          lfchars.push(LF);\n          i += 1;\n          break;\n        default:\n          lfchars.push(chars[i]);\n          i += 1;\n          break;\n      }\n    }\n    if (lfchars.length > 0 && lfchars[lfchars.length - 1] !== LF) {\n      lfchars.push(LF);\n    }\n    return lfchars;\n  },\n};\n\n// The base 64 algorithms.\nexports.base64 = {\n  encode(buf) {\n    if (buf.length === 0) {\n      return Buffer.alloc(0);\n    }\n    let i;\n    let j;\n    let n;\n    let tail = buf.length % 3;\n    tail = tail > 0 ? 3 - tail : 0;\n    let units = (buf.length + tail) / 3;\n    const base64 = Buffer.alloc(units * 4);\n    if (tail > 0) {\n      units -= 1;\n    }\n    i = 0;\n    j = 0;\n    for (let u = 0; u < units; u += 1) {\n      n = buf[i++] << 16;\n      n += buf[i++] << 8;\n      n += buf[i++];\n      base64[j++] = base64codes[(n >> 18) & mask[6]];\n      base64[j++] = base64codes[(n >> 12) & mask[6]];\n      base64[j++] = base64codes[(n >> 6) & mask[6]];\n      base64[j++] = base64codes[n & mask[6]];\n    }\n    if (tail === 0) {\n      return base64;\n    }\n    if (tail === 1) {\n      n = buf[i++] << 16;\n      n += buf[i] << 8;\n      base64[j++] = base64codes[(n >> 18) & mask[6]];\n      base64[j++] = base64codes[(n >> 12) & mask[6]];\n      base64[j++] = base64codes[(n >> 6) & mask[6]];\n      base64[j] = base64codes[64];\n      return base64;\n    }\n    if (tail === 2) {\n      n = buf[i] << 16;\n      base64[j++] = base64codes[(n >> 18) & mask[6]];\n      base64[j++] = base64codes[(n >> 12) & mask[6]];\n      base64[j++] = base64codes[64];\n      base64[j] = base64codes[64];\n      return base64;\n    }\n    return undefined;\n  },\n  decode(codes) {\n    /* remove white space and ctrl characters, validate & translate characters */\n    function validate(buf) {\n      const chars = [];\n      let tail = 0;\n      for (let i = 0; i < buf.length; i += 1) {\n        const char = buf[i];\n        const TRUE = true;\n        while (TRUE) {\n          if (char === 32 || char === 9 || char === 10 || char === 13) {\n            break;\n          }\n          if (char >= 65 && char <= 90) {\n            chars.push(char - 65);\n            break;\n          }\n          if (char >= 97 && char <= 122) {\n            chars.push(char - 71);\n            break;\n          }\n          if (char >= 48 && char <= 57) {\n            chars.push(char + 4);\n            break;\n          }\n          if (char === 43) {\n            chars.push(62);\n            break;\n          }\n          if (char === 47) {\n            chars.push(63);\n            break;\n          }\n          if (char === 61) {\n            chars.push(64);\n            tail += 1;\n            break;\n          }\n          /* invalid character */\n          throw new RangeError(`base64.decode: invalid character buf[${i}]: ${char}`);\n        }\n      }\n      /* validate length */\n      if (chars.length % 4 > 0) {\n        throw new RangeError(`base64.decode: string length not integral multiple of 4: ${chars.length}`);\n      }\n      /* validate tail */\n      switch (tail) {\n        case 0:\n          break;\n        case 1:\n          if (chars[chars.length - 1] !== 64) {\n            throw new RangeError('base64.decode: one tail character found: not last character');\n          }\n          break;\n        case 2:\n          if (chars[chars.length - 1] !== 64 || chars[chars.length - 2] !== 64) {\n            throw new RangeError('base64.decode: two tail characters found: not last characters');\n          }\n          break;\n        default:\n          throw new RangeError(`base64.decode: more than two tail characters found: ${tail}`);\n      }\n      return { tail, buf: Buffer.from(chars) };\n    }\n\n    if (codes.length === 0) {\n      return Buffer.alloc(0);\n    }\n    const val = validate(codes);\n    const { tail } = val;\n    const base64 = val.buf;\n    let i;\n    let j;\n    let n;\n    let units = base64.length / 4;\n    const buf = Buffer.alloc(units * 3 - tail);\n    if (tail > 0) {\n      units -= 1;\n    }\n    j = 0;\n    i = 0;\n    for (let u = 0; u < units; u += 1) {\n      n = base64[i++] << 18;\n      n += base64[i++] << 12;\n      n += base64[i++] << 6;\n      n += base64[i++];\n      buf[j++] = (n >> 16) & mask[8];\n      buf[j++] = (n >> 8) & mask[8];\n      buf[j++] = n & mask[8];\n    }\n    if (tail === 1) {\n      n = base64[i++] << 18;\n      n += base64[i++] << 12;\n      n += base64[i] << 6;\n      buf[j++] = (n >> 16) & mask[8];\n      buf[j] = (n >> 8) & mask[8];\n    }\n    if (tail === 2) {\n      n = base64[i++] << 18;\n      n += base64[i++] << 12;\n      buf[j] = (n >> 16) & mask[8];\n    }\n    return buf;\n  },\n  // Converts a base 64 Buffer of bytes to a JavaScript string with line breaks.\n  toString(buf) {\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`base64.toString: input buffer length not multiple of 4: ${buf.length}`);\n    }\n    let str = '';\n    let lineLen = 0;\n    function buildLine(c1, c2, c3, c4) {\n      switch (lineLen) {\n        case 76:\n          str += `\\r\\n${c1}${c2}${c3}${c4}`;\n          lineLen = 4;\n          break;\n        case 75:\n          str += `${c1}\\r\\n${c2}${c3}${c4}`;\n          lineLen = 3;\n          break;\n        case 74:\n          str += `${c1 + c2}\\r\\n${c3}${c4}`;\n          lineLen = 2;\n          break;\n        case 73:\n          str += `${c1 + c2 + c3}\\r\\n${c4}`;\n          lineLen = 1;\n          break;\n        default:\n          str += c1 + c2 + c3 + c4;\n          lineLen += 4;\n          break;\n      }\n    }\n    function validate(c) {\n      if (c >= 65 && c <= 90) {\n        return true;\n      }\n      if (c >= 97 && c <= 122) {\n        return true;\n      }\n      if (c >= 48 && c <= 57) {\n        return true;\n      }\n      if (c === 43) {\n        return true;\n      }\n      if (c === 47) {\n        return true;\n      }\n      if (c === 61) {\n        return true;\n      }\n      return false;\n    }\n    for (let i = 0; i < buf.length; i += 4) {\n      for (let j = i; j < i + 4; j += 1) {\n        if (!validate(buf[j])) {\n          throw new RangeError(`base64.toString: buf[${j}]: ${buf[j]} : not valid base64 character code`);\n        }\n      }\n      buildLine(\n        String.fromCharCode(buf[i]),\n        String.fromCharCode(buf[i + 1]),\n        String.fromCharCode(buf[i + 2]),\n        String.fromCharCode(buf[i + 3])\n      );\n    }\n    return str;\n  },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctY29udi1hcGkvdHJhbnNmb3JtZXJzLmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTs7QUFFWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDJFQUEyRSxLQUFLO0FBQ2hGO0FBQ0EsS0FBSztBQUNMLFdBQVcsTUFBTTtBQUNqQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEVBQUU7QUFDN0I7QUFDQSx1RkFBdUYsR0FBRztBQUMxRjtBQUNBO0FBQ0EsK0VBQStFLEdBQUc7QUFDbEY7QUFDQTtBQUNBLGlGQUFpRixHQUFHO0FBQ3BGO0FBQ0E7QUFDQSwyRUFBMkUsR0FBRztBQUM5RTtBQUNBLDBFQUEwRSxHQUFHO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsaUZBQWlGLEVBQUUsS0FBSyxLQUFLO0FBQzdGO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixXQUFXO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixFQUFFO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsaUZBQWlGLEVBQUUsS0FBSyxLQUFLO0FBQzdGO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixXQUFXO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixFQUFFO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsTUFBTSxLQUFLLEtBQUs7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxzR0FBc0csV0FBVztBQUNqSDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0EsMEZBQTBGLE1BQU0sS0FBSyxLQUFLO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLE1BQU0sS0FBSyxLQUFLO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHLFdBQVc7QUFDakg7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBLDBGQUEwRixNQUFNLEtBQUssS0FBSztBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQSxzRkFBc0YsRUFBRSxLQUFLLFNBQVM7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQSxzRkFBc0YsRUFBRSxLQUFLLE9BQU87QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QixvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0Esc0ZBQXNGLEVBQUUsS0FBSyxTQUFTO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixNQUFNLEtBQUssS0FBSztBQUM1RztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdHQUF3RyxXQUFXO0FBQ25IO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixNQUFNLEtBQUssS0FBSztBQUM1RztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdHQUF3RyxXQUFXO0FBQ25IO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esd0dBQXdHLFdBQVc7QUFDbkg7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RyxXQUFXO0FBQ25IO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxtQ0FBbUMsTUFBTTtBQUN6QyxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DLFVBQVU7QUFDVix1QkFBdUIsWUFBWTtBQUNuQyxVQUFVO0FBQ1YsdUJBQXVCLDZCQUE2QixFQUFFLHNCQUFzQjtBQUM1RSxVQUFVO0FBQ1YscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNGQUFzRjtBQUMxRyxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxFQUFFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsRUFBRSxLQUFLLEtBQUs7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsYUFBYTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixLQUFLO0FBQzNGO0FBQ0EsZUFBZSxXQUFXLE1BQU07QUFDaEM7O0FBRUE7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsV0FBVztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsR0FBRyxNQUFNLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxNQUFNLEdBQUcsRUFBRSxHQUFHO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhLE1BQU0sR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQyxzQkFBc0IsV0FBVztBQUNqQztBQUNBLHVEQUF1RCxFQUFFLEtBQUssUUFBUTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctY29udi1hcGkvdHJhbnNmb3JtZXJzLmpzPzdiYTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWRlc3RydWN0dXJpbmcgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXBsdXNwbHVzICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4vKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSBjb250YWlucyB0aGUgYWN0dWFsIGVuY29kaW5nIGFuZCBkZWNvZGluZyBhbGdvcml0aG1zLlxuLy8gVGhyb3dzIFwiUmFuZ2VFcnJvclwiIGV4Y2VwdGlvbnMgb24gY2hhcmFjdGVycyBvciBieXRlcyBvdXQgb2YgcmFuZ2UgZm9yIHRoZSBnaXZlbiBlbmNvZGluZy5cblxuJ3VzZSBzdHJpY3Q7JztcblxuY29uc3QgdGhpc1RoaXMgPSB0aGlzO1xuXG4vKiBkZWNvZGluZyBlcnJvciBjb2RlcyAqL1xuY29uc3QgTk9OX1NIT1JURVNUID0gMHhmZmZmZmZmYztcbmNvbnN0IFRSQUlMSU5HID0gMHhmZmZmZmZmZDtcbmNvbnN0IFJBTkdFID0gMHhmZmZmZmZmZTtcbmNvbnN0IElMTF9GT1JNRUQgPSAweGZmZmZmZmZmO1xuXG4vKiBtYXNrW25dID0gMioqbiAtIDEsIGllLiBtYXNrW25dID0gbiBiaXRzIG9uLiBlLmcuIG1hc2tbNl0gPSAlYjExMTExMSAqL1xuY29uc3QgbWFzayA9IFswLCAxLCAzLCA3LCAxNSwgMzEsIDYzLCAxMjcsIDI1NSwgNTExLCAxMDIzXTtcblxuLyogYXNjaWlbbl0gPSAnSEgnLCB3aGVyZSAweEhIID0gbiwgZWcuIGFzY2lpWzI1NF0gPSAnRkUnICovXG5jb25zdCBhc2NpaSA9IFtcbiAgJzAwJyxcbiAgJzAxJyxcbiAgJzAyJyxcbiAgJzAzJyxcbiAgJzA0JyxcbiAgJzA1JyxcbiAgJzA2JyxcbiAgJzA3JyxcbiAgJzA4JyxcbiAgJzA5JyxcbiAgJzBBJyxcbiAgJzBCJyxcbiAgJzBDJyxcbiAgJzBEJyxcbiAgJzBFJyxcbiAgJzBGJyxcbiAgJzEwJyxcbiAgJzExJyxcbiAgJzEyJyxcbiAgJzEzJyxcbiAgJzE0JyxcbiAgJzE1JyxcbiAgJzE2JyxcbiAgJzE3JyxcbiAgJzE4JyxcbiAgJzE5JyxcbiAgJzFBJyxcbiAgJzFCJyxcbiAgJzFDJyxcbiAgJzFEJyxcbiAgJzFFJyxcbiAgJzFGJyxcbiAgJzIwJyxcbiAgJzIxJyxcbiAgJzIyJyxcbiAgJzIzJyxcbiAgJzI0JyxcbiAgJzI1JyxcbiAgJzI2JyxcbiAgJzI3JyxcbiAgJzI4JyxcbiAgJzI5JyxcbiAgJzJBJyxcbiAgJzJCJyxcbiAgJzJDJyxcbiAgJzJEJyxcbiAgJzJFJyxcbiAgJzJGJyxcbiAgJzMwJyxcbiAgJzMxJyxcbiAgJzMyJyxcbiAgJzMzJyxcbiAgJzM0JyxcbiAgJzM1JyxcbiAgJzM2JyxcbiAgJzM3JyxcbiAgJzM4JyxcbiAgJzM5JyxcbiAgJzNBJyxcbiAgJzNCJyxcbiAgJzNDJyxcbiAgJzNEJyxcbiAgJzNFJyxcbiAgJzNGJyxcbiAgJzQwJyxcbiAgJzQxJyxcbiAgJzQyJyxcbiAgJzQzJyxcbiAgJzQ0JyxcbiAgJzQ1JyxcbiAgJzQ2JyxcbiAgJzQ3JyxcbiAgJzQ4JyxcbiAgJzQ5JyxcbiAgJzRBJyxcbiAgJzRCJyxcbiAgJzRDJyxcbiAgJzREJyxcbiAgJzRFJyxcbiAgJzRGJyxcbiAgJzUwJyxcbiAgJzUxJyxcbiAgJzUyJyxcbiAgJzUzJyxcbiAgJzU0JyxcbiAgJzU1JyxcbiAgJzU2JyxcbiAgJzU3JyxcbiAgJzU4JyxcbiAgJzU5JyxcbiAgJzVBJyxcbiAgJzVCJyxcbiAgJzVDJyxcbiAgJzVEJyxcbiAgJzVFJyxcbiAgJzVGJyxcbiAgJzYwJyxcbiAgJzYxJyxcbiAgJzYyJyxcbiAgJzYzJyxcbiAgJzY0JyxcbiAgJzY1JyxcbiAgJzY2JyxcbiAgJzY3JyxcbiAgJzY4JyxcbiAgJzY5JyxcbiAgJzZBJyxcbiAgJzZCJyxcbiAgJzZDJyxcbiAgJzZEJyxcbiAgJzZFJyxcbiAgJzZGJyxcbiAgJzcwJyxcbiAgJzcxJyxcbiAgJzcyJyxcbiAgJzczJyxcbiAgJzc0JyxcbiAgJzc1JyxcbiAgJzc2JyxcbiAgJzc3JyxcbiAgJzc4JyxcbiAgJzc5JyxcbiAgJzdBJyxcbiAgJzdCJyxcbiAgJzdDJyxcbiAgJzdEJyxcbiAgJzdFJyxcbiAgJzdGJyxcbiAgJzgwJyxcbiAgJzgxJyxcbiAgJzgyJyxcbiAgJzgzJyxcbiAgJzg0JyxcbiAgJzg1JyxcbiAgJzg2JyxcbiAgJzg3JyxcbiAgJzg4JyxcbiAgJzg5JyxcbiAgJzhBJyxcbiAgJzhCJyxcbiAgJzhDJyxcbiAgJzhEJyxcbiAgJzhFJyxcbiAgJzhGJyxcbiAgJzkwJyxcbiAgJzkxJyxcbiAgJzkyJyxcbiAgJzkzJyxcbiAgJzk0JyxcbiAgJzk1JyxcbiAgJzk2JyxcbiAgJzk3JyxcbiAgJzk4JyxcbiAgJzk5JyxcbiAgJzlBJyxcbiAgJzlCJyxcbiAgJzlDJyxcbiAgJzlEJyxcbiAgJzlFJyxcbiAgJzlGJyxcbiAgJ0EwJyxcbiAgJ0ExJyxcbiAgJ0EyJyxcbiAgJ0EzJyxcbiAgJ0E0JyxcbiAgJ0E1JyxcbiAgJ0E2JyxcbiAgJ0E3JyxcbiAgJ0E4JyxcbiAgJ0E5JyxcbiAgJ0FBJyxcbiAgJ0FCJyxcbiAgJ0FDJyxcbiAgJ0FEJyxcbiAgJ0FFJyxcbiAgJ0FGJyxcbiAgJ0IwJyxcbiAgJ0IxJyxcbiAgJ0IyJyxcbiAgJ0IzJyxcbiAgJ0I0JyxcbiAgJ0I1JyxcbiAgJ0I2JyxcbiAgJ0I3JyxcbiAgJ0I4JyxcbiAgJ0I5JyxcbiAgJ0JBJyxcbiAgJ0JCJyxcbiAgJ0JDJyxcbiAgJ0JEJyxcbiAgJ0JFJyxcbiAgJ0JGJyxcbiAgJ0MwJyxcbiAgJ0MxJyxcbiAgJ0MyJyxcbiAgJ0MzJyxcbiAgJ0M0JyxcbiAgJ0M1JyxcbiAgJ0M2JyxcbiAgJ0M3JyxcbiAgJ0M4JyxcbiAgJ0M5JyxcbiAgJ0NBJyxcbiAgJ0NCJyxcbiAgJ0NDJyxcbiAgJ0NEJyxcbiAgJ0NFJyxcbiAgJ0NGJyxcbiAgJ0QwJyxcbiAgJ0QxJyxcbiAgJ0QyJyxcbiAgJ0QzJyxcbiAgJ0Q0JyxcbiAgJ0Q1JyxcbiAgJ0Q2JyxcbiAgJ0Q3JyxcbiAgJ0Q4JyxcbiAgJ0Q5JyxcbiAgJ0RBJyxcbiAgJ0RCJyxcbiAgJ0RDJyxcbiAgJ0REJyxcbiAgJ0RFJyxcbiAgJ0RGJyxcbiAgJ0UwJyxcbiAgJ0UxJyxcbiAgJ0UyJyxcbiAgJ0UzJyxcbiAgJ0U0JyxcbiAgJ0U1JyxcbiAgJ0U2JyxcbiAgJ0U3JyxcbiAgJ0U4JyxcbiAgJ0U5JyxcbiAgJ0VBJyxcbiAgJ0VCJyxcbiAgJ0VDJyxcbiAgJ0VEJyxcbiAgJ0VFJyxcbiAgJ0VGJyxcbiAgJ0YwJyxcbiAgJ0YxJyxcbiAgJ0YyJyxcbiAgJ0YzJyxcbiAgJ0Y0JyxcbiAgJ0Y1JyxcbiAgJ0Y2JyxcbiAgJ0Y3JyxcbiAgJ0Y4JyxcbiAgJ0Y5JyxcbiAgJ0ZBJyxcbiAgJ0ZCJyxcbiAgJ0ZDJyxcbiAgJ0ZEJyxcbiAgJ0ZFJyxcbiAgJ0ZGJyxcbl07XG5cbi8qIHZlY3RvciBvZiBiYXNlIDY0IGNoYXJhY3RlcnMgKi9cbmNvbnN0IGJhc2U2NGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89Jy5zcGxpdCgnJyk7XG5cbi8qIHZlY3RvciBvZiBiYXNlIDY0IGNoYXJhY3RlciBjb2RlcyAqL1xuY29uc3QgYmFzZTY0Y29kZXMgPSBbXTtcbmJhc2U2NGNoYXJzLmZvckVhY2goKGNoYXIpID0+IHtcbiAgYmFzZTY0Y29kZXMucHVzaChjaGFyLmNoYXJDb2RlQXQoMCkpO1xufSk7XG5cbi8vIFRoZSBVVEY4IGFsZ29yaXRobXMuXG5leHBvcnRzLnV0ZjggPSB7XG4gIGVuY29kZShjaGFycykge1xuICAgIGNvbnN0IGJ5dGVzID0gW107XG4gICAgY2hhcnMuZm9yRWFjaCgoY2hhcikgPT4ge1xuICAgICAgaWYgKGNoYXIgPj0gMCAmJiBjaGFyIDw9IDB4N2YpIHtcbiAgICAgICAgYnl0ZXMucHVzaChjaGFyKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhciA8PSAweDdmZikge1xuICAgICAgICBieXRlcy5wdXNoKDB4YzAgKyAoKGNoYXIgPj4gNikgJiBtYXNrWzVdKSk7XG4gICAgICAgIGJ5dGVzLnB1c2goMHg4MCArIChjaGFyICYgbWFza1s2XSkpO1xuICAgICAgfSBlbHNlIGlmIChjaGFyIDwgMHhkODAwIHx8IChjaGFyID4gMHhkZmZmICYmIGNoYXIgPD0gMHhmZmZmKSkge1xuICAgICAgICBieXRlcy5wdXNoKDB4ZTAgKyAoKGNoYXIgPj4gMTIpICYgbWFza1s0XSkpO1xuICAgICAgICBieXRlcy5wdXNoKDB4ODAgKyAoKGNoYXIgPj4gNikgJiBtYXNrWzZdKSk7XG4gICAgICAgIGJ5dGVzLnB1c2goMHg4MCArIChjaGFyICYgbWFza1s2XSkpO1xuICAgICAgfSBlbHNlIGlmIChjaGFyID49IDB4MTAwMDAgJiYgY2hhciA8PSAweDEwZmZmZikge1xuICAgICAgICBjb25zdCB1ID0gKGNoYXIgPj4gMTYpICYgbWFza1s1XTtcbiAgICAgICAgYnl0ZXMucHVzaCgweGYwICsgKHUgPj4gMikpO1xuICAgICAgICBieXRlcy5wdXNoKDB4ODAgKyAoKHUgJiBtYXNrWzJdKSA8PCA0KSArICgoY2hhciA+PiAxMikgJiBtYXNrWzRdKSk7XG4gICAgICAgIGJ5dGVzLnB1c2goMHg4MCArICgoY2hhciA+PiA2KSAmIG1hc2tbNl0pKTtcbiAgICAgICAgYnl0ZXMucHVzaCgweDgwICsgKGNoYXIgJiBtYXNrWzZdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmOC5lbmNvZGU6IGNoYXJhY3RlciBvdXQgb2YgcmFuZ2U6IGNoYXI6ICR7Y2hhcn1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9LFxuICBkZWNvZGUoYnVmLCBib20pIHtcbiAgICAvKiBieXRlcyBmdW5jdGlvbnMgcmV0dXJuIGVycm9yIGZvciBub24tc2hvcnRlc3QgZm9ybXMgJiB2YWx1ZXMgb3V0IG9mIHJhbmdlICovXG4gICAgZnVuY3Rpb24gYnl0ZXMyKGIxLCBiMikge1xuICAgICAgLyogVSswMDgwLi5VKzA3RkYgKi9cbiAgICAgIC8qIDAwMDAwMDAwIDAwMDAweXl5IHl5eHh4eHh4IHwgMTEweXl5eXkgMTB4eHh4eHggKi9cbiAgICAgIGlmICgoYjIgJiAweGMwKSAhPT0gMHg4MCkge1xuICAgICAgICByZXR1cm4gVFJBSUxJTkc7XG4gICAgICB9XG4gICAgICBjb25zdCB4ID0gKChiMSAmIG1hc2tbNV0pIDw8IDYpICsgKGIyICYgbWFza1s2XSk7XG4gICAgICBpZiAoeCA8IDB4ODApIHtcbiAgICAgICAgcmV0dXJuIE5PTl9TSE9SVEVTVDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBieXRlczMoYjEsIGIyLCBiMykge1xuICAgICAgLyogVSswODAwLi5VK0ZGRkYgKi9cbiAgICAgIC8qIDAwMDAwMDAwIHp6enp5eXl5IHl5eHh4eHh4IHwgMTExMHp6enogMTB5eXl5eXkgMTB4eHh4eHggKi9cbiAgICAgIGlmICgoYjMgJiAweGMwKSAhPT0gMHg4MCB8fCAoYjIgJiAweGMwKSAhPT0gMHg4MCkge1xuICAgICAgICByZXR1cm4gVFJBSUxJTkc7XG4gICAgICB9XG4gICAgICBjb25zdCB4ID0gKChiMSAmIG1hc2tbNF0pIDw8IDEyKSArICgoYjIgJiBtYXNrWzZdKSA8PCA2KSArIChiMyAmIG1hc2tbNl0pO1xuICAgICAgaWYgKHggPCAweDgwMCkge1xuICAgICAgICByZXR1cm4gTk9OX1NIT1JURVNUO1xuICAgICAgfVxuICAgICAgaWYgKHggPj0gMHhkODAwICYmIHggPD0gMHhkZmZmKSB7XG4gICAgICAgIHJldHVybiBSQU5HRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBieXRlczQoYjEsIGIyLCBiMywgYjQpIHtcbiAgICAgIC8qIFUrMTAwMDAuLlUrMTBGRkZGICovXG4gICAgICAvKiAwMDB1dXV1dSB6enp6eXl5eSB5eXh4eHh4eCB8IDExMTEwdXV1IDEwdXV6enp6IDEweXl5eXl5IDEweHh4eHh4ICovXG4gICAgICBpZiAoKGI0ICYgMHhjMCkgIT09IDB4ODAgfHwgKGIzICYgMHhjMCkgIT09IDB4ODAgfHwgKGIyICYgMHhjMCkgIT09IDB4ODApIHtcbiAgICAgICAgcmV0dXJuIFRSQUlMSU5HO1xuICAgICAgfVxuICAgICAgY29uc3QgeCA9XG4gICAgICAgICgoKChiMSAmIG1hc2tbM10pIDw8IDIpICsgKChiMiA+PiA0KSAmIG1hc2tbMl0pKSA8PCAxNikgK1xuICAgICAgICAoKGIyICYgbWFza1s0XSkgPDwgMTIpICtcbiAgICAgICAgKChiMyAmIG1hc2tbNl0pIDw8IDYpICtcbiAgICAgICAgKGI0ICYgbWFza1s2XSk7XG4gICAgICBpZiAoeCA8IDB4MTAwMDApIHtcbiAgICAgICAgcmV0dXJuIE5PTl9TSE9SVEVTVDtcbiAgICAgIH1cbiAgICAgIGlmICh4ID4gMHgxMGZmZmYpIHtcbiAgICAgICAgcmV0dXJuIFJBTkdFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGxldCBjO1xuICAgIGxldCBiMTtcbiAgICBsZXQgaTE7XG4gICAgbGV0IGkyO1xuICAgIGxldCBpMztcbiAgICBsZXQgaW5jO1xuICAgIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgbGV0IGkgPSBib20gPyAzIDogMDtcbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBiMSA9IGJ1ZltpXTtcbiAgICAgIGMgPSBJTExfRk9STUVEO1xuICAgICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgICB3aGlsZSAoVFJVRSkge1xuICAgICAgICBpZiAoYjEgPj0gMCAmJiBiMSA8PSAweDdmKSB7XG4gICAgICAgICAgLyogVSswMDAwLi5VKzAwN0YgMDAuLjdGICovXG4gICAgICAgICAgYyA9IGIxO1xuICAgICAgICAgIGluYyA9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaTEgPSBpICsgMTtcbiAgICAgICAgaWYgKGkxIDwgbGVuICYmIGIxID49IDB4YzIgJiYgYjEgPD0gMHhkZikge1xuICAgICAgICAgIC8qIFUrMDA4MC4uVSswN0ZGIEMyLi5ERiA4MC4uQkYgKi9cbiAgICAgICAgICBjID0gYnl0ZXMyKGIxLCBidWZbaTFdKTtcbiAgICAgICAgICBpbmMgPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGkyID0gaSArIDI7XG4gICAgICAgIGlmIChpMiA8IGxlbiAmJiBiMSA+PSAweGUwICYmIGIxIDw9IDB4ZWYpIHtcbiAgICAgICAgICAvKiBVKzA4MDAuLlUrRkZGRiAqL1xuICAgICAgICAgIGMgPSBieXRlczMoYjEsIGJ1ZltpMV0sIGJ1ZltpMl0pO1xuICAgICAgICAgIGluYyA9IDM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaTMgPSBpICsgMztcbiAgICAgICAgaWYgKGkzIDwgbGVuICYmIGIxID49IDB4ZjAgJiYgYjEgPD0gMHhmNCkge1xuICAgICAgICAgIC8qIFUrMTAwMDAuLlUrMTBGRkZGICovXG4gICAgICAgICAgYyA9IGJ5dGVzNChiMSwgYnVmW2kxXSwgYnVmW2kyXSwgYnVmW2kzXSk7XG4gICAgICAgICAgaW5jID0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvKiBpZiB3ZSBmYWxsIHRocm91Z2ggdG8gaGVyZSwgaXQgaXMgYW4gaWxsLWZvcm1lZCBzZXF1ZW5jZSAqL1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChjID4gMHgxMGZmZmYpIHtcbiAgICAgICAgY29uc3QgYXQgPSBgYnl0ZVske2l9XWA7XG4gICAgICAgIGlmIChjID09PSBJTExfRk9STUVEKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjguZGVjb2RlOiBpbGwtZm9ybWVkIFVURjggYnl0ZSBzZXF1ZW5jZSBmb3VuZCBhdDogJHthdH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gVFJBSUxJTkcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmOC5kZWNvZGU6IGlsbGVnYWwgdHJhaWxpbmcgYnl0ZSBmb3VuZCBhdDogJHthdH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gUkFOR0UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmOC5kZWNvZGU6IGNvZGUgcG9pbnQgb3V0IG9mIHJhbmdlIGZvdW5kIGF0OiAke2F0fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjID09PSBOT05fU0hPUlRFU1QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmOC5kZWNvZGU6IG5vbi1zaG9ydGVzdCBmb3JtIGZvdW5kIGF0OiAke2F0fWApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGY4LmRlY29kZTogdW5yZWNvZ25pemVkIGVycm9yIGZvdW5kIGF0OiAke2F0fWApO1xuICAgICAgfVxuICAgICAgY2hhcnMucHVzaChjKTtcbiAgICAgIGkgKz0gaW5jO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgVVRGMTZCRSBhbGdvcml0aG1zLlxuZXhwb3J0cy51dGYxNmJlID0ge1xuICBlbmNvZGUoY2hhcnMpIHtcbiAgICBjb25zdCBieXRlcyA9IFtdO1xuICAgIGxldCBjaGFyO1xuICAgIGxldCBoO1xuICAgIGxldCBsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNoYXIgPSBjaGFyc1tpXTtcbiAgICAgIGlmICgoY2hhciA+PSAwICYmIGNoYXIgPD0gMHhkN2ZmKSB8fCAoY2hhciA+PSAweGUwMDAgJiYgY2hhciA8PSAweGZmZmYpKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goKGNoYXIgPj4gOCkgJiBtYXNrWzhdKTtcbiAgICAgICAgYnl0ZXMucHVzaChjaGFyICYgbWFza1s4XSk7XG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPj0gMHgxMDAwMCAmJiBjaGFyIDw9IDB4MTBmZmZmKSB7XG4gICAgICAgIGwgPSBjaGFyIC0gMHgxMDAwMDtcbiAgICAgICAgaCA9IDB4ZDgwMCArIChsID4+IDEwKTtcbiAgICAgICAgbCA9IDB4ZGMwMCArIChsICYgbWFza1sxMF0pO1xuICAgICAgICBieXRlcy5wdXNoKChoID4+IDgpICYgbWFza1s4XSk7XG4gICAgICAgIGJ5dGVzLnB1c2goaCAmIG1hc2tbOF0pO1xuICAgICAgICBieXRlcy5wdXNoKChsID4+IDgpICYgbWFza1s4XSk7XG4gICAgICAgIGJ5dGVzLnB1c2gobCAmIG1hc2tbOF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjE2YmUuZW5jb2RlOiBVVEYxNkJFIHZhbHVlIG91dCBvZiByYW5nZTogY2hhclske2l9XTogJHtjaGFyfWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9LFxuICBkZWNvZGUoYnVmLCBib20pIHtcbiAgICAvKiBhc3N1bWVzIGNhbGxlciBoYXMgaW5zdXJlZCB0aGF0IGJ1ZiBpcyBhIEJ1ZmZlciBvZiBieXRlcyAqL1xuICAgIGlmIChidWYubGVuZ3RoICUgMiA+IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGYxNmJlLmRlY29kZTogZGF0YSBsZW5ndGggbXVzdCBiZSBldmVuIG11bHRpcGxlIG9mIDI6IGxlbmd0aDogJHtidWYubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgbGV0IGkgPSBib20gPyAyIDogMDtcbiAgICBsZXQgaiA9IDA7XG4gICAgbGV0IGM7XG4gICAgbGV0IGluYztcbiAgICBsZXQgaTE7XG4gICAgbGV0IGkzO1xuICAgIGxldCBoaWdoO1xuICAgIGxldCBsb3c7XG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGNvbnN0IFRSVUUgPSB0cnVlO1xuICAgICAgd2hpbGUgKFRSVUUpIHtcbiAgICAgICAgaTEgPSBpICsgMTtcbiAgICAgICAgaWYgKGkxIDwgbGVuKSB7XG4gICAgICAgICAgaGlnaCA9IChidWZbaV0gPDwgOCkgKyBidWZbaTFdO1xuICAgICAgICAgIGlmIChoaWdoIDwgMHhkODAwIHx8IGhpZ2ggPiAweGRmZmYpIHtcbiAgICAgICAgICAgIGMgPSBoaWdoO1xuICAgICAgICAgICAgaW5jID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpMyA9IGkgKyAzO1xuICAgICAgICAgIGlmIChpMyA8IGxlbikge1xuICAgICAgICAgICAgbG93ID0gKGJ1ZltpICsgMl0gPDwgOCkgKyBidWZbaTNdO1xuICAgICAgICAgICAgaWYgKGhpZ2ggPD0gMHhkYmZmICYmIGxvdyA+PSAweGRjMDAgJiYgbG93IDw9IDB4ZGZmZikge1xuICAgICAgICAgICAgICBjID0gMHgxMDAwMCArICgoaGlnaCAtIDB4ZDgwMCkgPDwgMTApICsgKGxvdyAtIDB4ZGMwMCk7XG4gICAgICAgICAgICAgIGluYyA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiBpZiB3ZSBmYWxsIHRocm91Z2ggdG8gaGVyZSwgaXQgaXMgYW4gaWxsLWZvcm1lZCBzZXF1ZW5jZSAqL1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmMTZiZS5kZWNvZGU6IGlsbC1mb3JtZWQgVVRGMTZCRSBieXRlIHNlcXVlbmNlIGZvdW5kOiBieXRlWyR7aX1dYCk7XG4gICAgICB9XG4gICAgICBjaGFyc1tqKytdID0gYztcbiAgICAgIGkgKz0gaW5jO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgVVRGMTZMRSBhbGdvcml0aG1zLlxuZXhwb3J0cy51dGYxNmxlID0ge1xuICBlbmNvZGUoY2hhcnMpIHtcbiAgICBjb25zdCBieXRlcyA9IFtdO1xuICAgIGxldCBjaGFyO1xuICAgIGxldCBoO1xuICAgIGxldCBsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNoYXIgPSBjaGFyc1tpXTtcbiAgICAgIGlmICgoY2hhciA+PSAwICYmIGNoYXIgPD0gMHhkN2ZmKSB8fCAoY2hhciA+PSAweGUwMDAgJiYgY2hhciA8PSAweGZmZmYpKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goY2hhciAmIG1hc2tbOF0pO1xuICAgICAgICBieXRlcy5wdXNoKChjaGFyID4+IDgpICYgbWFza1s4XSk7XG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPj0gMHgxMDAwMCAmJiBjaGFyIDw9IDB4MTBmZmZmKSB7XG4gICAgICAgIGwgPSBjaGFyIC0gMHgxMDAwMDtcbiAgICAgICAgaCA9IDB4ZDgwMCArIChsID4+IDEwKTtcbiAgICAgICAgbCA9IDB4ZGMwMCArIChsICYgbWFza1sxMF0pO1xuICAgICAgICBieXRlcy5wdXNoKGggJiBtYXNrWzhdKTtcbiAgICAgICAgYnl0ZXMucHVzaCgoaCA+PiA4KSAmIG1hc2tbOF0pO1xuICAgICAgICBieXRlcy5wdXNoKGwgJiBtYXNrWzhdKTtcbiAgICAgICAgYnl0ZXMucHVzaCgobCA+PiA4KSAmIG1hc2tbOF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjE2bGUuZW5jb2RlOiBVVEYxNkxFIHZhbHVlIG91dCBvZiByYW5nZTogY2hhclske2l9XTogJHtjaGFyfWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9LFxuICBkZWNvZGUoYnVmLCBib20pIHtcbiAgICAvKiBhc3N1bWVzIGNhbGxlciBoYXMgaW5zdXJlZCB0aGF0IGJ1ZiBpcyBhIEJ1ZmZlciBvZiBieXRlcyAqL1xuICAgIGlmIChidWYubGVuZ3RoICUgMiA+IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGYxNmxlLmRlY29kZTogZGF0YSBsZW5ndGggbXVzdCBiZSBldmVuIG11bHRpcGxlIG9mIDI6IGxlbmd0aDogJHtidWYubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgbGV0IGkgPSBib20gPyAyIDogMDtcbiAgICBsZXQgaiA9IDA7XG4gICAgbGV0IGM7XG4gICAgbGV0IGluYztcbiAgICBsZXQgaTE7XG4gICAgbGV0IGkzO1xuICAgIGxldCBoaWdoO1xuICAgIGxldCBsb3c7XG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGNvbnN0IFRSVUUgPSB0cnVlO1xuICAgICAgd2hpbGUgKFRSVUUpIHtcbiAgICAgICAgaTEgPSBpICsgMTtcbiAgICAgICAgaWYgKGkxIDwgbGVuKSB7XG4gICAgICAgICAgaGlnaCA9IChidWZbaTFdIDw8IDgpICsgYnVmW2ldO1xuICAgICAgICAgIGlmIChoaWdoIDwgMHhkODAwIHx8IGhpZ2ggPiAweGRmZmYpIHtcbiAgICAgICAgICAgIGMgPSBoaWdoO1xuICAgICAgICAgICAgaW5jID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpMyA9IGkgKyAzO1xuICAgICAgICAgIGlmIChpMyA8IGxlbikge1xuICAgICAgICAgICAgbG93ID0gKGJ1ZltpM10gPDwgOCkgKyBidWZbaSArIDJdO1xuICAgICAgICAgICAgaWYgKGhpZ2ggPD0gMHhkYmZmICYmIGxvdyA+PSAweGRjMDAgJiYgbG93IDw9IDB4ZGZmZikge1xuICAgICAgICAgICAgICBjID0gMHgxMDAwMCArICgoaGlnaCAtIDB4ZDgwMCkgPDwgMTApICsgKGxvdyAtIDB4ZGMwMCk7XG4gICAgICAgICAgICAgIGluYyA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiBpZiB3ZSBmYWxsIHRocm91Z2ggdG8gaGVyZSwgaXQgaXMgYW4gaWxsLWZvcm1lZCBzZXF1ZW5jZSAqL1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmMTZsZS5kZWNvZGU6IGlsbC1mb3JtZWQgVVRGMTZMRSBieXRlIHNlcXVlbmNlIGZvdW5kOiBieXRlWyR7aX1dYCk7XG4gICAgICB9XG4gICAgICBjaGFyc1tqKytdID0gYztcbiAgICAgIGkgKz0gaW5jO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgVVRGMzJCRSBhbGdvcml0aG1zLlxuZXhwb3J0cy51dGYzMmJlID0ge1xuICBlbmNvZGUoY2hhcnMpIHtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2MoY2hhcnMubGVuZ3RoICogNCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNoYXJzLmZvckVhY2goKGNoYXIpID0+IHtcbiAgICAgIGlmICgoY2hhciA+PSAweGQ4MDAgJiYgY2hhciA8PSAweGRmZmYpIHx8IGNoYXIgPiAweDEwZmZmZikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmMzJiZS5lbmNvZGU6IFVURjMyQkUgY2hhcmFjdGVyIGNvZGUgb3V0IG9mIHJhbmdlOiBjaGFyWyR7aSAvIDR9XTogJHtjaGFyfWApO1xuICAgICAgfVxuICAgICAgYnVmW2krK10gPSAoY2hhciA+PiAyNCkgJiBtYXNrWzhdO1xuICAgICAgYnVmW2krK10gPSAoY2hhciA+PiAxNikgJiBtYXNrWzhdO1xuICAgICAgYnVmW2krK10gPSAoY2hhciA+PiA4KSAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IGNoYXIgJiBtYXNrWzhdO1xuICAgIH0pO1xuICAgIHJldHVybiBidWY7XG4gIH0sXG4gIGRlY29kZShidWYsIGJvbSkge1xuICAgIC8qIGNhbGxlciB0byBpbnN1cmUgYnVmIGlzIGEgQnVmZmVyIG9mIGJ5dGVzICovXG4gICAgaWYgKGJ1Zi5sZW5ndGggJSA0ID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjMyYmUuZGVjb2RlOiBVVEYzMkJFIGJ5dGUgbGVuZ3RoIG11c3QgYmUgZXZlbiBtdWx0aXBsZSBvZiA0OiBsZW5ndGg6ICR7YnVmLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICBsZXQgaSA9IGJvbSA/IDQgOiAwO1xuICAgIGZvciAoOyBpIDwgYnVmLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICBjb25zdCBjaGFyID0gKGJ1ZltpXSA8PCAyNCkgKyAoYnVmW2kgKyAxXSA8PCAxNikgKyAoYnVmW2kgKyAyXSA8PCA4KSArIGJ1ZltpICsgM107XG4gICAgICBpZiAoKGNoYXIgPj0gMHhkODAwICYmIGNoYXIgPD0gMHhkZmZmKSB8fCBjaGFyID4gMHgxMGZmZmYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjMyYmUuZGVjb2RlOiBVVEYzMkJFIGNoYXJhY3RlciBjb2RlIG91dCBvZiByYW5nZTogY2hhclske2kgLyA0fV06ICR7Y2hhcn1gKTtcbiAgICAgIH1cbiAgICAgIGNoYXJzLnB1c2goY2hhcik7XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfSxcbn07XG5cbi8vIFRoZSBVVEYzMkxFIGFsZ29yaXRobXMuXG5leHBvcnRzLnV0ZjMybGUgPSB7XG4gIGVuY29kZShjaGFycykge1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYyhjaGFycy5sZW5ndGggKiA0KTtcbiAgICBsZXQgaSA9IDA7XG4gICAgY2hhcnMuZm9yRWFjaCgoY2hhcikgPT4ge1xuICAgICAgaWYgKChjaGFyID49IDB4ZDgwMCAmJiBjaGFyIDw9IDB4ZGZmZikgfHwgY2hhciA+IDB4MTBmZmZmKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGYzMmxlLmVuY29kZTogVVRGMzJMRSBjaGFyYWN0ZXIgY29kZSBvdXQgb2YgcmFuZ2U6IGNoYXJbJHtpIC8gNH1dOiAke2NoYXJ9YCk7XG4gICAgICB9XG4gICAgICBidWZbaSsrXSA9IGNoYXIgJiBtYXNrWzhdO1xuICAgICAgYnVmW2krK10gPSAoY2hhciA+PiA4KSAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDE2KSAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDI0KSAmIG1hc2tbOF07XG4gICAgfSk7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfSxcbiAgZGVjb2RlKGJ1ZiwgYm9tKSB7XG4gICAgLyogY2FsbGVyIHRvIGluc3VyZSBidWYgaXMgYSBCdWZmZXIgb2YgYnl0ZXMgKi9cbiAgICBpZiAoYnVmLmxlbmd0aCAlIDQgPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmMzJiZS5kZWNvZGU6IFVURjMyTEUgYnl0ZSBsZW5ndGggbXVzdCBiZSBldmVuIG11bHRpcGxlIG9mIDQ6IGxlbmd0aDogJHtidWYubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIGxldCBpID0gYm9tID8gNCA6IDA7XG4gICAgZm9yICg7IGkgPCBidWYubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIGNvbnN0IGNoYXIgPSAoYnVmW2kgKyAzXSA8PCAyNCkgKyAoYnVmW2kgKyAyXSA8PCAxNikgKyAoYnVmW2kgKyAxXSA8PCA4KSArIGJ1ZltpXTtcbiAgICAgIGlmICgoY2hhciA+PSAweGQ4MDAgJiYgY2hhciA8PSAweGRmZmYpIHx8IGNoYXIgPiAweDEwZmZmZikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmMzJsZS5lbmNvZGU6IFVURjMyTEUgY2hhcmFjdGVyIGNvZGUgb3V0IG9mIHJhbmdlOiBjaGFyWyR7aSAvIDR9XTogJHtjaGFyfWApO1xuICAgICAgfVxuICAgICAgY2hhcnMucHVzaChjaGFyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9LFxufTtcblxuLy8gVGhlIFVJTlQ3IGFsZ29yaXRobXMuIEFTQ0lJIG9yIDctYml0IHVuc2lnbmVkIGludGVnZXJzLlxuZXhwb3J0cy51aW50NyA9IHtcbiAgZW5jb2RlKGNoYXJzKSB7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKGNoYXJzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKGNoYXJzW2ldID4gMHg3Zikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdWludDcuZW5jb2RlOiBVSU5UNyBjaGFyYWN0ZXIgY29kZSBvdXQgb2YgcmFuZ2U6IGNoYXJbJHtpfV06ICR7Y2hhcnNbaV19YCk7XG4gICAgICB9XG4gICAgICBidWZbaV0gPSBjaGFyc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfSxcbiAgZGVjb2RlKGJ1Zikge1xuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChidWZbaV0gPiAweDdmKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1aW50Ny5kZWNvZGU6IFVJTlQ3IGNoYXJhY3RlciBjb2RlIG91dCBvZiByYW5nZTogYnl0ZVske2l9XTogJHtidWZbaV19YCk7XG4gICAgICB9XG4gICAgICBjaGFyc1tpXSA9IGJ1ZltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9LFxufTtcblxuLy8gVGhlIFVJTlQ4IGFsZ29yaXRobXMuIEJJTkFSWSwgTGF0aW4gMSBvciA4LWJpdCB1bnNpZ25lZCBpbnRlZ2Vycy5cbmV4cG9ydHMudWludDggPSB7XG4gIGVuY29kZShjaGFycykge1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYyhjaGFycy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChjaGFyc1tpXSA+IDB4ZmYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHVpbnQ4LmVuY29kZTogVUlOVDggY2hhcmFjdGVyIGNvZGUgb3V0IG9mIHJhbmdlOiBjaGFyWyR7aX1dOiAke2NoYXJzW2ldfWApO1xuICAgICAgfVxuICAgICAgYnVmW2ldID0gY2hhcnNbaV07XG4gICAgfVxuICAgIHJldHVybiBidWY7XG4gIH0sXG4gIGRlY29kZShidWYpIHtcbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjaGFyc1tpXSA9IGJ1ZltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9LFxufTtcblxuLy8gVGhlIFVJTlQxNkJFIGFsZ29yaXRobXMuIEJpZy1lbmRpYW4gMTYtYml0IHVuc2lnbmVkIGludGVnZXJzLlxuZXhwb3J0cy51aW50MTZiZSA9IHtcbiAgZW5jb2RlKGNoYXJzKSB7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKGNoYXJzLmxlbmd0aCAqIDIpO1xuICAgIGxldCBpID0gMDtcbiAgICBjaGFycy5mb3JFYWNoKChjaGFyKSA9PiB7XG4gICAgICBpZiAoY2hhciA+IDB4ZmZmZikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdWludDE2YmUuZW5jb2RlOiBVSU5UMTZCRSBjaGFyYWN0ZXIgY29kZSBvdXQgb2YgcmFuZ2U6IGNoYXJbJHtpIC8gMn1dOiAke2NoYXJ9YCk7XG4gICAgICB9XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDgpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltpKytdID0gY2hhciAmIG1hc2tbOF07XG4gICAgfSk7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfSxcbiAgZGVjb2RlKGJ1Zikge1xuICAgIGlmIChidWYubGVuZ3RoICUgMiA+IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1aW50MTZiZS5kZWNvZGU6IFVJTlQxNkJFIGJ5dGUgbGVuZ3RoIG11c3QgYmUgZXZlbiBtdWx0aXBsZSBvZiAyOiBsZW5ndGg6ICR7YnVmLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgY2hhcnMucHVzaCgoYnVmW2ldIDw8IDgpICsgYnVmW2kgKyAxXSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfSxcbn07XG5cbi8vIFRoZSBVSU5UMTZMRSBhbGdvcml0aG1zLiBMaXR0bGUtZW5kaWFuIDE2LWJpdCB1bnNpZ25lZCBpbnRlZ2Vycy5cbmV4cG9ydHMudWludDE2bGUgPSB7XG4gIGVuY29kZShjaGFycykge1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYyhjaGFycy5sZW5ndGggKiAyKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgY2hhcnMuZm9yRWFjaCgoY2hhcikgPT4ge1xuICAgICAgaWYgKGNoYXIgPiAweGZmZmYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHVpbnQxNmxlLmVuY29kZTogVUlOVDE2TEUgY2hhcmFjdGVyIGNvZGUgb3V0IG9mIHJhbmdlOiBjaGFyWyR7aSAvIDJ9XTogJHtjaGFyfWApO1xuICAgICAgfVxuICAgICAgYnVmW2krK10gPSBjaGFyICYgbWFza1s4XTtcbiAgICAgIGJ1ZltpKytdID0gKGNoYXIgPj4gOCkgJiBtYXNrWzhdO1xuICAgIH0pO1xuICAgIHJldHVybiBidWY7XG4gIH0sXG4gIGRlY29kZShidWYpIHtcbiAgICBpZiAoYnVmLmxlbmd0aCAlIDIgPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdWludDE2bGUuZGVjb2RlOiBVSU5UMTZMRSBieXRlIGxlbmd0aCBtdXN0IGJlIGV2ZW4gbXVsdGlwbGUgb2YgMjogbGVuZ3RoOiAke2J1Zi5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNoYXJzLnB1c2goKGJ1ZltpICsgMV0gPDwgOCkgKyBidWZbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgVUlOVDMyQkUgYWxnb3JpdGhtcy4gQmlnLWVuZGlhbiAzMi1iaXQgdW5zaWduZWQgaW50ZWdlcnMuXG5leHBvcnRzLnVpbnQzMmJlID0ge1xuICBlbmNvZGUoY2hhcnMpIHtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2MoY2hhcnMubGVuZ3RoICogNCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNoYXJzLmZvckVhY2goKGNoYXIpID0+IHtcbiAgICAgIGJ1ZltpKytdID0gKGNoYXIgPj4gMjQpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltpKytdID0gKGNoYXIgPj4gMTYpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltpKytdID0gKGNoYXIgPj4gOCkgJiBtYXNrWzhdO1xuICAgICAgYnVmW2krK10gPSBjaGFyICYgbWFza1s4XTtcbiAgICB9KTtcbiAgICByZXR1cm4gYnVmO1xuICB9LFxuICBkZWNvZGUoYnVmKSB7XG4gICAgaWYgKGJ1Zi5sZW5ndGggJSA0ID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHVpbnQzMmJlLmRlY29kZTogVUlOVDMyQkUgYnl0ZSBsZW5ndGggbXVzdCBiZSBldmVuIG11bHRpcGxlIG9mIDQ6IGxlbmd0aDogJHtidWYubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICBjaGFycy5wdXNoKChidWZbaV0gPDwgMjQpICsgKGJ1ZltpICsgMV0gPDwgMTYpICsgKGJ1ZltpICsgMl0gPDwgOCkgKyBidWZbaSArIDNdKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9LFxufTtcblxuLy8gVGhlIFVJTlQzMkxFIGFsZ29yaXRobXMuIExpdHRsZS1lbmRpYW4gMzItYml0IHVuc2lnbmVkIGludGVnZXJzLlxuZXhwb3J0cy51aW50MzJsZSA9IHtcbiAgZW5jb2RlKGNoYXJzKSB7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKGNoYXJzLmxlbmd0aCAqIDQpO1xuICAgIGxldCBpID0gMDtcbiAgICBjaGFycy5mb3JFYWNoKChjaGFyKSA9PiB7XG4gICAgICBidWZbaSsrXSA9IGNoYXIgJiBtYXNrWzhdO1xuICAgICAgYnVmW2krK10gPSAoY2hhciA+PiA4KSAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDE2KSAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDI0KSAmIG1hc2tbOF07XG4gICAgfSk7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfSxcbiAgZGVjb2RlKGJ1Zikge1xuICAgIC8qIGNhbGxlciB0byBpbnN1cmUgYnVmIGlzIGEgQnVmZmVyIG9mIGJ5dGVzICovXG4gICAgaWYgKGJ1Zi5sZW5ndGggJSA0ID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHVpbnQzMmxlLmRlY29kZTogVUlOVDMyTEUgYnl0ZSBsZW5ndGggbXVzdCBiZSBldmVuIG11bHRpcGxlIG9mIDQ6IGxlbmd0aDogJHtidWYubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICBjaGFycy5wdXNoKChidWZbaSArIDNdIDw8IDI0KSArIChidWZbaSArIDJdIDw8IDE2KSArIChidWZbaSArIDFdIDw8IDgpICsgYnVmW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9LFxufTtcblxuLy8gVGhlIFNUUklORyBhbGdvcml0aG1zLiBDb252ZXJ0cyBKYXZhU2NyaXB0IHN0cmluZ3MgdG8gQXJyYXkgb2YgMzItYml0IGludGVnZXJzIGFuZCB2aWNlIHZlcnNhLlxuLy8gVXNlcyB0aGUgbm9kZS5qcyBCdWZmZXIncyBuYXRpdmUgXCJ1dGYxNmxlXCIgY2FwYWJpbGl0ZXMuXG5leHBvcnRzLnN0cmluZyA9IHtcbiAgZW5jb2RlKGNoYXJzKSB7XG4gICAgcmV0dXJuIHRoaXNUaGlzLnV0ZjE2bGUuZW5jb2RlKGNoYXJzKS50b1N0cmluZygndXRmMTZsZScpO1xuICB9LFxuICBkZWNvZGUoc3RyKSB7XG4gICAgcmV0dXJuIHRoaXNUaGlzLnV0ZjE2bGUuZGVjb2RlKEJ1ZmZlci5mcm9tKHN0ciwgJ3V0ZjE2bGUnKSwgMCk7XG4gIH0sXG59O1xuXG4vLyBUaGUgRVNDQVBFRCBhbGdvcml0aG1zLlxuLy8gTm90ZSB0aGF0IEVTQ0FQRUQgZm9ybWF0IGNvbnRhaW5zIG9ubHkgQVNDSUkgY2hhcmFjdGVycy5cbi8vIFRoZSBjaGFyYWN0ZXJzIGFyZSBhbHdheXMgaW4gdGhlIGZvcm0gb2YgYSBCdWZmZXIgb2YgYnl0ZXMuXG5leHBvcnRzLmVzY2FwZWQgPSB7XG4gIC8vIEVuY29kZXMgYW4gQXJyYXkgb2YgMzItYml0IGludGVnZXJzIGludG8gRVNDQVBFRCBmb3JtYXQuXG4gIGVuY29kZShjaGFycykge1xuICAgIGNvbnN0IGJ5dGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3QgY2hhciA9IGNoYXJzW2ldO1xuICAgICAgaWYgKGNoYXIgPT09IDk2KSB7XG4gICAgICAgIGJ5dGVzLnB1c2goY2hhcik7XG4gICAgICAgIGJ5dGVzLnB1c2goY2hhcik7XG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPT09IDEwKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goY2hhcik7XG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPj0gMzIgJiYgY2hhciA8PSAxMjYpIHtcbiAgICAgICAgYnl0ZXMucHVzaChjaGFyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBzdHIgPSAnJztcbiAgICAgICAgaWYgKGNoYXIgPj0gMCAmJiBjaGFyIDw9IDMxKSB7XG4gICAgICAgICAgc3RyICs9IGBcXGB4JHthc2NpaVtjaGFyXX1gO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPj0gMTI3ICYmIGNoYXIgPD0gMjU1KSB7XG4gICAgICAgICAgc3RyICs9IGBcXGB4JHthc2NpaVtjaGFyXX1gO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPj0gMHgxMDAgJiYgY2hhciA8PSAweGZmZmYpIHtcbiAgICAgICAgICBzdHIgKz0gYFxcYHUke2FzY2lpWyhjaGFyID4+IDgpICYgbWFza1s4XV19JHthc2NpaVtjaGFyICYgbWFza1s4XV19YDtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID49IDB4MTAwMDAgJiYgY2hhciA8PSAweGZmZmZmZmZmKSB7XG4gICAgICAgICAgc3RyICs9ICdgdXsnO1xuICAgICAgICAgIGNvbnN0IGRpZ2l0ID0gKGNoYXIgPj4gMjQpICYgbWFza1s4XTtcbiAgICAgICAgICBpZiAoZGlnaXQgPiAwKSB7XG4gICAgICAgICAgICBzdHIgKz0gYXNjaWlbZGlnaXRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHIgKz0gYCR7YXNjaWlbKGNoYXIgPj4gMTYpICYgbWFza1s4XV0gKyBhc2NpaVsoY2hhciA+PiA4KSAmIG1hc2tbOF1dICsgYXNjaWlbY2hhciAmIG1hc2tbOF1dfX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXNjYXBlLmVuY29kZShjaGFyKTogY2hhciA+IDB4ZmZmZmZmZmYgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWYgPSBCdWZmZXIuZnJvbShzdHIpO1xuICAgICAgICBidWYuZm9yRWFjaCgoYikgPT4ge1xuICAgICAgICAgIGJ5dGVzLnB1c2goYik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9LFxuICAvLyBEZWNvZGVzIEVTQ0FQRUQgZm9ybWF0IGZyb20gYSBCdWZmZXIgb2YgYnl0ZXMgdG8gYW4gQXJyYXkgb2YgMzItYml0IGludGVnZXJzLlxuICBkZWNvZGUoYnVmKSB7XG4gICAgZnVuY3Rpb24gaXNIZXgoaGV4KSB7XG4gICAgICBpZiAoKGhleCA+PSA0OCAmJiBoZXggPD0gNTcpIHx8IChoZXggPj0gNjUgJiYgaGV4IDw9IDcwKSB8fCAoaGV4ID49IDk3ICYmIGhleCA8PSAxMDIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXR4KGksIGxlbiwgYnVmQXJnKSB7XG4gICAgICBjb25zdCByZXQgPSB7IGNoYXI6IG51bGwsIG5leHRpOiBpICsgMiwgZXJyb3I6IHRydWUgfTtcbiAgICAgIGlmIChpICsgMSA8IGxlbikge1xuICAgICAgICBpZiAoaXNIZXgoYnVmQXJnW2ldKSAmJiBpc0hleChidWZBcmdbaSArIDFdKSkge1xuICAgICAgICAgIGNvbnN0IHN0ciA9IFN0cmluZy5mcm9tQ29kZVBvaW50KGJ1ZkFyZ1tpXSwgYnVmQXJnW2kgKyAxXSk7XG4gICAgICAgICAgcmV0LmNoYXIgPSBwYXJzZUludChzdHIsIDE2KTtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc05hTihyZXQuY2hhcikpIHtcbiAgICAgICAgICAgIHJldC5lcnJvciA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0dShpLCBsZW4sIGJ1ZkFyZykge1xuICAgICAgY29uc3QgcmV0ID0geyBjaGFyOiBudWxsLCBuZXh0aTogaSArIDQsIGVycm9yOiB0cnVlIH07XG4gICAgICBpZiAoaSArIDMgPCBsZW4pIHtcbiAgICAgICAgaWYgKGlzSGV4KGJ1ZkFyZ1tpXSkgJiYgaXNIZXgoYnVmQXJnW2kgKyAxXSkgJiYgaXNIZXgoYnVmQXJnW2kgKyAyXSkgJiYgaXNIZXgoYnVmQXJnW2kgKyAzXSkpIHtcbiAgICAgICAgICBjb25zdCBzdHIgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChidWZBcmdbaV0sIGJ1ZkFyZ1tpICsgMV0sIGJ1ZkFyZ1tpICsgMl0sIGJ1ZkFyZ1tpICsgM10pO1xuICAgICAgICAgIHJldC5jaGFyID0gcGFyc2VJbnQoc3RyLCAxNik7XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4ocmV0LmNoYXIpKSB7XG4gICAgICAgICAgICByZXQuZXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFUoaSwgbGVuLCBidWZBcmcpIHtcbiAgICAgIGNvbnN0IHJldCA9IHsgY2hhcjogbnVsbCwgbmV4dGk6IGkgKyA0LCBlcnJvcjogdHJ1ZSB9O1xuICAgICAgbGV0IHN0ciA9ICcnO1xuICAgICAgd2hpbGUgKGkgPCBsZW4gJiYgaXNIZXgoYnVmQXJnW2ldKSkge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoYnVmQXJnW2ldKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cbiAgICAgIHJldC5jaGFyID0gcGFyc2VJbnQoc3RyLCAxNik7XG4gICAgICBpZiAoYnVmQXJnW2ldID09PSAxMjUgJiYgIU51bWJlci5pc05hTihyZXQuY2hhcikpIHtcbiAgICAgICAgcmV0LmVycm9yID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXQubmV4dGkgPSBpICsgMTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDtcbiAgICBsZXQgaTE7XG4gICAgbGV0IHJldDtcbiAgICBsZXQgZXJyb3I7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBjb25zdCBUUlVFID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICAgIGVycm9yID0gdHJ1ZTtcbiAgICAgICAgaWYgKGJ1ZltpXSAhPT0gOTYpIHtcbiAgICAgICAgICAvKiB1bmVzY2FwZWQgY2hhcmFjdGVyICovXG4gICAgICAgICAgY2hhcnMucHVzaChidWZbaV0pO1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICBlcnJvciA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGkxID0gaSArIDE7XG4gICAgICAgIGlmIChpMSA+PSBsZW4pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmW2kxXSA9PT0gOTYpIHtcbiAgICAgICAgICAvKiBlc2NhcGVkIGdyYXZlIGFjY2VudCAqL1xuICAgICAgICAgIGNoYXJzLnB1c2goOTYpO1xuICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICBlcnJvciA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZbaTFdID09PSAxMjApIHtcbiAgICAgICAgICByZXQgPSBnZXR4KGkxICsgMSwgbGVuLCBidWYpO1xuICAgICAgICAgIGlmIChyZXQuZXJyb3IpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBlc2NhcGVkIGhleCAqL1xuICAgICAgICAgIGNoYXJzLnB1c2gocmV0LmNoYXIpO1xuICAgICAgICAgIGkgPSByZXQubmV4dGk7XG4gICAgICAgICAgZXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmW2kxXSA9PT0gMTE3KSB7XG4gICAgICAgICAgaWYgKGJ1ZltpMSArIDFdID09PSAxMjMpIHtcbiAgICAgICAgICAgIHJldCA9IGdldFUoaTEgKyAyLCBsZW4sIGJ1Zik7XG4gICAgICAgICAgICBpZiAocmV0LmVycm9yKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogZXNjYXBlZCB1dGYtMzIgKi9cbiAgICAgICAgICAgIGNoYXJzLnB1c2gocmV0LmNoYXIpO1xuICAgICAgICAgICAgaSA9IHJldC5uZXh0aTtcbiAgICAgICAgICAgIGVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0ID0gZ2V0dShpMSArIDEsIGxlbiwgYnVmKTtcbiAgICAgICAgICBpZiAocmV0LmVycm9yKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLyogZXNjYXBlZCB1dGYtMTYgKi9cbiAgICAgICAgICBjaGFycy5wdXNoKHJldC5jaGFyKTtcbiAgICAgICAgICBpID0gcmV0Lm5leHRpO1xuICAgICAgICAgIGVycm9yID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlc2NhcGVkLmRlY29kZTogaWxsLWZvcm1lZCBlc2NhcGUgc2VxdWVuY2UgYXQgYnVmWyR7aX1dYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfSxcbn07XG5cbi8vIFRoZSBsaW5lIGVuZCBjb252ZXJzaW9uIGFsZ29yaWd0aG1zLlxuY29uc3QgQ1IgPSAxMztcbmNvbnN0IExGID0gMTA7XG5leHBvcnRzLmxpbmVFbmRzID0ge1xuICBjcmxmKGNoYXJzKSB7XG4gICAgY29uc3QgbGZjaGFycyA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGNoYXJzLmxlbmd0aCkge1xuICAgICAgc3dpdGNoIChjaGFyc1tpXSkge1xuICAgICAgICBjYXNlIENSOlxuICAgICAgICAgIGlmIChpICsgMSA8IGNoYXJzLmxlbmd0aCAmJiBjaGFyc1tpICsgMV0gPT09IExGKSB7XG4gICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGZjaGFycy5wdXNoKENSKTtcbiAgICAgICAgICBsZmNoYXJzLnB1c2goTEYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExGOlxuICAgICAgICAgIGxmY2hhcnMucHVzaChDUik7XG4gICAgICAgICAgbGZjaGFycy5wdXNoKExGKTtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGZjaGFycy5wdXNoKGNoYXJzW2ldKTtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsZmNoYXJzLmxlbmd0aCA+IDAgJiYgbGZjaGFyc1tsZmNoYXJzLmxlbmd0aCAtIDFdICE9PSBMRikge1xuICAgICAgbGZjaGFycy5wdXNoKENSKTtcbiAgICAgIGxmY2hhcnMucHVzaChMRik7XG4gICAgfVxuICAgIHJldHVybiBsZmNoYXJzO1xuICB9LFxuICBsZihjaGFycykge1xuICAgIGNvbnN0IGxmY2hhcnMgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBjaGFycy5sZW5ndGgpIHtcbiAgICAgIHN3aXRjaCAoY2hhcnNbaV0pIHtcbiAgICAgICAgY2FzZSBDUjpcbiAgICAgICAgICBpZiAoaSArIDEgPCBjaGFycy5sZW5ndGggJiYgY2hhcnNbaSArIDFdID09PSBMRikge1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxmY2hhcnMucHVzaChMRik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTEY6XG4gICAgICAgICAgbGZjaGFycy5wdXNoKExGKTtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGZjaGFycy5wdXNoKGNoYXJzW2ldKTtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsZmNoYXJzLmxlbmd0aCA+IDAgJiYgbGZjaGFyc1tsZmNoYXJzLmxlbmd0aCAtIDFdICE9PSBMRikge1xuICAgICAgbGZjaGFycy5wdXNoKExGKTtcbiAgICB9XG4gICAgcmV0dXJuIGxmY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgYmFzZSA2NCBhbGdvcml0aG1zLlxuZXhwb3J0cy5iYXNlNjQgPSB7XG4gIGVuY29kZShidWYpIHtcbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICB9XG4gICAgbGV0IGk7XG4gICAgbGV0IGo7XG4gICAgbGV0IG47XG4gICAgbGV0IHRhaWwgPSBidWYubGVuZ3RoICUgMztcbiAgICB0YWlsID0gdGFpbCA+IDAgPyAzIC0gdGFpbCA6IDA7XG4gICAgbGV0IHVuaXRzID0gKGJ1Zi5sZW5ndGggKyB0YWlsKSAvIDM7XG4gICAgY29uc3QgYmFzZTY0ID0gQnVmZmVyLmFsbG9jKHVuaXRzICogNCk7XG4gICAgaWYgKHRhaWwgPiAwKSB7XG4gICAgICB1bml0cyAtPSAxO1xuICAgIH1cbiAgICBpID0gMDtcbiAgICBqID0gMDtcbiAgICBmb3IgKGxldCB1ID0gMDsgdSA8IHVuaXRzOyB1ICs9IDEpIHtcbiAgICAgIG4gPSBidWZbaSsrXSA8PCAxNjtcbiAgICAgIG4gKz0gYnVmW2krK10gPDwgODtcbiAgICAgIG4gKz0gYnVmW2krK107XG4gICAgICBiYXNlNjRbaisrXSA9IGJhc2U2NGNvZGVzWyhuID4+IDE4KSAmIG1hc2tbNl1dO1xuICAgICAgYmFzZTY0W2orK10gPSBiYXNlNjRjb2Rlc1sobiA+PiAxMikgJiBtYXNrWzZdXTtcbiAgICAgIGJhc2U2NFtqKytdID0gYmFzZTY0Y29kZXNbKG4gPj4gNikgJiBtYXNrWzZdXTtcbiAgICAgIGJhc2U2NFtqKytdID0gYmFzZTY0Y29kZXNbbiAmIG1hc2tbNl1dO1xuICAgIH1cbiAgICBpZiAodGFpbCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJhc2U2NDtcbiAgICB9XG4gICAgaWYgKHRhaWwgPT09IDEpIHtcbiAgICAgIG4gPSBidWZbaSsrXSA8PCAxNjtcbiAgICAgIG4gKz0gYnVmW2ldIDw8IDg7XG4gICAgICBiYXNlNjRbaisrXSA9IGJhc2U2NGNvZGVzWyhuID4+IDE4KSAmIG1hc2tbNl1dO1xuICAgICAgYmFzZTY0W2orK10gPSBiYXNlNjRjb2Rlc1sobiA+PiAxMikgJiBtYXNrWzZdXTtcbiAgICAgIGJhc2U2NFtqKytdID0gYmFzZTY0Y29kZXNbKG4gPj4gNikgJiBtYXNrWzZdXTtcbiAgICAgIGJhc2U2NFtqXSA9IGJhc2U2NGNvZGVzWzY0XTtcbiAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgfVxuICAgIGlmICh0YWlsID09PSAyKSB7XG4gICAgICBuID0gYnVmW2ldIDw8IDE2O1xuICAgICAgYmFzZTY0W2orK10gPSBiYXNlNjRjb2Rlc1sobiA+PiAxOCkgJiBtYXNrWzZdXTtcbiAgICAgIGJhc2U2NFtqKytdID0gYmFzZTY0Y29kZXNbKG4gPj4gMTIpICYgbWFza1s2XV07XG4gICAgICBiYXNlNjRbaisrXSA9IGJhc2U2NGNvZGVzWzY0XTtcbiAgICAgIGJhc2U2NFtqXSA9IGJhc2U2NGNvZGVzWzY0XTtcbiAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0sXG4gIGRlY29kZShjb2Rlcykge1xuICAgIC8qIHJlbW92ZSB3aGl0ZSBzcGFjZSBhbmQgY3RybCBjaGFyYWN0ZXJzLCB2YWxpZGF0ZSAmIHRyYW5zbGF0ZSBjaGFyYWN0ZXJzICovXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUoYnVmKSB7XG4gICAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgICAgbGV0IHRhaWwgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgY2hhciA9IGJ1ZltpXTtcbiAgICAgICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICAgICAgaWYgKGNoYXIgPT09IDMyIHx8IGNoYXIgPT09IDkgfHwgY2hhciA9PT0gMTAgfHwgY2hhciA9PT0gMTMpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hhciA+PSA2NSAmJiBjaGFyIDw9IDkwKSB7XG4gICAgICAgICAgICBjaGFycy5wdXNoKGNoYXIgLSA2NSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoYXIgPj0gOTcgJiYgY2hhciA8PSAxMjIpIHtcbiAgICAgICAgICAgIGNoYXJzLnB1c2goY2hhciAtIDcxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hhciA+PSA0OCAmJiBjaGFyIDw9IDU3KSB7XG4gICAgICAgICAgICBjaGFycy5wdXNoKGNoYXIgKyA0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hhciA9PT0gNDMpIHtcbiAgICAgICAgICAgIGNoYXJzLnB1c2goNjIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGFyID09PSA0Nykge1xuICAgICAgICAgICAgY2hhcnMucHVzaCg2Myk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoYXIgPT09IDYxKSB7XG4gICAgICAgICAgICBjaGFycy5wdXNoKDY0KTtcbiAgICAgICAgICAgIHRhaWwgKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBpbnZhbGlkIGNoYXJhY3RlciAqL1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBiYXNlNjQuZGVjb2RlOiBpbnZhbGlkIGNoYXJhY3RlciBidWZbJHtpfV06ICR7Y2hhcn1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyogdmFsaWRhdGUgbGVuZ3RoICovXG4gICAgICBpZiAoY2hhcnMubGVuZ3RoICUgNCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGJhc2U2NC5kZWNvZGU6IHN0cmluZyBsZW5ndGggbm90IGludGVncmFsIG11bHRpcGxlIG9mIDQ6ICR7Y2hhcnMubGVuZ3RofWApO1xuICAgICAgfVxuICAgICAgLyogdmFsaWRhdGUgdGFpbCAqL1xuICAgICAgc3dpdGNoICh0YWlsKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChjaGFyc1tjaGFycy5sZW5ndGggLSAxXSAhPT0gNjQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdiYXNlNjQuZGVjb2RlOiBvbmUgdGFpbCBjaGFyYWN0ZXIgZm91bmQ6IG5vdCBsYXN0IGNoYXJhY3RlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGlmIChjaGFyc1tjaGFycy5sZW5ndGggLSAxXSAhPT0gNjQgfHwgY2hhcnNbY2hhcnMubGVuZ3RoIC0gMl0gIT09IDY0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYmFzZTY0LmRlY29kZTogdHdvIHRhaWwgY2hhcmFjdGVycyBmb3VuZDogbm90IGxhc3QgY2hhcmFjdGVycycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgYmFzZTY0LmRlY29kZTogbW9yZSB0aGFuIHR3byB0YWlsIGNoYXJhY3RlcnMgZm91bmQ6ICR7dGFpbH1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHRhaWwsIGJ1ZjogQnVmZmVyLmZyb20oY2hhcnMpIH07XG4gICAgfVxuXG4gICAgaWYgKGNvZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICB9XG4gICAgY29uc3QgdmFsID0gdmFsaWRhdGUoY29kZXMpO1xuICAgIGNvbnN0IHsgdGFpbCB9ID0gdmFsO1xuICAgIGNvbnN0IGJhc2U2NCA9IHZhbC5idWY7XG4gICAgbGV0IGk7XG4gICAgbGV0IGo7XG4gICAgbGV0IG47XG4gICAgbGV0IHVuaXRzID0gYmFzZTY0Lmxlbmd0aCAvIDQ7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKHVuaXRzICogMyAtIHRhaWwpO1xuICAgIGlmICh0YWlsID4gMCkge1xuICAgICAgdW5pdHMgLT0gMTtcbiAgICB9XG4gICAgaiA9IDA7XG4gICAgaSA9IDA7XG4gICAgZm9yIChsZXQgdSA9IDA7IHUgPCB1bml0czsgdSArPSAxKSB7XG4gICAgICBuID0gYmFzZTY0W2krK10gPDwgMTg7XG4gICAgICBuICs9IGJhc2U2NFtpKytdIDw8IDEyO1xuICAgICAgbiArPSBiYXNlNjRbaSsrXSA8PCA2O1xuICAgICAgbiArPSBiYXNlNjRbaSsrXTtcbiAgICAgIGJ1ZltqKytdID0gKG4gPj4gMTYpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltqKytdID0gKG4gPj4gOCkgJiBtYXNrWzhdO1xuICAgICAgYnVmW2orK10gPSBuICYgbWFza1s4XTtcbiAgICB9XG4gICAgaWYgKHRhaWwgPT09IDEpIHtcbiAgICAgIG4gPSBiYXNlNjRbaSsrXSA8PCAxODtcbiAgICAgIG4gKz0gYmFzZTY0W2krK10gPDwgMTI7XG4gICAgICBuICs9IGJhc2U2NFtpXSA8PCA2O1xuICAgICAgYnVmW2orK10gPSAobiA+PiAxNikgJiBtYXNrWzhdO1xuICAgICAgYnVmW2pdID0gKG4gPj4gOCkgJiBtYXNrWzhdO1xuICAgIH1cbiAgICBpZiAodGFpbCA9PT0gMikge1xuICAgICAgbiA9IGJhc2U2NFtpKytdIDw8IDE4O1xuICAgICAgbiArPSBiYXNlNjRbaSsrXSA8PCAxMjtcbiAgICAgIGJ1ZltqXSA9IChuID4+IDE2KSAmIG1hc2tbOF07XG4gICAgfVxuICAgIHJldHVybiBidWY7XG4gIH0sXG4gIC8vIENvbnZlcnRzIGEgYmFzZSA2NCBCdWZmZXIgb2YgYnl0ZXMgdG8gYSBKYXZhU2NyaXB0IHN0cmluZyB3aXRoIGxpbmUgYnJlYWtzLlxuICB0b1N0cmluZyhidWYpIHtcbiAgICBpZiAoYnVmLmxlbmd0aCAlIDQgPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgYmFzZTY0LnRvU3RyaW5nOiBpbnB1dCBidWZmZXIgbGVuZ3RoIG5vdCBtdWx0aXBsZSBvZiA0OiAke2J1Zi5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGxldCBzdHIgPSAnJztcbiAgICBsZXQgbGluZUxlbiA9IDA7XG4gICAgZnVuY3Rpb24gYnVpbGRMaW5lKGMxLCBjMiwgYzMsIGM0KSB7XG4gICAgICBzd2l0Y2ggKGxpbmVMZW4pIHtcbiAgICAgICAgY2FzZSA3NjpcbiAgICAgICAgICBzdHIgKz0gYFxcclxcbiR7YzF9JHtjMn0ke2MzfSR7YzR9YDtcbiAgICAgICAgICBsaW5lTGVuID0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA3NTpcbiAgICAgICAgICBzdHIgKz0gYCR7YzF9XFxyXFxuJHtjMn0ke2MzfSR7YzR9YDtcbiAgICAgICAgICBsaW5lTGVuID0gMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA3NDpcbiAgICAgICAgICBzdHIgKz0gYCR7YzEgKyBjMn1cXHJcXG4ke2MzfSR7YzR9YDtcbiAgICAgICAgICBsaW5lTGVuID0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA3MzpcbiAgICAgICAgICBzdHIgKz0gYCR7YzEgKyBjMiArIGMzfVxcclxcbiR7YzR9YDtcbiAgICAgICAgICBsaW5lTGVuID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzdHIgKz0gYzEgKyBjMiArIGMzICsgYzQ7XG4gICAgICAgICAgbGluZUxlbiArPSA0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShjKSB7XG4gICAgICBpZiAoYyA+PSA2NSAmJiBjIDw9IDkwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGMgPj0gOTcgJiYgYyA8PSAxMjIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoYyA+PSA0OCAmJiBjIDw9IDU3KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDQzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDQ3KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDYxKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCBpICsgNDsgaiArPSAxKSB7XG4gICAgICAgIGlmICghdmFsaWRhdGUoYnVmW2pdKSkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBiYXNlNjQudG9TdHJpbmc6IGJ1Zlske2p9XTogJHtidWZbal19IDogbm90IHZhbGlkIGJhc2U2NCBjaGFyYWN0ZXIgY29kZWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBidWlsZExpbmUoXG4gICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKSxcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaSArIDFdKSxcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaSArIDJdKSxcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaSArIDNdKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfSxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-conv-api/transformers.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-lib/ast.js":
/*!************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/ast.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* eslint-disable guard-for-in */\n/* eslint-disable no-restricted-syntax */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module is used by the parser to build an [Abstract Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) (AST).\n// The AST can be thought of as a subset of the full parse tree.\n// Each node of the AST holds the phrase that was matched at the corresponding, named parse tree node.\n// It is built as the parser successfully matches phrases to the rule names\n// (`RNM` operators) and `UDT`s as it parses an input string.\n// The user controls which `RNM` or `UDT` names to keep on the AST.\n// The user can also associate callback functions with some or all of the retained\n// AST nodes to be used to translate the node phrases. That is, associate semantic\n// actions to the matched phrases.\n// Translating the AST rather that attempting to apply semantic actions during\n// the parsing process, has the advantage that there is no backtracking and that the phrases\n// are known while traversing down tree as will as up.\n//\n// Let `ast` be an `ast.js` object. To identify a node to be kept on the AST:\n// ```\n// ast.callbacks[\"rulename\"] = true; (all nodes default to false)\n// ```\n// To associate a callback function with a node:\n// ```\n// ast.callbacks[\"rulename\"] = fn\n// ```\n// `rulename` is any `RNM` or `UDT` name defined by the associated grammar\n// and `fn` is a user-written callback function.\n// (See [`apg-examples`](https://github.com/ldthomas/apg-js2-examples/tree/master/ast) for examples of how to create an AST,\n// define the nodes and callback functions and attach it to a parser.)\nmodule.exports = function exportsAst() {\n  const id = __webpack_require__(/*! ./identifiers */ \"./node_modules/apg-js/src/apg-lib/identifiers.js\");\n  const utils = __webpack_require__(/*! ./utilities */ \"./node_modules/apg-js/src/apg-lib/utilities.js\");\n\n  const thisFileName = 'ast.js: ';\n  const that = this;\n  let rules = null;\n  let udts = null;\n  let chars = null;\n  let nodeCount = 0;\n  const nodesDefined = [];\n  const nodeCallbacks = [];\n  const stack = [];\n  const records = [];\n  this.callbacks = [];\n  this.astObject = 'astObject';\n  /* called by the parser to initialize the AST with the rules, UDTs and the input characters */\n  this.init = function init(rulesIn, udtsIn, charsIn) {\n    stack.length = 0;\n    records.length = 0;\n    nodesDefined.length = 0;\n    nodeCount = 0;\n    rules = rulesIn;\n    udts = udtsIn;\n    chars = charsIn;\n    let i;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    nodeCount = rules.length + udts.length;\n    for (i = 0; i < nodeCount; i += 1) {\n      nodesDefined[i] = false;\n      nodeCallbacks[i] = null;\n    }\n    for (const index in that.callbacks) {\n      const lower = index.toLowerCase();\n      i = list.indexOf(lower);\n      if (i < 0) {\n        throw new Error(`${thisFileName}init: node '${index}' not a rule or udt name`);\n      }\n      if (typeof that.callbacks[index] === 'function') {\n        nodesDefined[i] = true;\n        nodeCallbacks[i] = that.callbacks[index];\n      }\n      if (that.callbacks[index] === true) {\n        nodesDefined[i] = true;\n      }\n    }\n  };\n  /* AST node definitions - called by the parser's `RNM` operator */\n  this.ruleDefined = function ruleDefined(index) {\n    return nodesDefined[index] !== false;\n  };\n  /* AST node definitions - called by the parser's `UDT` operator */\n  this.udtDefined = function udtDefined(index) {\n    return nodesDefined[rules.length + index] !== false;\n  };\n  /* called by the parser's `RNM` & `UDT` operators */\n  /* builds a record for the downward traversal of the node */\n  this.down = function down(callbackIndex, name) {\n    const thisIndex = records.length;\n    stack.push(thisIndex);\n    records.push({\n      name,\n      thisIndex,\n      thatIndex: null,\n      state: id.SEM_PRE,\n      callbackIndex,\n      phraseIndex: null,\n      phraseLength: null,\n      stack: stack.length,\n    });\n    return thisIndex;\n  };\n  /* called by the parser's `RNM` & `UDT` operators */\n  /* builds a record for the upward traversal of the node */\n  this.up = function up(callbackIndex, name, phraseIndex, phraseLength) {\n    const thisIndex = records.length;\n    const thatIndex = stack.pop();\n    records.push({\n      name,\n      thisIndex,\n      thatIndex,\n      state: id.SEM_POST,\n      callbackIndex,\n      phraseIndex,\n      phraseLength,\n      stack: stack.length,\n    });\n    records[thatIndex].thatIndex = thisIndex;\n    records[thatIndex].phraseIndex = phraseIndex;\n    records[thatIndex].phraseLength = phraseLength;\n    return thisIndex;\n  };\n  // Called by the user to translate the AST.\n  // Translate means to associate or apply some semantic action to the\n  // phrases that were syntactically matched to the AST nodes according\n  // to the defining grammar.\n  // ```\n  // data - optional user-defined data\n  //        passed to the callback functions by the translator\n  // ```\n  this.translate = function translate(data) {\n    let ret;\n    let callback;\n    let record;\n    for (let i = 0; i < records.length; i += 1) {\n      record = records[i];\n      callback = nodeCallbacks[record.callbackIndex];\n      if (record.state === id.SEM_PRE) {\n        if (callback !== null) {\n          ret = callback(id.SEM_PRE, chars, record.phraseIndex, record.phraseLength, data);\n          if (ret === id.SEM_SKIP) {\n            i = record.thatIndex;\n          }\n        }\n      } else if (callback !== null) {\n        callback(id.SEM_POST, chars, record.phraseIndex, record.phraseLength, data);\n      }\n    }\n  };\n  /* called by the parser to reset the length of the records array */\n  /* necessary on backtracking */\n  this.setLength = function setLength(length) {\n    records.length = length;\n    if (length > 0) {\n      stack.length = records[length - 1].stack;\n    } else {\n      stack.length = 0;\n    }\n  };\n  /* called by the parser to get the length of the records array */\n  this.getLength = function getLength() {\n    return records.length;\n  };\n  /* helper for XML display */\n  function indent(n) {\n    let ret = '';\n    for (let i = 0; i < n; i += 1) {\n      ret += ' ';\n    }\n    return ret;\n  }\n  // Generate an `XML` version of the AST.\n  // Useful if you want to use a special or favorite XML parser to translate the\n  // AST.\n  // ```\n  // mode - the display mode of the captured phrases\n  //      - default mode is \"ascii\"\n  //      - can be: \"ascii\"\n  //                \"decimal\"\n  //                \"hexadecimal\"\n  //                \"unicode\"\n  // ```\n  this.toXml = function toSml(modeArg) {\n    let display = utils.charsToDec;\n    let caption = 'decimal integer character codes';\n    if (typeof modeArg === 'string' && modeArg.length >= 3) {\n      const mode = modeArg.slice(0, 3).toLowerCase();\n      if (mode === 'asc') {\n        display = utils.charsToAscii;\n        caption = 'ASCII for printing characters, hex for non-printing';\n      } else if (mode === 'hex') {\n        display = utils.charsToHex;\n        caption = 'hexadecimal integer character codes';\n      } else if (mode === 'uni') {\n        display = utils.charsToUnicode;\n        caption = 'Unicode UTF-32 integer character codes';\n      }\n    }\n    let xml = '';\n    let depth = 0;\n    xml += '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n';\n    xml += `<root nodes=\"${records.length / 2}\" characters=\"${chars.length}\">\\n`;\n    xml += `<!-- input string, ${caption} -->\\n`;\n    xml += indent(depth + 2);\n    xml += display(chars);\n    xml += '\\n';\n    records.forEach((rec) => {\n      if (rec.state === id.SEM_PRE) {\n        depth += 1;\n        xml += indent(depth);\n        xml += `<node name=\"${rec.name}\" index=\"${rec.phraseIndex}\" length=\"${rec.phraseLength}\">\\n`;\n        xml += indent(depth + 2);\n        xml += display(chars, rec.phraseIndex, rec.phraseLength);\n        xml += '\\n';\n      } else {\n        xml += indent(depth);\n        xml += `</node><!-- name=\"${rec.name}\" -->\\n`;\n        depth -= 1;\n      }\n    });\n\n    xml += '</root>\\n';\n    return xml;\n  };\n  /* generate a JavaScript object version of the AST */\n  /* for the phrase-matching engine apg-exp */\n  this.phrases = function phrases() {\n    const obj = {};\n    let i;\n    let record;\n    for (i = 0; i < records.length; i += 1) {\n      record = records[i];\n      if (record.state === id.SEM_PRE) {\n        if (!Array.isArray(obj[record.name])) {\n          obj[record.name] = [];\n        }\n        obj[record.name].push({\n          index: record.phraseIndex,\n          length: record.phraseLength,\n        });\n      }\n    }\n    return obj;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2FzdC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsdUVBQWU7QUFDcEMsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQWE7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWEsY0FBYyxNQUFNO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQixnQkFBZ0IsYUFBYTtBQUMzRSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTLFdBQVcsZ0JBQWdCLFlBQVksaUJBQWlCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1saWIvYXN0LmpzPzdiOTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgZ3VhcmQtZm9yLWluICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLXN5bnRheCAqL1xuLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgaXMgdXNlZCBieSB0aGUgcGFyc2VyIHRvIGJ1aWxkIGFuIFtBYnN0cmFjdCBTeW50YXggVHJlZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQWJzdHJhY3Rfc3ludGF4X3RyZWUpIChBU1QpLlxuLy8gVGhlIEFTVCBjYW4gYmUgdGhvdWdodCBvZiBhcyBhIHN1YnNldCBvZiB0aGUgZnVsbCBwYXJzZSB0cmVlLlxuLy8gRWFjaCBub2RlIG9mIHRoZSBBU1QgaG9sZHMgdGhlIHBocmFzZSB0aGF0IHdhcyBtYXRjaGVkIGF0IHRoZSBjb3JyZXNwb25kaW5nLCBuYW1lZCBwYXJzZSB0cmVlIG5vZGUuXG4vLyBJdCBpcyBidWlsdCBhcyB0aGUgcGFyc2VyIHN1Y2Nlc3NmdWxseSBtYXRjaGVzIHBocmFzZXMgdG8gdGhlIHJ1bGUgbmFtZXNcbi8vIChgUk5NYCBvcGVyYXRvcnMpIGFuZCBgVURUYHMgYXMgaXQgcGFyc2VzIGFuIGlucHV0IHN0cmluZy5cbi8vIFRoZSB1c2VyIGNvbnRyb2xzIHdoaWNoIGBSTk1gIG9yIGBVRFRgIG5hbWVzIHRvIGtlZXAgb24gdGhlIEFTVC5cbi8vIFRoZSB1c2VyIGNhbiBhbHNvIGFzc29jaWF0ZSBjYWxsYmFjayBmdW5jdGlvbnMgd2l0aCBzb21lIG9yIGFsbCBvZiB0aGUgcmV0YWluZWRcbi8vIEFTVCBub2RlcyB0byBiZSB1c2VkIHRvIHRyYW5zbGF0ZSB0aGUgbm9kZSBwaHJhc2VzLiBUaGF0IGlzLCBhc3NvY2lhdGUgc2VtYW50aWNcbi8vIGFjdGlvbnMgdG8gdGhlIG1hdGNoZWQgcGhyYXNlcy5cbi8vIFRyYW5zbGF0aW5nIHRoZSBBU1QgcmF0aGVyIHRoYXQgYXR0ZW1wdGluZyB0byBhcHBseSBzZW1hbnRpYyBhY3Rpb25zIGR1cmluZ1xuLy8gdGhlIHBhcnNpbmcgcHJvY2VzcywgaGFzIHRoZSBhZHZhbnRhZ2UgdGhhdCB0aGVyZSBpcyBubyBiYWNrdHJhY2tpbmcgYW5kIHRoYXQgdGhlIHBocmFzZXNcbi8vIGFyZSBrbm93biB3aGlsZSB0cmF2ZXJzaW5nIGRvd24gdHJlZSBhcyB3aWxsIGFzIHVwLlxuLy9cbi8vIExldCBgYXN0YCBiZSBhbiBgYXN0LmpzYCBvYmplY3QuIFRvIGlkZW50aWZ5IGEgbm9kZSB0byBiZSBrZXB0IG9uIHRoZSBBU1Q6XG4vLyBgYGBcbi8vIGFzdC5jYWxsYmFja3NbXCJydWxlbmFtZVwiXSA9IHRydWU7IChhbGwgbm9kZXMgZGVmYXVsdCB0byBmYWxzZSlcbi8vIGBgYFxuLy8gVG8gYXNzb2NpYXRlIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBhIG5vZGU6XG4vLyBgYGBcbi8vIGFzdC5jYWxsYmFja3NbXCJydWxlbmFtZVwiXSA9IGZuXG4vLyBgYGBcbi8vIGBydWxlbmFtZWAgaXMgYW55IGBSTk1gIG9yIGBVRFRgIG5hbWUgZGVmaW5lZCBieSB0aGUgYXNzb2NpYXRlZCBncmFtbWFyXG4vLyBhbmQgYGZuYCBpcyBhIHVzZXItd3JpdHRlbiBjYWxsYmFjayBmdW5jdGlvbi5cbi8vIChTZWUgW2BhcGctZXhhbXBsZXNgXShodHRwczovL2dpdGh1Yi5jb20vbGR0aG9tYXMvYXBnLWpzMi1leGFtcGxlcy90cmVlL21hc3Rlci9hc3QpIGZvciBleGFtcGxlcyBvZiBob3cgdG8gY3JlYXRlIGFuIEFTVCxcbi8vIGRlZmluZSB0aGUgbm9kZXMgYW5kIGNhbGxiYWNrIGZ1bmN0aW9ucyBhbmQgYXR0YWNoIGl0IHRvIGEgcGFyc2VyLilcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXhwb3J0c0FzdCgpIHtcbiAgY29uc3QgaWQgPSByZXF1aXJlKCcuL2lkZW50aWZpZXJzJyk7XG4gIGNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMnKTtcblxuICBjb25zdCB0aGlzRmlsZU5hbWUgPSAnYXN0LmpzOiAnO1xuICBjb25zdCB0aGF0ID0gdGhpcztcbiAgbGV0IHJ1bGVzID0gbnVsbDtcbiAgbGV0IHVkdHMgPSBudWxsO1xuICBsZXQgY2hhcnMgPSBudWxsO1xuICBsZXQgbm9kZUNvdW50ID0gMDtcbiAgY29uc3Qgbm9kZXNEZWZpbmVkID0gW107XG4gIGNvbnN0IG5vZGVDYWxsYmFja3MgPSBbXTtcbiAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgY29uc3QgcmVjb3JkcyA9IFtdO1xuICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xuICB0aGlzLmFzdE9iamVjdCA9ICdhc3RPYmplY3QnO1xuICAvKiBjYWxsZWQgYnkgdGhlIHBhcnNlciB0byBpbml0aWFsaXplIHRoZSBBU1Qgd2l0aCB0aGUgcnVsZXMsIFVEVHMgYW5kIHRoZSBpbnB1dCBjaGFyYWN0ZXJzICovXG4gIHRoaXMuaW5pdCA9IGZ1bmN0aW9uIGluaXQocnVsZXNJbiwgdWR0c0luLCBjaGFyc0luKSB7XG4gICAgc3RhY2subGVuZ3RoID0gMDtcbiAgICByZWNvcmRzLmxlbmd0aCA9IDA7XG4gICAgbm9kZXNEZWZpbmVkLmxlbmd0aCA9IDA7XG4gICAgbm9kZUNvdW50ID0gMDtcbiAgICBydWxlcyA9IHJ1bGVzSW47XG4gICAgdWR0cyA9IHVkdHNJbjtcbiAgICBjaGFycyA9IGNoYXJzSW47XG4gICAgbGV0IGk7XG4gICAgY29uc3QgbGlzdCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgbGlzdC5wdXNoKHJ1bGVzW2ldLmxvd2VyKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHVkdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGxpc3QucHVzaCh1ZHRzW2ldLmxvd2VyKTtcbiAgICB9XG4gICAgbm9kZUNvdW50ID0gcnVsZXMubGVuZ3RoICsgdWR0cy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IG5vZGVDb3VudDsgaSArPSAxKSB7XG4gICAgICBub2Rlc0RlZmluZWRbaV0gPSBmYWxzZTtcbiAgICAgIG5vZGVDYWxsYmFja3NbaV0gPSBudWxsO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGluZGV4IGluIHRoYXQuY2FsbGJhY2tzKSB7XG4gICAgICBjb25zdCBsb3dlciA9IGluZGV4LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpID0gbGlzdC5pbmRleE9mKGxvd2VyKTtcbiAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWluaXQ6IG5vZGUgJyR7aW5kZXh9JyBub3QgYSBydWxlIG9yIHVkdCBuYW1lYCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoYXQuY2FsbGJhY2tzW2luZGV4XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBub2Rlc0RlZmluZWRbaV0gPSB0cnVlO1xuICAgICAgICBub2RlQ2FsbGJhY2tzW2ldID0gdGhhdC5jYWxsYmFja3NbaW5kZXhdO1xuICAgICAgfVxuICAgICAgaWYgKHRoYXQuY2FsbGJhY2tzW2luZGV4XSA9PT0gdHJ1ZSkge1xuICAgICAgICBub2Rlc0RlZmluZWRbaV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyogQVNUIG5vZGUgZGVmaW5pdGlvbnMgLSBjYWxsZWQgYnkgdGhlIHBhcnNlcidzIGBSTk1gIG9wZXJhdG9yICovXG4gIHRoaXMucnVsZURlZmluZWQgPSBmdW5jdGlvbiBydWxlRGVmaW5lZChpbmRleCkge1xuICAgIHJldHVybiBub2Rlc0RlZmluZWRbaW5kZXhdICE9PSBmYWxzZTtcbiAgfTtcbiAgLyogQVNUIG5vZGUgZGVmaW5pdGlvbnMgLSBjYWxsZWQgYnkgdGhlIHBhcnNlcidzIGBVRFRgIG9wZXJhdG9yICovXG4gIHRoaXMudWR0RGVmaW5lZCA9IGZ1bmN0aW9uIHVkdERlZmluZWQoaW5kZXgpIHtcbiAgICByZXR1cm4gbm9kZXNEZWZpbmVkW3J1bGVzLmxlbmd0aCArIGluZGV4XSAhPT0gZmFsc2U7XG4gIH07XG4gIC8qIGNhbGxlZCBieSB0aGUgcGFyc2VyJ3MgYFJOTWAgJiBgVURUYCBvcGVyYXRvcnMgKi9cbiAgLyogYnVpbGRzIGEgcmVjb3JkIGZvciB0aGUgZG93bndhcmQgdHJhdmVyc2FsIG9mIHRoZSBub2RlICovXG4gIHRoaXMuZG93biA9IGZ1bmN0aW9uIGRvd24oY2FsbGJhY2tJbmRleCwgbmFtZSkge1xuICAgIGNvbnN0IHRoaXNJbmRleCA9IHJlY29yZHMubGVuZ3RoO1xuICAgIHN0YWNrLnB1c2godGhpc0luZGV4KTtcbiAgICByZWNvcmRzLnB1c2goe1xuICAgICAgbmFtZSxcbiAgICAgIHRoaXNJbmRleCxcbiAgICAgIHRoYXRJbmRleDogbnVsbCxcbiAgICAgIHN0YXRlOiBpZC5TRU1fUFJFLFxuICAgICAgY2FsbGJhY2tJbmRleCxcbiAgICAgIHBocmFzZUluZGV4OiBudWxsLFxuICAgICAgcGhyYXNlTGVuZ3RoOiBudWxsLFxuICAgICAgc3RhY2s6IHN0YWNrLmxlbmd0aCxcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpc0luZGV4O1xuICB9O1xuICAvKiBjYWxsZWQgYnkgdGhlIHBhcnNlcidzIGBSTk1gICYgYFVEVGAgb3BlcmF0b3JzICovXG4gIC8qIGJ1aWxkcyBhIHJlY29yZCBmb3IgdGhlIHVwd2FyZCB0cmF2ZXJzYWwgb2YgdGhlIG5vZGUgKi9cbiAgdGhpcy51cCA9IGZ1bmN0aW9uIHVwKGNhbGxiYWNrSW5kZXgsIG5hbWUsIHBocmFzZUluZGV4LCBwaHJhc2VMZW5ndGgpIHtcbiAgICBjb25zdCB0aGlzSW5kZXggPSByZWNvcmRzLmxlbmd0aDtcbiAgICBjb25zdCB0aGF0SW5kZXggPSBzdGFjay5wb3AoKTtcbiAgICByZWNvcmRzLnB1c2goe1xuICAgICAgbmFtZSxcbiAgICAgIHRoaXNJbmRleCxcbiAgICAgIHRoYXRJbmRleCxcbiAgICAgIHN0YXRlOiBpZC5TRU1fUE9TVCxcbiAgICAgIGNhbGxiYWNrSW5kZXgsXG4gICAgICBwaHJhc2VJbmRleCxcbiAgICAgIHBocmFzZUxlbmd0aCxcbiAgICAgIHN0YWNrOiBzdGFjay5sZW5ndGgsXG4gICAgfSk7XG4gICAgcmVjb3Jkc1t0aGF0SW5kZXhdLnRoYXRJbmRleCA9IHRoaXNJbmRleDtcbiAgICByZWNvcmRzW3RoYXRJbmRleF0ucGhyYXNlSW5kZXggPSBwaHJhc2VJbmRleDtcbiAgICByZWNvcmRzW3RoYXRJbmRleF0ucGhyYXNlTGVuZ3RoID0gcGhyYXNlTGVuZ3RoO1xuICAgIHJldHVybiB0aGlzSW5kZXg7XG4gIH07XG4gIC8vIENhbGxlZCBieSB0aGUgdXNlciB0byB0cmFuc2xhdGUgdGhlIEFTVC5cbiAgLy8gVHJhbnNsYXRlIG1lYW5zIHRvIGFzc29jaWF0ZSBvciBhcHBseSBzb21lIHNlbWFudGljIGFjdGlvbiB0byB0aGVcbiAgLy8gcGhyYXNlcyB0aGF0IHdlcmUgc3ludGFjdGljYWxseSBtYXRjaGVkIHRvIHRoZSBBU1Qgbm9kZXMgYWNjb3JkaW5nXG4gIC8vIHRvIHRoZSBkZWZpbmluZyBncmFtbWFyLlxuICAvLyBgYGBcbiAgLy8gZGF0YSAtIG9wdGlvbmFsIHVzZXItZGVmaW5lZCBkYXRhXG4gIC8vICAgICAgICBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucyBieSB0aGUgdHJhbnNsYXRvclxuICAvLyBgYGBcbiAgdGhpcy50cmFuc2xhdGUgPSBmdW5jdGlvbiB0cmFuc2xhdGUoZGF0YSkge1xuICAgIGxldCByZXQ7XG4gICAgbGV0IGNhbGxiYWNrO1xuICAgIGxldCByZWNvcmQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWNvcmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICByZWNvcmQgPSByZWNvcmRzW2ldO1xuICAgICAgY2FsbGJhY2sgPSBub2RlQ2FsbGJhY2tzW3JlY29yZC5jYWxsYmFja0luZGV4XTtcbiAgICAgIGlmIChyZWNvcmQuc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0ID0gY2FsbGJhY2soaWQuU0VNX1BSRSwgY2hhcnMsIHJlY29yZC5waHJhc2VJbmRleCwgcmVjb3JkLnBocmFzZUxlbmd0aCwgZGF0YSk7XG4gICAgICAgICAgaWYgKHJldCA9PT0gaWQuU0VNX1NLSVApIHtcbiAgICAgICAgICAgIGkgPSByZWNvcmQudGhhdEluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICBjYWxsYmFjayhpZC5TRU1fUE9TVCwgY2hhcnMsIHJlY29yZC5waHJhc2VJbmRleCwgcmVjb3JkLnBocmFzZUxlbmd0aCwgZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKiBjYWxsZWQgYnkgdGhlIHBhcnNlciB0byByZXNldCB0aGUgbGVuZ3RoIG9mIHRoZSByZWNvcmRzIGFycmF5ICovXG4gIC8qIG5lY2Vzc2FyeSBvbiBiYWNrdHJhY2tpbmcgKi9cbiAgdGhpcy5zZXRMZW5ndGggPSBmdW5jdGlvbiBzZXRMZW5ndGgobGVuZ3RoKSB7XG4gICAgcmVjb3Jkcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgIHN0YWNrLmxlbmd0aCA9IHJlY29yZHNbbGVuZ3RoIC0gMV0uc3RhY2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YWNrLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9O1xuICAvKiBjYWxsZWQgYnkgdGhlIHBhcnNlciB0byBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgcmVjb3JkcyBhcnJheSAqL1xuICB0aGlzLmdldExlbmd0aCA9IGZ1bmN0aW9uIGdldExlbmd0aCgpIHtcbiAgICByZXR1cm4gcmVjb3Jkcy5sZW5ndGg7XG4gIH07XG4gIC8qIGhlbHBlciBmb3IgWE1MIGRpc3BsYXkgKi9cbiAgZnVuY3Rpb24gaW5kZW50KG4pIHtcbiAgICBsZXQgcmV0ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpICs9IDEpIHtcbiAgICAgIHJldCArPSAnICc7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgLy8gR2VuZXJhdGUgYW4gYFhNTGAgdmVyc2lvbiBvZiB0aGUgQVNULlxuICAvLyBVc2VmdWwgaWYgeW91IHdhbnQgdG8gdXNlIGEgc3BlY2lhbCBvciBmYXZvcml0ZSBYTUwgcGFyc2VyIHRvIHRyYW5zbGF0ZSB0aGVcbiAgLy8gQVNULlxuICAvLyBgYGBcbiAgLy8gbW9kZSAtIHRoZSBkaXNwbGF5IG1vZGUgb2YgdGhlIGNhcHR1cmVkIHBocmFzZXNcbiAgLy8gICAgICAtIGRlZmF1bHQgbW9kZSBpcyBcImFzY2lpXCJcbiAgLy8gICAgICAtIGNhbiBiZTogXCJhc2NpaVwiXG4gIC8vICAgICAgICAgICAgICAgIFwiZGVjaW1hbFwiXG4gIC8vICAgICAgICAgICAgICAgIFwiaGV4YWRlY2ltYWxcIlxuICAvLyAgICAgICAgICAgICAgICBcInVuaWNvZGVcIlxuICAvLyBgYGBcbiAgdGhpcy50b1htbCA9IGZ1bmN0aW9uIHRvU21sKG1vZGVBcmcpIHtcbiAgICBsZXQgZGlzcGxheSA9IHV0aWxzLmNoYXJzVG9EZWM7XG4gICAgbGV0IGNhcHRpb24gPSAnZGVjaW1hbCBpbnRlZ2VyIGNoYXJhY3RlciBjb2Rlcyc7XG4gICAgaWYgKHR5cGVvZiBtb2RlQXJnID09PSAnc3RyaW5nJyAmJiBtb2RlQXJnLmxlbmd0aCA+PSAzKSB7XG4gICAgICBjb25zdCBtb2RlID0gbW9kZUFyZy5zbGljZSgwLCAzKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKG1vZGUgPT09ICdhc2MnKSB7XG4gICAgICAgIGRpc3BsYXkgPSB1dGlscy5jaGFyc1RvQXNjaWk7XG4gICAgICAgIGNhcHRpb24gPSAnQVNDSUkgZm9yIHByaW50aW5nIGNoYXJhY3RlcnMsIGhleCBmb3Igbm9uLXByaW50aW5nJztcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2hleCcpIHtcbiAgICAgICAgZGlzcGxheSA9IHV0aWxzLmNoYXJzVG9IZXg7XG4gICAgICAgIGNhcHRpb24gPSAnaGV4YWRlY2ltYWwgaW50ZWdlciBjaGFyYWN0ZXIgY29kZXMnO1xuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAndW5pJykge1xuICAgICAgICBkaXNwbGF5ID0gdXRpbHMuY2hhcnNUb1VuaWNvZGU7XG4gICAgICAgIGNhcHRpb24gPSAnVW5pY29kZSBVVEYtMzIgaW50ZWdlciBjaGFyYWN0ZXIgY29kZXMnO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgeG1sID0gJyc7XG4gICAgbGV0IGRlcHRoID0gMDtcbiAgICB4bWwgKz0gJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cInV0Zi04XCI/Plxcbic7XG4gICAgeG1sICs9IGA8cm9vdCBub2Rlcz1cIiR7cmVjb3Jkcy5sZW5ndGggLyAyfVwiIGNoYXJhY3RlcnM9XCIke2NoYXJzLmxlbmd0aH1cIj5cXG5gO1xuICAgIHhtbCArPSBgPCEtLSBpbnB1dCBzdHJpbmcsICR7Y2FwdGlvbn0gLS0+XFxuYDtcbiAgICB4bWwgKz0gaW5kZW50KGRlcHRoICsgMik7XG4gICAgeG1sICs9IGRpc3BsYXkoY2hhcnMpO1xuICAgIHhtbCArPSAnXFxuJztcbiAgICByZWNvcmRzLmZvckVhY2goKHJlYykgPT4ge1xuICAgICAgaWYgKHJlYy5zdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgICBkZXB0aCArPSAxO1xuICAgICAgICB4bWwgKz0gaW5kZW50KGRlcHRoKTtcbiAgICAgICAgeG1sICs9IGA8bm9kZSBuYW1lPVwiJHtyZWMubmFtZX1cIiBpbmRleD1cIiR7cmVjLnBocmFzZUluZGV4fVwiIGxlbmd0aD1cIiR7cmVjLnBocmFzZUxlbmd0aH1cIj5cXG5gO1xuICAgICAgICB4bWwgKz0gaW5kZW50KGRlcHRoICsgMik7XG4gICAgICAgIHhtbCArPSBkaXNwbGF5KGNoYXJzLCByZWMucGhyYXNlSW5kZXgsIHJlYy5waHJhc2VMZW5ndGgpO1xuICAgICAgICB4bWwgKz0gJ1xcbic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4bWwgKz0gaW5kZW50KGRlcHRoKTtcbiAgICAgICAgeG1sICs9IGA8L25vZGU+PCEtLSBuYW1lPVwiJHtyZWMubmFtZX1cIiAtLT5cXG5gO1xuICAgICAgICBkZXB0aCAtPSAxO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgeG1sICs9ICc8L3Jvb3Q+XFxuJztcbiAgICByZXR1cm4geG1sO1xuICB9O1xuICAvKiBnZW5lcmF0ZSBhIEphdmFTY3JpcHQgb2JqZWN0IHZlcnNpb24gb2YgdGhlIEFTVCAqL1xuICAvKiBmb3IgdGhlIHBocmFzZS1tYXRjaGluZyBlbmdpbmUgYXBnLWV4cCAqL1xuICB0aGlzLnBocmFzZXMgPSBmdW5jdGlvbiBwaHJhc2VzKCkge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIGxldCBpO1xuICAgIGxldCByZWNvcmQ7XG4gICAgZm9yIChpID0gMDsgaSA8IHJlY29yZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHJlY29yZCA9IHJlY29yZHNbaV07XG4gICAgICBpZiAocmVjb3JkLnN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmpbcmVjb3JkLm5hbWVdKSkge1xuICAgICAgICAgIG9ialtyZWNvcmQubmFtZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBvYmpbcmVjb3JkLm5hbWVdLnB1c2goe1xuICAgICAgICAgIGluZGV4OiByZWNvcmQucGhyYXNlSW5kZXgsXG4gICAgICAgICAgbGVuZ3RoOiByZWNvcmQucGhyYXNlTGVuZ3RoLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-lib/ast.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-lib/circular-buffer.js":
/*!************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/circular-buffer.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module acts as a \"circular buffer\". It is used to keep track\n// only the last N records in an array of records. If more than N records\n// are saved, each additional record overwrites the previously oldest record.\n// This module deals only with the record indexes and does not save\n// any actual records. It is used by [`trace.js`](./trace.html) for limiting the number of\n// trace records saved.\nmodule.exports = function exportsCircularBuffer() {\n  'use strict;';\n\n  const thisFileName = 'circular-buffer.js: ';\n  let itemIndex = -1;\n  let maxListSize = 0;\n  // Initialize buffer.<br>\n  // *size* is `maxListSize`, the maximum number of records saved before overwriting begins.\n  this.init = function init(size) {\n    if (typeof size !== 'number' || size <= 0) {\n      throw new Error(`${thisFileName}init: circular buffer size must an integer > 0`);\n    }\n    maxListSize = Math.ceil(size);\n    itemIndex = -1;\n  };\n  // Call this to increment the number of records collected.<br>\n  // Returns the array index number to store the next record in.\n  this.increment = function increment() {\n    itemIndex += 1;\n    return (itemIndex + maxListSize) % maxListSize;\n  };\n  // Returns `maxListSize` - the maximum number of records to keep in the buffer.\n  this.maxSize = function maxSize() {\n    return maxListSize;\n  };\n  // Returns the highest number of items saved.<br>\n  // (The number of items is the actual number of records processed\n  // even though only `maxListSize` records are actually retained.)\n  this.items = function items() {\n    return itemIndex + 1;\n  };\n  // Returns the record number associated with this item index.\n  this.getListIndex = function getListIndex(item) {\n    if (itemIndex === -1) {\n      return -1;\n    }\n    if (item < 0 || item > itemIndex) {\n      return -1;\n    }\n    if (itemIndex - item >= maxListSize) {\n      return -1;\n    }\n    return (item + maxListSize) % maxListSize;\n  };\n  // The iterator over the circular buffer.\n  // The user's function, `fn`, will be called with arguments `fn(listIndex, itemIndex)`\n  // where `listIndex` is the saved record index and `itemIndex` is the actual item index.\n  this.forEach = function forEach(fn) {\n    if (itemIndex === -1) {\n      /* no records have been collected */\n      return;\n    }\n    if (itemIndex < maxListSize) {\n      /* fewer than maxListSize records have been collected - number of items = number of records */\n      for (let i = 0; i <= itemIndex; i += 1) {\n        fn(i, i);\n      }\n      return;\n    }\n    /* start with the oldest record saved and finish with the most recent record saved */\n    for (let i = itemIndex - maxListSize + 1; i <= itemIndex; i += 1) {\n      const listIndex = (i + maxListSize) % maxListSize;\n      fn(listIndex, i);\n    }\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2NpcmN1bGFyLWJ1ZmZlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdCQUFnQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1saWIvY2lyY3VsYXItYnVmZmVyLmpzPzFiYzciXSwic291cmNlc0NvbnRlbnQiOlsiLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgYWN0cyBhcyBhIFwiY2lyY3VsYXIgYnVmZmVyXCIuIEl0IGlzIHVzZWQgdG8ga2VlcCB0cmFja1xuLy8gb25seSB0aGUgbGFzdCBOIHJlY29yZHMgaW4gYW4gYXJyYXkgb2YgcmVjb3Jkcy4gSWYgbW9yZSB0aGFuIE4gcmVjb3Jkc1xuLy8gYXJlIHNhdmVkLCBlYWNoIGFkZGl0aW9uYWwgcmVjb3JkIG92ZXJ3cml0ZXMgdGhlIHByZXZpb3VzbHkgb2xkZXN0IHJlY29yZC5cbi8vIFRoaXMgbW9kdWxlIGRlYWxzIG9ubHkgd2l0aCB0aGUgcmVjb3JkIGluZGV4ZXMgYW5kIGRvZXMgbm90IHNhdmVcbi8vIGFueSBhY3R1YWwgcmVjb3Jkcy4gSXQgaXMgdXNlZCBieSBbYHRyYWNlLmpzYF0oLi90cmFjZS5odG1sKSBmb3IgbGltaXRpbmcgdGhlIG51bWJlciBvZlxuLy8gdHJhY2UgcmVjb3JkcyBzYXZlZC5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXhwb3J0c0NpcmN1bGFyQnVmZmVyKCkge1xuICAndXNlIHN0cmljdDsnO1xuXG4gIGNvbnN0IHRoaXNGaWxlTmFtZSA9ICdjaXJjdWxhci1idWZmZXIuanM6ICc7XG4gIGxldCBpdGVtSW5kZXggPSAtMTtcbiAgbGV0IG1heExpc3RTaXplID0gMDtcbiAgLy8gSW5pdGlhbGl6ZSBidWZmZXIuPGJyPlxuICAvLyAqc2l6ZSogaXMgYG1heExpc3RTaXplYCwgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJlY29yZHMgc2F2ZWQgYmVmb3JlIG92ZXJ3cml0aW5nIGJlZ2lucy5cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24gaW5pdChzaXplKSB7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJyB8fCBzaXplIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9aW5pdDogY2lyY3VsYXIgYnVmZmVyIHNpemUgbXVzdCBhbiBpbnRlZ2VyID4gMGApO1xuICAgIH1cbiAgICBtYXhMaXN0U2l6ZSA9IE1hdGguY2VpbChzaXplKTtcbiAgICBpdGVtSW5kZXggPSAtMTtcbiAgfTtcbiAgLy8gQ2FsbCB0aGlzIHRvIGluY3JlbWVudCB0aGUgbnVtYmVyIG9mIHJlY29yZHMgY29sbGVjdGVkLjxicj5cbiAgLy8gUmV0dXJucyB0aGUgYXJyYXkgaW5kZXggbnVtYmVyIHRvIHN0b3JlIHRoZSBuZXh0IHJlY29yZCBpbi5cbiAgdGhpcy5pbmNyZW1lbnQgPSBmdW5jdGlvbiBpbmNyZW1lbnQoKSB7XG4gICAgaXRlbUluZGV4ICs9IDE7XG4gICAgcmV0dXJuIChpdGVtSW5kZXggKyBtYXhMaXN0U2l6ZSkgJSBtYXhMaXN0U2l6ZTtcbiAgfTtcbiAgLy8gUmV0dXJucyBgbWF4TGlzdFNpemVgIC0gdGhlIG1heGltdW0gbnVtYmVyIG9mIHJlY29yZHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLlxuICB0aGlzLm1heFNpemUgPSBmdW5jdGlvbiBtYXhTaXplKCkge1xuICAgIHJldHVybiBtYXhMaXN0U2l6ZTtcbiAgfTtcbiAgLy8gUmV0dXJucyB0aGUgaGlnaGVzdCBudW1iZXIgb2YgaXRlbXMgc2F2ZWQuPGJyPlxuICAvLyAoVGhlIG51bWJlciBvZiBpdGVtcyBpcyB0aGUgYWN0dWFsIG51bWJlciBvZiByZWNvcmRzIHByb2Nlc3NlZFxuICAvLyBldmVuIHRob3VnaCBvbmx5IGBtYXhMaXN0U2l6ZWAgcmVjb3JkcyBhcmUgYWN0dWFsbHkgcmV0YWluZWQuKVxuICB0aGlzLml0ZW1zID0gZnVuY3Rpb24gaXRlbXMoKSB7XG4gICAgcmV0dXJuIGl0ZW1JbmRleCArIDE7XG4gIH07XG4gIC8vIFJldHVybnMgdGhlIHJlY29yZCBudW1iZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaXRlbSBpbmRleC5cbiAgdGhpcy5nZXRMaXN0SW5kZXggPSBmdW5jdGlvbiBnZXRMaXN0SW5kZXgoaXRlbSkge1xuICAgIGlmIChpdGVtSW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChpdGVtIDwgMCB8fCBpdGVtID4gaXRlbUluZGV4KSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChpdGVtSW5kZXggLSBpdGVtID49IG1heExpc3RTaXplKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHJldHVybiAoaXRlbSArIG1heExpc3RTaXplKSAlIG1heExpc3RTaXplO1xuICB9O1xuICAvLyBUaGUgaXRlcmF0b3Igb3ZlciB0aGUgY2lyY3VsYXIgYnVmZmVyLlxuICAvLyBUaGUgdXNlcidzIGZ1bmN0aW9uLCBgZm5gLCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFyZ3VtZW50cyBgZm4obGlzdEluZGV4LCBpdGVtSW5kZXgpYFxuICAvLyB3aGVyZSBgbGlzdEluZGV4YCBpcyB0aGUgc2F2ZWQgcmVjb3JkIGluZGV4IGFuZCBgaXRlbUluZGV4YCBpcyB0aGUgYWN0dWFsIGl0ZW0gaW5kZXguXG4gIHRoaXMuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgICBpZiAoaXRlbUluZGV4ID09PSAtMSkge1xuICAgICAgLyogbm8gcmVjb3JkcyBoYXZlIGJlZW4gY29sbGVjdGVkICovXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpdGVtSW5kZXggPCBtYXhMaXN0U2l6ZSkge1xuICAgICAgLyogZmV3ZXIgdGhhbiBtYXhMaXN0U2l6ZSByZWNvcmRzIGhhdmUgYmVlbiBjb2xsZWN0ZWQgLSBudW1iZXIgb2YgaXRlbXMgPSBudW1iZXIgb2YgcmVjb3JkcyAqL1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gaXRlbUluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgZm4oaSwgaSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qIHN0YXJ0IHdpdGggdGhlIG9sZGVzdCByZWNvcmQgc2F2ZWQgYW5kIGZpbmlzaCB3aXRoIHRoZSBtb3N0IHJlY2VudCByZWNvcmQgc2F2ZWQgKi9cbiAgICBmb3IgKGxldCBpID0gaXRlbUluZGV4IC0gbWF4TGlzdFNpemUgKyAxOyBpIDw9IGl0ZW1JbmRleDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBsaXN0SW5kZXggPSAoaSArIG1heExpc3RTaXplKSAlIG1heExpc3RTaXplO1xuICAgICAgZm4obGlzdEluZGV4LCBpKTtcbiAgICB9XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-lib/circular-buffer.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-lib/emitcss.js":
/*!****************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/emitcss.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// This module has been developed programmatically in the `apg-lib` build process.\n// It is used to build web pages programatically on the fly without the need for <script> or <style> tags.\n\nmodule.exports = function emittcss(){\nreturn '/* This file automatically generated by jsonToless() and LESS. */\\n.apg-mono {\\n  font-family: monospace;\\n}\\n.apg-active {\\n  font-weight: bold;\\n  color: #000000;\\n}\\n.apg-match {\\n  font-weight: bold;\\n  color: #264BFF;\\n}\\n.apg-empty {\\n  font-weight: bold;\\n  color: #0fbd0f;\\n}\\n.apg-nomatch {\\n  font-weight: bold;\\n  color: #FF4000;\\n}\\n.apg-lh-match {\\n  font-weight: bold;\\n  color: #1A97BA;\\n}\\n.apg-lb-match {\\n  font-weight: bold;\\n  color: #5F1687;\\n}\\n.apg-remainder {\\n  font-weight: bold;\\n  color: #999999;\\n}\\n.apg-ctrl-char {\\n  font-weight: bolder;\\n  font-style: italic;\\n  font-size: 0.6em;\\n}\\n.apg-line-end {\\n  font-weight: bold;\\n  color: #000000;\\n}\\n.apg-error {\\n  font-weight: bold;\\n  color: #FF4000;\\n}\\n.apg-phrase {\\n  color: #000000;\\n  background-color: #8caae6;\\n}\\n.apg-empty-phrase {\\n  color: #0fbd0f;\\n}\\ntable.apg-state {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: left;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-state th,\\ntable.apg-state td {\\n  text-align: left;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-state th:nth-last-child(2),\\ntable.apg-state td:nth-last-child(2) {\\n  text-align: right;\\n}\\ntable.apg-state caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-stats {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-stats th,\\ntable.apg-stats td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-stats caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-trace {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-trace caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-trace th,\\ntable.apg-trace td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-trace th:last-child,\\ntable.apg-trace th:nth-last-child(2),\\ntable.apg-trace td:last-child,\\ntable.apg-trace td:nth-last-child(2) {\\n  text-align: left;\\n}\\ntable.apg-grammar {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-grammar caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-grammar th,\\ntable.apg-grammar td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-grammar th:last-child,\\ntable.apg-grammar td:last-child {\\n  text-align: left;\\n}\\ntable.apg-rules {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-rules caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-rules th,\\ntable.apg-rules td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-rules a {\\n  color: #003399 !important;\\n}\\ntable.apg-rules a:hover {\\n  color: #8caae6 !important;\\n}\\ntable.apg-attrs {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: center;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-attrs caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-attrs th,\\ntable.apg-attrs td {\\n  text-align: center;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-attrs th:nth-child(1),\\ntable.apg-attrs th:nth-child(2),\\ntable.apg-attrs th:nth-child(3) {\\n  text-align: right;\\n}\\ntable.apg-attrs td:nth-child(1),\\ntable.apg-attrs td:nth-child(2),\\ntable.apg-attrs td:nth-child(3) {\\n  text-align: right;\\n}\\ntable.apg-attrs a {\\n  color: #003399 !important;\\n}\\ntable.apg-attrs a:hover {\\n  color: #8caae6 !important;\\n}\\n';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2VtaXRjc3MuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBLHNGQUFzRiwyQkFBMkIsR0FBRyxlQUFlLHNCQUFzQixtQkFBbUIsR0FBRyxjQUFjLHNCQUFzQixtQkFBbUIsR0FBRyxjQUFjLHNCQUFzQixtQkFBbUIsR0FBRyxnQkFBZ0Isc0JBQXNCLG1CQUFtQixHQUFHLGlCQUFpQixzQkFBc0IsbUJBQW1CLEdBQUcsaUJBQWlCLHNCQUFzQixtQkFBbUIsR0FBRyxrQkFBa0Isc0JBQXNCLG1CQUFtQixHQUFHLGtCQUFrQix3QkFBd0IsdUJBQXVCLHFCQUFxQixHQUFHLGlCQUFpQixzQkFBc0IsbUJBQW1CLEdBQUcsY0FBYyxzQkFBc0IsbUJBQW1CLEdBQUcsZUFBZSxtQkFBbUIsOEJBQThCLEdBQUcscUJBQXFCLG1CQUFtQixHQUFHLG1CQUFtQiwyQkFBMkIsb0JBQW9CLG9CQUFvQixzQkFBc0IscUJBQXFCLDRCQUE0Qiw4QkFBOEIsR0FBRywyQ0FBMkMscUJBQXFCLDRCQUE0Qiw4QkFBOEIsR0FBRywrRUFBK0Usc0JBQXNCLEdBQUcsMkJBQTJCLG9CQUFvQixzQkFBc0Isc0JBQXNCLHFCQUFxQixHQUFHLG1CQUFtQiwyQkFBMkIsb0JBQW9CLG9CQUFvQixzQkFBc0Isc0JBQXNCLDRCQUE0Qiw4QkFBOEIsR0FBRywyQ0FBMkMsc0JBQXNCLDRCQUE0Qiw4QkFBOEIsR0FBRywyQkFBMkIsb0JBQW9CLHNCQUFzQixzQkFBc0IscUJBQXFCLEdBQUcsbUJBQW1CLDJCQUEyQixvQkFBb0Isb0JBQW9CLHNCQUFzQixzQkFBc0IsNEJBQTRCLDhCQUE4QixHQUFHLDJCQUEyQixvQkFBb0Isc0JBQXNCLHNCQUFzQixxQkFBcUIsR0FBRywyQ0FBMkMsc0JBQXNCLDRCQUE0Qiw4QkFBOEIsR0FBRywrSUFBK0kscUJBQXFCLEdBQUcscUJBQXFCLDJCQUEyQixvQkFBb0Isb0JBQW9CLHNCQUFzQixzQkFBc0IsNEJBQTRCLDhCQUE4QixHQUFHLDZCQUE2QixvQkFBb0Isc0JBQXNCLHNCQUFzQixxQkFBcUIsR0FBRywrQ0FBK0Msc0JBQXNCLDRCQUE0Qiw4QkFBOEIsR0FBRyxxRUFBcUUscUJBQXFCLEdBQUcsbUJBQW1CLDJCQUEyQixvQkFBb0Isb0JBQW9CLHNCQUFzQixzQkFBc0IsNEJBQTRCLDhCQUE4QixHQUFHLDJCQUEyQixvQkFBb0Isc0JBQXNCLHNCQUFzQixxQkFBcUIsR0FBRywyQ0FBMkMsc0JBQXNCLDRCQUE0Qiw4QkFBOEIsR0FBRyxxQkFBcUIsOEJBQThCLEdBQUcsMkJBQTJCLDhCQUE4QixHQUFHLG1CQUFtQiwyQkFBMkIsb0JBQW9CLG9CQUFvQixzQkFBc0IsdUJBQXVCLDRCQUE0Qiw4QkFBOEIsR0FBRywyQkFBMkIsb0JBQW9CLHNCQUFzQixzQkFBc0IscUJBQXFCLEdBQUcsMkNBQTJDLHVCQUF1Qiw0QkFBNEIsOEJBQThCLEdBQUcsdUdBQXVHLHNCQUFzQixHQUFHLHVHQUF1RyxzQkFBc0IsR0FBRyxxQkFBcUIsOEJBQThCLEdBQUcsMkJBQTJCLDhCQUE4QixHQUFHO0FBQzdzSSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2VtaXRjc3MuanM/ZjI2OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIG1vZHVsZSBoYXMgYmVlbiBkZXZlbG9wZWQgcHJvZ3JhbW1hdGljYWxseSBpbiB0aGUgYGFwZy1saWJgIGJ1aWxkIHByb2Nlc3MuXG4vLyBJdCBpcyB1c2VkIHRvIGJ1aWxkIHdlYiBwYWdlcyBwcm9ncmFtYXRpY2FsbHkgb24gdGhlIGZseSB3aXRob3V0IHRoZSBuZWVkIGZvciA8c2NyaXB0PiBvciA8c3R5bGU+IHRhZ3MuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW1pdHRjc3MoKXtcbnJldHVybiAnLyogVGhpcyBmaWxlIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IGpzb25Ub2xlc3MoKSBhbmQgTEVTUy4gKi9cXG4uYXBnLW1vbm8ge1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG59XFxuLmFwZy1hY3RpdmUge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBjb2xvcjogIzAwMDAwMDtcXG59XFxuLmFwZy1tYXRjaCB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGNvbG9yOiAjMjY0QkZGO1xcbn1cXG4uYXBnLWVtcHR5IHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgY29sb3I6ICMwZmJkMGY7XFxufVxcbi5hcGctbm9tYXRjaCB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGNvbG9yOiAjRkY0MDAwO1xcbn1cXG4uYXBnLWxoLW1hdGNoIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgY29sb3I6ICMxQTk3QkE7XFxufVxcbi5hcGctbGItbWF0Y2gge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBjb2xvcjogIzVGMTY4NztcXG59XFxuLmFwZy1yZW1haW5kZXIge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBjb2xvcjogIzk5OTk5OTtcXG59XFxuLmFwZy1jdHJsLWNoYXIge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcXG4gIGZvbnQtc3R5bGU6IGl0YWxpYztcXG4gIGZvbnQtc2l6ZTogMC42ZW07XFxufVxcbi5hcGctbGluZS1lbmQge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBjb2xvcjogIzAwMDAwMDtcXG59XFxuLmFwZy1lcnJvciB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGNvbG9yOiAjRkY0MDAwO1xcbn1cXG4uYXBnLXBocmFzZSB7XFxuICBjb2xvcjogIzAwMDAwMDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICM4Y2FhZTY7XFxufVxcbi5hcGctZW1wdHktcGhyYXNlIHtcXG4gIGNvbG9yOiAjMGZiZDBmO1xcbn1cXG50YWJsZS5hcGctc3RhdGUge1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gIG1hcmdpbi10b3A6IDVweDtcXG4gIGZvbnQtc2l6ZTogMTFweDtcXG4gIGxpbmUtaGVpZ2h0OiAxMzAlO1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG59XFxudGFibGUuYXBnLXN0YXRlIHRoLFxcbnRhYmxlLmFwZy1zdGF0ZSB0ZCB7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG50YWJsZS5hcGctc3RhdGUgdGg6bnRoLWxhc3QtY2hpbGQoMiksXFxudGFibGUuYXBnLXN0YXRlIHRkOm50aC1sYXN0LWNoaWxkKDIpIHtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbn1cXG50YWJsZS5hcGctc3RhdGUgY2FwdGlvbiB7XFxuICBmb250LXNpemU6IDEyNSU7XFxuICBsaW5lLWhlaWdodDogMTMwJTtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxudGFibGUuYXBnLXN0YXRzIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxuICBtYXJnaW4tdG9wOiA1cHg7XFxuICBmb250LXNpemU6IDExcHg7XFxuICBsaW5lLWhlaWdodDogMTMwJTtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG50YWJsZS5hcGctc3RhdHMgdGgsXFxudGFibGUuYXBnLXN0YXRzIHRkIHtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG50YWJsZS5hcGctc3RhdHMgY2FwdGlvbiB7XFxuICBmb250LXNpemU6IDEyNSU7XFxuICBsaW5lLWhlaWdodDogMTMwJTtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxudGFibGUuYXBnLXRyYWNlIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxuICBtYXJnaW4tdG9wOiA1cHg7XFxuICBmb250LXNpemU6IDExcHg7XFxuICBsaW5lLWhlaWdodDogMTMwJTtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG50YWJsZS5hcGctdHJhY2UgY2FwdGlvbiB7XFxuICBmb250LXNpemU6IDEyNSU7XFxuICBsaW5lLWhlaWdodDogMTMwJTtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxudGFibGUuYXBnLXRyYWNlIHRoLFxcbnRhYmxlLmFwZy10cmFjZSB0ZCB7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG59XFxudGFibGUuYXBnLXRyYWNlIHRoOmxhc3QtY2hpbGQsXFxudGFibGUuYXBnLXRyYWNlIHRoOm50aC1sYXN0LWNoaWxkKDIpLFxcbnRhYmxlLmFwZy10cmFjZSB0ZDpsYXN0LWNoaWxkLFxcbnRhYmxlLmFwZy10cmFjZSB0ZDpudGgtbGFzdC1jaGlsZCgyKSB7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbn1cXG50YWJsZS5hcGctZ3JhbW1hciB7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbiAgbWFyZ2luLXRvcDogNXB4O1xcbiAgZm9udC1zaXplOiAxMXB4O1xcbiAgbGluZS1oZWlnaHQ6IDEzMCU7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG59XFxudGFibGUuYXBnLWdyYW1tYXIgY2FwdGlvbiB7XFxuICBmb250LXNpemU6IDEyNSU7XFxuICBsaW5lLWhlaWdodDogMTMwJTtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxudGFibGUuYXBnLWdyYW1tYXIgdGgsXFxudGFibGUuYXBnLWdyYW1tYXIgdGQge1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxufVxcbnRhYmxlLmFwZy1ncmFtbWFyIHRoOmxhc3QtY2hpbGQsXFxudGFibGUuYXBnLWdyYW1tYXIgdGQ6bGFzdC1jaGlsZCB7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbn1cXG50YWJsZS5hcGctcnVsZXMge1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gIG1hcmdpbi10b3A6IDVweDtcXG4gIGZvbnQtc2l6ZTogMTFweDtcXG4gIGxpbmUtaGVpZ2h0OiAxMzAlO1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxufVxcbnRhYmxlLmFwZy1ydWxlcyBjYXB0aW9uIHtcXG4gIGZvbnQtc2l6ZTogMTI1JTtcXG4gIGxpbmUtaGVpZ2h0OiAxMzAlO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbn1cXG50YWJsZS5hcGctcnVsZXMgdGgsXFxudGFibGUuYXBnLXJ1bGVzIHRkIHtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG50YWJsZS5hcGctcnVsZXMgYSB7XFxuICBjb2xvcjogIzAwMzM5OSAhaW1wb3J0YW50O1xcbn1cXG50YWJsZS5hcGctcnVsZXMgYTpob3ZlciB7XFxuICBjb2xvcjogIzhjYWFlNiAhaW1wb3J0YW50O1xcbn1cXG50YWJsZS5hcGctYXR0cnMge1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gIG1hcmdpbi10b3A6IDVweDtcXG4gIGZvbnQtc2l6ZTogMTFweDtcXG4gIGxpbmUtaGVpZ2h0OiAxMzAlO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG50YWJsZS5hcGctYXR0cnMgY2FwdGlvbiB7XFxuICBmb250LXNpemU6IDEyNSU7XFxuICBsaW5lLWhlaWdodDogMTMwJTtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxudGFibGUuYXBnLWF0dHJzIHRoLFxcbnRhYmxlLmFwZy1hdHRycyB0ZCB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxufVxcbnRhYmxlLmFwZy1hdHRycyB0aDpudGgtY2hpbGQoMSksXFxudGFibGUuYXBnLWF0dHJzIHRoOm50aC1jaGlsZCgyKSxcXG50YWJsZS5hcGctYXR0cnMgdGg6bnRoLWNoaWxkKDMpIHtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbn1cXG50YWJsZS5hcGctYXR0cnMgdGQ6bnRoLWNoaWxkKDEpLFxcbnRhYmxlLmFwZy1hdHRycyB0ZDpudGgtY2hpbGQoMiksXFxudGFibGUuYXBnLWF0dHJzIHRkOm50aC1jaGlsZCgzKSB7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG59XFxudGFibGUuYXBnLWF0dHJzIGEge1xcbiAgY29sb3I6ICMwMDMzOTkgIWltcG9ydGFudDtcXG59XFxudGFibGUuYXBnLWF0dHJzIGE6aG92ZXIge1xcbiAgY29sb3I6ICM4Y2FhZTYgIWltcG9ydGFudDtcXG59XFxuJztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-lib/emitcss.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-lib/identifiers.js":
/*!********************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/identifiers.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module exposes a list of named identifiers, shared across the parser generator\n// and the parsers that are generated.\n\nmodule.exports = {\n  // Identifies the operator type. Used by the generator\n  // to indicate operator types in the grammar object.\n  // Used by the [parser](./parser.html) when interpreting the grammar object.\n  /* the original ABNF operators */\n  ALT: 1 /* alternation */,\n  CAT: 2 /* concatenation */,\n  REP: 3 /* repetition */,\n  RNM: 4 /* rule name */,\n  TRG: 5 /* terminal range */,\n  TBS: 6 /* terminal binary string, case sensitive */,\n  TLS: 7 /* terminal literal string, case insensitive */,\n  /* the super set, SABNF operators */\n  UDT: 11 /* user-defined terminal */,\n  AND: 12 /* positive look ahead */,\n  NOT: 13 /* negative look ahead */,\n  BKR: 14 /* back reference to a previously matched rule name */,\n  BKA: 15 /* positive look behind */,\n  BKN: 16 /* negative look behind */,\n  ABG: 17 /* anchor - begin of string */,\n  AEN: 18 /* anchor - end of string */,\n  // Used by the parser and the user's `RNM` and `UDT` callback functions.\n  // Identifies the parser state as it traverses the parse tree nodes.\n  // - *ACTIVE* - indicates the downward direction through the parse tree node.\n  // - *MATCH* - indicates the upward direction and a phrase, of length \\> 0, has been successfully matched\n  // - *EMPTY* - indicates the upward direction and a phrase, of length = 0, has been successfully matched\n  // - *NOMATCH* - indicates the upward direction and the parser failed to match any phrase at all\n  ACTIVE: 100,\n  MATCH: 101,\n  EMPTY: 102,\n  NOMATCH: 103,\n  // Used by [`AST` translator](./ast.html) (semantic analysis) and the user's callback functions\n  // to indicate the direction of flow through the `AST` nodes.\n  // - *SEM_PRE* - indicates the downward (pre-branch) direction through the `AST` node.\n  // - *SEM_POST* - indicates the upward (post-branch) direction through the `AST` node.\n  SEM_PRE: 200,\n  SEM_POST: 201,\n  // Used by the user's callback functions to indicate to the `AST` translator (semantic analysis) how to proceed.\n  // - *SEM_OK* - normal return value\n  // - *SEM_SKIP* - if a callback function returns this value from the SEM_PRE state,\n  // the translator will skip processing all `AST` nodes in the branch below the current node.\n  // Ignored if returned from the SEM_POST state.\n  SEM_OK: 300,\n  SEM_SKIP: 301,\n  // Used in attribute generation to distinguish the necessary attribute categories.\n  // - *ATTR_N* - non-recursive\n  // - *ATTR_R* - recursive\n  // - *ATTR_MR* - belongs to a mutually-recursive set\n  ATTR_N: 400,\n  ATTR_R: 401,\n  ATTR_MR: 402,\n  // Look around values indicate whether the parser is in look ahead or look behind mode.\n  // Used by the tracing facility to indicate the look around mode in the trace records display.\n  // - *LOOKAROUND_NONE* - the parser is in normal parsing mode\n  // - *LOOKAROUND_AHEAD* - the parse is in look-ahead mode, phrase matching for operator `AND(&)` or `NOT(!)`\n  // - *LOOKAROUND_BEHIND* - the parse is in look-behind mode, phrase matching for operator `BKA(&&)` or `BKN(!!)`\n  LOOKAROUND_NONE: 500,\n  LOOKAROUND_AHEAD: 501,\n  LOOKAROUND_BEHIND: 502,\n  // Back reference rule mode indicators\n  // - *BKR_MODE_UM* - the back reference is using universal mode\n  // - *BKR_MODE_PM* - the back reference is using parent frame mode\n  // - *BKR_MODE_CS* - the back reference is using case-sensitive phrase matching\n  // - *BKR_MODE_CI* - the back reference is using case-insensitive phrase matching\n  BKR_MODE_UM: 601,\n  BKR_MODE_PM: 602,\n  BKR_MODE_CS: 603,\n  BKR_MODE_CI: 604,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2lkZW50aWZpZXJzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWxpYi9pZGVudGlmaWVycy5qcz82NmM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIGV4cG9zZXMgYSBsaXN0IG9mIG5hbWVkIGlkZW50aWZpZXJzLCBzaGFyZWQgYWNyb3NzIHRoZSBwYXJzZXIgZ2VuZXJhdG9yXG4vLyBhbmQgdGhlIHBhcnNlcnMgdGhhdCBhcmUgZ2VuZXJhdGVkLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gSWRlbnRpZmllcyB0aGUgb3BlcmF0b3IgdHlwZS4gVXNlZCBieSB0aGUgZ2VuZXJhdG9yXG4gIC8vIHRvIGluZGljYXRlIG9wZXJhdG9yIHR5cGVzIGluIHRoZSBncmFtbWFyIG9iamVjdC5cbiAgLy8gVXNlZCBieSB0aGUgW3BhcnNlcl0oLi9wYXJzZXIuaHRtbCkgd2hlbiBpbnRlcnByZXRpbmcgdGhlIGdyYW1tYXIgb2JqZWN0LlxuICAvKiB0aGUgb3JpZ2luYWwgQUJORiBvcGVyYXRvcnMgKi9cbiAgQUxUOiAxIC8qIGFsdGVybmF0aW9uICovLFxuICBDQVQ6IDIgLyogY29uY2F0ZW5hdGlvbiAqLyxcbiAgUkVQOiAzIC8qIHJlcGV0aXRpb24gKi8sXG4gIFJOTTogNCAvKiBydWxlIG5hbWUgKi8sXG4gIFRSRzogNSAvKiB0ZXJtaW5hbCByYW5nZSAqLyxcbiAgVEJTOiA2IC8qIHRlcm1pbmFsIGJpbmFyeSBzdHJpbmcsIGNhc2Ugc2Vuc2l0aXZlICovLFxuICBUTFM6IDcgLyogdGVybWluYWwgbGl0ZXJhbCBzdHJpbmcsIGNhc2UgaW5zZW5zaXRpdmUgKi8sXG4gIC8qIHRoZSBzdXBlciBzZXQsIFNBQk5GIG9wZXJhdG9ycyAqL1xuICBVRFQ6IDExIC8qIHVzZXItZGVmaW5lZCB0ZXJtaW5hbCAqLyxcbiAgQU5EOiAxMiAvKiBwb3NpdGl2ZSBsb29rIGFoZWFkICovLFxuICBOT1Q6IDEzIC8qIG5lZ2F0aXZlIGxvb2sgYWhlYWQgKi8sXG4gIEJLUjogMTQgLyogYmFjayByZWZlcmVuY2UgdG8gYSBwcmV2aW91c2x5IG1hdGNoZWQgcnVsZSBuYW1lICovLFxuICBCS0E6IDE1IC8qIHBvc2l0aXZlIGxvb2sgYmVoaW5kICovLFxuICBCS046IDE2IC8qIG5lZ2F0aXZlIGxvb2sgYmVoaW5kICovLFxuICBBQkc6IDE3IC8qIGFuY2hvciAtIGJlZ2luIG9mIHN0cmluZyAqLyxcbiAgQUVOOiAxOCAvKiBhbmNob3IgLSBlbmQgb2Ygc3RyaW5nICovLFxuICAvLyBVc2VkIGJ5IHRoZSBwYXJzZXIgYW5kIHRoZSB1c2VyJ3MgYFJOTWAgYW5kIGBVRFRgIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgLy8gSWRlbnRpZmllcyB0aGUgcGFyc2VyIHN0YXRlIGFzIGl0IHRyYXZlcnNlcyB0aGUgcGFyc2UgdHJlZSBub2Rlcy5cbiAgLy8gLSAqQUNUSVZFKiAtIGluZGljYXRlcyB0aGUgZG93bndhcmQgZGlyZWN0aW9uIHRocm91Z2ggdGhlIHBhcnNlIHRyZWUgbm9kZS5cbiAgLy8gLSAqTUFUQ0gqIC0gaW5kaWNhdGVzIHRoZSB1cHdhcmQgZGlyZWN0aW9uIGFuZCBhIHBocmFzZSwgb2YgbGVuZ3RoIFxcPiAwLCBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgbWF0Y2hlZFxuICAvLyAtICpFTVBUWSogLSBpbmRpY2F0ZXMgdGhlIHVwd2FyZCBkaXJlY3Rpb24gYW5kIGEgcGhyYXNlLCBvZiBsZW5ndGggPSAwLCBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgbWF0Y2hlZFxuICAvLyAtICpOT01BVENIKiAtIGluZGljYXRlcyB0aGUgdXB3YXJkIGRpcmVjdGlvbiBhbmQgdGhlIHBhcnNlciBmYWlsZWQgdG8gbWF0Y2ggYW55IHBocmFzZSBhdCBhbGxcbiAgQUNUSVZFOiAxMDAsXG4gIE1BVENIOiAxMDEsXG4gIEVNUFRZOiAxMDIsXG4gIE5PTUFUQ0g6IDEwMyxcbiAgLy8gVXNlZCBieSBbYEFTVGAgdHJhbnNsYXRvcl0oLi9hc3QuaHRtbCkgKHNlbWFudGljIGFuYWx5c2lzKSBhbmQgdGhlIHVzZXIncyBjYWxsYmFjayBmdW5jdGlvbnNcbiAgLy8gdG8gaW5kaWNhdGUgdGhlIGRpcmVjdGlvbiBvZiBmbG93IHRocm91Z2ggdGhlIGBBU1RgIG5vZGVzLlxuICAvLyAtICpTRU1fUFJFKiAtIGluZGljYXRlcyB0aGUgZG93bndhcmQgKHByZS1icmFuY2gpIGRpcmVjdGlvbiB0aHJvdWdoIHRoZSBgQVNUYCBub2RlLlxuICAvLyAtICpTRU1fUE9TVCogLSBpbmRpY2F0ZXMgdGhlIHVwd2FyZCAocG9zdC1icmFuY2gpIGRpcmVjdGlvbiB0aHJvdWdoIHRoZSBgQVNUYCBub2RlLlxuICBTRU1fUFJFOiAyMDAsXG4gIFNFTV9QT1NUOiAyMDEsXG4gIC8vIFVzZWQgYnkgdGhlIHVzZXIncyBjYWxsYmFjayBmdW5jdGlvbnMgdG8gaW5kaWNhdGUgdG8gdGhlIGBBU1RgIHRyYW5zbGF0b3IgKHNlbWFudGljIGFuYWx5c2lzKSBob3cgdG8gcHJvY2VlZC5cbiAgLy8gLSAqU0VNX09LKiAtIG5vcm1hbCByZXR1cm4gdmFsdWVcbiAgLy8gLSAqU0VNX1NLSVAqIC0gaWYgYSBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIHRoaXMgdmFsdWUgZnJvbSB0aGUgU0VNX1BSRSBzdGF0ZSxcbiAgLy8gdGhlIHRyYW5zbGF0b3Igd2lsbCBza2lwIHByb2Nlc3NpbmcgYWxsIGBBU1RgIG5vZGVzIGluIHRoZSBicmFuY2ggYmVsb3cgdGhlIGN1cnJlbnQgbm9kZS5cbiAgLy8gSWdub3JlZCBpZiByZXR1cm5lZCBmcm9tIHRoZSBTRU1fUE9TVCBzdGF0ZS5cbiAgU0VNX09LOiAzMDAsXG4gIFNFTV9TS0lQOiAzMDEsXG4gIC8vIFVzZWQgaW4gYXR0cmlidXRlIGdlbmVyYXRpb24gdG8gZGlzdGluZ3Vpc2ggdGhlIG5lY2Vzc2FyeSBhdHRyaWJ1dGUgY2F0ZWdvcmllcy5cbiAgLy8gLSAqQVRUUl9OKiAtIG5vbi1yZWN1cnNpdmVcbiAgLy8gLSAqQVRUUl9SKiAtIHJlY3Vyc2l2ZVxuICAvLyAtICpBVFRSX01SKiAtIGJlbG9uZ3MgdG8gYSBtdXR1YWxseS1yZWN1cnNpdmUgc2V0XG4gIEFUVFJfTjogNDAwLFxuICBBVFRSX1I6IDQwMSxcbiAgQVRUUl9NUjogNDAyLFxuICAvLyBMb29rIGFyb3VuZCB2YWx1ZXMgaW5kaWNhdGUgd2hldGhlciB0aGUgcGFyc2VyIGlzIGluIGxvb2sgYWhlYWQgb3IgbG9vayBiZWhpbmQgbW9kZS5cbiAgLy8gVXNlZCBieSB0aGUgdHJhY2luZyBmYWNpbGl0eSB0byBpbmRpY2F0ZSB0aGUgbG9vayBhcm91bmQgbW9kZSBpbiB0aGUgdHJhY2UgcmVjb3JkcyBkaXNwbGF5LlxuICAvLyAtICpMT09LQVJPVU5EX05PTkUqIC0gdGhlIHBhcnNlciBpcyBpbiBub3JtYWwgcGFyc2luZyBtb2RlXG4gIC8vIC0gKkxPT0tBUk9VTkRfQUhFQUQqIC0gdGhlIHBhcnNlIGlzIGluIGxvb2stYWhlYWQgbW9kZSwgcGhyYXNlIG1hdGNoaW5nIGZvciBvcGVyYXRvciBgQU5EKCYpYCBvciBgTk9UKCEpYFxuICAvLyAtICpMT09LQVJPVU5EX0JFSElORCogLSB0aGUgcGFyc2UgaXMgaW4gbG9vay1iZWhpbmQgbW9kZSwgcGhyYXNlIG1hdGNoaW5nIGZvciBvcGVyYXRvciBgQktBKCYmKWAgb3IgYEJLTighISlgXG4gIExPT0tBUk9VTkRfTk9ORTogNTAwLFxuICBMT09LQVJPVU5EX0FIRUFEOiA1MDEsXG4gIExPT0tBUk9VTkRfQkVISU5EOiA1MDIsXG4gIC8vIEJhY2sgcmVmZXJlbmNlIHJ1bGUgbW9kZSBpbmRpY2F0b3JzXG4gIC8vIC0gKkJLUl9NT0RFX1VNKiAtIHRoZSBiYWNrIHJlZmVyZW5jZSBpcyB1c2luZyB1bml2ZXJzYWwgbW9kZVxuICAvLyAtICpCS1JfTU9ERV9QTSogLSB0aGUgYmFjayByZWZlcmVuY2UgaXMgdXNpbmcgcGFyZW50IGZyYW1lIG1vZGVcbiAgLy8gLSAqQktSX01PREVfQ1MqIC0gdGhlIGJhY2sgcmVmZXJlbmNlIGlzIHVzaW5nIGNhc2Utc2Vuc2l0aXZlIHBocmFzZSBtYXRjaGluZ1xuICAvLyAtICpCS1JfTU9ERV9DSSogLSB0aGUgYmFjayByZWZlcmVuY2UgaXMgdXNpbmcgY2FzZS1pbnNlbnNpdGl2ZSBwaHJhc2UgbWF0Y2hpbmdcbiAgQktSX01PREVfVU06IDYwMSxcbiAgQktSX01PREVfUE06IDYwMixcbiAgQktSX01PREVfQ1M6IDYwMyxcbiAgQktSX01PREVfQ0k6IDYwNCxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-lib/identifiers.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-lib/node-exports.js":
/*!*********************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/node-exports.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module serves to export all library objects and object constructors with the `require(\"apg-lib\")` statement.\n// For example, to create a new parser in your program,\n// ````\n// let apglib = require(\"../apg-lib/node-exports\");\n// let my-parser = new apglib.parser();\n// ````\nmodule.exports = {\n  ast: __webpack_require__(/*! ./ast */ \"./node_modules/apg-js/src/apg-lib/ast.js\"),\n  circular: __webpack_require__(/*! ./circular-buffer */ \"./node_modules/apg-js/src/apg-lib/circular-buffer.js\"),\n  ids: __webpack_require__(/*! ./identifiers */ \"./node_modules/apg-js/src/apg-lib/identifiers.js\"),\n  parser: __webpack_require__(/*! ./parser */ \"./node_modules/apg-js/src/apg-lib/parser.js\"),\n  stats: __webpack_require__(/*! ./stats */ \"./node_modules/apg-js/src/apg-lib/stats.js\"),\n  trace: __webpack_require__(/*! ./trace */ \"./node_modules/apg-js/src/apg-lib/trace.js\"),\n  utils: __webpack_require__(/*! ./utilities */ \"./node_modules/apg-js/src/apg-lib/utilities.js\"),\n  emitcss: __webpack_require__(/*! ./emitcss */ \"./node_modules/apg-js/src/apg-lib/emitcss.js\"),\n  style: __webpack_require__(/*! ./style */ \"./node_modules/apg-js/src/apg-lib/style.js\"),\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL25vZGUtZXhwb3J0cy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxtQkFBTyxDQUFDLHVEQUFPO0FBQ3RCLFlBQVksbUJBQU8sQ0FBQywrRUFBbUI7QUFDdkMsT0FBTyxtQkFBTyxDQUFDLHVFQUFlO0FBQzlCLFVBQVUsbUJBQU8sQ0FBQyw2REFBVTtBQUM1QixTQUFTLG1CQUFPLENBQUMsMkRBQVM7QUFDMUIsU0FBUyxtQkFBTyxDQUFDLDJEQUFTO0FBQzFCLFNBQVMsbUJBQU8sQ0FBQyxtRUFBYTtBQUM5QixXQUFXLG1CQUFPLENBQUMsK0RBQVc7QUFDOUIsU0FBUyxtQkFBTyxDQUFDLDJEQUFTO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1saWIvbm9kZS1leHBvcnRzLmpzP2FlZjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgc2VydmVzIHRvIGV4cG9ydCBhbGwgbGlicmFyeSBvYmplY3RzIGFuZCBvYmplY3QgY29uc3RydWN0b3JzIHdpdGggdGhlIGByZXF1aXJlKFwiYXBnLWxpYlwiKWAgc3RhdGVtZW50LlxuLy8gRm9yIGV4YW1wbGUsIHRvIGNyZWF0ZSBhIG5ldyBwYXJzZXIgaW4geW91ciBwcm9ncmFtLFxuLy8gYGBgYFxuLy8gbGV0IGFwZ2xpYiA9IHJlcXVpcmUoXCIuLi9hcGctbGliL25vZGUtZXhwb3J0c1wiKTtcbi8vIGxldCBteS1wYXJzZXIgPSBuZXcgYXBnbGliLnBhcnNlcigpO1xuLy8gYGBgYFxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFzdDogcmVxdWlyZSgnLi9hc3QnKSxcbiAgY2lyY3VsYXI6IHJlcXVpcmUoJy4vY2lyY3VsYXItYnVmZmVyJyksXG4gIGlkczogcmVxdWlyZSgnLi9pZGVudGlmaWVycycpLFxuICBwYXJzZXI6IHJlcXVpcmUoJy4vcGFyc2VyJyksXG4gIHN0YXRzOiByZXF1aXJlKCcuL3N0YXRzJyksXG4gIHRyYWNlOiByZXF1aXJlKCcuL3RyYWNlJyksXG4gIHV0aWxzOiByZXF1aXJlKCcuL3V0aWxpdGllcycpLFxuICBlbWl0Y3NzOiByZXF1aXJlKCcuL2VtaXRjc3MnKSxcbiAgc3R5bGU6IHJlcXVpcmUoJy4vc3R5bGUnKSxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-lib/node-exports.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-lib/parser.js":
/*!***************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/parser.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* eslint-disable func-names */\n/* eslint-disable no-restricted-syntax */\n/* eslint-disable new-cap */\n/* eslint-disable guard-for-in */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This is the primary object of `apg-lib`. Calling its `parse()` member function\n// walks the parse tree of opcodes, matching phrases from the input string as it goes.\n// The working code for all of the operators, `ALT`, `CAT`, etc. is in this module.\nmodule.exports = function parser() {\n  const id = __webpack_require__(/*! ./identifiers */ \"./node_modules/apg-js/src/apg-lib/identifiers.js\");\n  const utils = __webpack_require__(/*! ./utilities */ \"./node_modules/apg-js/src/apg-lib/utilities.js\");\n\n  const thisFileName = 'parser.js: ';\n  const thisThis = this;\n  let opExecute;\n  this.ast = null;\n  this.stats = null;\n  this.trace = null;\n  this.callbacks = [];\n  let opcodes = null;\n  let chars = null;\n  let charsBegin;\n  let charsLength;\n  let charsEnd;\n  let lookAround;\n  let treeDepth = 0;\n  let maxTreeDepth = 0;\n  let nodeHits = 0;\n  let ruleCallbacks = null;\n  let udtCallbacks = null;\n  let rules = null;\n  let udts = null;\n  let syntaxData = null;\n  let maxMatched = 0;\n  let limitTreeDepth = Infinity;\n  let limitNodeHits = Infinity;\n  // Evaluates any given rule. This can be called from the syntax callback\n  // functions to evaluate any rule in the grammar's rule list. Great caution\n  // should be used. Use of this function will alter the language that the\n  // parser accepts.\n  const evaluateRule = function evaluateRule(ruleIndex, phraseIndex, sysData) {\n    const functionName = `${thisFileName}evaluateRule(): `;\n    if (ruleIndex >= rules.length) {\n      throw new Error(`${functionName}rule index: ${ruleIndex} out of range`);\n    }\n    if (phraseIndex >= charsEnd) {\n      throw new Error(`${functionName}phrase index: ${phraseIndex} out of range`);\n    }\n    const { length } = opcodes;\n    opcodes.push({\n      type: id.RNM,\n      index: ruleIndex,\n    });\n    opExecute(length, phraseIndex, sysData);\n    opcodes.pop();\n  };\n  // Evaluates any given UDT. This can be called from the syntax callback\n  // functions to evaluate any UDT in the grammar's UDT list. Great caution\n  // should be used. Use of this function will alter the language that the\n  // parser accepts.\n  const evaluateUdt = function (udtIndex, phraseIndex, sysData) {\n    const functionName = `${thisFileName}evaluateUdt(): `;\n    if (udtIndex >= udts.length) {\n      throw new Error(`${functionName}udt index: ${udtIndex} out of range`);\n    }\n    if (phraseIndex >= charsEnd) {\n      throw new Error(`${functionName}phrase index: ${phraseIndex} out of range`);\n    }\n    const { length } = opcodes;\n    opcodes.push({\n      type: id.UDT,\n      empty: udts[udtIndex].empty,\n      index: udtIndex,\n    });\n    opExecute(length, phraseIndex, sysData);\n    opcodes.pop();\n  };\n  /* Clears this object of any/all data that has been initialized or added to it. */\n  /* Called by parse() on initialization, allowing this object to be re-used for multiple parsing calls. */\n  const clear = function () {\n    treeDepth = 0;\n    maxTreeDepth = 0;\n    nodeHits = 0;\n    maxMatched = 0;\n    lookAround = [\n      {\n        lookAround: id.LOOKAROUND_NONE,\n        anchor: 0,\n        charsEnd: 0,\n        charsLength: 0,\n      },\n    ];\n    rules = null;\n    udts = null;\n    chars = null;\n    charsBegin = 0;\n    charsLength = 0;\n    charsEnd = 0;\n    ruleCallbacks = null;\n    udtCallbacks = null;\n    syntaxData = null;\n    opcodes = null;\n  };\n  /* object for maintaining a stack of back reference frames */\n  const backRef = function () {\n    const stack = [];\n    const init = function () {\n      const obj = {};\n      rules.forEach((rule) => {\n        if (rule.isBkr) {\n          obj[rule.lower] = null;\n        }\n      });\n      if (udts.length > 0) {\n        udts.forEach((udt) => {\n          if (udt.isBkr) {\n            obj[udt.lower] = null;\n          }\n        });\n      }\n      stack.push(obj);\n    };\n    const copy = function () {\n      const top = stack[stack.length - 1];\n      const obj = {};\n      /* // eslint-disable-next-line no-restricted-syntax */\n      for (const name in top) {\n        obj[name] = top[name];\n      }\n      return obj;\n    };\n    this.push = function push() {\n      stack.push(copy());\n    };\n    this.pop = function pop(lengthArg) {\n      let length = lengthArg;\n      if (!length) {\n        length = stack.length - 1;\n      }\n      if (length < 1 || length > stack.length) {\n        throw new Error(`${thisFileName}backRef.pop(): bad length: ${length}`);\n      }\n      stack.length = length;\n      return stack[stack.length - 1];\n    };\n    this.length = function length() {\n      return stack.length;\n    };\n    this.savePhrase = function savePhrase(name, index, length) {\n      stack[stack.length - 1][name] = {\n        phraseIndex: index,\n        phraseLength: length,\n      };\n    };\n    this.getPhrase = function (name) {\n      return stack[stack.length - 1][name];\n    };\n    /* constructor */\n    init();\n  };\n  // The system data structure that relays system information to and from the rule and UDT callback functions.\n  // - *state* - the state of the parser, ACTIVE, MATCH, EMPTY or NOMATCH (see the `identifiers` object in\n  // [`apg-lib`](https://github.com/ldthomas/apg-js2-lib))\n  // - *phraseLength* - the number of characters matched if the state is MATCHED or EMPTY\n  // - *lookaround* - the top of the stack holds the current look around state,\n  // LOOKAROUND_NONE, LOOKAROUND_AHEAD or LOOKAROUND_BEHIND,\n  // - *uFrame* - the \"universal\" back reference frame.\n  // Holds the last matched phrase for each of the back referenced rules and UDTs.\n  // - *pFrame* - the stack of \"parent\" back reference frames.\n  // Holds the matched phrase from the parent frame of each back referenced rules and UDTs.\n  // - *evaluateRule* - a reference to this object's `evaluateRule()` function.\n  // Can be called from a callback function (use with extreme caution!)\n  // - *evaluateUdt* - a reference to this object's `evaluateUdt()` function.\n  // Can be called from a callback function (use with extreme caution!)\n  const systemData = function systemData() {\n    const thisData = this;\n    this.state = id.ACTIVE;\n    this.phraseLength = 0;\n    this.ruleIndex = 0;\n    this.udtIndex = 0;\n    this.lookAround = lookAround[lookAround.length - 1];\n    this.uFrame = new backRef();\n    this.pFrame = new backRef();\n    this.evaluateRule = evaluateRule;\n    this.evaluateUdt = evaluateUdt;\n    /* refresh the parser state for the next operation */\n    this.refresh = function refresh() {\n      thisData.state = id.ACTIVE;\n      thisData.phraseLength = 0;\n      thisData.lookAround = lookAround[lookAround.length - 1];\n    };\n  };\n  /* some look around helper functions */\n  const lookAroundValue = function lookAroundValue() {\n    return lookAround[lookAround.length - 1];\n  };\n  /* return true if parser is in look around (ahead or behind) state */\n  const inLookAround = function inLookAround() {\n    return lookAround.length > 1;\n  };\n  /* return true if parser is in look behind state */\n  const inLookBehind = function () {\n    return lookAround[lookAround.length - 1].lookAround === id.LOOKAROUND_BEHIND;\n  };\n  /* called by parse() to initialize the AST object, if one has been defined */\n  const initializeAst = function () {\n    const functionName = `${thisFileName}initializeAst(): `;\n    const TRUE = true;\n    while (TRUE) {\n      if (thisThis.ast === undefined) {\n        thisThis.ast = null;\n        break;\n      }\n      if (thisThis.ast === null) {\n        break;\n      }\n      if (thisThis.ast.astObject !== 'astObject') {\n        throw new Error(`${functionName}ast object not recognized`);\n      }\n      break;\n    }\n    if (thisThis.ast !== null) {\n      thisThis.ast.init(rules, udts, chars);\n    }\n  };\n  /* called by parse() to initialize the trace object, if one has been defined */\n  const initializeTrace = function () {\n    const functionName = `${thisFileName}initializeTrace(): `;\n    const TRUE = true;\n    while (TRUE) {\n      if (thisThis.trace === undefined) {\n        thisThis.trace = null;\n        break;\n      }\n      if (thisThis.trace === null) {\n        break;\n      }\n      if (thisThis.trace.traceObject !== 'traceObject') {\n        throw new Error(`${functionName}trace object not recognized`);\n      }\n      break;\n    }\n    if (thisThis.trace !== null) {\n      thisThis.trace.init(rules, udts, chars);\n    }\n  };\n  /* called by parse() to initialize the statistics object, if one has been defined */\n  const initializeStats = function () {\n    const functionName = `${thisFileName}initializeStats(): `;\n    const TRUE = true;\n    while (TRUE) {\n      if (thisThis.stats === undefined) {\n        thisThis.stats = null;\n        break;\n      }\n      if (thisThis.stats === null) {\n        break;\n      }\n      if (thisThis.stats.statsObject !== 'statsObject') {\n        throw new Error(`${functionName}stats object not recognized`);\n      }\n      break;\n    }\n    if (thisThis.stats !== null) {\n      thisThis.stats.init(rules, udts);\n    }\n  };\n  /* called by parse() to initialize the rules & udts from the grammar object */\n  /* (the grammar object generated previously by apg) */\n  const initializeGrammar = function (grammar) {\n    const functionName = `${thisFileName}initializeGrammar(): `;\n    if (!grammar) {\n      throw new Error(`${functionName}grammar object undefined`);\n    }\n    if (grammar.grammarObject !== 'grammarObject') {\n      throw new Error(`${functionName}bad grammar object`);\n    }\n    rules = grammar.rules;\n    udts = grammar.udts;\n  };\n  /* called by parse() to initialize the start rule */\n  const initializeStartRule = function (startRule) {\n    const functionName = `${thisFileName}initializeStartRule(): `;\n    let start = null;\n    if (typeof startRule === 'number') {\n      if (startRule >= rules.length) {\n        throw new Error(`${functionName}start rule index too large: max: ${rules.length}: index: ${startRule}`);\n      }\n      start = startRule;\n    } else if (typeof startRule === 'string') {\n      const lower = startRule.toLowerCase();\n      for (let i = 0; i < rules.length; i += 1) {\n        if (lower === rules[i].lower) {\n          start = rules[i].index;\n          break;\n        }\n      }\n      if (start === null) {\n        throw new Error(`${functionName}start rule name '${startRule}' not recognized`);\n      }\n    } else {\n      throw new Error(`${functionName}type of start rule '${typeof startRule}' not recognized`);\n    }\n    return start;\n  };\n  /* called by parse() to initialize the array of characters codes representing the input string */\n  const initializeInputChars = function initializeInputChars(inputArg, begArg, lenArg) {\n    const functionName = `${thisFileName}initializeInputChars(): `;\n    /* varify and normalize input */\n    let input = inputArg;\n    let beg = begArg;\n    let len = lenArg;\n    if (input === undefined) {\n      throw new Error(`${functionName}input string is undefined`);\n    }\n    if (input === null) {\n      throw new Error(`${functionName}input string is null`);\n    }\n    if (typeof input === 'string') {\n      input = utils.stringToChars(input);\n    } else if (!Array.isArray(input)) {\n      throw new Error(`${functionName}input string is not a string or array`);\n    }\n    if (input.length > 0) {\n      if (typeof input[0] !== 'number') {\n        throw new Error(`${functionName}input string not an array of integers`);\n      }\n    }\n    /* verify and normalize beginning index */\n    if (typeof beg !== 'number') {\n      beg = 0;\n    } else {\n      beg = Math.floor(beg);\n      if (beg < 0 || beg > input.length) {\n        throw new Error(`${functionName}input beginning index out of range: ${beg}`);\n      }\n    }\n    /* verify and normalize input length */\n    if (typeof len !== 'number') {\n      len = input.length - beg;\n    } else {\n      len = Math.floor(len);\n      if (len < 0 || len > input.length - beg) {\n        throw new Error(`${functionName}input length out of range: ${len}`);\n      }\n    }\n    chars = input;\n    charsBegin = beg;\n    charsLength = len;\n    charsEnd = charsBegin + charsLength;\n  };\n  /* called by parse() to initialize the user-written, syntax callback functions, if any */\n  const initializeCallbacks = function () {\n    const functionName = `${thisFileName}initializeCallbacks(): `;\n    let i;\n    ruleCallbacks = [];\n    udtCallbacks = [];\n    for (i = 0; i < rules.length; i += 1) {\n      ruleCallbacks[i] = null;\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      udtCallbacks[i] = null;\n    }\n    let func;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    for (const index in thisThis.callbacks) {\n      i = list.indexOf(index.toLowerCase());\n      if (i < 0) {\n        throw new Error(`${functionName}syntax callback '${index}' not a rule or udt name`);\n      }\n      func = thisThis.callbacks[index];\n      if (!func) {\n        func = null;\n      }\n      if (typeof func === 'function' || func === null) {\n        if (i < rules.length) {\n          ruleCallbacks[i] = func;\n        } else {\n          udtCallbacks[i - rules.length] = func;\n        }\n      } else {\n        throw new Error(\n          `${functionName}syntax callback[${index}] must be function reference or 'false' (false/null/undefined/etc.)`\n        );\n      }\n    }\n    /* make sure all udts have been defined - the parser can't work without them */\n    for (i = 0; i < udts.length; i += 1) {\n      if (udtCallbacks[i] === null) {\n        throw new Error(\n          `${functionName}all UDT callbacks must be defined. UDT callback[${udts[i].lower}] not a function reference`\n        );\n      }\n    }\n  };\n  // Set the maximum parse tree depth allowed. The default is `Infinity`.\n  // A limit is not normally needed, but can be used to protect against an\n  // exponentual or \"catastrophically backtracking\" grammar.\n  // <ul>\n  // <li>\n  // depth - max allowed parse tree depth. An exception is thrown if exceeded.\n  // </li>\n  // </ul>\n  this.setMaxTreeDepth = function (depth) {\n    if (typeof depth !== 'number') {\n      throw new Error(`parser: max tree depth must be integer > 0: ${depth}`);\n    }\n    limitTreeDepth = Math.floor(depth);\n    if (limitTreeDepth <= 0) {\n      throw new Error(`parser: max tree depth must be integer > 0: ${depth}`);\n    }\n  };\n  // Set the maximum number of node hits (parser unit steps or opcode function calls) allowed.\n  // The default is `Infinity`.\n  // A limit is not normally needed, but can be used to protect against an\n  // exponentual or \"catastrophically backtracking\" grammar.\n  // <ul>\n  // <li>\n  // hits - maximum number of node hits or parser unit steps allowed.\n  // An exception thrown if exceeded.\n  // </li>\n  // </ul>\n  this.setMaxNodeHits = function (hits) {\n    if (typeof hits !== 'number') {\n      throw new Error(`parser: max node hits must be integer > 0: ${hits}`);\n    }\n    limitNodeHits = Math.floor(hits);\n    if (limitNodeHits <= 0) {\n      throw new Error(`parser: max node hits must be integer > 0: ${hits}`);\n    }\n  };\n  /* the main parser function */\n  const privateParse = function (grammar, startRuleArg, callbackData) {\n    let success;\n    const functionName = `${thisFileName}parse(): `;\n    initializeGrammar(grammar);\n    const startRule = initializeStartRule(startRuleArg);\n    initializeCallbacks();\n    initializeTrace();\n    initializeStats();\n    initializeAst();\n    const sysData = new systemData();\n    if (!(callbackData === undefined || callbackData === null)) {\n      syntaxData = callbackData;\n    }\n    /* create a dummy opcode for the start rule */\n    opcodes = [\n      {\n        type: id.RNM,\n        index: startRule,\n      },\n    ];\n    /* execute the start rule */\n    opExecute(0, charsBegin, sysData);\n    opcodes = null;\n    /* test and return the sysData */\n    switch (sysData.state) {\n      case id.ACTIVE:\n        throw new Error(`${functionName}final state should never be 'ACTIVE'`);\n      case id.NOMATCH:\n        success = false;\n        break;\n      case id.EMPTY:\n      case id.MATCH:\n        if (sysData.phraseLength === charsLength) {\n          success = true;\n        } else {\n          success = false;\n        }\n        break;\n      default:\n        throw new Error('unrecognized state');\n    }\n    return {\n      success,\n      state: sysData.state,\n      length: charsLength,\n      matched: sysData.phraseLength,\n      maxMatched,\n      maxTreeDepth,\n      nodeHits,\n      inputLength: chars.length,\n      subBegin: charsBegin,\n      subEnd: charsEnd,\n      subLength: charsLength,\n    };\n  };\n\n  // This form allows parsing of a sub-string of the full input string.\n  // <ul>\n  // <li>*inputIndex* - index of the first character in the sub-string</li>\n  // <li>*inputLength* - length of the sub-string</li>\n  // </ul>\n  // All other parameters as for the above function `parse()`.\n  this.parseSubstring = function parseSubstring(grammar, startRule, inputChars, inputIndex, inputLength, callbackData) {\n    clear();\n    initializeInputChars(inputChars, inputIndex, inputLength);\n    return privateParse(grammar, startRule, callbackData);\n  };\n  // This is the main function, called to parse an input string.\n  // <ul>\n  // <li>*grammar* - an instantiated grammar object - the output of `apg` for a\n  // specific SABNF grammar</li>\n  // <li>*startRule* - the rule name or rule index to be used as the root of the\n  // parse tree. This is usually the first rule, index = 0, of the grammar\n  // but can be any rule defined in the above grammar object.</li>\n  // <li>*inputChars* - the input string. Can be a string or an array of integer character codes representing the\n  // string.</li>\n  // <li>*callbackData* - user-defined data object to be passed to the user's\n  // callback functions.\n  // This is not used by the parser in any way, merely passed on to the user.\n  // May be `null` or omitted.</li>\n  // </ul>\n  this.parse = function parse(grammar, startRule, inputChars, callbackData) {\n    clear();\n    initializeInputChars(inputChars, 0, inputChars.length);\n    return privateParse(grammar, startRule, callbackData);\n  };\n  // The `ALT` operator.<br>\n  // Executes its child nodes, from left to right, until it finds a match.\n  // Fails if *all* of its child nodes fail.\n  const opALT = function (opIndex, phraseIndex, sysData) {\n    const op = opcodes[opIndex];\n    for (let i = 0; i < op.children.length; i += 1) {\n      opExecute(op.children[i], phraseIndex, sysData);\n      if (sysData.state !== id.NOMATCH) {\n        break;\n      }\n    }\n  };\n  // The `CAT` operator.<br>\n  // Executes all of its child nodes, from left to right,\n  // concatenating the matched phrases.\n  // Fails if *any* child nodes fail.\n  const opCAT = function (opIndex, phraseIndex, sysData) {\n    let success;\n    let astLength;\n    let catCharIndex;\n    let catPhrase;\n    const op = opcodes[opIndex];\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    success = true;\n    catCharIndex = phraseIndex;\n    catPhrase = 0;\n    for (let i = 0; i < op.children.length; i += 1) {\n      opExecute(op.children[i], catCharIndex, sysData);\n      if (sysData.state === id.NOMATCH) {\n        success = false;\n        break;\n      } else {\n        catCharIndex += sysData.phraseLength;\n        catPhrase += sysData.phraseLength;\n      }\n    }\n    if (success) {\n      sysData.state = catPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = catPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      /* reset the back referencing frames on failure */\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // The `REP` operator.<br>\n  // Repeatedly executes its single child node,\n  // concatenating each of the matched phrases found.\n  // The number of repetitions executed and its final sysData depends\n  // on its `min` & `max` repetition values.\n  const opREP = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let repCharIndex;\n    let repPhrase;\n    let repCount;\n    const op = opcodes[opIndex];\n    repCharIndex = phraseIndex;\n    repPhrase = 0;\n    repCount = 0;\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    const TRUE = true;\n    while (TRUE) {\n      if (repCharIndex >= charsEnd) {\n        /* exit on end of input string */\n        break;\n      }\n      opExecute(opIndex + 1, repCharIndex, sysData);\n      if (sysData.state === id.NOMATCH) {\n        /* always end if the child node fails */\n        break;\n      }\n      if (sysData.state === id.EMPTY) {\n        /* REP always succeeds when the child node returns an empty phrase */\n        /* this may not seem obvious, but that's the way it works out */\n        break;\n      }\n      repCount += 1;\n      repPhrase += sysData.phraseLength;\n      repCharIndex += sysData.phraseLength;\n      if (repCount === op.max) {\n        /* end on maxed out reps */\n        break;\n      }\n    }\n    /* evaluate the match count according to the min, max values */\n    if (sysData.state === id.EMPTY) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else if (repCount >= op.min) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      /* reset the back referencing frames on failure */\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // Validate the callback function's returned sysData values.\n  // It's the user's responsibility to get them right\n  // but `RNM` fails if not.\n  const validateRnmCallbackResult = function (rule, sysData, charsLeft, down) {\n    if (sysData.phraseLength > charsLeft) {\n      let str = `${thisFileName}opRNM(${rule.name}): callback function error: `;\n      str += `sysData.phraseLength: ${sysData.phraseLength}`;\n      str += ` must be <= remaining chars: ${charsLeft}`;\n      throw new Error(str);\n    }\n    switch (sysData.state) {\n      case id.ACTIVE:\n        if (down !== true) {\n          throw new Error(\n            `${thisFileName}opRNM(${rule.name}): callback function return error. ACTIVE state not allowed.`\n          );\n        }\n        break;\n      case id.EMPTY:\n        sysData.phraseLength = 0;\n        break;\n      case id.MATCH:\n        if (sysData.phraseLength === 0) {\n          sysData.state = id.EMPTY;\n        }\n        break;\n      case id.NOMATCH:\n        sysData.phraseLength = 0;\n        break;\n      default:\n        throw new Error(\n          `${thisFileName}opRNM(${rule.name}): callback function return error. Unrecognized return state: ${sysData.state}`\n        );\n    }\n  };\n  // The `RNM` operator.<br>\n  // This operator will acts as a root node for a parse tree branch below and\n  // returns the matched phrase to its parent.\n  // However, its larger responsibility is handling user-defined callback functions, back references and `AST` nodes.\n  // Note that the `AST` is a separate object, but `RNM` calls its functions to create its nodes.\n  // See [`ast.js`](./ast.html) for usage.\n  const opRNM = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let astDefined;\n    let savedOpcodes;\n    let ulen;\n    let plen;\n    let saveFrame;\n    const op = opcodes[opIndex];\n    const rule = rules[op.index];\n    const callback = ruleCallbacks[rule.index];\n    const notLookAround = !inLookAround();\n    /* ignore AST and back references in lookaround */\n    if (notLookAround) {\n      /* begin AST and back references */\n      astDefined = thisThis.ast && thisThis.ast.ruleDefined(op.index);\n      if (astDefined) {\n        astLength = thisThis.ast.getLength();\n        thisThis.ast.down(op.index, rules[op.index].name);\n      }\n      ulen = sysData.uFrame.length();\n      plen = sysData.pFrame.length();\n      sysData.uFrame.push();\n      sysData.pFrame.push();\n      saveFrame = sysData.pFrame;\n      sysData.pFrame = new backRef();\n    }\n    if (callback === null) {\n      /* no callback - just execute the rule */\n      savedOpcodes = opcodes;\n      opcodes = rule.opcodes;\n      opExecute(0, phraseIndex, sysData);\n      opcodes = savedOpcodes;\n    } else {\n      /* call user's callback */\n      const charsLeft = charsEnd - phraseIndex;\n      sysData.ruleIndex = rule.index;\n      callback(sysData, chars, phraseIndex, syntaxData);\n      validateRnmCallbackResult(rule, sysData, charsLeft, true);\n      if (sysData.state === id.ACTIVE) {\n        savedOpcodes = opcodes;\n        opcodes = rule.opcodes;\n        opExecute(0, phraseIndex, sysData);\n        opcodes = savedOpcodes;\n        sysData.ruleIndex = rule.index;\n        callback(sysData, chars, phraseIndex, syntaxData);\n        validateRnmCallbackResult(rule, sysData, charsLeft, false);\n      } /* implied else clause: just accept the callback sysData - RNM acting as UDT */\n    }\n    if (notLookAround) {\n      /* end AST */\n      if (astDefined) {\n        if (sysData.state === id.NOMATCH) {\n          thisThis.ast.setLength(astLength);\n        } else {\n          thisThis.ast.up(op.index, rule.name, phraseIndex, sysData.phraseLength);\n        }\n      }\n      /* end back reference */\n      sysData.pFrame = saveFrame;\n      if (sysData.state === id.NOMATCH) {\n        sysData.uFrame.pop(ulen);\n        sysData.pFrame.pop(plen);\n      } else if (rule.isBkr) {\n        /* save phrase on both the parent and universal frames */\n        /* BKR operator will decide which to use later */\n        sysData.pFrame.savePhrase(rule.lower, phraseIndex, sysData.phraseLength);\n        sysData.uFrame.savePhrase(rule.lower, phraseIndex, sysData.phraseLength);\n      }\n    }\n  };\n  // Validate the callback function's returned sysData values.\n  // It's the user's responsibility to get it right but `UDT` fails if not.\n  const validateUdtCallbackResult = function (udt, sysData, charsLeft) {\n    if (sysData.phraseLength > charsLeft) {\n      let str = `${thisFileName}opUDT(${udt.name}): callback function error: `;\n      str += `sysData.phraseLength: ${sysData.phraseLength}`;\n      str += ` must be <= remaining chars: ${charsLeft}`;\n      throw new Error(str);\n    }\n    switch (sysData.state) {\n      case id.ACTIVE:\n        throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. ACTIVE state not allowed.`);\n      case id.EMPTY:\n        if (udt.empty === false) {\n          throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. May not return EMPTY.`);\n        } else {\n          sysData.phraseLength = 0;\n        }\n        break;\n      case id.MATCH:\n        if (sysData.phraseLength === 0) {\n          if (udt.empty === false) {\n            throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. May not return EMPTY.`);\n          } else {\n            sysData.state = id.EMPTY;\n          }\n        }\n        break;\n      case id.NOMATCH:\n        sysData.phraseLength = 0;\n        break;\n      default:\n        throw new Error(\n          `${thisFileName}opUDT(${udt.name}): callback function return error. Unrecognized return state: ${sysData.state}`\n        );\n    }\n  };\n  // The `UDT` operator.<br>\n  // Simply calls the user's callback function, but operates like `RNM` with regard to the `AST`\n  // and back referencing.\n  // There is some ambiguity here. `UDT`s act as terminals for phrase recognition but as named rules\n  // for `AST` nodes and back referencing.\n  // See [`ast.js`](./ast.html) for usage.\n  const opUDT = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let astIndex;\n    let astDefined;\n    let ulen;\n    let plen;\n    let saveFrame;\n    const op = opcodes[opIndex];\n    const udt = udts[op.index];\n    sysData.UdtIndex = udt.index;\n\n    const notLookAround = !inLookAround();\n    /* ignore AST and back references in lookaround */\n    if (notLookAround) {\n      /* begin AST and back reference */\n      astDefined = thisThis.ast && thisThis.ast.udtDefined(op.index);\n      if (astDefined) {\n        astIndex = rules.length + op.index;\n        astLength = thisThis.ast.getLength();\n        thisThis.ast.down(astIndex, udt.name);\n      }\n      /* NOTE: push and pop of the back reference frame is normally not necessary */\n      /* only in the case that the UDT calls evaluateRule() or evaluateUdt() */\n      ulen = sysData.uFrame.length();\n      plen = sysData.pFrame.length();\n      sysData.uFrame.push();\n      sysData.pFrame.push();\n      saveFrame = sysData.pFrame;\n      sysData.pFrame = new backRef();\n    }\n    /* call the UDT */\n    const charsLeft = charsEnd - phraseIndex;\n    udtCallbacks[op.index](sysData, chars, phraseIndex, syntaxData);\n    validateUdtCallbackResult(udt, sysData, charsLeft);\n    if (notLookAround) {\n      /* end AST */\n      if (astDefined) {\n        if (sysData.state === id.NOMATCH) {\n          thisThis.ast.setLength(astLength);\n        } else {\n          thisThis.ast.up(astIndex, udt.name, phraseIndex, sysData.phraseLength);\n        }\n      }\n      /* end back reference */\n      sysData.pFrame = saveFrame;\n      if (sysData.state === id.NOMATCH) {\n        sysData.uFrame.pop(ulen);\n        sysData.pFrame.pop(plen);\n      } else if (udt.isBkr) {\n        /* save phrase on both the parent and universal frames */\n        /* BKR operator will decide which to use later */\n        sysData.pFrame.savePhrase(udt.lower, phraseIndex, sysData.phraseLength);\n        sysData.uFrame.savePhrase(udt.lower, phraseIndex, sysData.phraseLength);\n      }\n    }\n  };\n  // The `AND` operator.<br>\n  // This is the positive `look ahead` operator.\n  // Executes its single child node, returning the EMPTY state\n  // if it succeedsand NOMATCH if it fails.\n  // *Always* backtracks on any matched phrase and returns EMPTY on success.\n  const opAND = function (opIndex, phraseIndex, sysData) {\n    lookAround.push({\n      lookAround: id.LOOKAROUND_AHEAD,\n      anchor: phraseIndex,\n      charsEnd,\n      charsLength,\n    });\n    charsEnd = chars.length;\n    charsLength = chars.length - charsBegin;\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    const pop = lookAround.pop();\n    charsEnd = pop.charsEnd;\n    charsLength = pop.charsLength;\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n        sysData.state = id.EMPTY;\n        break;\n      case id.MATCH:\n        sysData.state = id.EMPTY;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      default:\n        throw new Error(`opAND: invalid state ${sysData.state}`);\n    }\n  };\n  // The `NOT` operator.<br>\n  // This is the negative `look ahead` operator.\n  // Executes its single child node, returning the EMPTY state\n  // if it *fails* and NOMATCH if it succeeds.\n  // *Always* backtracks on any matched phrase and returns EMPTY\n  // on success (failure of its child node).\n  const opNOT = function (opIndex, phraseIndex, sysData) {\n    lookAround.push({\n      lookAround: id.LOOKAROUND_AHEAD,\n      anchor: phraseIndex,\n      charsEnd,\n      charsLength,\n    });\n    charsEnd = chars.length;\n    charsLength = chars.length - charsBegin;\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    const pop = lookAround.pop();\n    charsEnd = pop.charsEnd;\n    charsLength = pop.charsLength;\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n      case id.MATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.EMPTY;\n        break;\n      default:\n        throw new Error(`opNOT: invalid state ${sysData.state}`);\n    }\n  };\n  // The `TRG` operator.<br>\n  // Succeeds if the single first character of the phrase is\n  // within the `min - max` range.\n  const opTRG = function (opIndex, phraseIndex, sysData) {\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    if (phraseIndex < charsEnd) {\n      if (op.min <= chars[phraseIndex] && chars[phraseIndex] <= op.max) {\n        sysData.state = id.MATCH;\n        sysData.phraseLength = 1;\n      }\n    }\n  };\n  // The `TBS` operator.<br>\n  // Matches its pre-defined phrase against the input string.\n  // All characters must match exactly.\n  // Case-sensitive literal strings (`'string'` & `%s\"string\"`) are translated to `TBS`\n  // operators by `apg`.\n  // Phrase length of zero is not allowed.\n  // Empty phrases can only be defined with `TLS` operators.\n  const opTBS = function (opIndex, phraseIndex, sysData) {\n    let i;\n    const op = opcodes[opIndex];\n    const len = op.string.length;\n    sysData.state = id.NOMATCH;\n    if (phraseIndex + len <= charsEnd) {\n      for (i = 0; i < len; i += 1) {\n        if (chars[phraseIndex + i] !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    } /* implied else NOMATCH */\n  };\n  // The `TLS` operator.<br>\n  // Matches its pre-defined phrase against the input string.\n  // A case-insensitive match is attempted for ASCII alphbetical characters.\n  // `TLS` is the only operator that explicitly allows empty phrases.\n  // `apg` will fail for empty `TBS`, case-sensitive strings (`''`) or\n  // zero repetitions (`0*0RuleName` or `0RuleName`).\n  const opTLS = function (opIndex, phraseIndex, sysData) {\n    let i;\n    let code;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    const len = op.string.length;\n    if (len === 0) {\n      /* EMPTY match allowed for TLS */\n      sysData.state = id.EMPTY;\n      return;\n    }\n    if (phraseIndex + len <= charsEnd) {\n      for (i = 0; i < len; i += 1) {\n        code = chars[phraseIndex + i];\n        if (code >= 65 && code <= 90) {\n          code += 32;\n        }\n        if (code !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    } /* implied else NOMATCH */\n  };\n  // The `ABG` operator.<br>\n  // This is an \"anchor\" for the beginning of the string, similar to the familiar regex `^` anchor.\n  // An anchor matches a position rather than a phrase.\n  // Returns EMPTY if `phraseIndex` is 0, NOMATCH otherwise.\n  const opABG = function (opIndex, phraseIndex, sysData) {\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    sysData.state = phraseIndex === 0 ? id.EMPTY : id.NOMATCH;\n  };\n  // The `AEN` operator.<br>\n  // This is an \"anchor\" for the end of the string, similar to the familiar regex `$` anchor.\n  // An anchor matches a position rather than a phrase.\n  // Returns EMPTY if `phraseIndex` equals the input string length, NOMATCH otherwise.\n  const opAEN = function (opIndex, phraseIndex, sysData) {\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    sysData.state = phraseIndex === chars.length ? id.EMPTY : id.NOMATCH;\n  };\n  // The `BKR` operator.<br>\n  // The back reference operator.\n  // Matches the last matched phrase of the named rule or UDT against the input string.\n  // For ASCII alphbetical characters the match may be case sensitive (`%s`) or insensitive (`%i`),\n  // depending on the back reference definition.\n  // For `universal` mode (`%u`) matches the last phrase found anywhere in the grammar.\n  // For `parent frame` mode (`%p`) matches the last phrase found in the parent rule only.\n  const opBKR = function (opIndex, phraseIndex, sysData) {\n    let i;\n    let code;\n    let lmcode;\n    let lower;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    if (op.index < rules.length) {\n      lower = rules[op.index].lower;\n    } else {\n      lower = udts[op.index - rules.length].lower;\n    }\n    const frame = op.bkrMode === id.BKR_MODE_PM ? sysData.pFrame.getPhrase(lower) : sysData.uFrame.getPhrase(lower);\n    const insensitive = op.bkrCase === id.BKR_MODE_CI;\n    if (frame === null) {\n      return;\n    }\n    const lmIndex = frame.phraseIndex;\n    const len = frame.phraseLength;\n    if (len === 0) {\n      sysData.state = id.EMPTY;\n      return;\n    }\n    if (phraseIndex + len <= charsEnd) {\n      if (insensitive) {\n        /* case-insensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[phraseIndex + i];\n          lmcode = chars[lmIndex + i];\n          if (code >= 65 && code <= 90) {\n            code += 32;\n          }\n          if (lmcode >= 65 && lmcode <= 90) {\n            lmcode += 32;\n          }\n          if (code !== lmcode) {\n            return;\n          }\n        }\n        sysData.state = id.MATCH;\n        sysData.phraseLength = len;\n      } else {\n        /* case-sensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[phraseIndex + i];\n          lmcode = chars[lmIndex + i];\n          if (code !== lmcode) {\n            return;\n          }\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // The `BKA` operator.<br>\n  // This is the positive `look behind` operator.\n  // It's child node is parsed right-to-left.\n  // Returns the EMPTY state if a match is found, NOMATCH otherwise.\n  // Like the look ahead operators, it always backtracks to `phraseIndex`.\n  const opBKA = function (opIndex, phraseIndex, sysData) {\n    lookAround.push({\n      lookAround: id.LOOKAROUND_BEHIND,\n      anchor: phraseIndex,\n    });\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    lookAround.pop();\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n        sysData.state = id.EMPTY;\n        break;\n      case id.MATCH:\n        sysData.state = id.EMPTY;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      default:\n        throw new Error(`opBKA: invalid state ${sysData.state}`);\n    }\n  };\n  // The `BKN` operator.<br>\n  // This is the negative `look behind` operator.\n  // It's child node is parsed right-to-left.\n  // Returns the EMPTY state if a match is *not* found, NOMATCH otherwise.\n  // Like the look ahead operators, it always backtracks to `phraseIndex`.\n  const opBKN = function (opIndex, phraseIndex, sysData) {\n    // let op;\n    // op = opcodes[opIndex];\n    lookAround.push({\n      lookAround: id.LOOKAROUND_BEHIND,\n      anchor: phraseIndex,\n    });\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    lookAround.pop();\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n      case id.MATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.EMPTY;\n        break;\n      default:\n        throw new Error(`opBKN: invalid state ${sysData.state}`);\n    }\n  };\n  // The right-to-left `CAT` operator.<br>\n  // Called for `CAT` operators when in look behind mode.\n  // Calls its child nodes from right to left concatenating matched phrases right to left.\n  const opCATBehind = function (opIndex, phraseIndex, sysData) {\n    let success;\n    let astLength;\n    let catCharIndex;\n    let catMatched;\n    const op = opcodes[opIndex];\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    success = true;\n    catCharIndex = phraseIndex;\n    catMatched = 0;\n    // catPhrase = 0;\n    for (let i = op.children.length - 1; i >= 0; i -= 1) {\n      opExecute(op.children[i], catCharIndex, sysData);\n      catCharIndex -= sysData.phraseLength;\n      catMatched += sysData.phraseLength;\n      // catPhrase += sysData.phraseLength;\n      if (sysData.state === id.NOMATCH) {\n        success = false;\n        break;\n      }\n    }\n    if (success) {\n      sysData.state = catMatched === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = catMatched;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // The right-to-left `REP` operator.<br>\n  // Called for `REP` operators in look behind mode.\n  // Makes repeated calls to its child node, concatenating matched phrases right to left.\n  const opREPBehind = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let repCharIndex;\n    let repPhrase;\n    let repCount;\n    const op = opcodes[opIndex];\n    repCharIndex = phraseIndex;\n    repPhrase = 0;\n    repCount = 0;\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    const TRUE = true;\n    while (TRUE) {\n      if (repCharIndex <= 0) {\n        /* exit on end of input string */\n        break;\n      }\n      opExecute(opIndex + 1, repCharIndex, sysData);\n      if (sysData.state === id.NOMATCH) {\n        /* always end if the child node fails */\n        break;\n      }\n      if (sysData.state === id.EMPTY) {\n        /* REP always succeeds when the child node returns an empty phrase */\n        /* this may not seem obvious, but that's the way it works out */\n        break;\n      }\n      repCount += 1;\n      repPhrase += sysData.phraseLength;\n      repCharIndex -= sysData.phraseLength;\n      if (repCount === op.max) {\n        /* end on maxed out reps */\n        break;\n      }\n    }\n    /* evaluate the match count according to the min, max values */\n    if (sysData.state === id.EMPTY) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else if (repCount >= op.min) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // The right-to-left `TRG` operator.<br>\n  // Called for `TRG` operators in look behind mode.\n  // Matches a single character at `phraseIndex - 1` to the `min` - `max` range.\n  const opTRGBehind = function (opIndex, phraseIndex, sysData) {\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    if (phraseIndex > 0) {\n      const char = chars[phraseIndex - 1];\n      if (op.min <= char && char <= op.max) {\n        sysData.state = id.MATCH;\n        sysData.phraseLength = 1;\n      }\n    }\n  };\n  // The right-to-left `TBS` operator.<br>\n  // Called for `TBS` operators in look behind mode.\n  // Matches the `TBS` phrase to the left of `phraseIndex`.\n  const opTBSBehind = function (opIndex, phraseIndex, sysData) {\n    let i;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    const len = op.string.length;\n    const beg = phraseIndex - len;\n    if (beg >= 0) {\n      for (i = 0; i < len; i += 1) {\n        if (chars[beg + i] !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // The right-to-left `TLS` operator.<br>\n  // Called for `TLS` operators in look behind mode.\n  // Matches the `TLS` phrase to the left of `phraseIndex`.\n  const opTLSBehind = function (opIndex, phraseIndex, sysData) {\n    let char;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    const len = op.string.length;\n    if (len === 0) {\n      /* EMPTY match allowed for TLS */\n      sysData.state = id.EMPTY;\n      return;\n    }\n    const beg = phraseIndex - len;\n    if (beg >= 0) {\n      for (let i = 0; i < len; i += 1) {\n        char = chars[beg + i];\n        if (char >= 65 && char <= 90) {\n          char += 32;\n        }\n        if (char !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // The right-to-left back reference operator.<br>\n  // Matches the back referenced phrase to the left of `phraseIndex`.\n  const opBKRBehind = function (opIndex, phraseIndex, sysData) {\n    let i;\n    let code;\n    let lmcode;\n    let lower;\n    const op = opcodes[opIndex];\n    /* NOMATCH default */\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    if (op.index < rules.length) {\n      lower = rules[op.index].lower;\n    } else {\n      lower = udts[op.index - rules.length].lower;\n    }\n    const frame = op.bkrMode === id.BKR_MODE_PM ? sysData.pFrame.getPhrase(lower) : sysData.uFrame.getPhrase(lower);\n    const insensitive = op.bkrCase === id.BKR_MODE_CI;\n    if (frame === null) {\n      return;\n    }\n    const lmIndex = frame.phraseIndex;\n    const len = frame.phraseLength;\n    if (len === 0) {\n      sysData.state = id.EMPTY;\n      sysData.phraseLength = 0;\n      return;\n    }\n    const beg = phraseIndex - len;\n    if (beg >= 0) {\n      if (insensitive) {\n        /* case-insensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[beg + i];\n          lmcode = chars[lmIndex + i];\n          if (code >= 65 && code <= 90) {\n            code += 32;\n          }\n          if (lmcode >= 65 && lmcode <= 90) {\n            lmcode += 32;\n          }\n          if (code !== lmcode) {\n            return;\n          }\n        }\n        sysData.state = id.MATCH;\n        sysData.phraseLength = len;\n      } else {\n        /* case-sensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[beg + i];\n          lmcode = chars[lmIndex + i];\n          if (code !== lmcode) {\n            return;\n          }\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // Generalized execution function.<br>\n  // Having a single, generalized function, allows a single location\n  // for tracing and statistics gathering functions to be called.\n  // Tracing and statistics are handled in separate objects.\n  // However, the parser calls their API to build the object data records.\n  // See [`trace.js`](./trace.html) and [`stats.js`](./stats.html) for their\n  // usage.\n  opExecute = function opExecuteFunc(opIndex, phraseIndex, sysData) {\n    let ret = true;\n    const op = opcodes[opIndex];\n    nodeHits += 1;\n    if (nodeHits > limitNodeHits) {\n      throw new Error(`parser: maximum number of node hits exceeded: ${limitNodeHits}`);\n    }\n    treeDepth += 1;\n    if (treeDepth > maxTreeDepth) {\n      maxTreeDepth = treeDepth;\n      if (maxTreeDepth > limitTreeDepth) {\n        throw new Error(`parser: maximum parse tree depth exceeded: ${limitTreeDepth}`);\n      }\n    }\n    sysData.refresh();\n    if (thisThis.trace !== null) {\n      /* collect the trace record for down the parse tree */\n      const lk = lookAroundValue();\n      thisThis.trace.down(op, sysData.state, phraseIndex, sysData.phraseLength, lk.anchor, lk.lookAround);\n    }\n    if (inLookBehind()) {\n      switch (op.type) {\n        case id.ALT:\n          opALT(opIndex, phraseIndex, sysData);\n          break;\n        case id.CAT:\n          opCATBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.REP:\n          opREPBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.RNM:\n          opRNM(opIndex, phraseIndex, sysData);\n          break;\n        case id.UDT:\n          opUDT(opIndex, phraseIndex, sysData);\n          break;\n        case id.AND:\n          opAND(opIndex, phraseIndex, sysData);\n          break;\n        case id.NOT:\n          opNOT(opIndex, phraseIndex, sysData);\n          break;\n        case id.TRG:\n          opTRGBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.TBS:\n          opTBSBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.TLS:\n          opTLSBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKR:\n          opBKRBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKA:\n          opBKA(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKN:\n          opBKN(opIndex, phraseIndex, sysData);\n          break;\n        case id.ABG:\n          opABG(opIndex, phraseIndex, sysData);\n          break;\n        case id.AEN:\n          opAEN(opIndex, phraseIndex, sysData);\n          break;\n        default:\n          ret = false;\n          break;\n      }\n    } else {\n      switch (op.type) {\n        case id.ALT:\n          opALT(opIndex, phraseIndex, sysData);\n          break;\n        case id.CAT:\n          opCAT(opIndex, phraseIndex, sysData);\n          break;\n        case id.REP:\n          opREP(opIndex, phraseIndex, sysData);\n          break;\n        case id.RNM:\n          opRNM(opIndex, phraseIndex, sysData);\n          break;\n        case id.UDT:\n          opUDT(opIndex, phraseIndex, sysData);\n          break;\n        case id.AND:\n          opAND(opIndex, phraseIndex, sysData);\n          break;\n        case id.NOT:\n          opNOT(opIndex, phraseIndex, sysData);\n          break;\n        case id.TRG:\n          opTRG(opIndex, phraseIndex, sysData);\n          break;\n        case id.TBS:\n          opTBS(opIndex, phraseIndex, sysData);\n          break;\n        case id.TLS:\n          opTLS(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKR:\n          opBKR(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKA:\n          opBKA(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKN:\n          opBKN(opIndex, phraseIndex, sysData);\n          break;\n        case id.ABG:\n          opABG(opIndex, phraseIndex, sysData);\n          break;\n        case id.AEN:\n          opAEN(opIndex, phraseIndex, sysData);\n          break;\n        default:\n          ret = false;\n          break;\n      }\n    }\n    if (!inLookAround() && phraseIndex + sysData.phraseLength > maxMatched) {\n      maxMatched = phraseIndex + sysData.phraseLength;\n    }\n    if (thisThis.stats !== null) {\n      /* collect the statistics */\n      thisThis.stats.collect(op, sysData);\n    }\n    if (thisThis.trace !== null) {\n      /* collect the trace record for up the parse tree */\n      const lk = lookAroundValue();\n      thisThis.trace.up(op, sysData.state, phraseIndex, sysData.phraseLength, lk.anchor, lk.lookAround);\n    }\n    treeDepth -= 1;\n    return ret;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3BhcnNlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsdUVBQWU7QUFDcEMsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQWE7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBLHlCQUF5QixhQUFhLGNBQWMsV0FBVztBQUMvRDtBQUNBO0FBQ0EseUJBQXlCLGFBQWEsZ0JBQWdCLGFBQWE7QUFDbkU7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBLHlCQUF5QixhQUFhLGFBQWEsVUFBVTtBQUM3RDtBQUNBO0FBQ0EseUJBQXlCLGFBQWEsZ0JBQWdCLGFBQWE7QUFDbkU7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWEsNkJBQTZCLE9BQU87QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWEsbUNBQW1DLGFBQWEsV0FBVyxVQUFVO0FBQzdHO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhLG1CQUFtQixVQUFVO0FBQ3JFO0FBQ0EsTUFBTTtBQUNOLHlCQUF5QixhQUFhLHNCQUFzQixpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDJCQUEyQixhQUFhLHNDQUFzQyxJQUFJO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDJCQUEyQixhQUFhLDZCQUE2QixJQUFJO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYSxtQkFBbUIsTUFBTTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxhQUFhLGFBQWEsa0JBQWtCLE1BQU07QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQSxhQUFhLGFBQWEsa0RBQWtELGNBQWM7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxNQUFNO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxNQUFNO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsS0FBSztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsS0FBSztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhLFFBQVEsVUFBVTtBQUNsRCxzQ0FBc0MscUJBQXFCO0FBQzNELDZDQUE2QyxVQUFVO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYSxRQUFRLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWEsUUFBUSxVQUFVLGdFQUFnRSxjQUFjO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhLFFBQVEsU0FBUztBQUNqRCxzQ0FBc0MscUJBQXFCO0FBQzNELDZDQUE2QyxVQUFVO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWEsUUFBUSxTQUFTO0FBQ3pEO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYSxRQUFRLFNBQVM7QUFDM0QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhLFFBQVEsU0FBUztBQUM3RCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhLFFBQVEsU0FBUyxnRUFBZ0UsY0FBYztBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxjQUFjO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxjQUFjO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsY0FBYztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGVBQWU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3BhcnNlci5qcz9iNzkxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGZ1bmMtbmFtZXMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtc3ludGF4ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXG4vKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cbi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgaXMgdGhlIHByaW1hcnkgb2JqZWN0IG9mIGBhcGctbGliYC4gQ2FsbGluZyBpdHMgYHBhcnNlKClgIG1lbWJlciBmdW5jdGlvblxuLy8gd2Fsa3MgdGhlIHBhcnNlIHRyZWUgb2Ygb3Bjb2RlcywgbWF0Y2hpbmcgcGhyYXNlcyBmcm9tIHRoZSBpbnB1dCBzdHJpbmcgYXMgaXQgZ29lcy5cbi8vIFRoZSB3b3JraW5nIGNvZGUgZm9yIGFsbCBvZiB0aGUgb3BlcmF0b3JzLCBgQUxUYCwgYENBVGAsIGV0Yy4gaXMgaW4gdGhpcyBtb2R1bGUuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlcigpIHtcbiAgY29uc3QgaWQgPSByZXF1aXJlKCcuL2lkZW50aWZpZXJzJyk7XG4gIGNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMnKTtcblxuICBjb25zdCB0aGlzRmlsZU5hbWUgPSAncGFyc2VyLmpzOiAnO1xuICBjb25zdCB0aGlzVGhpcyA9IHRoaXM7XG4gIGxldCBvcEV4ZWN1dGU7XG4gIHRoaXMuYXN0ID0gbnVsbDtcbiAgdGhpcy5zdGF0cyA9IG51bGw7XG4gIHRoaXMudHJhY2UgPSBudWxsO1xuICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xuICBsZXQgb3Bjb2RlcyA9IG51bGw7XG4gIGxldCBjaGFycyA9IG51bGw7XG4gIGxldCBjaGFyc0JlZ2luO1xuICBsZXQgY2hhcnNMZW5ndGg7XG4gIGxldCBjaGFyc0VuZDtcbiAgbGV0IGxvb2tBcm91bmQ7XG4gIGxldCB0cmVlRGVwdGggPSAwO1xuICBsZXQgbWF4VHJlZURlcHRoID0gMDtcbiAgbGV0IG5vZGVIaXRzID0gMDtcbiAgbGV0IHJ1bGVDYWxsYmFja3MgPSBudWxsO1xuICBsZXQgdWR0Q2FsbGJhY2tzID0gbnVsbDtcbiAgbGV0IHJ1bGVzID0gbnVsbDtcbiAgbGV0IHVkdHMgPSBudWxsO1xuICBsZXQgc3ludGF4RGF0YSA9IG51bGw7XG4gIGxldCBtYXhNYXRjaGVkID0gMDtcbiAgbGV0IGxpbWl0VHJlZURlcHRoID0gSW5maW5pdHk7XG4gIGxldCBsaW1pdE5vZGVIaXRzID0gSW5maW5pdHk7XG4gIC8vIEV2YWx1YXRlcyBhbnkgZ2l2ZW4gcnVsZS4gVGhpcyBjYW4gYmUgY2FsbGVkIGZyb20gdGhlIHN5bnRheCBjYWxsYmFja1xuICAvLyBmdW5jdGlvbnMgdG8gZXZhbHVhdGUgYW55IHJ1bGUgaW4gdGhlIGdyYW1tYXIncyBydWxlIGxpc3QuIEdyZWF0IGNhdXRpb25cbiAgLy8gc2hvdWxkIGJlIHVzZWQuIFVzZSBvZiB0aGlzIGZ1bmN0aW9uIHdpbGwgYWx0ZXIgdGhlIGxhbmd1YWdlIHRoYXQgdGhlXG4gIC8vIHBhcnNlciBhY2NlcHRzLlxuICBjb25zdCBldmFsdWF0ZVJ1bGUgPSBmdW5jdGlvbiBldmFsdWF0ZVJ1bGUocnVsZUluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGAke3RoaXNGaWxlTmFtZX1ldmFsdWF0ZVJ1bGUoKTogYDtcbiAgICBpZiAocnVsZUluZGV4ID49IHJ1bGVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1ydWxlIGluZGV4OiAke3J1bGVJbmRleH0gb3V0IG9mIHJhbmdlYCk7XG4gICAgfVxuICAgIGlmIChwaHJhc2VJbmRleCA+PSBjaGFyc0VuZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1waHJhc2UgaW5kZXg6ICR7cGhyYXNlSW5kZXh9IG91dCBvZiByYW5nZWApO1xuICAgIH1cbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gb3Bjb2RlcztcbiAgICBvcGNvZGVzLnB1c2goe1xuICAgICAgdHlwZTogaWQuUk5NLFxuICAgICAgaW5kZXg6IHJ1bGVJbmRleCxcbiAgICB9KTtcbiAgICBvcEV4ZWN1dGUobGVuZ3RoLCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgb3Bjb2Rlcy5wb3AoKTtcbiAgfTtcbiAgLy8gRXZhbHVhdGVzIGFueSBnaXZlbiBVRFQuIFRoaXMgY2FuIGJlIGNhbGxlZCBmcm9tIHRoZSBzeW50YXggY2FsbGJhY2tcbiAgLy8gZnVuY3Rpb25zIHRvIGV2YWx1YXRlIGFueSBVRFQgaW4gdGhlIGdyYW1tYXIncyBVRFQgbGlzdC4gR3JlYXQgY2F1dGlvblxuICAvLyBzaG91bGQgYmUgdXNlZC4gVXNlIG9mIHRoaXMgZnVuY3Rpb24gd2lsbCBhbHRlciB0aGUgbGFuZ3VhZ2UgdGhhdCB0aGVcbiAgLy8gcGFyc2VyIGFjY2VwdHMuXG4gIGNvbnN0IGV2YWx1YXRlVWR0ID0gZnVuY3Rpb24gKHVkdEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGAke3RoaXNGaWxlTmFtZX1ldmFsdWF0ZVVkdCgpOiBgO1xuICAgIGlmICh1ZHRJbmRleCA+PSB1ZHRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX11ZHQgaW5kZXg6ICR7dWR0SW5kZXh9IG91dCBvZiByYW5nZWApO1xuICAgIH1cbiAgICBpZiAocGhyYXNlSW5kZXggPj0gY2hhcnNFbmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9cGhyYXNlIGluZGV4OiAke3BocmFzZUluZGV4fSBvdXQgb2YgcmFuZ2VgKTtcbiAgICB9XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IG9wY29kZXM7XG4gICAgb3Bjb2Rlcy5wdXNoKHtcbiAgICAgIHR5cGU6IGlkLlVEVCxcbiAgICAgIGVtcHR5OiB1ZHRzW3VkdEluZGV4XS5lbXB0eSxcbiAgICAgIGluZGV4OiB1ZHRJbmRleCxcbiAgICB9KTtcbiAgICBvcEV4ZWN1dGUobGVuZ3RoLCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgb3Bjb2Rlcy5wb3AoKTtcbiAgfTtcbiAgLyogQ2xlYXJzIHRoaXMgb2JqZWN0IG9mIGFueS9hbGwgZGF0YSB0aGF0IGhhcyBiZWVuIGluaXRpYWxpemVkIG9yIGFkZGVkIHRvIGl0LiAqL1xuICAvKiBDYWxsZWQgYnkgcGFyc2UoKSBvbiBpbml0aWFsaXphdGlvbiwgYWxsb3dpbmcgdGhpcyBvYmplY3QgdG8gYmUgcmUtdXNlZCBmb3IgbXVsdGlwbGUgcGFyc2luZyBjYWxscy4gKi9cbiAgY29uc3QgY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdHJlZURlcHRoID0gMDtcbiAgICBtYXhUcmVlRGVwdGggPSAwO1xuICAgIG5vZGVIaXRzID0gMDtcbiAgICBtYXhNYXRjaGVkID0gMDtcbiAgICBsb29rQXJvdW5kID0gW1xuICAgICAge1xuICAgICAgICBsb29rQXJvdW5kOiBpZC5MT09LQVJPVU5EX05PTkUsXG4gICAgICAgIGFuY2hvcjogMCxcbiAgICAgICAgY2hhcnNFbmQ6IDAsXG4gICAgICAgIGNoYXJzTGVuZ3RoOiAwLFxuICAgICAgfSxcbiAgICBdO1xuICAgIHJ1bGVzID0gbnVsbDtcbiAgICB1ZHRzID0gbnVsbDtcbiAgICBjaGFycyA9IG51bGw7XG4gICAgY2hhcnNCZWdpbiA9IDA7XG4gICAgY2hhcnNMZW5ndGggPSAwO1xuICAgIGNoYXJzRW5kID0gMDtcbiAgICBydWxlQ2FsbGJhY2tzID0gbnVsbDtcbiAgICB1ZHRDYWxsYmFja3MgPSBudWxsO1xuICAgIHN5bnRheERhdGEgPSBudWxsO1xuICAgIG9wY29kZXMgPSBudWxsO1xuICB9O1xuICAvKiBvYmplY3QgZm9yIG1haW50YWluaW5nIGEgc3RhY2sgb2YgYmFjayByZWZlcmVuY2UgZnJhbWVzICovXG4gIGNvbnN0IGJhY2tSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgICBjb25zdCBpbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICBydWxlcy5mb3JFYWNoKChydWxlKSA9PiB7XG4gICAgICAgIGlmIChydWxlLmlzQmtyKSB7XG4gICAgICAgICAgb2JqW3J1bGUubG93ZXJdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAodWR0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHVkdHMuZm9yRWFjaCgodWR0KSA9PiB7XG4gICAgICAgICAgaWYgKHVkdC5pc0Jrcikge1xuICAgICAgICAgICAgb2JqW3VkdC5sb3dlcl0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzdGFjay5wdXNoKG9iaik7XG4gICAgfTtcbiAgICBjb25zdCBjb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgdG9wID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgIC8qIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCAqL1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIHRvcCkge1xuICAgICAgICBvYmpbbmFtZV0gPSB0b3BbbmFtZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gICAgdGhpcy5wdXNoID0gZnVuY3Rpb24gcHVzaCgpIHtcbiAgICAgIHN0YWNrLnB1c2goY29weSgpKTtcbiAgICB9O1xuICAgIHRoaXMucG9wID0gZnVuY3Rpb24gcG9wKGxlbmd0aEFyZykge1xuICAgICAgbGV0IGxlbmd0aCA9IGxlbmd0aEFyZztcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGxlbmd0aCA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoIDwgMSB8fCBsZW5ndGggPiBzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1iYWNrUmVmLnBvcCgpOiBiYWQgbGVuZ3RoOiAke2xlbmd0aH1gKTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgIHJldHVybiBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIHRoaXMubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgICAgcmV0dXJuIHN0YWNrLmxlbmd0aDtcbiAgICB9O1xuICAgIHRoaXMuc2F2ZVBocmFzZSA9IGZ1bmN0aW9uIHNhdmVQaHJhc2UobmFtZSwgaW5kZXgsIGxlbmd0aCkge1xuICAgICAgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1bbmFtZV0gPSB7XG4gICAgICAgIHBocmFzZUluZGV4OiBpbmRleCxcbiAgICAgICAgcGhyYXNlTGVuZ3RoOiBsZW5ndGgsXG4gICAgICB9O1xuICAgIH07XG4gICAgdGhpcy5nZXRQaHJhc2UgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdW25hbWVdO1xuICAgIH07XG4gICAgLyogY29uc3RydWN0b3IgKi9cbiAgICBpbml0KCk7XG4gIH07XG4gIC8vIFRoZSBzeXN0ZW0gZGF0YSBzdHJ1Y3R1cmUgdGhhdCByZWxheXMgc3lzdGVtIGluZm9ybWF0aW9uIHRvIGFuZCBmcm9tIHRoZSBydWxlIGFuZCBVRFQgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICAvLyAtICpzdGF0ZSogLSB0aGUgc3RhdGUgb2YgdGhlIHBhcnNlciwgQUNUSVZFLCBNQVRDSCwgRU1QVFkgb3IgTk9NQVRDSCAoc2VlIHRoZSBgaWRlbnRpZmllcnNgIG9iamVjdCBpblxuICAvLyBbYGFwZy1saWJgXShodHRwczovL2dpdGh1Yi5jb20vbGR0aG9tYXMvYXBnLWpzMi1saWIpKVxuICAvLyAtICpwaHJhc2VMZW5ndGgqIC0gdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIG1hdGNoZWQgaWYgdGhlIHN0YXRlIGlzIE1BVENIRUQgb3IgRU1QVFlcbiAgLy8gLSAqbG9va2Fyb3VuZCogLSB0aGUgdG9wIG9mIHRoZSBzdGFjayBob2xkcyB0aGUgY3VycmVudCBsb29rIGFyb3VuZCBzdGF0ZSxcbiAgLy8gTE9PS0FST1VORF9OT05FLCBMT09LQVJPVU5EX0FIRUFEIG9yIExPT0tBUk9VTkRfQkVISU5ELFxuICAvLyAtICp1RnJhbWUqIC0gdGhlIFwidW5pdmVyc2FsXCIgYmFjayByZWZlcmVuY2UgZnJhbWUuXG4gIC8vIEhvbGRzIHRoZSBsYXN0IG1hdGNoZWQgcGhyYXNlIGZvciBlYWNoIG9mIHRoZSBiYWNrIHJlZmVyZW5jZWQgcnVsZXMgYW5kIFVEVHMuXG4gIC8vIC0gKnBGcmFtZSogLSB0aGUgc3RhY2sgb2YgXCJwYXJlbnRcIiBiYWNrIHJlZmVyZW5jZSBmcmFtZXMuXG4gIC8vIEhvbGRzIHRoZSBtYXRjaGVkIHBocmFzZSBmcm9tIHRoZSBwYXJlbnQgZnJhbWUgb2YgZWFjaCBiYWNrIHJlZmVyZW5jZWQgcnVsZXMgYW5kIFVEVHMuXG4gIC8vIC0gKmV2YWx1YXRlUnVsZSogLSBhIHJlZmVyZW5jZSB0byB0aGlzIG9iamVjdCdzIGBldmFsdWF0ZVJ1bGUoKWAgZnVuY3Rpb24uXG4gIC8vIENhbiBiZSBjYWxsZWQgZnJvbSBhIGNhbGxiYWNrIGZ1bmN0aW9uICh1c2Ugd2l0aCBleHRyZW1lIGNhdXRpb24hKVxuICAvLyAtICpldmFsdWF0ZVVkdCogLSBhIHJlZmVyZW5jZSB0byB0aGlzIG9iamVjdCdzIGBldmFsdWF0ZVVkdCgpYCBmdW5jdGlvbi5cbiAgLy8gQ2FuIGJlIGNhbGxlZCBmcm9tIGEgY2FsbGJhY2sgZnVuY3Rpb24gKHVzZSB3aXRoIGV4dHJlbWUgY2F1dGlvbiEpXG4gIGNvbnN0IHN5c3RlbURhdGEgPSBmdW5jdGlvbiBzeXN0ZW1EYXRhKCkge1xuICAgIGNvbnN0IHRoaXNEYXRhID0gdGhpcztcbiAgICB0aGlzLnN0YXRlID0gaWQuQUNUSVZFO1xuICAgIHRoaXMucGhyYXNlTGVuZ3RoID0gMDtcbiAgICB0aGlzLnJ1bGVJbmRleCA9IDA7XG4gICAgdGhpcy51ZHRJbmRleCA9IDA7XG4gICAgdGhpcy5sb29rQXJvdW5kID0gbG9va0Fyb3VuZFtsb29rQXJvdW5kLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMudUZyYW1lID0gbmV3IGJhY2tSZWYoKTtcbiAgICB0aGlzLnBGcmFtZSA9IG5ldyBiYWNrUmVmKCk7XG4gICAgdGhpcy5ldmFsdWF0ZVJ1bGUgPSBldmFsdWF0ZVJ1bGU7XG4gICAgdGhpcy5ldmFsdWF0ZVVkdCA9IGV2YWx1YXRlVWR0O1xuICAgIC8qIHJlZnJlc2ggdGhlIHBhcnNlciBzdGF0ZSBmb3IgdGhlIG5leHQgb3BlcmF0aW9uICovXG4gICAgdGhpcy5yZWZyZXNoID0gZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgIHRoaXNEYXRhLnN0YXRlID0gaWQuQUNUSVZFO1xuICAgICAgdGhpc0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICAgIHRoaXNEYXRhLmxvb2tBcm91bmQgPSBsb29rQXJvdW5kW2xvb2tBcm91bmQubGVuZ3RoIC0gMV07XG4gICAgfTtcbiAgfTtcbiAgLyogc29tZSBsb29rIGFyb3VuZCBoZWxwZXIgZnVuY3Rpb25zICovXG4gIGNvbnN0IGxvb2tBcm91bmRWYWx1ZSA9IGZ1bmN0aW9uIGxvb2tBcm91bmRWYWx1ZSgpIHtcbiAgICByZXR1cm4gbG9va0Fyb3VuZFtsb29rQXJvdW5kLmxlbmd0aCAtIDFdO1xuICB9O1xuICAvKiByZXR1cm4gdHJ1ZSBpZiBwYXJzZXIgaXMgaW4gbG9vayBhcm91bmQgKGFoZWFkIG9yIGJlaGluZCkgc3RhdGUgKi9cbiAgY29uc3QgaW5Mb29rQXJvdW5kID0gZnVuY3Rpb24gaW5Mb29rQXJvdW5kKCkge1xuICAgIHJldHVybiBsb29rQXJvdW5kLmxlbmd0aCA+IDE7XG4gIH07XG4gIC8qIHJldHVybiB0cnVlIGlmIHBhcnNlciBpcyBpbiBsb29rIGJlaGluZCBzdGF0ZSAqL1xuICBjb25zdCBpbkxvb2tCZWhpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxvb2tBcm91bmRbbG9va0Fyb3VuZC5sZW5ndGggLSAxXS5sb29rQXJvdW5kID09PSBpZC5MT09LQVJPVU5EX0JFSElORDtcbiAgfTtcbiAgLyogY2FsbGVkIGJ5IHBhcnNlKCkgdG8gaW5pdGlhbGl6ZSB0aGUgQVNUIG9iamVjdCwgaWYgb25lIGhhcyBiZWVuIGRlZmluZWQgKi9cbiAgY29uc3QgaW5pdGlhbGl6ZUFzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBgJHt0aGlzRmlsZU5hbWV9aW5pdGlhbGl6ZUFzdCgpOiBgO1xuICAgIGNvbnN0IFRSVUUgPSB0cnVlO1xuICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICBpZiAodGhpc1RoaXMuYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpc1RoaXMuYXN0ID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodGhpc1RoaXMuYXN0ID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXNUaGlzLmFzdC5hc3RPYmplY3QgIT09ICdhc3RPYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9YXN0IG9iamVjdCBub3QgcmVjb2duaXplZGApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzVGhpcy5hc3QgIT09IG51bGwpIHtcbiAgICAgIHRoaXNUaGlzLmFzdC5pbml0KHJ1bGVzLCB1ZHRzLCBjaGFycyk7XG4gICAgfVxuICB9O1xuICAvKiBjYWxsZWQgYnkgcGFyc2UoKSB0byBpbml0aWFsaXplIHRoZSB0cmFjZSBvYmplY3QsIGlmIG9uZSBoYXMgYmVlbiBkZWZpbmVkICovXG4gIGNvbnN0IGluaXRpYWxpemVUcmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBgJHt0aGlzRmlsZU5hbWV9aW5pdGlhbGl6ZVRyYWNlKCk6IGA7XG4gICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgd2hpbGUgKFRSVUUpIHtcbiAgICAgIGlmICh0aGlzVGhpcy50cmFjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXNUaGlzLnRyYWNlID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodGhpc1RoaXMudHJhY2UgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodGhpc1RoaXMudHJhY2UudHJhY2VPYmplY3QgIT09ICd0cmFjZU9iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX10cmFjZSBvYmplY3Qgbm90IHJlY29nbml6ZWRgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpc1RoaXMudHJhY2UgIT09IG51bGwpIHtcbiAgICAgIHRoaXNUaGlzLnRyYWNlLmluaXQocnVsZXMsIHVkdHMsIGNoYXJzKTtcbiAgICB9XG4gIH07XG4gIC8qIGNhbGxlZCBieSBwYXJzZSgpIHRvIGluaXRpYWxpemUgdGhlIHN0YXRpc3RpY3Mgb2JqZWN0LCBpZiBvbmUgaGFzIGJlZW4gZGVmaW5lZCAqL1xuICBjb25zdCBpbml0aWFsaXplU3RhdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYCR7dGhpc0ZpbGVOYW1lfWluaXRpYWxpemVTdGF0cygpOiBgO1xuICAgIGNvbnN0IFRSVUUgPSB0cnVlO1xuICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICBpZiAodGhpc1RoaXMuc3RhdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzVGhpcy5zdGF0cyA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXNUaGlzLnN0YXRzID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXNUaGlzLnN0YXRzLnN0YXRzT2JqZWN0ICE9PSAnc3RhdHNPYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9c3RhdHMgb2JqZWN0IG5vdCByZWNvZ25pemVkYCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXNUaGlzLnN0YXRzICE9PSBudWxsKSB7XG4gICAgICB0aGlzVGhpcy5zdGF0cy5pbml0KHJ1bGVzLCB1ZHRzKTtcbiAgICB9XG4gIH07XG4gIC8qIGNhbGxlZCBieSBwYXJzZSgpIHRvIGluaXRpYWxpemUgdGhlIHJ1bGVzICYgdWR0cyBmcm9tIHRoZSBncmFtbWFyIG9iamVjdCAqL1xuICAvKiAodGhlIGdyYW1tYXIgb2JqZWN0IGdlbmVyYXRlZCBwcmV2aW91c2x5IGJ5IGFwZykgKi9cbiAgY29uc3QgaW5pdGlhbGl6ZUdyYW1tYXIgPSBmdW5jdGlvbiAoZ3JhbW1hcikge1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGAke3RoaXNGaWxlTmFtZX1pbml0aWFsaXplR3JhbW1hcigpOiBgO1xuICAgIGlmICghZ3JhbW1hcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1ncmFtbWFyIG9iamVjdCB1bmRlZmluZWRgKTtcbiAgICB9XG4gICAgaWYgKGdyYW1tYXIuZ3JhbW1hck9iamVjdCAhPT0gJ2dyYW1tYXJPYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfWJhZCBncmFtbWFyIG9iamVjdGApO1xuICAgIH1cbiAgICBydWxlcyA9IGdyYW1tYXIucnVsZXM7XG4gICAgdWR0cyA9IGdyYW1tYXIudWR0cztcbiAgfTtcbiAgLyogY2FsbGVkIGJ5IHBhcnNlKCkgdG8gaW5pdGlhbGl6ZSB0aGUgc3RhcnQgcnVsZSAqL1xuICBjb25zdCBpbml0aWFsaXplU3RhcnRSdWxlID0gZnVuY3Rpb24gKHN0YXJ0UnVsZSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGAke3RoaXNGaWxlTmFtZX1pbml0aWFsaXplU3RhcnRSdWxlKCk6IGA7XG4gICAgbGV0IHN0YXJ0ID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIHN0YXJ0UnVsZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChzdGFydFJ1bGUgPj0gcnVsZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9c3RhcnQgcnVsZSBpbmRleCB0b28gbGFyZ2U6IG1heDogJHtydWxlcy5sZW5ndGh9OiBpbmRleDogJHtzdGFydFJ1bGV9YCk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IHN0YXJ0UnVsZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdGFydFJ1bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBsb3dlciA9IHN0YXJ0UnVsZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAobG93ZXIgPT09IHJ1bGVzW2ldLmxvd2VyKSB7XG4gICAgICAgICAgc3RhcnQgPSBydWxlc1tpXS5pbmRleDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9c3RhcnQgcnVsZSBuYW1lICcke3N0YXJ0UnVsZX0nIG5vdCByZWNvZ25pemVkYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9dHlwZSBvZiBzdGFydCBydWxlICcke3R5cGVvZiBzdGFydFJ1bGV9JyBub3QgcmVjb2duaXplZGApO1xuICAgIH1cbiAgICByZXR1cm4gc3RhcnQ7XG4gIH07XG4gIC8qIGNhbGxlZCBieSBwYXJzZSgpIHRvIGluaXRpYWxpemUgdGhlIGFycmF5IG9mIGNoYXJhY3RlcnMgY29kZXMgcmVwcmVzZW50aW5nIHRoZSBpbnB1dCBzdHJpbmcgKi9cbiAgY29uc3QgaW5pdGlhbGl6ZUlucHV0Q2hhcnMgPSBmdW5jdGlvbiBpbml0aWFsaXplSW5wdXRDaGFycyhpbnB1dEFyZywgYmVnQXJnLCBsZW5BcmcpIHtcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBgJHt0aGlzRmlsZU5hbWV9aW5pdGlhbGl6ZUlucHV0Q2hhcnMoKTogYDtcbiAgICAvKiB2YXJpZnkgYW5kIG5vcm1hbGl6ZSBpbnB1dCAqL1xuICAgIGxldCBpbnB1dCA9IGlucHV0QXJnO1xuICAgIGxldCBiZWcgPSBiZWdBcmc7XG4gICAgbGV0IGxlbiA9IGxlbkFyZztcbiAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1pbnB1dCBzdHJpbmcgaXMgdW5kZWZpbmVkYCk7XG4gICAgfVxuICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1pbnB1dCBzdHJpbmcgaXMgbnVsbGApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgaW5wdXQgPSB1dGlscy5zdHJpbmdUb0NoYXJzKGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1pbnB1dCBzdHJpbmcgaXMgbm90IGEgc3RyaW5nIG9yIGFycmF5YCk7XG4gICAgfVxuICAgIGlmIChpbnB1dC5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGlucHV0WzBdICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfWlucHV0IHN0cmluZyBub3QgYW4gYXJyYXkgb2YgaW50ZWdlcnNgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogdmVyaWZ5IGFuZCBub3JtYWxpemUgYmVnaW5uaW5nIGluZGV4ICovXG4gICAgaWYgKHR5cGVvZiBiZWcgIT09ICdudW1iZXInKSB7XG4gICAgICBiZWcgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBiZWcgPSBNYXRoLmZsb29yKGJlZyk7XG4gICAgICBpZiAoYmVnIDwgMCB8fCBiZWcgPiBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1pbnB1dCBiZWdpbm5pbmcgaW5kZXggb3V0IG9mIHJhbmdlOiAke2JlZ31gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogdmVyaWZ5IGFuZCBub3JtYWxpemUgaW5wdXQgbGVuZ3RoICovXG4gICAgaWYgKHR5cGVvZiBsZW4gIT09ICdudW1iZXInKSB7XG4gICAgICBsZW4gPSBpbnB1dC5sZW5ndGggLSBiZWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbiA9IE1hdGguZmxvb3IobGVuKTtcbiAgICAgIGlmIChsZW4gPCAwIHx8IGxlbiA+IGlucHV0Lmxlbmd0aCAtIGJlZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfWlucHV0IGxlbmd0aCBvdXQgb2YgcmFuZ2U6ICR7bGVufWApO1xuICAgICAgfVxuICAgIH1cbiAgICBjaGFycyA9IGlucHV0O1xuICAgIGNoYXJzQmVnaW4gPSBiZWc7XG4gICAgY2hhcnNMZW5ndGggPSBsZW47XG4gICAgY2hhcnNFbmQgPSBjaGFyc0JlZ2luICsgY2hhcnNMZW5ndGg7XG4gIH07XG4gIC8qIGNhbGxlZCBieSBwYXJzZSgpIHRvIGluaXRpYWxpemUgdGhlIHVzZXItd3JpdHRlbiwgc3ludGF4IGNhbGxiYWNrIGZ1bmN0aW9ucywgaWYgYW55ICovXG4gIGNvbnN0IGluaXRpYWxpemVDYWxsYmFja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYCR7dGhpc0ZpbGVOYW1lfWluaXRpYWxpemVDYWxsYmFja3MoKTogYDtcbiAgICBsZXQgaTtcbiAgICBydWxlQ2FsbGJhY2tzID0gW107XG4gICAgdWR0Q2FsbGJhY2tzID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBydWxlQ2FsbGJhY2tzW2ldID0gbnVsbDtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHVkdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHVkdENhbGxiYWNrc1tpXSA9IG51bGw7XG4gICAgfVxuICAgIGxldCBmdW5jO1xuICAgIGNvbnN0IGxpc3QgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGxpc3QucHVzaChydWxlc1tpXS5sb3dlcik7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCB1ZHRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBsaXN0LnB1c2godWR0c1tpXS5sb3dlcik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaW5kZXggaW4gdGhpc1RoaXMuY2FsbGJhY2tzKSB7XG4gICAgICBpID0gbGlzdC5pbmRleE9mKGluZGV4LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9c3ludGF4IGNhbGxiYWNrICcke2luZGV4fScgbm90IGEgcnVsZSBvciB1ZHQgbmFtZWApO1xuICAgICAgfVxuICAgICAgZnVuYyA9IHRoaXNUaGlzLmNhbGxiYWNrc1tpbmRleF07XG4gICAgICBpZiAoIWZ1bmMpIHtcbiAgICAgICAgZnVuYyA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbicgfHwgZnVuYyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoaSA8IHJ1bGVzLmxlbmd0aCkge1xuICAgICAgICAgIHJ1bGVDYWxsYmFja3NbaV0gPSBmdW5jO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVkdENhbGxiYWNrc1tpIC0gcnVsZXMubGVuZ3RoXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgJHtmdW5jdGlvbk5hbWV9c3ludGF4IGNhbGxiYWNrWyR7aW5kZXh9XSBtdXN0IGJlIGZ1bmN0aW9uIHJlZmVyZW5jZSBvciAnZmFsc2UnIChmYWxzZS9udWxsL3VuZGVmaW5lZC9ldGMuKWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogbWFrZSBzdXJlIGFsbCB1ZHRzIGhhdmUgYmVlbiBkZWZpbmVkIC0gdGhlIHBhcnNlciBjYW4ndCB3b3JrIHdpdGhvdXQgdGhlbSAqL1xuICAgIGZvciAoaSA9IDA7IGkgPCB1ZHRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAodWR0Q2FsbGJhY2tzW2ldID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgJHtmdW5jdGlvbk5hbWV9YWxsIFVEVCBjYWxsYmFja3MgbXVzdCBiZSBkZWZpbmVkLiBVRFQgY2FsbGJhY2tbJHt1ZHRzW2ldLmxvd2VyfV0gbm90IGEgZnVuY3Rpb24gcmVmZXJlbmNlYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gU2V0IHRoZSBtYXhpbXVtIHBhcnNlIHRyZWUgZGVwdGggYWxsb3dlZC4gVGhlIGRlZmF1bHQgaXMgYEluZmluaXR5YC5cbiAgLy8gQSBsaW1pdCBpcyBub3Qgbm9ybWFsbHkgbmVlZGVkLCBidXQgY2FuIGJlIHVzZWQgdG8gcHJvdGVjdCBhZ2FpbnN0IGFuXG4gIC8vIGV4cG9uZW50dWFsIG9yIFwiY2F0YXN0cm9waGljYWxseSBiYWNrdHJhY2tpbmdcIiBncmFtbWFyLlxuICAvLyA8dWw+XG4gIC8vIDxsaT5cbiAgLy8gZGVwdGggLSBtYXggYWxsb3dlZCBwYXJzZSB0cmVlIGRlcHRoLiBBbiBleGNlcHRpb24gaXMgdGhyb3duIGlmIGV4Y2VlZGVkLlxuICAvLyA8L2xpPlxuICAvLyA8L3VsPlxuICB0aGlzLnNldE1heFRyZWVEZXB0aCA9IGZ1bmN0aW9uIChkZXB0aCkge1xuICAgIGlmICh0eXBlb2YgZGVwdGggIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcnNlcjogbWF4IHRyZWUgZGVwdGggbXVzdCBiZSBpbnRlZ2VyID4gMDogJHtkZXB0aH1gKTtcbiAgICB9XG4gICAgbGltaXRUcmVlRGVwdGggPSBNYXRoLmZsb29yKGRlcHRoKTtcbiAgICBpZiAobGltaXRUcmVlRGVwdGggPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJzZXI6IG1heCB0cmVlIGRlcHRoIG11c3QgYmUgaW50ZWdlciA+IDA6ICR7ZGVwdGh9YCk7XG4gICAgfVxuICB9O1xuICAvLyBTZXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIG5vZGUgaGl0cyAocGFyc2VyIHVuaXQgc3RlcHMgb3Igb3Bjb2RlIGZ1bmN0aW9uIGNhbGxzKSBhbGxvd2VkLlxuICAvLyBUaGUgZGVmYXVsdCBpcyBgSW5maW5pdHlgLlxuICAvLyBBIGxpbWl0IGlzIG5vdCBub3JtYWxseSBuZWVkZWQsIGJ1dCBjYW4gYmUgdXNlZCB0byBwcm90ZWN0IGFnYWluc3QgYW5cbiAgLy8gZXhwb25lbnR1YWwgb3IgXCJjYXRhc3Ryb3BoaWNhbGx5IGJhY2t0cmFja2luZ1wiIGdyYW1tYXIuXG4gIC8vIDx1bD5cbiAgLy8gPGxpPlxuICAvLyBoaXRzIC0gbWF4aW11bSBudW1iZXIgb2Ygbm9kZSBoaXRzIG9yIHBhcnNlciB1bml0IHN0ZXBzIGFsbG93ZWQuXG4gIC8vIEFuIGV4Y2VwdGlvbiB0aHJvd24gaWYgZXhjZWVkZWQuXG4gIC8vIDwvbGk+XG4gIC8vIDwvdWw+XG4gIHRoaXMuc2V0TWF4Tm9kZUhpdHMgPSBmdW5jdGlvbiAoaGl0cykge1xuICAgIGlmICh0eXBlb2YgaGl0cyAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcGFyc2VyOiBtYXggbm9kZSBoaXRzIG11c3QgYmUgaW50ZWdlciA+IDA6ICR7aGl0c31gKTtcbiAgICB9XG4gICAgbGltaXROb2RlSGl0cyA9IE1hdGguZmxvb3IoaGl0cyk7XG4gICAgaWYgKGxpbWl0Tm9kZUhpdHMgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJzZXI6IG1heCBub2RlIGhpdHMgbXVzdCBiZSBpbnRlZ2VyID4gMDogJHtoaXRzfWApO1xuICAgIH1cbiAgfTtcbiAgLyogdGhlIG1haW4gcGFyc2VyIGZ1bmN0aW9uICovXG4gIGNvbnN0IHByaXZhdGVQYXJzZSA9IGZ1bmN0aW9uIChncmFtbWFyLCBzdGFydFJ1bGVBcmcsIGNhbGxiYWNrRGF0YSkge1xuICAgIGxldCBzdWNjZXNzO1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGAke3RoaXNGaWxlTmFtZX1wYXJzZSgpOiBgO1xuICAgIGluaXRpYWxpemVHcmFtbWFyKGdyYW1tYXIpO1xuICAgIGNvbnN0IHN0YXJ0UnVsZSA9IGluaXRpYWxpemVTdGFydFJ1bGUoc3RhcnRSdWxlQXJnKTtcbiAgICBpbml0aWFsaXplQ2FsbGJhY2tzKCk7XG4gICAgaW5pdGlhbGl6ZVRyYWNlKCk7XG4gICAgaW5pdGlhbGl6ZVN0YXRzKCk7XG4gICAgaW5pdGlhbGl6ZUFzdCgpO1xuICAgIGNvbnN0IHN5c0RhdGEgPSBuZXcgc3lzdGVtRGF0YSgpO1xuICAgIGlmICghKGNhbGxiYWNrRGF0YSA9PT0gdW5kZWZpbmVkIHx8IGNhbGxiYWNrRGF0YSA9PT0gbnVsbCkpIHtcbiAgICAgIHN5bnRheERhdGEgPSBjYWxsYmFja0RhdGE7XG4gICAgfVxuICAgIC8qIGNyZWF0ZSBhIGR1bW15IG9wY29kZSBmb3IgdGhlIHN0YXJ0IHJ1bGUgKi9cbiAgICBvcGNvZGVzID0gW1xuICAgICAge1xuICAgICAgICB0eXBlOiBpZC5STk0sXG4gICAgICAgIGluZGV4OiBzdGFydFJ1bGUsXG4gICAgICB9LFxuICAgIF07XG4gICAgLyogZXhlY3V0ZSB0aGUgc3RhcnQgcnVsZSAqL1xuICAgIG9wRXhlY3V0ZSgwLCBjaGFyc0JlZ2luLCBzeXNEYXRhKTtcbiAgICBvcGNvZGVzID0gbnVsbDtcbiAgICAvKiB0ZXN0IGFuZCByZXR1cm4gdGhlIHN5c0RhdGEgKi9cbiAgICBzd2l0Y2ggKHN5c0RhdGEuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfWZpbmFsIHN0YXRlIHNob3VsZCBuZXZlciBiZSAnQUNUSVZFJ2ApO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChzeXNEYXRhLnBocmFzZUxlbmd0aCA9PT0gY2hhcnNMZW5ndGgpIHtcbiAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVjb2duaXplZCBzdGF0ZScpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzcyxcbiAgICAgIHN0YXRlOiBzeXNEYXRhLnN0YXRlLFxuICAgICAgbGVuZ3RoOiBjaGFyc0xlbmd0aCxcbiAgICAgIG1hdGNoZWQ6IHN5c0RhdGEucGhyYXNlTGVuZ3RoLFxuICAgICAgbWF4TWF0Y2hlZCxcbiAgICAgIG1heFRyZWVEZXB0aCxcbiAgICAgIG5vZGVIaXRzLFxuICAgICAgaW5wdXRMZW5ndGg6IGNoYXJzLmxlbmd0aCxcbiAgICAgIHN1YkJlZ2luOiBjaGFyc0JlZ2luLFxuICAgICAgc3ViRW5kOiBjaGFyc0VuZCxcbiAgICAgIHN1Ykxlbmd0aDogY2hhcnNMZW5ndGgsXG4gICAgfTtcbiAgfTtcblxuICAvLyBUaGlzIGZvcm0gYWxsb3dzIHBhcnNpbmcgb2YgYSBzdWItc3RyaW5nIG9mIHRoZSBmdWxsIGlucHV0IHN0cmluZy5cbiAgLy8gPHVsPlxuICAvLyA8bGk+KmlucHV0SW5kZXgqIC0gaW5kZXggb2YgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgc3ViLXN0cmluZzwvbGk+XG4gIC8vIDxsaT4qaW5wdXRMZW5ndGgqIC0gbGVuZ3RoIG9mIHRoZSBzdWItc3RyaW5nPC9saT5cbiAgLy8gPC91bD5cbiAgLy8gQWxsIG90aGVyIHBhcmFtZXRlcnMgYXMgZm9yIHRoZSBhYm92ZSBmdW5jdGlvbiBgcGFyc2UoKWAuXG4gIHRoaXMucGFyc2VTdWJzdHJpbmcgPSBmdW5jdGlvbiBwYXJzZVN1YnN0cmluZyhncmFtbWFyLCBzdGFydFJ1bGUsIGlucHV0Q2hhcnMsIGlucHV0SW5kZXgsIGlucHV0TGVuZ3RoLCBjYWxsYmFja0RhdGEpIHtcbiAgICBjbGVhcigpO1xuICAgIGluaXRpYWxpemVJbnB1dENoYXJzKGlucHV0Q2hhcnMsIGlucHV0SW5kZXgsIGlucHV0TGVuZ3RoKTtcbiAgICByZXR1cm4gcHJpdmF0ZVBhcnNlKGdyYW1tYXIsIHN0YXJ0UnVsZSwgY2FsbGJhY2tEYXRhKTtcbiAgfTtcbiAgLy8gVGhpcyBpcyB0aGUgbWFpbiBmdW5jdGlvbiwgY2FsbGVkIHRvIHBhcnNlIGFuIGlucHV0IHN0cmluZy5cbiAgLy8gPHVsPlxuICAvLyA8bGk+KmdyYW1tYXIqIC0gYW4gaW5zdGFudGlhdGVkIGdyYW1tYXIgb2JqZWN0IC0gdGhlIG91dHB1dCBvZiBgYXBnYCBmb3IgYVxuICAvLyBzcGVjaWZpYyBTQUJORiBncmFtbWFyPC9saT5cbiAgLy8gPGxpPipzdGFydFJ1bGUqIC0gdGhlIHJ1bGUgbmFtZSBvciBydWxlIGluZGV4IHRvIGJlIHVzZWQgYXMgdGhlIHJvb3Qgb2YgdGhlXG4gIC8vIHBhcnNlIHRyZWUuIFRoaXMgaXMgdXN1YWxseSB0aGUgZmlyc3QgcnVsZSwgaW5kZXggPSAwLCBvZiB0aGUgZ3JhbW1hclxuICAvLyBidXQgY2FuIGJlIGFueSBydWxlIGRlZmluZWQgaW4gdGhlIGFib3ZlIGdyYW1tYXIgb2JqZWN0LjwvbGk+XG4gIC8vIDxsaT4qaW5wdXRDaGFycyogLSB0aGUgaW5wdXQgc3RyaW5nLiBDYW4gYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2YgaW50ZWdlciBjaGFyYWN0ZXIgY29kZXMgcmVwcmVzZW50aW5nIHRoZVxuICAvLyBzdHJpbmcuPC9saT5cbiAgLy8gPGxpPipjYWxsYmFja0RhdGEqIC0gdXNlci1kZWZpbmVkIGRhdGEgb2JqZWN0IHRvIGJlIHBhc3NlZCB0byB0aGUgdXNlcidzXG4gIC8vIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgLy8gVGhpcyBpcyBub3QgdXNlZCBieSB0aGUgcGFyc2VyIGluIGFueSB3YXksIG1lcmVseSBwYXNzZWQgb24gdG8gdGhlIHVzZXIuXG4gIC8vIE1heSBiZSBgbnVsbGAgb3Igb21pdHRlZC48L2xpPlxuICAvLyA8L3VsPlxuICB0aGlzLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoZ3JhbW1hciwgc3RhcnRSdWxlLCBpbnB1dENoYXJzLCBjYWxsYmFja0RhdGEpIHtcbiAgICBjbGVhcigpO1xuICAgIGluaXRpYWxpemVJbnB1dENoYXJzKGlucHV0Q2hhcnMsIDAsIGlucHV0Q2hhcnMubGVuZ3RoKTtcbiAgICByZXR1cm4gcHJpdmF0ZVBhcnNlKGdyYW1tYXIsIHN0YXJ0UnVsZSwgY2FsbGJhY2tEYXRhKTtcbiAgfTtcbiAgLy8gVGhlIGBBTFRgIG9wZXJhdG9yLjxicj5cbiAgLy8gRXhlY3V0ZXMgaXRzIGNoaWxkIG5vZGVzLCBmcm9tIGxlZnQgdG8gcmlnaHQsIHVudGlsIGl0IGZpbmRzIGEgbWF0Y2guXG4gIC8vIEZhaWxzIGlmICphbGwqIG9mIGl0cyBjaGlsZCBub2RlcyBmYWlsLlxuICBjb25zdCBvcEFMVCA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBvcEV4ZWN1dGUob3AuY2hpbGRyZW5baV0sIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgIGlmIChzeXNEYXRhLnN0YXRlICE9PSBpZC5OT01BVENIKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gVGhlIGBDQVRgIG9wZXJhdG9yLjxicj5cbiAgLy8gRXhlY3V0ZXMgYWxsIG9mIGl0cyBjaGlsZCBub2RlcywgZnJvbSBsZWZ0IHRvIHJpZ2h0LFxuICAvLyBjb25jYXRlbmF0aW5nIHRoZSBtYXRjaGVkIHBocmFzZXMuXG4gIC8vIEZhaWxzIGlmICphbnkqIGNoaWxkIG5vZGVzIGZhaWwuXG4gIGNvbnN0IG9wQ0FUID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbGV0IHN1Y2Nlc3M7XG4gICAgbGV0IGFzdExlbmd0aDtcbiAgICBsZXQgY2F0Q2hhckluZGV4O1xuICAgIGxldCBjYXRQaHJhc2U7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIGNvbnN0IHVsZW4gPSBzeXNEYXRhLnVGcmFtZS5sZW5ndGgoKTtcbiAgICBjb25zdCBwbGVuID0gc3lzRGF0YS5wRnJhbWUubGVuZ3RoKCk7XG4gICAgaWYgKHRoaXNUaGlzLmFzdCkge1xuICAgICAgYXN0TGVuZ3RoID0gdGhpc1RoaXMuYXN0LmdldExlbmd0aCgpO1xuICAgIH1cbiAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICBjYXRDaGFySW5kZXggPSBwaHJhc2VJbmRleDtcbiAgICBjYXRQaHJhc2UgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3AuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIG9wRXhlY3V0ZShvcC5jaGlsZHJlbltpXSwgY2F0Q2hhckluZGV4LCBzeXNEYXRhKTtcbiAgICAgIGlmIChzeXNEYXRhLnN0YXRlID09PSBpZC5OT01BVENIKSB7XG4gICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXRDaGFySW5kZXggKz0gc3lzRGF0YS5waHJhc2VMZW5ndGg7XG4gICAgICAgIGNhdFBocmFzZSArPSBzeXNEYXRhLnBocmFzZUxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBjYXRQaHJhc2UgPT09IDAgPyBpZC5FTVBUWSA6IGlkLk1BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSBjYXRQaHJhc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgICAgLyogcmVzZXQgdGhlIGJhY2sgcmVmZXJlbmNpbmcgZnJhbWVzIG9uIGZhaWx1cmUgKi9cbiAgICAgIHN5c0RhdGEudUZyYW1lLnBvcCh1bGVuKTtcbiAgICAgIHN5c0RhdGEucEZyYW1lLnBvcChwbGVuKTtcbiAgICAgIGlmICh0aGlzVGhpcy5hc3QpIHtcbiAgICAgICAgdGhpc1RoaXMuYXN0LnNldExlbmd0aChhc3RMZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gVGhlIGBSRVBgIG9wZXJhdG9yLjxicj5cbiAgLy8gUmVwZWF0ZWRseSBleGVjdXRlcyBpdHMgc2luZ2xlIGNoaWxkIG5vZGUsXG4gIC8vIGNvbmNhdGVuYXRpbmcgZWFjaCBvZiB0aGUgbWF0Y2hlZCBwaHJhc2VzIGZvdW5kLlxuICAvLyBUaGUgbnVtYmVyIG9mIHJlcGV0aXRpb25zIGV4ZWN1dGVkIGFuZCBpdHMgZmluYWwgc3lzRGF0YSBkZXBlbmRzXG4gIC8vIG9uIGl0cyBgbWluYCAmIGBtYXhgIHJlcGV0aXRpb24gdmFsdWVzLlxuICBjb25zdCBvcFJFUCA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxldCBhc3RMZW5ndGg7XG4gICAgbGV0IHJlcENoYXJJbmRleDtcbiAgICBsZXQgcmVwUGhyYXNlO1xuICAgIGxldCByZXBDb3VudDtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgcmVwQ2hhckluZGV4ID0gcGhyYXNlSW5kZXg7XG4gICAgcmVwUGhyYXNlID0gMDtcbiAgICByZXBDb3VudCA9IDA7XG4gICAgY29uc3QgdWxlbiA9IHN5c0RhdGEudUZyYW1lLmxlbmd0aCgpO1xuICAgIGNvbnN0IHBsZW4gPSBzeXNEYXRhLnBGcmFtZS5sZW5ndGgoKTtcbiAgICBpZiAodGhpc1RoaXMuYXN0KSB7XG4gICAgICBhc3RMZW5ndGggPSB0aGlzVGhpcy5hc3QuZ2V0TGVuZ3RoKCk7XG4gICAgfVxuICAgIGNvbnN0IFRSVUUgPSB0cnVlO1xuICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICBpZiAocmVwQ2hhckluZGV4ID49IGNoYXJzRW5kKSB7XG4gICAgICAgIC8qIGV4aXQgb24gZW5kIG9mIGlucHV0IHN0cmluZyAqL1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG9wRXhlY3V0ZShvcEluZGV4ICsgMSwgcmVwQ2hhckluZGV4LCBzeXNEYXRhKTtcbiAgICAgIGlmIChzeXNEYXRhLnN0YXRlID09PSBpZC5OT01BVENIKSB7XG4gICAgICAgIC8qIGFsd2F5cyBlbmQgaWYgdGhlIGNoaWxkIG5vZGUgZmFpbHMgKi9cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3lzRGF0YS5zdGF0ZSA9PT0gaWQuRU1QVFkpIHtcbiAgICAgICAgLyogUkVQIGFsd2F5cyBzdWNjZWVkcyB3aGVuIHRoZSBjaGlsZCBub2RlIHJldHVybnMgYW4gZW1wdHkgcGhyYXNlICovXG4gICAgICAgIC8qIHRoaXMgbWF5IG5vdCBzZWVtIG9idmlvdXMsIGJ1dCB0aGF0J3MgdGhlIHdheSBpdCB3b3JrcyBvdXQgKi9cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXBDb3VudCArPSAxO1xuICAgICAgcmVwUGhyYXNlICs9IHN5c0RhdGEucGhyYXNlTGVuZ3RoO1xuICAgICAgcmVwQ2hhckluZGV4ICs9IHN5c0RhdGEucGhyYXNlTGVuZ3RoO1xuICAgICAgaWYgKHJlcENvdW50ID09PSBvcC5tYXgpIHtcbiAgICAgICAgLyogZW5kIG9uIG1heGVkIG91dCByZXBzICovXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBldmFsdWF0ZSB0aGUgbWF0Y2ggY291bnQgYWNjb3JkaW5nIHRvIHRoZSBtaW4sIG1heCB2YWx1ZXMgKi9cbiAgICBpZiAoc3lzRGF0YS5zdGF0ZSA9PT0gaWQuRU1QVFkpIHtcbiAgICAgIHN5c0RhdGEuc3RhdGUgPSByZXBQaHJhc2UgPT09IDAgPyBpZC5FTVBUWSA6IGlkLk1BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSByZXBQaHJhc2U7XG4gICAgfSBlbHNlIGlmIChyZXBDb3VudCA+PSBvcC5taW4pIHtcbiAgICAgIHN5c0RhdGEuc3RhdGUgPSByZXBQaHJhc2UgPT09IDAgPyBpZC5FTVBUWSA6IGlkLk1BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSByZXBQaHJhc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgICAgLyogcmVzZXQgdGhlIGJhY2sgcmVmZXJlbmNpbmcgZnJhbWVzIG9uIGZhaWx1cmUgKi9cbiAgICAgIHN5c0RhdGEudUZyYW1lLnBvcCh1bGVuKTtcbiAgICAgIHN5c0RhdGEucEZyYW1lLnBvcChwbGVuKTtcbiAgICAgIGlmICh0aGlzVGhpcy5hc3QpIHtcbiAgICAgICAgdGhpc1RoaXMuYXN0LnNldExlbmd0aChhc3RMZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gVmFsaWRhdGUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uJ3MgcmV0dXJuZWQgc3lzRGF0YSB2YWx1ZXMuXG4gIC8vIEl0J3MgdGhlIHVzZXIncyByZXNwb25zaWJpbGl0eSB0byBnZXQgdGhlbSByaWdodFxuICAvLyBidXQgYFJOTWAgZmFpbHMgaWYgbm90LlxuICBjb25zdCB2YWxpZGF0ZVJubUNhbGxiYWNrUmVzdWx0ID0gZnVuY3Rpb24gKHJ1bGUsIHN5c0RhdGEsIGNoYXJzTGVmdCwgZG93bikge1xuICAgIGlmIChzeXNEYXRhLnBocmFzZUxlbmd0aCA+IGNoYXJzTGVmdCkge1xuICAgICAgbGV0IHN0ciA9IGAke3RoaXNGaWxlTmFtZX1vcFJOTSgke3J1bGUubmFtZX0pOiBjYWxsYmFjayBmdW5jdGlvbiBlcnJvcjogYDtcbiAgICAgIHN0ciArPSBgc3lzRGF0YS5waHJhc2VMZW5ndGg6ICR7c3lzRGF0YS5waHJhc2VMZW5ndGh9YDtcbiAgICAgIHN0ciArPSBgIG11c3QgYmUgPD0gcmVtYWluaW5nIGNoYXJzOiAke2NoYXJzTGVmdH1gO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cik7XG4gICAgfVxuICAgIHN3aXRjaCAoc3lzRGF0YS5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGlmIChkb3duICE9PSB0cnVlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYCR7dGhpc0ZpbGVOYW1lfW9wUk5NKCR7cnVsZS5uYW1lfSk6IGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybiBlcnJvci4gQUNUSVZFIHN0YXRlIG5vdCBhbGxvd2VkLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChzeXNEYXRhLnBocmFzZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgJHt0aGlzRmlsZU5hbWV9b3BSTk0oJHtydWxlLm5hbWV9KTogY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJuIGVycm9yLiBVbnJlY29nbml6ZWQgcmV0dXJuIHN0YXRlOiAke3N5c0RhdGEuc3RhdGV9YFxuICAgICAgICApO1xuICAgIH1cbiAgfTtcbiAgLy8gVGhlIGBSTk1gIG9wZXJhdG9yLjxicj5cbiAgLy8gVGhpcyBvcGVyYXRvciB3aWxsIGFjdHMgYXMgYSByb290IG5vZGUgZm9yIGEgcGFyc2UgdHJlZSBicmFuY2ggYmVsb3cgYW5kXG4gIC8vIHJldHVybnMgdGhlIG1hdGNoZWQgcGhyYXNlIHRvIGl0cyBwYXJlbnQuXG4gIC8vIEhvd2V2ZXIsIGl0cyBsYXJnZXIgcmVzcG9uc2liaWxpdHkgaXMgaGFuZGxpbmcgdXNlci1kZWZpbmVkIGNhbGxiYWNrIGZ1bmN0aW9ucywgYmFjayByZWZlcmVuY2VzIGFuZCBgQVNUYCBub2Rlcy5cbiAgLy8gTm90ZSB0aGF0IHRoZSBgQVNUYCBpcyBhIHNlcGFyYXRlIG9iamVjdCwgYnV0IGBSTk1gIGNhbGxzIGl0cyBmdW5jdGlvbnMgdG8gY3JlYXRlIGl0cyBub2Rlcy5cbiAgLy8gU2VlIFtgYXN0LmpzYF0oLi9hc3QuaHRtbCkgZm9yIHVzYWdlLlxuICBjb25zdCBvcFJOTSA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxldCBhc3RMZW5ndGg7XG4gICAgbGV0IGFzdERlZmluZWQ7XG4gICAgbGV0IHNhdmVkT3Bjb2RlcztcbiAgICBsZXQgdWxlbjtcbiAgICBsZXQgcGxlbjtcbiAgICBsZXQgc2F2ZUZyYW1lO1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBjb25zdCBydWxlID0gcnVsZXNbb3AuaW5kZXhdO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gcnVsZUNhbGxiYWNrc1tydWxlLmluZGV4XTtcbiAgICBjb25zdCBub3RMb29rQXJvdW5kID0gIWluTG9va0Fyb3VuZCgpO1xuICAgIC8qIGlnbm9yZSBBU1QgYW5kIGJhY2sgcmVmZXJlbmNlcyBpbiBsb29rYXJvdW5kICovXG4gICAgaWYgKG5vdExvb2tBcm91bmQpIHtcbiAgICAgIC8qIGJlZ2luIEFTVCBhbmQgYmFjayByZWZlcmVuY2VzICovXG4gICAgICBhc3REZWZpbmVkID0gdGhpc1RoaXMuYXN0ICYmIHRoaXNUaGlzLmFzdC5ydWxlRGVmaW5lZChvcC5pbmRleCk7XG4gICAgICBpZiAoYXN0RGVmaW5lZCkge1xuICAgICAgICBhc3RMZW5ndGggPSB0aGlzVGhpcy5hc3QuZ2V0TGVuZ3RoKCk7XG4gICAgICAgIHRoaXNUaGlzLmFzdC5kb3duKG9wLmluZGV4LCBydWxlc1tvcC5pbmRleF0ubmFtZSk7XG4gICAgICB9XG4gICAgICB1bGVuID0gc3lzRGF0YS51RnJhbWUubGVuZ3RoKCk7XG4gICAgICBwbGVuID0gc3lzRGF0YS5wRnJhbWUubGVuZ3RoKCk7XG4gICAgICBzeXNEYXRhLnVGcmFtZS5wdXNoKCk7XG4gICAgICBzeXNEYXRhLnBGcmFtZS5wdXNoKCk7XG4gICAgICBzYXZlRnJhbWUgPSBzeXNEYXRhLnBGcmFtZTtcbiAgICAgIHN5c0RhdGEucEZyYW1lID0gbmV3IGJhY2tSZWYoKTtcbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrID09PSBudWxsKSB7XG4gICAgICAvKiBubyBjYWxsYmFjayAtIGp1c3QgZXhlY3V0ZSB0aGUgcnVsZSAqL1xuICAgICAgc2F2ZWRPcGNvZGVzID0gb3Bjb2RlcztcbiAgICAgIG9wY29kZXMgPSBydWxlLm9wY29kZXM7XG4gICAgICBvcEV4ZWN1dGUoMCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgb3Bjb2RlcyA9IHNhdmVkT3Bjb2RlcztcbiAgICB9IGVsc2Uge1xuICAgICAgLyogY2FsbCB1c2VyJ3MgY2FsbGJhY2sgKi9cbiAgICAgIGNvbnN0IGNoYXJzTGVmdCA9IGNoYXJzRW5kIC0gcGhyYXNlSW5kZXg7XG4gICAgICBzeXNEYXRhLnJ1bGVJbmRleCA9IHJ1bGUuaW5kZXg7XG4gICAgICBjYWxsYmFjayhzeXNEYXRhLCBjaGFycywgcGhyYXNlSW5kZXgsIHN5bnRheERhdGEpO1xuICAgICAgdmFsaWRhdGVSbm1DYWxsYmFja1Jlc3VsdChydWxlLCBzeXNEYXRhLCBjaGFyc0xlZnQsIHRydWUpO1xuICAgICAgaWYgKHN5c0RhdGEuc3RhdGUgPT09IGlkLkFDVElWRSkge1xuICAgICAgICBzYXZlZE9wY29kZXMgPSBvcGNvZGVzO1xuICAgICAgICBvcGNvZGVzID0gcnVsZS5vcGNvZGVzO1xuICAgICAgICBvcEV4ZWN1dGUoMCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICBvcGNvZGVzID0gc2F2ZWRPcGNvZGVzO1xuICAgICAgICBzeXNEYXRhLnJ1bGVJbmRleCA9IHJ1bGUuaW5kZXg7XG4gICAgICAgIGNhbGxiYWNrKHN5c0RhdGEsIGNoYXJzLCBwaHJhc2VJbmRleCwgc3ludGF4RGF0YSk7XG4gICAgICAgIHZhbGlkYXRlUm5tQ2FsbGJhY2tSZXN1bHQocnVsZSwgc3lzRGF0YSwgY2hhcnNMZWZ0LCBmYWxzZSk7XG4gICAgICB9IC8qIGltcGxpZWQgZWxzZSBjbGF1c2U6IGp1c3QgYWNjZXB0IHRoZSBjYWxsYmFjayBzeXNEYXRhIC0gUk5NIGFjdGluZyBhcyBVRFQgKi9cbiAgICB9XG4gICAgaWYgKG5vdExvb2tBcm91bmQpIHtcbiAgICAgIC8qIGVuZCBBU1QgKi9cbiAgICAgIGlmIChhc3REZWZpbmVkKSB7XG4gICAgICAgIGlmIChzeXNEYXRhLnN0YXRlID09PSBpZC5OT01BVENIKSB7XG4gICAgICAgICAgdGhpc1RoaXMuYXN0LnNldExlbmd0aChhc3RMZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNUaGlzLmFzdC51cChvcC5pbmRleCwgcnVsZS5uYW1lLCBwaHJhc2VJbmRleCwgc3lzRGF0YS5waHJhc2VMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKiBlbmQgYmFjayByZWZlcmVuY2UgKi9cbiAgICAgIHN5c0RhdGEucEZyYW1lID0gc2F2ZUZyYW1lO1xuICAgICAgaWYgKHN5c0RhdGEuc3RhdGUgPT09IGlkLk5PTUFUQ0gpIHtcbiAgICAgICAgc3lzRGF0YS51RnJhbWUucG9wKHVsZW4pO1xuICAgICAgICBzeXNEYXRhLnBGcmFtZS5wb3AocGxlbik7XG4gICAgICB9IGVsc2UgaWYgKHJ1bGUuaXNCa3IpIHtcbiAgICAgICAgLyogc2F2ZSBwaHJhc2Ugb24gYm90aCB0aGUgcGFyZW50IGFuZCB1bml2ZXJzYWwgZnJhbWVzICovXG4gICAgICAgIC8qIEJLUiBvcGVyYXRvciB3aWxsIGRlY2lkZSB3aGljaCB0byB1c2UgbGF0ZXIgKi9cbiAgICAgICAgc3lzRGF0YS5wRnJhbWUuc2F2ZVBocmFzZShydWxlLmxvd2VyLCBwaHJhc2VJbmRleCwgc3lzRGF0YS5waHJhc2VMZW5ndGgpO1xuICAgICAgICBzeXNEYXRhLnVGcmFtZS5zYXZlUGhyYXNlKHJ1bGUubG93ZXIsIHBocmFzZUluZGV4LCBzeXNEYXRhLnBocmFzZUxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBWYWxpZGF0ZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24ncyByZXR1cm5lZCBzeXNEYXRhIHZhbHVlcy5cbiAgLy8gSXQncyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvIGdldCBpdCByaWdodCBidXQgYFVEVGAgZmFpbHMgaWYgbm90LlxuICBjb25zdCB2YWxpZGF0ZVVkdENhbGxiYWNrUmVzdWx0ID0gZnVuY3Rpb24gKHVkdCwgc3lzRGF0YSwgY2hhcnNMZWZ0KSB7XG4gICAgaWYgKHN5c0RhdGEucGhyYXNlTGVuZ3RoID4gY2hhcnNMZWZ0KSB7XG4gICAgICBsZXQgc3RyID0gYCR7dGhpc0ZpbGVOYW1lfW9wVURUKCR7dWR0Lm5hbWV9KTogY2FsbGJhY2sgZnVuY3Rpb24gZXJyb3I6IGA7XG4gICAgICBzdHIgKz0gYHN5c0RhdGEucGhyYXNlTGVuZ3RoOiAke3N5c0RhdGEucGhyYXNlTGVuZ3RofWA7XG4gICAgICBzdHIgKz0gYCBtdXN0IGJlIDw9IHJlbWFpbmluZyBjaGFyczogJHtjaGFyc0xlZnR9YDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihzdHIpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHN5c0RhdGEuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfW9wVURUKCR7dWR0Lm5hbWV9KTogY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJuIGVycm9yLiBBQ1RJVkUgc3RhdGUgbm90IGFsbG93ZWQuYCk7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBpZiAodWR0LmVtcHR5ID09PSBmYWxzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9b3BVRFQoJHt1ZHQubmFtZX0pOiBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm4gZXJyb3IuIE1heSBub3QgcmV0dXJuIEVNUFRZLmApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChzeXNEYXRhLnBocmFzZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmICh1ZHQuZW1wdHkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfW9wVURUKCR7dWR0Lm5hbWV9KTogY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJuIGVycm9yLiBNYXkgbm90IHJldHVybiBFTVBUWS5gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgJHt0aGlzRmlsZU5hbWV9b3BVRFQoJHt1ZHQubmFtZX0pOiBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm4gZXJyb3IuIFVucmVjb2duaXplZCByZXR1cm4gc3RhdGU6ICR7c3lzRGF0YS5zdGF0ZX1gXG4gICAgICAgICk7XG4gICAgfVxuICB9O1xuICAvLyBUaGUgYFVEVGAgb3BlcmF0b3IuPGJyPlxuICAvLyBTaW1wbHkgY2FsbHMgdGhlIHVzZXIncyBjYWxsYmFjayBmdW5jdGlvbiwgYnV0IG9wZXJhdGVzIGxpa2UgYFJOTWAgd2l0aCByZWdhcmQgdG8gdGhlIGBBU1RgXG4gIC8vIGFuZCBiYWNrIHJlZmVyZW5jaW5nLlxuICAvLyBUaGVyZSBpcyBzb21lIGFtYmlndWl0eSBoZXJlLiBgVURUYHMgYWN0IGFzIHRlcm1pbmFscyBmb3IgcGhyYXNlIHJlY29nbml0aW9uIGJ1dCBhcyBuYW1lZCBydWxlc1xuICAvLyBmb3IgYEFTVGAgbm9kZXMgYW5kIGJhY2sgcmVmZXJlbmNpbmcuXG4gIC8vIFNlZSBbYGFzdC5qc2BdKC4vYXN0Lmh0bWwpIGZvciB1c2FnZS5cbiAgY29uc3Qgb3BVRFQgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsZXQgYXN0TGVuZ3RoO1xuICAgIGxldCBhc3RJbmRleDtcbiAgICBsZXQgYXN0RGVmaW5lZDtcbiAgICBsZXQgdWxlbjtcbiAgICBsZXQgcGxlbjtcbiAgICBsZXQgc2F2ZUZyYW1lO1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBjb25zdCB1ZHQgPSB1ZHRzW29wLmluZGV4XTtcbiAgICBzeXNEYXRhLlVkdEluZGV4ID0gdWR0LmluZGV4O1xuXG4gICAgY29uc3Qgbm90TG9va0Fyb3VuZCA9ICFpbkxvb2tBcm91bmQoKTtcbiAgICAvKiBpZ25vcmUgQVNUIGFuZCBiYWNrIHJlZmVyZW5jZXMgaW4gbG9va2Fyb3VuZCAqL1xuICAgIGlmIChub3RMb29rQXJvdW5kKSB7XG4gICAgICAvKiBiZWdpbiBBU1QgYW5kIGJhY2sgcmVmZXJlbmNlICovXG4gICAgICBhc3REZWZpbmVkID0gdGhpc1RoaXMuYXN0ICYmIHRoaXNUaGlzLmFzdC51ZHREZWZpbmVkKG9wLmluZGV4KTtcbiAgICAgIGlmIChhc3REZWZpbmVkKSB7XG4gICAgICAgIGFzdEluZGV4ID0gcnVsZXMubGVuZ3RoICsgb3AuaW5kZXg7XG4gICAgICAgIGFzdExlbmd0aCA9IHRoaXNUaGlzLmFzdC5nZXRMZW5ndGgoKTtcbiAgICAgICAgdGhpc1RoaXMuYXN0LmRvd24oYXN0SW5kZXgsIHVkdC5uYW1lKTtcbiAgICAgIH1cbiAgICAgIC8qIE5PVEU6IHB1c2ggYW5kIHBvcCBvZiB0aGUgYmFjayByZWZlcmVuY2UgZnJhbWUgaXMgbm9ybWFsbHkgbm90IG5lY2Vzc2FyeSAqL1xuICAgICAgLyogb25seSBpbiB0aGUgY2FzZSB0aGF0IHRoZSBVRFQgY2FsbHMgZXZhbHVhdGVSdWxlKCkgb3IgZXZhbHVhdGVVZHQoKSAqL1xuICAgICAgdWxlbiA9IHN5c0RhdGEudUZyYW1lLmxlbmd0aCgpO1xuICAgICAgcGxlbiA9IHN5c0RhdGEucEZyYW1lLmxlbmd0aCgpO1xuICAgICAgc3lzRGF0YS51RnJhbWUucHVzaCgpO1xuICAgICAgc3lzRGF0YS5wRnJhbWUucHVzaCgpO1xuICAgICAgc2F2ZUZyYW1lID0gc3lzRGF0YS5wRnJhbWU7XG4gICAgICBzeXNEYXRhLnBGcmFtZSA9IG5ldyBiYWNrUmVmKCk7XG4gICAgfVxuICAgIC8qIGNhbGwgdGhlIFVEVCAqL1xuICAgIGNvbnN0IGNoYXJzTGVmdCA9IGNoYXJzRW5kIC0gcGhyYXNlSW5kZXg7XG4gICAgdWR0Q2FsbGJhY2tzW29wLmluZGV4XShzeXNEYXRhLCBjaGFycywgcGhyYXNlSW5kZXgsIHN5bnRheERhdGEpO1xuICAgIHZhbGlkYXRlVWR0Q2FsbGJhY2tSZXN1bHQodWR0LCBzeXNEYXRhLCBjaGFyc0xlZnQpO1xuICAgIGlmIChub3RMb29rQXJvdW5kKSB7XG4gICAgICAvKiBlbmQgQVNUICovXG4gICAgICBpZiAoYXN0RGVmaW5lZCkge1xuICAgICAgICBpZiAoc3lzRGF0YS5zdGF0ZSA9PT0gaWQuTk9NQVRDSCkge1xuICAgICAgICAgIHRoaXNUaGlzLmFzdC5zZXRMZW5ndGgoYXN0TGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzVGhpcy5hc3QudXAoYXN0SW5kZXgsIHVkdC5uYW1lLCBwaHJhc2VJbmRleCwgc3lzRGF0YS5waHJhc2VMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKiBlbmQgYmFjayByZWZlcmVuY2UgKi9cbiAgICAgIHN5c0RhdGEucEZyYW1lID0gc2F2ZUZyYW1lO1xuICAgICAgaWYgKHN5c0RhdGEuc3RhdGUgPT09IGlkLk5PTUFUQ0gpIHtcbiAgICAgICAgc3lzRGF0YS51RnJhbWUucG9wKHVsZW4pO1xuICAgICAgICBzeXNEYXRhLnBGcmFtZS5wb3AocGxlbik7XG4gICAgICB9IGVsc2UgaWYgKHVkdC5pc0Jrcikge1xuICAgICAgICAvKiBzYXZlIHBocmFzZSBvbiBib3RoIHRoZSBwYXJlbnQgYW5kIHVuaXZlcnNhbCBmcmFtZXMgKi9cbiAgICAgICAgLyogQktSIG9wZXJhdG9yIHdpbGwgZGVjaWRlIHdoaWNoIHRvIHVzZSBsYXRlciAqL1xuICAgICAgICBzeXNEYXRhLnBGcmFtZS5zYXZlUGhyYXNlKHVkdC5sb3dlciwgcGhyYXNlSW5kZXgsIHN5c0RhdGEucGhyYXNlTGVuZ3RoKTtcbiAgICAgICAgc3lzRGF0YS51RnJhbWUuc2F2ZVBocmFzZSh1ZHQubG93ZXIsIHBocmFzZUluZGV4LCBzeXNEYXRhLnBocmFzZUxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBUaGUgYEFORGAgb3BlcmF0b3IuPGJyPlxuICAvLyBUaGlzIGlzIHRoZSBwb3NpdGl2ZSBgbG9vayBhaGVhZGAgb3BlcmF0b3IuXG4gIC8vIEV4ZWN1dGVzIGl0cyBzaW5nbGUgY2hpbGQgbm9kZSwgcmV0dXJuaW5nIHRoZSBFTVBUWSBzdGF0ZVxuICAvLyBpZiBpdCBzdWNjZWVkc2FuZCBOT01BVENIIGlmIGl0IGZhaWxzLlxuICAvLyAqQWx3YXlzKiBiYWNrdHJhY2tzIG9uIGFueSBtYXRjaGVkIHBocmFzZSBhbmQgcmV0dXJucyBFTVBUWSBvbiBzdWNjZXNzLlxuICBjb25zdCBvcEFORCA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxvb2tBcm91bmQucHVzaCh7XG4gICAgICBsb29rQXJvdW5kOiBpZC5MT09LQVJPVU5EX0FIRUFELFxuICAgICAgYW5jaG9yOiBwaHJhc2VJbmRleCxcbiAgICAgIGNoYXJzRW5kLFxuICAgICAgY2hhcnNMZW5ndGgsXG4gICAgfSk7XG4gICAgY2hhcnNFbmQgPSBjaGFycy5sZW5ndGg7XG4gICAgY2hhcnNMZW5ndGggPSBjaGFycy5sZW5ndGggLSBjaGFyc0JlZ2luO1xuICAgIG9wRXhlY3V0ZShvcEluZGV4ICsgMSwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgIGNvbnN0IHBvcCA9IGxvb2tBcm91bmQucG9wKCk7XG4gICAgY2hhcnNFbmQgPSBwb3AuY2hhcnNFbmQ7XG4gICAgY2hhcnNMZW5ndGggPSBwb3AuY2hhcnNMZW5ndGg7XG4gICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgIHN3aXRjaCAoc3lzRGF0YS5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5FTVBUWTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgb3BBTkQ6IGludmFsaWQgc3RhdGUgJHtzeXNEYXRhLnN0YXRlfWApO1xuICAgIH1cbiAgfTtcbiAgLy8gVGhlIGBOT1RgIG9wZXJhdG9yLjxicj5cbiAgLy8gVGhpcyBpcyB0aGUgbmVnYXRpdmUgYGxvb2sgYWhlYWRgIG9wZXJhdG9yLlxuICAvLyBFeGVjdXRlcyBpdHMgc2luZ2xlIGNoaWxkIG5vZGUsIHJldHVybmluZyB0aGUgRU1QVFkgc3RhdGVcbiAgLy8gaWYgaXQgKmZhaWxzKiBhbmQgTk9NQVRDSCBpZiBpdCBzdWNjZWVkcy5cbiAgLy8gKkFsd2F5cyogYmFja3RyYWNrcyBvbiBhbnkgbWF0Y2hlZCBwaHJhc2UgYW5kIHJldHVybnMgRU1QVFlcbiAgLy8gb24gc3VjY2VzcyAoZmFpbHVyZSBvZiBpdHMgY2hpbGQgbm9kZSkuXG4gIGNvbnN0IG9wTk9UID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbG9va0Fyb3VuZC5wdXNoKHtcbiAgICAgIGxvb2tBcm91bmQ6IGlkLkxPT0tBUk9VTkRfQUhFQUQsXG4gICAgICBhbmNob3I6IHBocmFzZUluZGV4LFxuICAgICAgY2hhcnNFbmQsXG4gICAgICBjaGFyc0xlbmd0aCxcbiAgICB9KTtcbiAgICBjaGFyc0VuZCA9IGNoYXJzLmxlbmd0aDtcbiAgICBjaGFyc0xlbmd0aCA9IGNoYXJzLmxlbmd0aCAtIGNoYXJzQmVnaW47XG4gICAgb3BFeGVjdXRlKG9wSW5kZXggKyAxLCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgY29uc3QgcG9wID0gbG9va0Fyb3VuZC5wb3AoKTtcbiAgICBjaGFyc0VuZCA9IHBvcC5jaGFyc0VuZDtcbiAgICBjaGFyc0xlbmd0aCA9IHBvcC5jaGFyc0xlbmd0aDtcbiAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgc3dpdGNoIChzeXNEYXRhLnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuRU1QVFk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvcE5PVDogaW52YWxpZCBzdGF0ZSAke3N5c0RhdGEuc3RhdGV9YCk7XG4gICAgfVxuICB9O1xuICAvLyBUaGUgYFRSR2Agb3BlcmF0b3IuPGJyPlxuICAvLyBTdWNjZWVkcyBpZiB0aGUgc2luZ2xlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgcGhyYXNlIGlzXG4gIC8vIHdpdGhpbiB0aGUgYG1pbiAtIG1heGAgcmFuZ2UuXG4gIGNvbnN0IG9wVFJHID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgIGlmIChwaHJhc2VJbmRleCA8IGNoYXJzRW5kKSB7XG4gICAgICBpZiAob3AubWluIDw9IGNoYXJzW3BocmFzZUluZGV4XSAmJiBjaGFyc1twaHJhc2VJbmRleF0gPD0gb3AubWF4KSB7XG4gICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5NQVRDSDtcbiAgICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gVGhlIGBUQlNgIG9wZXJhdG9yLjxicj5cbiAgLy8gTWF0Y2hlcyBpdHMgcHJlLWRlZmluZWQgcGhyYXNlIGFnYWluc3QgdGhlIGlucHV0IHN0cmluZy5cbiAgLy8gQWxsIGNoYXJhY3RlcnMgbXVzdCBtYXRjaCBleGFjdGx5LlxuICAvLyBDYXNlLXNlbnNpdGl2ZSBsaXRlcmFsIHN0cmluZ3MgKGAnc3RyaW5nJ2AgJiBgJXNcInN0cmluZ1wiYCkgYXJlIHRyYW5zbGF0ZWQgdG8gYFRCU2BcbiAgLy8gb3BlcmF0b3JzIGJ5IGBhcGdgLlxuICAvLyBQaHJhc2UgbGVuZ3RoIG9mIHplcm8gaXMgbm90IGFsbG93ZWQuXG4gIC8vIEVtcHR5IHBocmFzZXMgY2FuIG9ubHkgYmUgZGVmaW5lZCB3aXRoIGBUTFNgIG9wZXJhdG9ycy5cbiAgY29uc3Qgb3BUQlMgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsZXQgaTtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgY29uc3QgbGVuID0gb3Auc3RyaW5nLmxlbmd0aDtcbiAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICBpZiAocGhyYXNlSW5kZXggKyBsZW4gPD0gY2hhcnNFbmQpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoY2hhcnNbcGhyYXNlSW5kZXggKyBpXSAhPT0gb3Auc3RyaW5nW2ldKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IGxlbjtcbiAgICB9IC8qIGltcGxpZWQgZWxzZSBOT01BVENIICovXG4gIH07XG4gIC8vIFRoZSBgVExTYCBvcGVyYXRvci48YnI+XG4gIC8vIE1hdGNoZXMgaXRzIHByZS1kZWZpbmVkIHBocmFzZSBhZ2FpbnN0IHRoZSBpbnB1dCBzdHJpbmcuXG4gIC8vIEEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBpcyBhdHRlbXB0ZWQgZm9yIEFTQ0lJIGFscGhiZXRpY2FsIGNoYXJhY3RlcnMuXG4gIC8vIGBUTFNgIGlzIHRoZSBvbmx5IG9wZXJhdG9yIHRoYXQgZXhwbGljaXRseSBhbGxvd3MgZW1wdHkgcGhyYXNlcy5cbiAgLy8gYGFwZ2Agd2lsbCBmYWlsIGZvciBlbXB0eSBgVEJTYCwgY2FzZS1zZW5zaXRpdmUgc3RyaW5ncyAoYCcnYCkgb3JcbiAgLy8gemVybyByZXBldGl0aW9ucyAoYDAqMFJ1bGVOYW1lYCBvciBgMFJ1bGVOYW1lYCkuXG4gIGNvbnN0IG9wVExTID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IGNvZGU7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgIGNvbnN0IGxlbiA9IG9wLnN0cmluZy5sZW5ndGg7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgLyogRU1QVFkgbWF0Y2ggYWxsb3dlZCBmb3IgVExTICovXG4gICAgICBzeXNEYXRhLnN0YXRlID0gaWQuRU1QVFk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwaHJhc2VJbmRleCArIGxlbiA8PSBjaGFyc0VuZCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGNvZGUgPSBjaGFyc1twaHJhc2VJbmRleCArIGldO1xuICAgICAgICBpZiAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKSB7XG4gICAgICAgICAgY29kZSArPSAzMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZSAhPT0gb3Auc3RyaW5nW2ldKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IGxlbjtcbiAgICB9IC8qIGltcGxpZWQgZWxzZSBOT01BVENIICovXG4gIH07XG4gIC8vIFRoZSBgQUJHYCBvcGVyYXRvci48YnI+XG4gIC8vIFRoaXMgaXMgYW4gXCJhbmNob3JcIiBmb3IgdGhlIGJlZ2lubmluZyBvZiB0aGUgc3RyaW5nLCBzaW1pbGFyIHRvIHRoZSBmYW1pbGlhciByZWdleCBgXmAgYW5jaG9yLlxuICAvLyBBbiBhbmNob3IgbWF0Y2hlcyBhIHBvc2l0aW9uIHJhdGhlciB0aGFuIGEgcGhyYXNlLlxuICAvLyBSZXR1cm5zIEVNUFRZIGlmIGBwaHJhc2VJbmRleGAgaXMgMCwgTk9NQVRDSCBvdGhlcndpc2UuXG4gIGNvbnN0IG9wQUJHID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgIHN5c0RhdGEuc3RhdGUgPSBwaHJhc2VJbmRleCA9PT0gMCA/IGlkLkVNUFRZIDogaWQuTk9NQVRDSDtcbiAgfTtcbiAgLy8gVGhlIGBBRU5gIG9wZXJhdG9yLjxicj5cbiAgLy8gVGhpcyBpcyBhbiBcImFuY2hvclwiIGZvciB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHNpbWlsYXIgdG8gdGhlIGZhbWlsaWFyIHJlZ2V4IGAkYCBhbmNob3IuXG4gIC8vIEFuIGFuY2hvciBtYXRjaGVzIGEgcG9zaXRpb24gcmF0aGVyIHRoYW4gYSBwaHJhc2UuXG4gIC8vIFJldHVybnMgRU1QVFkgaWYgYHBocmFzZUluZGV4YCBlcXVhbHMgdGhlIGlucHV0IHN0cmluZyBsZW5ndGgsIE5PTUFUQ0ggb3RoZXJ3aXNlLlxuICBjb25zdCBvcEFFTiA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICBzeXNEYXRhLnN0YXRlID0gcGhyYXNlSW5kZXggPT09IGNoYXJzLmxlbmd0aCA/IGlkLkVNUFRZIDogaWQuTk9NQVRDSDtcbiAgfTtcbiAgLy8gVGhlIGBCS1JgIG9wZXJhdG9yLjxicj5cbiAgLy8gVGhlIGJhY2sgcmVmZXJlbmNlIG9wZXJhdG9yLlxuICAvLyBNYXRjaGVzIHRoZSBsYXN0IG1hdGNoZWQgcGhyYXNlIG9mIHRoZSBuYW1lZCBydWxlIG9yIFVEVCBhZ2FpbnN0IHRoZSBpbnB1dCBzdHJpbmcuXG4gIC8vIEZvciBBU0NJSSBhbHBoYmV0aWNhbCBjaGFyYWN0ZXJzIHRoZSBtYXRjaCBtYXkgYmUgY2FzZSBzZW5zaXRpdmUgKGAlc2ApIG9yIGluc2Vuc2l0aXZlIChgJWlgKSxcbiAgLy8gZGVwZW5kaW5nIG9uIHRoZSBiYWNrIHJlZmVyZW5jZSBkZWZpbml0aW9uLlxuICAvLyBGb3IgYHVuaXZlcnNhbGAgbW9kZSAoYCV1YCkgbWF0Y2hlcyB0aGUgbGFzdCBwaHJhc2UgZm91bmQgYW55d2hlcmUgaW4gdGhlIGdyYW1tYXIuXG4gIC8vIEZvciBgcGFyZW50IGZyYW1lYCBtb2RlIChgJXBgKSBtYXRjaGVzIHRoZSBsYXN0IHBocmFzZSBmb3VuZCBpbiB0aGUgcGFyZW50IHJ1bGUgb25seS5cbiAgY29uc3Qgb3BCS1IgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsZXQgaTtcbiAgICBsZXQgY29kZTtcbiAgICBsZXQgbG1jb2RlO1xuICAgIGxldCBsb3dlcjtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgaWYgKG9wLmluZGV4IDwgcnVsZXMubGVuZ3RoKSB7XG4gICAgICBsb3dlciA9IHJ1bGVzW29wLmluZGV4XS5sb3dlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgbG93ZXIgPSB1ZHRzW29wLmluZGV4IC0gcnVsZXMubGVuZ3RoXS5sb3dlcjtcbiAgICB9XG4gICAgY29uc3QgZnJhbWUgPSBvcC5ia3JNb2RlID09PSBpZC5CS1JfTU9ERV9QTSA/IHN5c0RhdGEucEZyYW1lLmdldFBocmFzZShsb3dlcikgOiBzeXNEYXRhLnVGcmFtZS5nZXRQaHJhc2UobG93ZXIpO1xuICAgIGNvbnN0IGluc2Vuc2l0aXZlID0gb3AuYmtyQ2FzZSA9PT0gaWQuQktSX01PREVfQ0k7XG4gICAgaWYgKGZyYW1lID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxtSW5kZXggPSBmcmFtZS5waHJhc2VJbmRleDtcbiAgICBjb25zdCBsZW4gPSBmcmFtZS5waHJhc2VMZW5ndGg7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGhyYXNlSW5kZXggKyBsZW4gPD0gY2hhcnNFbmQpIHtcbiAgICAgIGlmIChpbnNlbnNpdGl2ZSkge1xuICAgICAgICAvKiBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoICovXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGNvZGUgPSBjaGFyc1twaHJhc2VJbmRleCArIGldO1xuICAgICAgICAgIGxtY29kZSA9IGNoYXJzW2xtSW5kZXggKyBpXTtcbiAgICAgICAgICBpZiAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKSB7XG4gICAgICAgICAgICBjb2RlICs9IDMyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobG1jb2RlID49IDY1ICYmIGxtY29kZSA8PSA5MCkge1xuICAgICAgICAgICAgbG1jb2RlICs9IDMyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29kZSAhPT0gbG1jb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5NQVRDSDtcbiAgICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSBsZW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBjYXNlLXNlbnNpdGl2ZSBtYXRjaCAqL1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBjb2RlID0gY2hhcnNbcGhyYXNlSW5kZXggKyBpXTtcbiAgICAgICAgICBsbWNvZGUgPSBjaGFyc1tsbUluZGV4ICsgaV07XG4gICAgICAgICAgaWYgKGNvZGUgIT09IGxtY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk1BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSBsZW47XG4gICAgfVxuICB9O1xuICAvLyBUaGUgYEJLQWAgb3BlcmF0b3IuPGJyPlxuICAvLyBUaGlzIGlzIHRoZSBwb3NpdGl2ZSBgbG9vayBiZWhpbmRgIG9wZXJhdG9yLlxuICAvLyBJdCdzIGNoaWxkIG5vZGUgaXMgcGFyc2VkIHJpZ2h0LXRvLWxlZnQuXG4gIC8vIFJldHVybnMgdGhlIEVNUFRZIHN0YXRlIGlmIGEgbWF0Y2ggaXMgZm91bmQsIE5PTUFUQ0ggb3RoZXJ3aXNlLlxuICAvLyBMaWtlIHRoZSBsb29rIGFoZWFkIG9wZXJhdG9ycywgaXQgYWx3YXlzIGJhY2t0cmFja3MgdG8gYHBocmFzZUluZGV4YC5cbiAgY29uc3Qgb3BCS0EgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsb29rQXJvdW5kLnB1c2goe1xuICAgICAgbG9va0Fyb3VuZDogaWQuTE9PS0FST1VORF9CRUhJTkQsXG4gICAgICBhbmNob3I6IHBocmFzZUluZGV4LFxuICAgIH0pO1xuICAgIG9wRXhlY3V0ZShvcEluZGV4ICsgMSwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgIGxvb2tBcm91bmQucG9wKCk7XG4gICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgIHN3aXRjaCAoc3lzRGF0YS5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5FTVBUWTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgb3BCS0E6IGludmFsaWQgc3RhdGUgJHtzeXNEYXRhLnN0YXRlfWApO1xuICAgIH1cbiAgfTtcbiAgLy8gVGhlIGBCS05gIG9wZXJhdG9yLjxicj5cbiAgLy8gVGhpcyBpcyB0aGUgbmVnYXRpdmUgYGxvb2sgYmVoaW5kYCBvcGVyYXRvci5cbiAgLy8gSXQncyBjaGlsZCBub2RlIGlzIHBhcnNlZCByaWdodC10by1sZWZ0LlxuICAvLyBSZXR1cm5zIHRoZSBFTVBUWSBzdGF0ZSBpZiBhIG1hdGNoIGlzICpub3QqIGZvdW5kLCBOT01BVENIIG90aGVyd2lzZS5cbiAgLy8gTGlrZSB0aGUgbG9vayBhaGVhZCBvcGVyYXRvcnMsIGl0IGFsd2F5cyBiYWNrdHJhY2tzIHRvIGBwaHJhc2VJbmRleGAuXG4gIGNvbnN0IG9wQktOID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgLy8gbGV0IG9wO1xuICAgIC8vIG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBsb29rQXJvdW5kLnB1c2goe1xuICAgICAgbG9va0Fyb3VuZDogaWQuTE9PS0FST1VORF9CRUhJTkQsXG4gICAgICBhbmNob3I6IHBocmFzZUluZGV4LFxuICAgIH0pO1xuICAgIG9wRXhlY3V0ZShvcEluZGV4ICsgMSwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgIGxvb2tBcm91bmQucG9wKCk7XG4gICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgIHN3aXRjaCAoc3lzRGF0YS5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgb3BCS046IGludmFsaWQgc3RhdGUgJHtzeXNEYXRhLnN0YXRlfWApO1xuICAgIH1cbiAgfTtcbiAgLy8gVGhlIHJpZ2h0LXRvLWxlZnQgYENBVGAgb3BlcmF0b3IuPGJyPlxuICAvLyBDYWxsZWQgZm9yIGBDQVRgIG9wZXJhdG9ycyB3aGVuIGluIGxvb2sgYmVoaW5kIG1vZGUuXG4gIC8vIENhbGxzIGl0cyBjaGlsZCBub2RlcyBmcm9tIHJpZ2h0IHRvIGxlZnQgY29uY2F0ZW5hdGluZyBtYXRjaGVkIHBocmFzZXMgcmlnaHQgdG8gbGVmdC5cbiAgY29uc3Qgb3BDQVRCZWhpbmQgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsZXQgc3VjY2VzcztcbiAgICBsZXQgYXN0TGVuZ3RoO1xuICAgIGxldCBjYXRDaGFySW5kZXg7XG4gICAgbGV0IGNhdE1hdGNoZWQ7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIGNvbnN0IHVsZW4gPSBzeXNEYXRhLnVGcmFtZS5sZW5ndGgoKTtcbiAgICBjb25zdCBwbGVuID0gc3lzRGF0YS5wRnJhbWUubGVuZ3RoKCk7XG4gICAgaWYgKHRoaXNUaGlzLmFzdCkge1xuICAgICAgYXN0TGVuZ3RoID0gdGhpc1RoaXMuYXN0LmdldExlbmd0aCgpO1xuICAgIH1cbiAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICBjYXRDaGFySW5kZXggPSBwaHJhc2VJbmRleDtcbiAgICBjYXRNYXRjaGVkID0gMDtcbiAgICAvLyBjYXRQaHJhc2UgPSAwO1xuICAgIGZvciAobGV0IGkgPSBvcC5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgb3BFeGVjdXRlKG9wLmNoaWxkcmVuW2ldLCBjYXRDaGFySW5kZXgsIHN5c0RhdGEpO1xuICAgICAgY2F0Q2hhckluZGV4IC09IHN5c0RhdGEucGhyYXNlTGVuZ3RoO1xuICAgICAgY2F0TWF0Y2hlZCArPSBzeXNEYXRhLnBocmFzZUxlbmd0aDtcbiAgICAgIC8vIGNhdFBocmFzZSArPSBzeXNEYXRhLnBocmFzZUxlbmd0aDtcbiAgICAgIGlmIChzeXNEYXRhLnN0YXRlID09PSBpZC5OT01BVENIKSB7XG4gICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICBzeXNEYXRhLnN0YXRlID0gY2F0TWF0Y2hlZCA9PT0gMCA/IGlkLkVNUFRZIDogaWQuTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IGNhdE1hdGNoZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgICAgc3lzRGF0YS51RnJhbWUucG9wKHVsZW4pO1xuICAgICAgc3lzRGF0YS5wRnJhbWUucG9wKHBsZW4pO1xuICAgICAgaWYgKHRoaXNUaGlzLmFzdCkge1xuICAgICAgICB0aGlzVGhpcy5hc3Quc2V0TGVuZ3RoKGFzdExlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBUaGUgcmlnaHQtdG8tbGVmdCBgUkVQYCBvcGVyYXRvci48YnI+XG4gIC8vIENhbGxlZCBmb3IgYFJFUGAgb3BlcmF0b3JzIGluIGxvb2sgYmVoaW5kIG1vZGUuXG4gIC8vIE1ha2VzIHJlcGVhdGVkIGNhbGxzIHRvIGl0cyBjaGlsZCBub2RlLCBjb25jYXRlbmF0aW5nIG1hdGNoZWQgcGhyYXNlcyByaWdodCB0byBsZWZ0LlxuICBjb25zdCBvcFJFUEJlaGluZCA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxldCBhc3RMZW5ndGg7XG4gICAgbGV0IHJlcENoYXJJbmRleDtcbiAgICBsZXQgcmVwUGhyYXNlO1xuICAgIGxldCByZXBDb3VudDtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgcmVwQ2hhckluZGV4ID0gcGhyYXNlSW5kZXg7XG4gICAgcmVwUGhyYXNlID0gMDtcbiAgICByZXBDb3VudCA9IDA7XG4gICAgY29uc3QgdWxlbiA9IHN5c0RhdGEudUZyYW1lLmxlbmd0aCgpO1xuICAgIGNvbnN0IHBsZW4gPSBzeXNEYXRhLnBGcmFtZS5sZW5ndGgoKTtcbiAgICBpZiAodGhpc1RoaXMuYXN0KSB7XG4gICAgICBhc3RMZW5ndGggPSB0aGlzVGhpcy5hc3QuZ2V0TGVuZ3RoKCk7XG4gICAgfVxuICAgIGNvbnN0IFRSVUUgPSB0cnVlO1xuICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICBpZiAocmVwQ2hhckluZGV4IDw9IDApIHtcbiAgICAgICAgLyogZXhpdCBvbiBlbmQgb2YgaW5wdXQgc3RyaW5nICovXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgb3BFeGVjdXRlKG9wSW5kZXggKyAxLCByZXBDaGFySW5kZXgsIHN5c0RhdGEpO1xuICAgICAgaWYgKHN5c0RhdGEuc3RhdGUgPT09IGlkLk5PTUFUQ0gpIHtcbiAgICAgICAgLyogYWx3YXlzIGVuZCBpZiB0aGUgY2hpbGQgbm9kZSBmYWlscyAqL1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzeXNEYXRhLnN0YXRlID09PSBpZC5FTVBUWSkge1xuICAgICAgICAvKiBSRVAgYWx3YXlzIHN1Y2NlZWRzIHdoZW4gdGhlIGNoaWxkIG5vZGUgcmV0dXJucyBhbiBlbXB0eSBwaHJhc2UgKi9cbiAgICAgICAgLyogdGhpcyBtYXkgbm90IHNlZW0gb2J2aW91cywgYnV0IHRoYXQncyB0aGUgd2F5IGl0IHdvcmtzIG91dCAqL1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJlcENvdW50ICs9IDE7XG4gICAgICByZXBQaHJhc2UgKz0gc3lzRGF0YS5waHJhc2VMZW5ndGg7XG4gICAgICByZXBDaGFySW5kZXggLT0gc3lzRGF0YS5waHJhc2VMZW5ndGg7XG4gICAgICBpZiAocmVwQ291bnQgPT09IG9wLm1heCkge1xuICAgICAgICAvKiBlbmQgb24gbWF4ZWQgb3V0IHJlcHMgKi9cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIGV2YWx1YXRlIHRoZSBtYXRjaCBjb3VudCBhY2NvcmRpbmcgdG8gdGhlIG1pbiwgbWF4IHZhbHVlcyAqL1xuICAgIGlmIChzeXNEYXRhLnN0YXRlID09PSBpZC5FTVBUWSkge1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IHJlcFBocmFzZSA9PT0gMCA/IGlkLkVNUFRZIDogaWQuTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IHJlcFBocmFzZTtcbiAgICB9IGVsc2UgaWYgKHJlcENvdW50ID49IG9wLm1pbikge1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IHJlcFBocmFzZSA9PT0gMCA/IGlkLkVNUFRZIDogaWQuTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IHJlcFBocmFzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgICBzeXNEYXRhLnVGcmFtZS5wb3AodWxlbik7XG4gICAgICBzeXNEYXRhLnBGcmFtZS5wb3AocGxlbik7XG4gICAgICBpZiAodGhpc1RoaXMuYXN0KSB7XG4gICAgICAgIHRoaXNUaGlzLmFzdC5zZXRMZW5ndGgoYXN0TGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIFRoZSByaWdodC10by1sZWZ0IGBUUkdgIG9wZXJhdG9yLjxicj5cbiAgLy8gQ2FsbGVkIGZvciBgVFJHYCBvcGVyYXRvcnMgaW4gbG9vayBiZWhpbmQgbW9kZS5cbiAgLy8gTWF0Y2hlcyBhIHNpbmdsZSBjaGFyYWN0ZXIgYXQgYHBocmFzZUluZGV4IC0gMWAgdG8gdGhlIGBtaW5gIC0gYG1heGAgcmFuZ2UuXG4gIGNvbnN0IG9wVFJHQmVoaW5kID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICBpZiAocGhyYXNlSW5kZXggPiAwKSB7XG4gICAgICBjb25zdCBjaGFyID0gY2hhcnNbcGhyYXNlSW5kZXggLSAxXTtcbiAgICAgIGlmIChvcC5taW4gPD0gY2hhciAmJiBjaGFyIDw9IG9wLm1heCkge1xuICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTUFUQ0g7XG4gICAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIFRoZSByaWdodC10by1sZWZ0IGBUQlNgIG9wZXJhdG9yLjxicj5cbiAgLy8gQ2FsbGVkIGZvciBgVEJTYCBvcGVyYXRvcnMgaW4gbG9vayBiZWhpbmQgbW9kZS5cbiAgLy8gTWF0Y2hlcyB0aGUgYFRCU2AgcGhyYXNlIHRvIHRoZSBsZWZ0IG9mIGBwaHJhc2VJbmRleGAuXG4gIGNvbnN0IG9wVEJTQmVoaW5kID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbGV0IGk7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgIGNvbnN0IGxlbiA9IG9wLnN0cmluZy5sZW5ndGg7XG4gICAgY29uc3QgYmVnID0gcGhyYXNlSW5kZXggLSBsZW47XG4gICAgaWYgKGJlZyA+PSAwKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGNoYXJzW2JlZyArIGldICE9PSBvcC5zdHJpbmdbaV0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5NQVRDSDtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gbGVuO1xuICAgIH1cbiAgfTtcbiAgLy8gVGhlIHJpZ2h0LXRvLWxlZnQgYFRMU2Agb3BlcmF0b3IuPGJyPlxuICAvLyBDYWxsZWQgZm9yIGBUTFNgIG9wZXJhdG9ycyBpbiBsb29rIGJlaGluZCBtb2RlLlxuICAvLyBNYXRjaGVzIHRoZSBgVExTYCBwaHJhc2UgdG8gdGhlIGxlZnQgb2YgYHBocmFzZUluZGV4YC5cbiAgY29uc3Qgb3BUTFNCZWhpbmQgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsZXQgY2hhcjtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgY29uc3QgbGVuID0gb3Auc3RyaW5nLmxlbmd0aDtcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAvKiBFTVBUWSBtYXRjaCBhbGxvd2VkIGZvciBUTFMgKi9cbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5FTVBUWTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYmVnID0gcGhyYXNlSW5kZXggLSBsZW47XG4gICAgaWYgKGJlZyA+PSAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGNoYXIgPSBjaGFyc1tiZWcgKyBpXTtcbiAgICAgICAgaWYgKGNoYXIgPj0gNjUgJiYgY2hhciA8PSA5MCkge1xuICAgICAgICAgIGNoYXIgKz0gMzI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgIT09IG9wLnN0cmluZ1tpXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk1BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSBsZW47XG4gICAgfVxuICB9O1xuICAvLyBUaGUgcmlnaHQtdG8tbGVmdCBiYWNrIHJlZmVyZW5jZSBvcGVyYXRvci48YnI+XG4gIC8vIE1hdGNoZXMgdGhlIGJhY2sgcmVmZXJlbmNlZCBwaHJhc2UgdG8gdGhlIGxlZnQgb2YgYHBocmFzZUluZGV4YC5cbiAgY29uc3Qgb3BCS1JCZWhpbmQgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsZXQgaTtcbiAgICBsZXQgY29kZTtcbiAgICBsZXQgbG1jb2RlO1xuICAgIGxldCBsb3dlcjtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgLyogTk9NQVRDSCBkZWZhdWx0ICovXG4gICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgIGlmIChvcC5pbmRleCA8IHJ1bGVzLmxlbmd0aCkge1xuICAgICAgbG93ZXIgPSBydWxlc1tvcC5pbmRleF0ubG93ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvd2VyID0gdWR0c1tvcC5pbmRleCAtIHJ1bGVzLmxlbmd0aF0ubG93ZXI7XG4gICAgfVxuICAgIGNvbnN0IGZyYW1lID0gb3AuYmtyTW9kZSA9PT0gaWQuQktSX01PREVfUE0gPyBzeXNEYXRhLnBGcmFtZS5nZXRQaHJhc2UobG93ZXIpIDogc3lzRGF0YS51RnJhbWUuZ2V0UGhyYXNlKGxvd2VyKTtcbiAgICBjb25zdCBpbnNlbnNpdGl2ZSA9IG9wLmJrckNhc2UgPT09IGlkLkJLUl9NT0RFX0NJO1xuICAgIGlmIChmcmFtZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsbUluZGV4ID0gZnJhbWUucGhyYXNlSW5kZXg7XG4gICAgY29uc3QgbGVuID0gZnJhbWUucGhyYXNlTGVuZ3RoO1xuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5FTVBUWTtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYmVnID0gcGhyYXNlSW5kZXggLSBsZW47XG4gICAgaWYgKGJlZyA+PSAwKSB7XG4gICAgICBpZiAoaW5zZW5zaXRpdmUpIHtcbiAgICAgICAgLyogY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCAqL1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBjb2RlID0gY2hhcnNbYmVnICsgaV07XG4gICAgICAgICAgbG1jb2RlID0gY2hhcnNbbG1JbmRleCArIGldO1xuICAgICAgICAgIGlmIChjb2RlID49IDY1ICYmIGNvZGUgPD0gOTApIHtcbiAgICAgICAgICAgIGNvZGUgKz0gMzI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsbWNvZGUgPj0gNjUgJiYgbG1jb2RlIDw9IDkwKSB7XG4gICAgICAgICAgICBsbWNvZGUgKz0gMzI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb2RlICE9PSBsbWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk1BVENIO1xuICAgICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IGxlbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGNhc2Utc2Vuc2l0aXZlIG1hdGNoICovXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGNvZGUgPSBjaGFyc1tiZWcgKyBpXTtcbiAgICAgICAgICBsbWNvZGUgPSBjaGFyc1tsbUluZGV4ICsgaV07XG4gICAgICAgICAgaWYgKGNvZGUgIT09IGxtY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk1BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSBsZW47XG4gICAgfVxuICB9O1xuICAvLyBHZW5lcmFsaXplZCBleGVjdXRpb24gZnVuY3Rpb24uPGJyPlxuICAvLyBIYXZpbmcgYSBzaW5nbGUsIGdlbmVyYWxpemVkIGZ1bmN0aW9uLCBhbGxvd3MgYSBzaW5nbGUgbG9jYXRpb25cbiAgLy8gZm9yIHRyYWNpbmcgYW5kIHN0YXRpc3RpY3MgZ2F0aGVyaW5nIGZ1bmN0aW9ucyB0byBiZSBjYWxsZWQuXG4gIC8vIFRyYWNpbmcgYW5kIHN0YXRpc3RpY3MgYXJlIGhhbmRsZWQgaW4gc2VwYXJhdGUgb2JqZWN0cy5cbiAgLy8gSG93ZXZlciwgdGhlIHBhcnNlciBjYWxscyB0aGVpciBBUEkgdG8gYnVpbGQgdGhlIG9iamVjdCBkYXRhIHJlY29yZHMuXG4gIC8vIFNlZSBbYHRyYWNlLmpzYF0oLi90cmFjZS5odG1sKSBhbmQgW2BzdGF0cy5qc2BdKC4vc3RhdHMuaHRtbCkgZm9yIHRoZWlyXG4gIC8vIHVzYWdlLlxuICBvcEV4ZWN1dGUgPSBmdW5jdGlvbiBvcEV4ZWN1dGVGdW5jKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbGV0IHJldCA9IHRydWU7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIG5vZGVIaXRzICs9IDE7XG4gICAgaWYgKG5vZGVIaXRzID4gbGltaXROb2RlSGl0cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJzZXI6IG1heGltdW0gbnVtYmVyIG9mIG5vZGUgaGl0cyBleGNlZWRlZDogJHtsaW1pdE5vZGVIaXRzfWApO1xuICAgIH1cbiAgICB0cmVlRGVwdGggKz0gMTtcbiAgICBpZiAodHJlZURlcHRoID4gbWF4VHJlZURlcHRoKSB7XG4gICAgICBtYXhUcmVlRGVwdGggPSB0cmVlRGVwdGg7XG4gICAgICBpZiAobWF4VHJlZURlcHRoID4gbGltaXRUcmVlRGVwdGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJzZXI6IG1heGltdW0gcGFyc2UgdHJlZSBkZXB0aCBleGNlZWRlZDogJHtsaW1pdFRyZWVEZXB0aH1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3lzRGF0YS5yZWZyZXNoKCk7XG4gICAgaWYgKHRoaXNUaGlzLnRyYWNlICE9PSBudWxsKSB7XG4gICAgICAvKiBjb2xsZWN0IHRoZSB0cmFjZSByZWNvcmQgZm9yIGRvd24gdGhlIHBhcnNlIHRyZWUgKi9cbiAgICAgIGNvbnN0IGxrID0gbG9va0Fyb3VuZFZhbHVlKCk7XG4gICAgICB0aGlzVGhpcy50cmFjZS5kb3duKG9wLCBzeXNEYXRhLnN0YXRlLCBwaHJhc2VJbmRleCwgc3lzRGF0YS5waHJhc2VMZW5ndGgsIGxrLmFuY2hvciwgbGsubG9va0Fyb3VuZCk7XG4gICAgfVxuICAgIGlmIChpbkxvb2tCZWhpbmQoKSkge1xuICAgICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICAgIGNhc2UgaWQuQUxUOlxuICAgICAgICAgIG9wQUxUKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5DQVQ6XG4gICAgICAgICAgb3BDQVRCZWhpbmQob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLlJFUDpcbiAgICAgICAgICBvcFJFUEJlaGluZChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuUk5NOlxuICAgICAgICAgIG9wUk5NKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5VRFQ6XG4gICAgICAgICAgb3BVRFQob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkFORDpcbiAgICAgICAgICBvcEFORChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuTk9UOlxuICAgICAgICAgIG9wTk9UKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5UUkc6XG4gICAgICAgICAgb3BUUkdCZWhpbmQob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLlRCUzpcbiAgICAgICAgICBvcFRCU0JlaGluZChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuVExTOlxuICAgICAgICAgIG9wVExTQmVoaW5kKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5CS1I6XG4gICAgICAgICAgb3BCS1JCZWhpbmQob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkJLQTpcbiAgICAgICAgICBvcEJLQShvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuQktOOlxuICAgICAgICAgIG9wQktOKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5BQkc6XG4gICAgICAgICAgb3BBQkcob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkFFTjpcbiAgICAgICAgICBvcEFFTihvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICBjYXNlIGlkLkFMVDpcbiAgICAgICAgICBvcEFMVChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuQ0FUOlxuICAgICAgICAgIG9wQ0FUKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5SRVA6XG4gICAgICAgICAgb3BSRVAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLlJOTTpcbiAgICAgICAgICBvcFJOTShvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuVURUOlxuICAgICAgICAgIG9wVURUKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5BTkQ6XG4gICAgICAgICAgb3BBTkQob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLk5PVDpcbiAgICAgICAgICBvcE5PVChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuVFJHOlxuICAgICAgICAgIG9wVFJHKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5UQlM6XG4gICAgICAgICAgb3BUQlMob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLlRMUzpcbiAgICAgICAgICBvcFRMUyhvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuQktSOlxuICAgICAgICAgIG9wQktSKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5CS0E6XG4gICAgICAgICAgb3BCS0Eob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkJLTjpcbiAgICAgICAgICBvcEJLTihvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuQUJHOlxuICAgICAgICAgIG9wQUJHKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5BRU46XG4gICAgICAgICAgb3BBRU4ob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWluTG9va0Fyb3VuZCgpICYmIHBocmFzZUluZGV4ICsgc3lzRGF0YS5waHJhc2VMZW5ndGggPiBtYXhNYXRjaGVkKSB7XG4gICAgICBtYXhNYXRjaGVkID0gcGhyYXNlSW5kZXggKyBzeXNEYXRhLnBocmFzZUxlbmd0aDtcbiAgICB9XG4gICAgaWYgKHRoaXNUaGlzLnN0YXRzICE9PSBudWxsKSB7XG4gICAgICAvKiBjb2xsZWN0IHRoZSBzdGF0aXN0aWNzICovXG4gICAgICB0aGlzVGhpcy5zdGF0cy5jb2xsZWN0KG9wLCBzeXNEYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXNUaGlzLnRyYWNlICE9PSBudWxsKSB7XG4gICAgICAvKiBjb2xsZWN0IHRoZSB0cmFjZSByZWNvcmQgZm9yIHVwIHRoZSBwYXJzZSB0cmVlICovXG4gICAgICBjb25zdCBsayA9IGxvb2tBcm91bmRWYWx1ZSgpO1xuICAgICAgdGhpc1RoaXMudHJhY2UudXAob3AsIHN5c0RhdGEuc3RhdGUsIHBocmFzZUluZGV4LCBzeXNEYXRhLnBocmFzZUxlbmd0aCwgbGsuYW5jaG9yLCBsay5sb29rQXJvdW5kKTtcbiAgICB9XG4gICAgdHJlZURlcHRoIC09IDE7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-lib/parser.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-lib/stats.js":
/*!**************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/stats.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module is the constructor for the statistics gathering object.\n// The statistics are nothing more than keeping a count of the\n// number of times each node in the parse tree is traversed.\n//\n// Counts are collected for each of the individual types of operators.\n// Additionally, counts are collected for each of the individually named\n// `RNM` and `UDT` operators.\nmodule.exports = function statsFunc() {\n  const id = __webpack_require__(/*! ./identifiers */ \"./node_modules/apg-js/src/apg-lib/identifiers.js\");\n  const utils = __webpack_require__(/*! ./utilities */ \"./node_modules/apg-js/src/apg-lib/utilities.js\");\n  const style = __webpack_require__(/*! ./style */ \"./node_modules/apg-js/src/apg-lib/style.js\");\n\n  const thisFileName = 'stats.js: ';\n  let rules = [];\n  let udts = [];\n  const stats = [];\n  let totals;\n  const ruleStats = [];\n  const udtStats = [];\n  this.statsObject = 'statsObject';\n  const nameId = 'stats';\n  /* `Array.sort()` callback function for sorting `RNM` and `UDT` operators alphabetically by name. */\n  const sortAlpha = function sortAlpha(lhs, rhs) {\n    if (lhs.lower < rhs.lower) {\n      return -1;\n    }\n    if (lhs.lower > rhs.lower) {\n      return 1;\n    }\n    return 0;\n  };\n  /* `Array.sort()` callback function for sorting `RNM` and `UDT` operators by hit count. */\n  const sortHits = function sortHits(lhs, rhs) {\n    if (lhs.total < rhs.total) {\n      return 1;\n    }\n    if (lhs.total > rhs.total) {\n      return -1;\n    }\n    return sortAlpha(lhs, rhs);\n  };\n  /* `Array.sort()` callback function for sorting `RNM` and `UDT` operators by index */\n  /* (in the order in which they appear in the SABNF grammar). */\n  const sortIndex = function sortIndex(lhs, rhs) {\n    if (lhs.index < rhs.index) {\n      return -1;\n    }\n    if (lhs.index > rhs.index) {\n      return 1;\n    }\n    return 0;\n  };\n  const EmptyStat = function EmptyStat() {\n    this.empty = 0;\n    this.match = 0;\n    this.nomatch = 0;\n    this.total = 0;\n  };\n  /* Zero out all stats */\n  const clear = function clear() {\n    stats.length = 0;\n    totals = new EmptyStat();\n    stats[id.ALT] = new EmptyStat();\n    stats[id.CAT] = new EmptyStat();\n    stats[id.REP] = new EmptyStat();\n    stats[id.RNM] = new EmptyStat();\n    stats[id.TRG] = new EmptyStat();\n    stats[id.TBS] = new EmptyStat();\n    stats[id.TLS] = new EmptyStat();\n    stats[id.UDT] = new EmptyStat();\n    stats[id.AND] = new EmptyStat();\n    stats[id.NOT] = new EmptyStat();\n    stats[id.BKR] = new EmptyStat();\n    stats[id.BKA] = new EmptyStat();\n    stats[id.BKN] = new EmptyStat();\n    stats[id.ABG] = new EmptyStat();\n    stats[id.AEN] = new EmptyStat();\n    ruleStats.length = 0;\n    for (let i = 0; i < rules.length; i += 1) {\n      ruleStats.push({\n        empty: 0,\n        match: 0,\n        nomatch: 0,\n        total: 0,\n        name: rules[i].name,\n        lower: rules[i].lower,\n        index: rules[i].index,\n      });\n    }\n    if (udts.length > 0) {\n      udtStats.length = 0;\n      for (let i = 0; i < udts.length; i += 1) {\n        udtStats.push({\n          empty: 0,\n          match: 0,\n          nomatch: 0,\n          total: 0,\n          name: udts[i].name,\n          lower: udts[i].lower,\n          index: udts[i].index,\n        });\n      }\n    }\n  };\n  /* increment the designated operator hit count by one */\n  const incStat = function incStat(stat, state) {\n    stat.total += 1;\n    switch (state) {\n      case id.EMPTY:\n        stat.empty += 1;\n        break;\n      case id.MATCH:\n        stat.match += 1;\n        break;\n      case id.NOMATCH:\n        stat.nomatch += 1;\n        break;\n      default:\n        throw new Error(`${thisFileName}collect(): incStat(): unrecognized state: ${state}`);\n    }\n  };\n  /* helper for toHtml() */\n  const displayRow = function displayRow(name, stat) {\n    let html = '';\n    html += '<tr>';\n    html += `<td class=\"${style.CLASS_ACTIVE}\">${name}</td>`;\n    html += `<td class=\"${style.CLASS_EMPTY}\">${stat.empty}</td>`;\n    html += `<td class=\"${style.CLASS_MATCH}\">${stat.match}</td>`;\n    html += `<td class=\"${style.CLASS_NOMATCH}\">${stat.nomatch}</td>`;\n    html += `<td class=\"${style.CLASS_ACTIVE}\">${stat.total}</td>`;\n    html += '</tr>\\n';\n    return html;\n  };\n  const displayOpsOnly = function displayOpsOnly() {\n    let html = '';\n    html += displayRow('ALT', stats[id.ALT]);\n    html += displayRow('CAT', stats[id.CAT]);\n    html += displayRow('REP', stats[id.REP]);\n    html += displayRow('RNM', stats[id.RNM]);\n    html += displayRow('TRG', stats[id.TRG]);\n    html += displayRow('TBS', stats[id.TBS]);\n    html += displayRow('TLS', stats[id.TLS]);\n    html += displayRow('UDT', stats[id.UDT]);\n    html += displayRow('AND', stats[id.AND]);\n    html += displayRow('NOT', stats[id.NOT]);\n    html += displayRow('BKR', stats[id.BKR]);\n    html += displayRow('BKA', stats[id.BKA]);\n    html += displayRow('BKN', stats[id.BKN]);\n    html += displayRow('ABG', stats[id.ABG]);\n    html += displayRow('AEN', stats[id.AEN]);\n    html += displayRow('totals', totals);\n    return html;\n  };\n  /* helper for toHtml() */\n  const displayRules = function displayRules() {\n    let html = '';\n    html += '<tr><th></th><th></th><th></th><th></th><th></th></tr>\\n';\n    html += '<tr><th>rules</th><th></th><th></th><th></th><th></th></tr>\\n';\n    for (let i = 0; i < rules.length; i += 1) {\n      if (ruleStats[i].total > 0) {\n        html += '<tr>';\n        html += `<td class=\"${style.CLASS_ACTIVE}\">${ruleStats[i].name}</td>`;\n        html += `<td class=\"${style.CLASS_EMPTY}\">${ruleStats[i].empty}</td>`;\n        html += `<td class=\"${style.CLASS_MATCH}\">${ruleStats[i].match}</td>`;\n        html += `<td class=\"${style.CLASS_NOMATCH}\">${ruleStats[i].nomatch}</td>`;\n        html += `<td class=\"${style.CLASS_ACTIVE}\">${ruleStats[i].total}</td>`;\n        html += '</tr>\\n';\n      }\n    }\n    if (udts.length > 0) {\n      html += '<tr><th></th><th></th><th></th><th></th><th></th></tr>\\n';\n      html += '<tr><th>udts</th><th></th><th></th><th></th><th></th></tr>\\n';\n      for (let i = 0; i < udts.length; i += 1) {\n        if (udtStats[i].total > 0) {\n          html += '<tr>';\n          html += `<td class=\"${style.CLASS_ACTIVE}\">${udtStats[i].name}</td>`;\n          html += `<td class=\"${style.CLASS_EMPTY}\">${udtStats[i].empty}</td>`;\n          html += `<td class=\"${style.CLASS_MATCH}\">${udtStats[i].match}</td>`;\n          html += `<td class=\"${style.CLASS_NOMATCH}\">${udtStats[i].nomatch}</td>`;\n          html += `<td class=\"${style.CLASS_ACTIVE}\">${udtStats[i].total}</td>`;\n          html += '</tr>\\n';\n        }\n      }\n    }\n    return html;\n  };\n  /* called only by the parser to validate a stats object */\n  this.validate = function validate(name) {\n    let ret = false;\n    if (typeof name === 'string' && nameId === name) {\n      ret = true;\n    }\n    return ret;\n  };\n  /* no verification of input - only called by parser() */\n  this.init = function init(inputRules, inputUdts) {\n    rules = inputRules;\n    udts = inputUdts;\n    clear();\n  };\n  /* This function is the main interaction with the parser. */\n  /* The parser calls it after each node has been traversed. */\n  this.collect = function collect(op, result) {\n    incStat(totals, result.state, result.phraseLength);\n    incStat(stats[op.type], result.state, result.phraseLength);\n    if (op.type === id.RNM) {\n      incStat(ruleStats[op.index], result.state, result.phraseLength);\n    }\n    if (op.type === id.UDT) {\n      incStat(udtStats[op.index], result.state, result.phraseLength);\n    }\n  };\n  // Display the statistics as an HTML table.\n  // - *type*\n  //   - \"ops\" - (default) display only the total hit counts for all operator types.\n  //   - \"index\" - additionally, display the hit counts for the individual `RNM` and `UDT` operators ordered by index.\n  //   - \"hits\" - additionally, display the hit counts for the individual `RNM` and `UDT` operators by hit count.\n  //   - \"alpha\" - additionally, display the hit counts for the individual `RNM` and `UDT` operators by name alphabetically.\n  // - *caption* - optional caption for the table\n  this.toHtml = function toHtml(type, caption) {\n    let html = '';\n    html += `<table class=\"${style.CLASS_STATS}\">\\n`;\n    if (typeof caption === 'string') {\n      html += `<caption>${caption}</caption>\\n`;\n    }\n    html += `<tr><th class=\"${style.CLASS_ACTIVE}\">ops</th>\\n`;\n    html += `<th class=\"${style.CLASS_EMPTY}\">EMPTY</th>\\n`;\n    html += `<th class=\"${style.CLASS_MATCH}\">MATCH</th>\\n`;\n    html += `<th class=\"${style.CLASS_NOMATCH}\">NOMATCH</th>\\n`;\n    html += `<th class=\"${style.CLASS_ACTIVE}\">totals</th></tr>\\n`;\n    const test = true;\n    while (test) {\n      if (type === undefined) {\n        html += displayOpsOnly();\n        break;\n      }\n      if (type === null) {\n        html += displayOpsOnly();\n        break;\n      }\n      if (type === 'ops') {\n        html += displayOpsOnly();\n        break;\n      }\n      if (type === 'index') {\n        ruleStats.sort(sortIndex);\n        if (udtStats.length > 0) {\n          udtStats.sort(sortIndex);\n        }\n        html += displayOpsOnly();\n        html += displayRules();\n        break;\n      }\n      if (type === 'hits') {\n        ruleStats.sort(sortHits);\n        if (udtStats.length > 0) {\n          udtStats.sort(sortIndex);\n        }\n        html += displayOpsOnly();\n        html += displayRules();\n        break;\n      }\n      if (type === 'alpha') {\n        ruleStats.sort(sortAlpha);\n        if (udtStats.length > 0) {\n          udtStats.sort(sortAlpha);\n        }\n        html += displayOpsOnly();\n        html += displayRules();\n        break;\n      }\n      break;\n    }\n    html += '</table>\\n';\n    return html;\n  };\n  // Display the stats table in a complete HTML5 page.\n  this.toHtmlPage = function toHtmlPage(type, caption, title) {\n    return utils.htmlToPage(this.toHtml(type, caption), title);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3N0YXRzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyx1RUFBZTtBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBYTtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQywyREFBUzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWEsNENBQTRDLE1BQU07QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFtQixJQUFJLEtBQUs7QUFDdEQsMEJBQTBCLGtCQUFrQixJQUFJLFdBQVc7QUFDM0QsMEJBQTBCLGtCQUFrQixJQUFJLFdBQVc7QUFDM0QsMEJBQTBCLG9CQUFvQixJQUFJLGFBQWE7QUFDL0QsMEJBQTBCLG1CQUFtQixJQUFJLFdBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQSw4QkFBOEIsbUJBQW1CLElBQUksa0JBQWtCO0FBQ3ZFLDhCQUE4QixrQkFBa0IsSUFBSSxtQkFBbUI7QUFDdkUsOEJBQThCLGtCQUFrQixJQUFJLG1CQUFtQjtBQUN2RSw4QkFBOEIsb0JBQW9CLElBQUkscUJBQXFCO0FBQzNFLDhCQUE4QixtQkFBbUIsSUFBSSxtQkFBbUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQixJQUFJLGlCQUFpQjtBQUN4RSxnQ0FBZ0Msa0JBQWtCLElBQUksa0JBQWtCO0FBQ3hFLGdDQUFnQyxrQkFBa0IsSUFBSSxrQkFBa0I7QUFDeEUsZ0NBQWdDLG9CQUFvQixJQUFJLG9CQUFvQjtBQUM1RSxnQ0FBZ0MsbUJBQW1CLElBQUksa0JBQWtCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQSw4QkFBOEIsbUJBQW1CO0FBQ2pELDBCQUEwQixrQkFBa0I7QUFDNUMsMEJBQTBCLGtCQUFrQjtBQUM1QywwQkFBMEIsb0JBQW9CO0FBQzlDLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1saWIvc3RhdHMuanM/ZmQzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSBpcyB0aGUgY29uc3RydWN0b3IgZm9yIHRoZSBzdGF0aXN0aWNzIGdhdGhlcmluZyBvYmplY3QuXG4vLyBUaGUgc3RhdGlzdGljcyBhcmUgbm90aGluZyBtb3JlIHRoYW4ga2VlcGluZyBhIGNvdW50IG9mIHRoZVxuLy8gbnVtYmVyIG9mIHRpbWVzIGVhY2ggbm9kZSBpbiB0aGUgcGFyc2UgdHJlZSBpcyB0cmF2ZXJzZWQuXG4vL1xuLy8gQ291bnRzIGFyZSBjb2xsZWN0ZWQgZm9yIGVhY2ggb2YgdGhlIGluZGl2aWR1YWwgdHlwZXMgb2Ygb3BlcmF0b3JzLlxuLy8gQWRkaXRpb25hbGx5LCBjb3VudHMgYXJlIGNvbGxlY3RlZCBmb3IgZWFjaCBvZiB0aGUgaW5kaXZpZHVhbGx5IG5hbWVkXG4vLyBgUk5NYCBhbmQgYFVEVGAgb3BlcmF0b3JzLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdGF0c0Z1bmMoKSB7XG4gIGNvbnN0IGlkID0gcmVxdWlyZSgnLi9pZGVudGlmaWVycycpO1xuICBjb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzJyk7XG4gIGNvbnN0IHN0eWxlID0gcmVxdWlyZSgnLi9zdHlsZScpO1xuXG4gIGNvbnN0IHRoaXNGaWxlTmFtZSA9ICdzdGF0cy5qczogJztcbiAgbGV0IHJ1bGVzID0gW107XG4gIGxldCB1ZHRzID0gW107XG4gIGNvbnN0IHN0YXRzID0gW107XG4gIGxldCB0b3RhbHM7XG4gIGNvbnN0IHJ1bGVTdGF0cyA9IFtdO1xuICBjb25zdCB1ZHRTdGF0cyA9IFtdO1xuICB0aGlzLnN0YXRzT2JqZWN0ID0gJ3N0YXRzT2JqZWN0JztcbiAgY29uc3QgbmFtZUlkID0gJ3N0YXRzJztcbiAgLyogYEFycmF5LnNvcnQoKWAgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNvcnRpbmcgYFJOTWAgYW5kIGBVRFRgIG9wZXJhdG9ycyBhbHBoYWJldGljYWxseSBieSBuYW1lLiAqL1xuICBjb25zdCBzb3J0QWxwaGEgPSBmdW5jdGlvbiBzb3J0QWxwaGEobGhzLCByaHMpIHtcbiAgICBpZiAobGhzLmxvd2VyIDwgcmhzLmxvd2VyKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChsaHMubG93ZXIgPiByaHMubG93ZXIpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgLyogYEFycmF5LnNvcnQoKWAgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNvcnRpbmcgYFJOTWAgYW5kIGBVRFRgIG9wZXJhdG9ycyBieSBoaXQgY291bnQuICovXG4gIGNvbnN0IHNvcnRIaXRzID0gZnVuY3Rpb24gc29ydEhpdHMobGhzLCByaHMpIHtcbiAgICBpZiAobGhzLnRvdGFsIDwgcmhzLnRvdGFsKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKGxocy50b3RhbCA+IHJocy50b3RhbCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICByZXR1cm4gc29ydEFscGhhKGxocywgcmhzKTtcbiAgfTtcbiAgLyogYEFycmF5LnNvcnQoKWAgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNvcnRpbmcgYFJOTWAgYW5kIGBVRFRgIG9wZXJhdG9ycyBieSBpbmRleCAqL1xuICAvKiAoaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXBwZWFyIGluIHRoZSBTQUJORiBncmFtbWFyKS4gKi9cbiAgY29uc3Qgc29ydEluZGV4ID0gZnVuY3Rpb24gc29ydEluZGV4KGxocywgcmhzKSB7XG4gICAgaWYgKGxocy5pbmRleCA8IHJocy5pbmRleCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAobGhzLmluZGV4ID4gcmhzLmluZGV4KSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG4gIGNvbnN0IEVtcHR5U3RhdCA9IGZ1bmN0aW9uIEVtcHR5U3RhdCgpIHtcbiAgICB0aGlzLmVtcHR5ID0gMDtcbiAgICB0aGlzLm1hdGNoID0gMDtcbiAgICB0aGlzLm5vbWF0Y2ggPSAwO1xuICAgIHRoaXMudG90YWwgPSAwO1xuICB9O1xuICAvKiBaZXJvIG91dCBhbGwgc3RhdHMgKi9cbiAgY29uc3QgY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBzdGF0cy5sZW5ndGggPSAwO1xuICAgIHRvdGFscyA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5BTFRdID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLkNBVF0gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuUkVQXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5STk1dID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLlRSR10gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuVEJTXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5UTFNdID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLlVEVF0gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuQU5EXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5OT1RdID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLkJLUl0gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuQktBXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5CS05dID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLkFCR10gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuQUVOXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBydWxlU3RhdHMubGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBydWxlU3RhdHMucHVzaCh7XG4gICAgICAgIGVtcHR5OiAwLFxuICAgICAgICBtYXRjaDogMCxcbiAgICAgICAgbm9tYXRjaDogMCxcbiAgICAgICAgdG90YWw6IDAsXG4gICAgICAgIG5hbWU6IHJ1bGVzW2ldLm5hbWUsXG4gICAgICAgIGxvd2VyOiBydWxlc1tpXS5sb3dlcixcbiAgICAgICAgaW5kZXg6IHJ1bGVzW2ldLmluZGV4LFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh1ZHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHVkdFN0YXRzLmxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVkdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdWR0U3RhdHMucHVzaCh7XG4gICAgICAgICAgZW1wdHk6IDAsXG4gICAgICAgICAgbWF0Y2g6IDAsXG4gICAgICAgICAgbm9tYXRjaDogMCxcbiAgICAgICAgICB0b3RhbDogMCxcbiAgICAgICAgICBuYW1lOiB1ZHRzW2ldLm5hbWUsXG4gICAgICAgICAgbG93ZXI6IHVkdHNbaV0ubG93ZXIsXG4gICAgICAgICAgaW5kZXg6IHVkdHNbaV0uaW5kZXgsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyogaW5jcmVtZW50IHRoZSBkZXNpZ25hdGVkIG9wZXJhdG9yIGhpdCBjb3VudCBieSBvbmUgKi9cbiAgY29uc3QgaW5jU3RhdCA9IGZ1bmN0aW9uIGluY1N0YXQoc3RhdCwgc3RhdGUpIHtcbiAgICBzdGF0LnRvdGFsICs9IDE7XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgc3RhdC5lbXB0eSArPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHN0YXQubWF0Y2ggKz0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIHN0YXQubm9tYXRjaCArPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Y29sbGVjdCgpOiBpbmNTdGF0KCk6IHVucmVjb2duaXplZCBzdGF0ZTogJHtzdGF0ZX1gKTtcbiAgICB9XG4gIH07XG4gIC8qIGhlbHBlciBmb3IgdG9IdG1sKCkgKi9cbiAgY29uc3QgZGlzcGxheVJvdyA9IGZ1bmN0aW9uIGRpc3BsYXlSb3cobmFtZSwgc3RhdCkge1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgaHRtbCArPSAnPHRyPic7XG4gICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19BQ1RJVkV9XCI+JHtuYW1lfTwvdGQ+YDtcbiAgICBodG1sICs9IGA8dGQgY2xhc3M9XCIke3N0eWxlLkNMQVNTX0VNUFRZfVwiPiR7c3RhdC5lbXB0eX08L3RkPmA7XG4gICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj4ke3N0YXQubWF0Y2h9PC90ZD5gO1xuICAgIGh0bWwgKz0gYDx0ZCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTk9NQVRDSH1cIj4ke3N0YXQubm9tYXRjaH08L3RkPmA7XG4gICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19BQ1RJVkV9XCI+JHtzdGF0LnRvdGFsfTwvdGQ+YDtcbiAgICBodG1sICs9ICc8L3RyPlxcbic7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIGNvbnN0IGRpc3BsYXlPcHNPbmx5ID0gZnVuY3Rpb24gZGlzcGxheU9wc09ubHkoKSB7XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ0FMVCcsIHN0YXRzW2lkLkFMVF0pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnQ0FUJywgc3RhdHNbaWQuQ0FUXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdSRVAnLCBzdGF0c1tpZC5SRVBdKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ1JOTScsIHN0YXRzW2lkLlJOTV0pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnVFJHJywgc3RhdHNbaWQuVFJHXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdUQlMnLCBzdGF0c1tpZC5UQlNdKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ1RMUycsIHN0YXRzW2lkLlRMU10pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnVURUJywgc3RhdHNbaWQuVURUXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdBTkQnLCBzdGF0c1tpZC5BTkRdKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ05PVCcsIHN0YXRzW2lkLk5PVF0pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnQktSJywgc3RhdHNbaWQuQktSXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdCS0EnLCBzdGF0c1tpZC5CS0FdKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ0JLTicsIHN0YXRzW2lkLkJLTl0pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnQUJHJywgc3RhdHNbaWQuQUJHXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdBRU4nLCBzdGF0c1tpZC5BRU5dKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ3RvdGFscycsIHRvdGFscyk7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIC8qIGhlbHBlciBmb3IgdG9IdG1sKCkgKi9cbiAgY29uc3QgZGlzcGxheVJ1bGVzID0gZnVuY3Rpb24gZGlzcGxheVJ1bGVzKCkge1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgaHRtbCArPSAnPHRyPjx0aD48L3RoPjx0aD48L3RoPjx0aD48L3RoPjx0aD48L3RoPjx0aD48L3RoPjwvdHI+XFxuJztcbiAgICBodG1sICs9ICc8dHI+PHRoPnJ1bGVzPC90aD48dGg+PC90aD48dGg+PC90aD48dGg+PC90aD48dGg+PC90aD48L3RyPlxcbic7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHJ1bGVTdGF0c1tpXS50b3RhbCA+IDApIHtcbiAgICAgICAgaHRtbCArPSAnPHRyPic7XG4gICAgICAgIGh0bWwgKz0gYDx0ZCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfQUNUSVZFfVwiPiR7cnVsZVN0YXRzW2ldLm5hbWV9PC90ZD5gO1xuICAgICAgICBodG1sICs9IGA8dGQgY2xhc3M9XCIke3N0eWxlLkNMQVNTX0VNUFRZfVwiPiR7cnVsZVN0YXRzW2ldLmVtcHR5fTwvdGQ+YDtcbiAgICAgICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj4ke3J1bGVTdGF0c1tpXS5tYXRjaH08L3RkPmA7XG4gICAgICAgIGh0bWwgKz0gYDx0ZCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTk9NQVRDSH1cIj4ke3J1bGVTdGF0c1tpXS5ub21hdGNofTwvdGQ+YDtcbiAgICAgICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19BQ1RJVkV9XCI+JHtydWxlU3RhdHNbaV0udG90YWx9PC90ZD5gO1xuICAgICAgICBodG1sICs9ICc8L3RyPlxcbic7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1ZHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGh0bWwgKz0gJzx0cj48dGg+PC90aD48dGg+PC90aD48dGg+PC90aD48dGg+PC90aD48dGg+PC90aD48L3RyPlxcbic7XG4gICAgICBodG1sICs9ICc8dHI+PHRoPnVkdHM8L3RoPjx0aD48L3RoPjx0aD48L3RoPjx0aD48L3RoPjx0aD48L3RoPjwvdHI+XFxuJztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWR0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAodWR0U3RhdHNbaV0udG90YWwgPiAwKSB7XG4gICAgICAgICAgaHRtbCArPSAnPHRyPic7XG4gICAgICAgICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19BQ1RJVkV9XCI+JHt1ZHRTdGF0c1tpXS5uYW1lfTwvdGQ+YDtcbiAgICAgICAgICBodG1sICs9IGA8dGQgY2xhc3M9XCIke3N0eWxlLkNMQVNTX0VNUFRZfVwiPiR7dWR0U3RhdHNbaV0uZW1wdHl9PC90ZD5gO1xuICAgICAgICAgIGh0bWwgKz0gYDx0ZCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTUFUQ0h9XCI+JHt1ZHRTdGF0c1tpXS5tYXRjaH08L3RkPmA7XG4gICAgICAgICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19OT01BVENIfVwiPiR7dWR0U3RhdHNbaV0ubm9tYXRjaH08L3RkPmA7XG4gICAgICAgICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19BQ1RJVkV9XCI+JHt1ZHRTdGF0c1tpXS50b3RhbH08L3RkPmA7XG4gICAgICAgICAgaHRtbCArPSAnPC90cj5cXG4nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBodG1sO1xuICB9O1xuICAvKiBjYWxsZWQgb25seSBieSB0aGUgcGFyc2VyIHRvIHZhbGlkYXRlIGEgc3RhdHMgb2JqZWN0ICovXG4gIHRoaXMudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShuYW1lKSB7XG4gICAgbGV0IHJldCA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgJiYgbmFtZUlkID09PSBuYW1lKSB7XG4gICAgICByZXQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuICAvKiBubyB2ZXJpZmljYXRpb24gb2YgaW5wdXQgLSBvbmx5IGNhbGxlZCBieSBwYXJzZXIoKSAqL1xuICB0aGlzLmluaXQgPSBmdW5jdGlvbiBpbml0KGlucHV0UnVsZXMsIGlucHV0VWR0cykge1xuICAgIHJ1bGVzID0gaW5wdXRSdWxlcztcbiAgICB1ZHRzID0gaW5wdXRVZHRzO1xuICAgIGNsZWFyKCk7XG4gIH07XG4gIC8qIFRoaXMgZnVuY3Rpb24gaXMgdGhlIG1haW4gaW50ZXJhY3Rpb24gd2l0aCB0aGUgcGFyc2VyLiAqL1xuICAvKiBUaGUgcGFyc2VyIGNhbGxzIGl0IGFmdGVyIGVhY2ggbm9kZSBoYXMgYmVlbiB0cmF2ZXJzZWQuICovXG4gIHRoaXMuY29sbGVjdCA9IGZ1bmN0aW9uIGNvbGxlY3Qob3AsIHJlc3VsdCkge1xuICAgIGluY1N0YXQodG90YWxzLCByZXN1bHQuc3RhdGUsIHJlc3VsdC5waHJhc2VMZW5ndGgpO1xuICAgIGluY1N0YXQoc3RhdHNbb3AudHlwZV0sIHJlc3VsdC5zdGF0ZSwgcmVzdWx0LnBocmFzZUxlbmd0aCk7XG4gICAgaWYgKG9wLnR5cGUgPT09IGlkLlJOTSkge1xuICAgICAgaW5jU3RhdChydWxlU3RhdHNbb3AuaW5kZXhdLCByZXN1bHQuc3RhdGUsIHJlc3VsdC5waHJhc2VMZW5ndGgpO1xuICAgIH1cbiAgICBpZiAob3AudHlwZSA9PT0gaWQuVURUKSB7XG4gICAgICBpbmNTdGF0KHVkdFN0YXRzW29wLmluZGV4XSwgcmVzdWx0LnN0YXRlLCByZXN1bHQucGhyYXNlTGVuZ3RoKTtcbiAgICB9XG4gIH07XG4gIC8vIERpc3BsYXkgdGhlIHN0YXRpc3RpY3MgYXMgYW4gSFRNTCB0YWJsZS5cbiAgLy8gLSAqdHlwZSpcbiAgLy8gICAtIFwib3BzXCIgLSAoZGVmYXVsdCkgZGlzcGxheSBvbmx5IHRoZSB0b3RhbCBoaXQgY291bnRzIGZvciBhbGwgb3BlcmF0b3IgdHlwZXMuXG4gIC8vICAgLSBcImluZGV4XCIgLSBhZGRpdGlvbmFsbHksIGRpc3BsYXkgdGhlIGhpdCBjb3VudHMgZm9yIHRoZSBpbmRpdmlkdWFsIGBSTk1gIGFuZCBgVURUYCBvcGVyYXRvcnMgb3JkZXJlZCBieSBpbmRleC5cbiAgLy8gICAtIFwiaGl0c1wiIC0gYWRkaXRpb25hbGx5LCBkaXNwbGF5IHRoZSBoaXQgY291bnRzIGZvciB0aGUgaW5kaXZpZHVhbCBgUk5NYCBhbmQgYFVEVGAgb3BlcmF0b3JzIGJ5IGhpdCBjb3VudC5cbiAgLy8gICAtIFwiYWxwaGFcIiAtIGFkZGl0aW9uYWxseSwgZGlzcGxheSB0aGUgaGl0IGNvdW50cyBmb3IgdGhlIGluZGl2aWR1YWwgYFJOTWAgYW5kIGBVRFRgIG9wZXJhdG9ycyBieSBuYW1lIGFscGhhYmV0aWNhbGx5LlxuICAvLyAtICpjYXB0aW9uKiAtIG9wdGlvbmFsIGNhcHRpb24gZm9yIHRoZSB0YWJsZVxuICB0aGlzLnRvSHRtbCA9IGZ1bmN0aW9uIHRvSHRtbCh0eXBlLCBjYXB0aW9uKSB7XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBodG1sICs9IGA8dGFibGUgY2xhc3M9XCIke3N0eWxlLkNMQVNTX1NUQVRTfVwiPlxcbmA7XG4gICAgaWYgKHR5cGVvZiBjYXB0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgaHRtbCArPSBgPGNhcHRpb24+JHtjYXB0aW9ufTwvY2FwdGlvbj5cXG5gO1xuICAgIH1cbiAgICBodG1sICs9IGA8dHI+PHRoIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19BQ1RJVkV9XCI+b3BzPC90aD5cXG5gO1xuICAgIGh0bWwgKz0gYDx0aCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfRU1QVFl9XCI+RU1QVFk8L3RoPlxcbmA7XG4gICAgaHRtbCArPSBgPHRoIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj5NQVRDSDwvdGg+XFxuYDtcbiAgICBodG1sICs9IGA8dGggY2xhc3M9XCIke3N0eWxlLkNMQVNTX05PTUFUQ0h9XCI+Tk9NQVRDSDwvdGg+XFxuYDtcbiAgICBodG1sICs9IGA8dGggY2xhc3M9XCIke3N0eWxlLkNMQVNTX0FDVElWRX1cIj50b3RhbHM8L3RoPjwvdHI+XFxuYDtcbiAgICBjb25zdCB0ZXN0ID0gdHJ1ZTtcbiAgICB3aGlsZSAodGVzdCkge1xuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBodG1sICs9IGRpc3BsYXlPcHNPbmx5KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgaHRtbCArPSBkaXNwbGF5T3BzT25seSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAnb3BzJykge1xuICAgICAgICBodG1sICs9IGRpc3BsYXlPcHNPbmx5KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09ICdpbmRleCcpIHtcbiAgICAgICAgcnVsZVN0YXRzLnNvcnQoc29ydEluZGV4KTtcbiAgICAgICAgaWYgKHVkdFN0YXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB1ZHRTdGF0cy5zb3J0KHNvcnRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbCArPSBkaXNwbGF5T3BzT25seSgpO1xuICAgICAgICBodG1sICs9IGRpc3BsYXlSdWxlcygpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAnaGl0cycpIHtcbiAgICAgICAgcnVsZVN0YXRzLnNvcnQoc29ydEhpdHMpO1xuICAgICAgICBpZiAodWR0U3RhdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHVkdFN0YXRzLnNvcnQoc29ydEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBodG1sICs9IGRpc3BsYXlPcHNPbmx5KCk7XG4gICAgICAgIGh0bWwgKz0gZGlzcGxheVJ1bGVzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09ICdhbHBoYScpIHtcbiAgICAgICAgcnVsZVN0YXRzLnNvcnQoc29ydEFscGhhKTtcbiAgICAgICAgaWYgKHVkdFN0YXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB1ZHRTdGF0cy5zb3J0KHNvcnRBbHBoYSk7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbCArPSBkaXNwbGF5T3BzT25seSgpO1xuICAgICAgICBodG1sICs9IGRpc3BsYXlSdWxlcygpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBodG1sICs9ICc8L3RhYmxlPlxcbic7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIC8vIERpc3BsYXkgdGhlIHN0YXRzIHRhYmxlIGluIGEgY29tcGxldGUgSFRNTDUgcGFnZS5cbiAgdGhpcy50b0h0bWxQYWdlID0gZnVuY3Rpb24gdG9IdG1sUGFnZSh0eXBlLCBjYXB0aW9uLCB0aXRsZSkge1xuICAgIHJldHVybiB1dGlscy5odG1sVG9QYWdlKHRoaXMudG9IdG1sKHR5cGUsIGNhcHRpb24pLCB0aXRsZSk7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-lib/stats.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-lib/style.js":
/*!**************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/style.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = {\n\n  // Generated by apglib/style.js \n  CLASS_MONOSPACE: 'apg-mono',\n  CLASS_ACTIVE: 'apg-active',\n  CLASS_EMPTY: 'apg-empty',\n  CLASS_MATCH: 'apg-match',\n  CLASS_NOMATCH: 'apg-nomatch',\n  CLASS_LOOKAHEAD: 'apg-lh-match',\n  CLASS_LOOKBEHIND: 'apg-lb-match',\n  CLASS_REMAINDER: 'apg-remainder',\n  CLASS_CTRLCHAR: 'apg-ctrl-char',\n  CLASS_LINEEND: 'apg-line-end',\n  CLASS_ERROR: 'apg-error',\n  CLASS_PHRASE: 'apg-phrase',\n  CLASS_EMPTYPHRASE: 'apg-empty-phrase',\n  CLASS_STATE: 'apg-state',\n  CLASS_STATS: 'apg-stats',\n  CLASS_TRACE: 'apg-trace',\n  CLASS_GRAMMAR: 'apg-grammar',\n  CLASS_RULES: 'apg-rules',\n  CLASS_RULESLINK: 'apg-rules-link',\n  CLASS_ATTRIBUTES: 'apg-attrs',\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3N0eWxlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1saWIvc3R5bGUuanM/MjE2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvLyBHZW5lcmF0ZWQgYnkgYXBnbGliL3N0eWxlLmpzIFxuICBDTEFTU19NT05PU1BBQ0U6ICdhcGctbW9ubycsXG4gIENMQVNTX0FDVElWRTogJ2FwZy1hY3RpdmUnLFxuICBDTEFTU19FTVBUWTogJ2FwZy1lbXB0eScsXG4gIENMQVNTX01BVENIOiAnYXBnLW1hdGNoJyxcbiAgQ0xBU1NfTk9NQVRDSDogJ2FwZy1ub21hdGNoJyxcbiAgQ0xBU1NfTE9PS0FIRUFEOiAnYXBnLWxoLW1hdGNoJyxcbiAgQ0xBU1NfTE9PS0JFSElORDogJ2FwZy1sYi1tYXRjaCcsXG4gIENMQVNTX1JFTUFJTkRFUjogJ2FwZy1yZW1haW5kZXInLFxuICBDTEFTU19DVFJMQ0hBUjogJ2FwZy1jdHJsLWNoYXInLFxuICBDTEFTU19MSU5FRU5EOiAnYXBnLWxpbmUtZW5kJyxcbiAgQ0xBU1NfRVJST1I6ICdhcGctZXJyb3InLFxuICBDTEFTU19QSFJBU0U6ICdhcGctcGhyYXNlJyxcbiAgQ0xBU1NfRU1QVFlQSFJBU0U6ICdhcGctZW1wdHktcGhyYXNlJyxcbiAgQ0xBU1NfU1RBVEU6ICdhcGctc3RhdGUnLFxuICBDTEFTU19TVEFUUzogJ2FwZy1zdGF0cycsXG4gIENMQVNTX1RSQUNFOiAnYXBnLXRyYWNlJyxcbiAgQ0xBU1NfR1JBTU1BUjogJ2FwZy1ncmFtbWFyJyxcbiAgQ0xBU1NfUlVMRVM6ICdhcGctcnVsZXMnLFxuICBDTEFTU19SVUxFU0xJTks6ICdhcGctcnVsZXMtbGluaycsXG4gIENMQVNTX0FUVFJJQlVURVM6ICdhcGctYXR0cnMnLFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-lib/style.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-lib/trace.js":
/*!**************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/trace.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* eslint-disable func-names */\n/* eslint-disable prefer-destructuring */\n/* eslint-disable no-restricted-syntax */\n/* eslint-disable guard-for-in */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module provides a means of tracing the parser through the parse tree as it goes.\n// It is the primary debugging facility for debugging both the SABNF grammar syntax\n// and the input strings that are supposed to be valid grammar sentences.\n// It is also a very informative and educational tool for understanding\n// how a parser actually operates for a given language.\n//\n// Tracing is the process of generating and saving a record of information for each passage\n// of the parser through a parse tree node. And since it traverses each node twice, once down the tree\n// and once coming back up, there are two records for each node.\n// This, obviously, has the potential of generating lots of records.\n// And since these records are normally displayed on a web page\n// it is important to have a means to limit the actual number of records generated to\n// probably no more that a few thousand. This is almost always enough to find any errors.\n// The problem is to get the *right* few thousand records.\n// Therefore, this module has a number of ways of limiting and/or filtering, the number and type of records.\n// Considerable effort has been made to make this filtering of the trace output as simple\n// and intuitive as possible.\n//\n// However, the ability to filter the trace records, or for that matter even understand what they are\n// and the information they contain, does require a minimum amount of understanding of the APG parsing\n// method. The parse tree nodes are all represented by APG operators. They break down into two natural groups.\n// - The `RNM` operators and `UDT` operators are named phrases.\n// These are names chosen by the writer of the SABNF grammar to represent special phrases of interest.\n// - All others collect, concatenate and otherwise manipulate various intermediate phrases along the way.\n//\n// There are separate means of filtering which of these operators in each of these two groups get traced.\n// Let `trace` be an instantiated `trace.js` object.\n// Prior to parsing the string, filtering the rules and UDTs can be defined as follows:\n// ```\n// trace.filter.rules[\"rulename\"] = true;\n//     /* trace rule name \"rulename\" */\n// trace.filter.rules[\"udtname\"]  = true;\n//     /* trace UDT name \"udtname\" */\n// trace.filter.rules[\"<ALL>\"]    = true;\n//     /* trace all rules and UDTs (the default) */\n// trace.filter.rules[\"<NONE>\"]   = true;\n//     /* trace no rules or UDTS */\n// ```\n// If any rule or UDT name other than \"&lt;ALL>\" or \"&lt;NONE>\" is specified, all other names are turned off.\n// Therefore, to be selective of rule names, a filter statement is required for each rule/UDT name desired.\n//\n// Filtering of the other operators follows a similar procedure.\n// ```\n// trace.filter.operators[\"TRG\"] = true;\n//     /* trace the terminal range, TRG, operators */\n// trace.filter.operators[\"CAT\"]  = true;\n//     /* trace the concatenations, CAT, operators */\n// trace.filter.operators[\"<ALL>\"]    = true;\n//     /* trace all operators */\n// trace.filter.operators[\"<NONE>\"]   = true;\n//     /* trace no operators (the default) */\n// ```\n// If any operator name other than \"&lt;ALL>\" or \"&lt;NONE>\" is specified, all other names are turned off.\n// Therefore, to be selective of operator names, a filter statement is required for each name desired.\n//\n// There is, additionally, a means for limiting the total number of filtered or saved trace records.\n// See the function, `setMaxRecords(max)` below. This will result in only the last `max` records being saved.\n//\n// (See [`apg-examples`](https://github.com/ldthomas/apg-js-examples) for examples of using `trace.js`.)\nmodule.exports = function exportTrace() {\n  const utils = __webpack_require__(/*! ./utilities */ \"./node_modules/apg-js/src/apg-lib/utilities.js\");\n  const style = __webpack_require__(/*! ./style */ \"./node_modules/apg-js/src/apg-lib/style.js\");\n  const circular = new (__webpack_require__(/*! ./circular-buffer */ \"./node_modules/apg-js/src/apg-lib/circular-buffer.js\"))();\n  const id = __webpack_require__(/*! ./identifiers */ \"./node_modules/apg-js/src/apg-lib/identifiers.js\");\n\n  const thisFileName = 'trace.js: ';\n  const that = this;\n  const MODE_HEX = 16;\n  const MODE_DEC = 10;\n  const MODE_ASCII = 8;\n  const MODE_UNICODE = 32;\n  const MAX_PHRASE = 80;\n  const MAX_TLS = 5;\n  const records = [];\n  let maxRecords = 5000;\n  let lastRecord = -1;\n  let filteredRecords = 0;\n  let treeDepth = 0;\n  const recordStack = [];\n  let chars = null;\n  let rules = null;\n  let udts = null;\n  const operatorFilter = [];\n  const ruleFilter = [];\n  /* special trace table phrases */\n  const PHRASE_END = `<span class=\"${style.CLASS_LINEEND}\">&bull;</span>`;\n  const PHRASE_CONTINUE = `<span class=\"${style.CLASS_LINEEND}\">&hellip;</span>`;\n  const PHRASE_EMPTY = `<span class=\"${style.CLASS_EMPTY}\">&#120634;</span>`;\n  /* filter the non-RNM & non-UDT operators */\n  const initOperatorFilter = function () {\n    const setOperators = function (set) {\n      operatorFilter[id.ALT] = set;\n      operatorFilter[id.CAT] = set;\n      operatorFilter[id.REP] = set;\n      operatorFilter[id.TLS] = set;\n      operatorFilter[id.TBS] = set;\n      operatorFilter[id.TRG] = set;\n      operatorFilter[id.AND] = set;\n      operatorFilter[id.NOT] = set;\n      operatorFilter[id.BKR] = set;\n      operatorFilter[id.BKA] = set;\n      operatorFilter[id.BKN] = set;\n      operatorFilter[id.ABG] = set;\n      operatorFilter[id.AEN] = set;\n    };\n    let items = 0;\n    // eslint-disable-next-line no-unused-vars\n    for (const name in that.filter.operators) {\n      items += 1;\n    }\n    if (items === 0) {\n      /* case 1: no operators specified: default: do not trace any operators */\n      setOperators(false);\n      return;\n    }\n    for (const name in that.filter.operators) {\n      const upper = name.toUpperCase();\n      if (upper === '<ALL>') {\n        /* case 2: <all> operators specified: trace all operators ignore all other operator commands */\n        setOperators(true);\n        return;\n      }\n      if (upper === '<NONE>') {\n        /* case 3: <none> operators specified: trace NO operators ignore all other operator commands */\n        setOperators(false);\n        return;\n      }\n    }\n    setOperators(false);\n    for (const name in that.filter.operators) {\n      const upper = name.toUpperCase();\n      /* case 4: one or more individual operators specified: trace 'true' operators only */\n      if (upper === 'ALT') {\n        operatorFilter[id.ALT] = that.filter.operators[name] === true;\n      } else if (upper === 'CAT') {\n        operatorFilter[id.CAT] = that.filter.operators[name] === true;\n      } else if (upper === 'REP') {\n        operatorFilter[id.REP] = that.filter.operators[name] === true;\n      } else if (upper === 'AND') {\n        operatorFilter[id.AND] = that.filter.operators[name] === true;\n      } else if (upper === 'NOT') {\n        operatorFilter[id.NOT] = that.filter.operators[name] === true;\n      } else if (upper === 'TLS') {\n        operatorFilter[id.TLS] = that.filter.operators[name] === true;\n      } else if (upper === 'TBS') {\n        operatorFilter[id.TBS] = that.filter.operators[name] === true;\n      } else if (upper === 'TRG') {\n        operatorFilter[id.TRG] = that.filter.operators[name] === true;\n      } else if (upper === 'BKR') {\n        operatorFilter[id.BKR] = that.filter.operators[name] === true;\n      } else if (upper === 'BKA') {\n        operatorFilter[id.BKA] = that.filter.operators[name] === true;\n      } else if (upper === 'BKN') {\n        operatorFilter[id.BKN] = that.filter.operators[name] === true;\n      } else if (upper === 'ABG') {\n        operatorFilter[id.ABG] = that.filter.operators[name] === true;\n      } else if (upper === 'AEN') {\n        operatorFilter[id.AEN] = that.filter.operators[name] === true;\n      } else {\n        throw new Error(\n          `${thisFileName}initOpratorFilter: '${name}' not a valid operator name.` +\n            ` Must be <all>, <none>, alt, cat, rep, tls, tbs, trg, and, not, bkr, bka or bkn`\n        );\n      }\n    }\n  };\n  /* filter the rule and `UDT` named operators */\n  const initRuleFilter = function () {\n    const setRules = function (set) {\n      operatorFilter[id.RNM] = set;\n      operatorFilter[id.UDT] = set;\n      const count = rules.length + udts.length;\n      ruleFilter.length = 0;\n      for (let i = 0; i < count; i += 1) {\n        ruleFilter.push(set);\n      }\n    };\n    let items;\n    let i;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    ruleFilter.length = 0;\n    items = 0;\n    // eslint-disable-next-line no-unused-vars\n    for (const name in that.filter.rules) {\n      items += 1;\n    }\n    if (items === 0) {\n      /* case 1: default to all rules & udts */\n      setRules(true);\n      return;\n    }\n    for (const name in that.filter.rules) {\n      const lower = name.toLowerCase();\n      if (lower === '<all>') {\n        /* case 2: trace all rules ignore all other rule commands */\n        setRules(true);\n        return;\n      }\n      if (lower === '<none>') {\n        /* case 3: trace no rules */\n        setRules(false);\n        return;\n      }\n    }\n    /* case 4: trace only individually specified rules */\n    setRules(false);\n    operatorFilter[id.RNM] = true;\n    operatorFilter[id.UDT] = true;\n    for (const name in that.filter.rules) {\n      const lower = name.toLowerCase();\n      i = list.indexOf(lower);\n      if (i < 0) {\n        throw new Error(`${thisFileName}initRuleFilter: '${name}' not a valid rule or udt name`);\n      }\n      ruleFilter[i] = that.filter.rules[name] === true;\n    }\n  };\n  /* used by other APG components to verify that they have a valid trace object */\n  this.traceObject = 'traceObject';\n  this.filter = {\n    operators: [],\n    rules: [],\n  };\n  // Set the maximum number of records to keep (default = 5000).\n  // Each record number larger than `maxRecords`\n  // will result in deleting the previously oldest record.\n  // - `max`: maximum number of records to retain (default = 5000)\n  // - `last`: last record number to retain, (default = -1 for (unknown) actual last record)\n  this.setMaxRecords = function (max, last) {\n    lastRecord = -1;\n    if (typeof max === 'number' && max > 0) {\n      maxRecords = Math.ceil(max);\n    } else {\n      maxRecords = 0;\n      return;\n    }\n    if (typeof last === 'number') {\n      lastRecord = Math.floor(last);\n      if (lastRecord < 0) {\n        lastRecord = -1;\n      }\n    }\n  };\n  // Returns `maxRecords` to the caller.\n  this.getMaxRecords = function () {\n    return maxRecords;\n  };\n  // Returns `lastRecord` to the caller.\n  this.getLastRecord = function () {\n    return lastRecord;\n  };\n  /* Called only by the `parser.js` object. No verification of input. */\n  this.init = function (rulesIn, udtsIn, charsIn) {\n    records.length = 0;\n    recordStack.length = 0;\n    filteredRecords = 0;\n    treeDepth = 0;\n    chars = charsIn;\n    rules = rulesIn;\n    udts = udtsIn;\n    initOperatorFilter();\n    initRuleFilter();\n    circular.init(maxRecords);\n  };\n  /* returns true if this records passes through the designated filter, false if the record is to be skipped */\n  const filterOps = function (op) {\n    let ret = false;\n    if (op.type === id.RNM) {\n      if (operatorFilter[op.type] && ruleFilter[op.index]) {\n        ret = true;\n      } else {\n        ret = false;\n      }\n    } else if (op.type === id.UDT) {\n      if (operatorFilter[op.type] && ruleFilter[rules.length + op.index]) {\n        ret = true;\n      } else {\n        ret = false;\n      }\n    } else {\n      ret = operatorFilter[op.type];\n    }\n    return ret;\n  };\n  const filterRecords = function (record) {\n    if (lastRecord === -1) {\n      return true;\n    }\n    if (record <= lastRecord) {\n      return true;\n    }\n    return false;\n  };\n  /* Collect the \"down\" record. */\n  this.down = function (op, state, offset, length, anchor, lookAround) {\n    if (filterRecords(filteredRecords) && filterOps(op)) {\n      recordStack.push(filteredRecords);\n      records[circular.increment()] = {\n        dirUp: false,\n        depth: treeDepth,\n        thisLine: filteredRecords,\n        thatLine: undefined,\n        opcode: op,\n        state,\n        phraseIndex: offset,\n        phraseLength: length,\n        lookAnchor: anchor,\n        lookAround,\n      };\n      filteredRecords += 1;\n      treeDepth += 1;\n    }\n  };\n  /* Collect the \"up\" record. */\n  this.up = function (op, state, offset, length, anchor, lookAround) {\n    if (filterRecords(filteredRecords) && filterOps(op)) {\n      const thisLine = filteredRecords;\n      const thatLine = recordStack.pop();\n      const thatRecord = circular.getListIndex(thatLine);\n      if (thatRecord !== -1) {\n        records[thatRecord].thatLine = thisLine;\n      }\n      treeDepth -= 1;\n      records[circular.increment()] = {\n        dirUp: true,\n        depth: treeDepth,\n        thisLine,\n        thatLine,\n        opcode: op,\n        state,\n        phraseIndex: offset,\n        phraseLength: length,\n        lookAnchor: anchor,\n        lookAround,\n      };\n      filteredRecords += 1;\n    }\n  };\n  /* convert the trace records to a tree of nodes */\n  const toTreeObj = function () {\n    /* private helper functions */\n    function nodeOpcode(node, opcode) {\n      let name;\n      let casetype;\n      let modetype;\n      if (opcode) {\n        node.op = { id: opcode.type, name: utils.opcodeToString(opcode.type) };\n        node.opData = undefined;\n        switch (opcode.type) {\n          case id.RNM:\n            node.opData = rules[opcode.index].name;\n            break;\n          case id.UDT:\n            node.opData = udts[opcode.index].name;\n            break;\n          case id.BKR:\n            if (opcode.index < rules.length) {\n              name = rules[opcode.index].name;\n            } else {\n              name = udts[opcode.index - rules.length].name;\n            }\n            casetype = opcode.bkrCase === id.BKR_MODE_CI ? '%i' : '%s';\n            modetype = opcode.bkrMode === id.BKR_MODE_UM ? '%u' : '%p';\n            node.opData = `\\\\\\\\${casetype}${modetype}${name}`;\n            break;\n          case id.TLS:\n            node.opData = [];\n            for (let i = 0; i < opcode.string.length; i += 1) {\n              node.opData.push(opcode.string[i]);\n            }\n            break;\n          case id.TBS:\n            node.opData = [];\n            for (let i = 0; i < opcode.string.length; i += 1) {\n              node.opData.push(opcode.string[i]);\n            }\n            break;\n          case id.TRG:\n            node.opData = [opcode.min, opcode.max];\n            break;\n          case id.REP:\n            node.opData = [opcode.min, opcode.max];\n            break;\n          default:\n            throw new Error('unrecognized opcode');\n        }\n      } else {\n        node.op = { id: undefined, name: undefined };\n        node.opData = undefined;\n      }\n    }\n    function nodePhrase(state, index, length) {\n      if (state === id.MATCH) {\n        return {\n          index,\n          length,\n        };\n      }\n      if (state === id.NOMATCH) {\n        return {\n          index,\n          length: 0,\n        };\n      }\n      if (state === id.EMPTY) {\n        return {\n          index,\n          length: 0,\n        };\n      }\n      return null;\n    }\n    let nodeId = -1;\n    function nodeDown(parent, record, depth) {\n      const node = {\n        // eslint-disable-next-line no-plusplus\n        id: nodeId++,\n        branch: -1,\n        parent,\n        up: false,\n        down: false,\n        depth,\n        children: [],\n      };\n      if (record) {\n        node.down = true;\n        node.state = { id: record.state, name: utils.stateToString(record.state) };\n        node.phrase = null;\n        nodeOpcode(node, record.opcode);\n      } else {\n        node.state = { id: undefined, name: undefined };\n        node.phrase = nodePhrase();\n        nodeOpcode(node, undefined);\n      }\n      return node;\n    }\n    function nodeUp(node, record) {\n      if (record) {\n        node.up = true;\n        node.state = { id: record.state, name: utils.stateToString(record.state) };\n        node.phrase = nodePhrase(record.state, record.phraseIndex, record.phraseLength);\n        if (!node.down) {\n          nodeOpcode(node, record.opcode);\n        }\n      }\n    }\n    /* walk the final tree: label branches and count leaf nodes */\n    let leafNodes = 0;\n    let depth = -1;\n    let branchCount = 1;\n    function walk(node) {\n      depth += 1;\n      node.branch = branchCount;\n      if (depth > treeDepth) {\n        treeDepth = depth;\n      }\n      if (node.children.length === 0) {\n        leafNodes += 1;\n      } else {\n        for (let i = 0; i < node.children.length; i += 1) {\n          if (i > 0) {\n            branchCount += 1;\n          }\n          node.children[i].leftMost = false;\n          node.children[i].rightMost = false;\n          if (node.leftMost) {\n            node.children[i].leftMost = i === 0;\n          }\n          if (node.rightMost) {\n            node.children[i].rightMost = i === node.children.length - 1;\n          }\n          walk(node.children[i]);\n        }\n      }\n      depth -= 1;\n    }\n    function display(node, offset) {\n      let name;\n      const obj = {};\n      obj.id = node.id;\n      obj.branch = node.branch;\n      obj.leftMost = node.leftMost;\n      obj.rightMost = node.rightMost;\n      name = node.state.name ? node.state.name : 'ACTIVE';\n      obj.state = { id: node.state.id, name };\n      name = node.op.name ? node.op.name : '?';\n      obj.op = { id: node.op.id, name };\n      if (typeof node.opData === 'string') {\n        obj.opData = node.opData;\n      } else if (Array.isArray(node.opData)) {\n        obj.opData = [];\n        for (let i = 0; i < node.opData.length; i += 1) {\n          obj.opData[i] = node.opData[i];\n        }\n      } else {\n        obj.opData = undefined;\n      }\n      if (node.phrase) {\n        obj.phrase = { index: node.phrase.index, length: node.phrase.length };\n      } else {\n        obj.phrase = null;\n      }\n      obj.depth = node.depth;\n      obj.children = [];\n      for (let i = 0; i < node.children.length; i += 1) {\n        const c = i !== node.children.length - 1;\n        obj.children[i] = display(node.children[i], offset, c);\n      }\n      return obj;\n    }\n\n    /* construct the tree beginning here */\n    const branch = [];\n    let root;\n    let node;\n    let parent;\n    let record;\n    let firstRecord = true;\n    /* push a dummy node so the root node will have a non-null parent */\n    const dummy = nodeDown(null, null, -1);\n    branch.push(dummy);\n    node = dummy;\n    circular.forEach((lineIndex) => {\n      record = records[lineIndex];\n      if (firstRecord) {\n        firstRecord = false;\n        if (record.depth > 0) {\n          /* push some dummy nodes to fill in for missing records */\n          const num = record.dirUp ? record.depth + 1 : record.depth;\n          for (let i = 0; i < num; i += 1) {\n            parent = node;\n            node = nodeDown(node, null, i);\n            branch.push(node);\n            parent.children.push(node);\n          }\n        }\n      }\n      if (record.dirUp) {\n        /* handle the next record up */\n        node = branch.pop();\n        nodeUp(node, record);\n        node = branch[branch.length - 1];\n      } else {\n        /* handle the next record down */\n        parent = node;\n        node = nodeDown(node, record, record.depth);\n        branch.push(node);\n        parent.children.push(node);\n      }\n    });\n\n    /* if not at root, walk it up to root */\n    while (branch.length > 1) {\n      node = branch.pop();\n      nodeUp(node, null);\n    }\n    /* maybe redundant or paranoid tests: these should never happen */\n    if (dummy.children.length === 0) {\n      throw new Error('trace.toTree(): parse tree has no nodes');\n    }\n    if (branch.length === 0) {\n      throw new Error('trace.toTree(): integrity check: dummy root node disappeared?');\n    }\n\n    /* if no record for start rule: find the pseudo root node (first dummy node above a real node) */\n    root = dummy.children[0];\n    let prev = root;\n    while (root && !root.down && !root.up) {\n      prev = root;\n      root = root.children[0];\n    }\n    root = prev;\n\n    /* walk the tree of nodes: label brances and count leaves */\n    root.leftMost = true;\n    root.rightMost = true;\n    walk(root);\n    root.branch = 0;\n\n    /* generate the exported object */\n    const obj = {};\n    obj.string = [];\n    for (let i = 0; i < chars.length; i += 1) {\n      obj.string[i] = chars[i];\n    }\n    /* generate the exported rule names */\n    obj.rules = [];\n    for (let i = 0; i < rules.length; i += 1) {\n      obj.rules[i] = rules[i].name;\n    }\n    /* generate the exported UDT names */\n    obj.udts = [];\n    for (let i = 0; i < udts.length; i += 1) {\n      obj.udts[i] = udts[i].name;\n    }\n    /* generate the ids */\n    obj.id = {};\n    obj.id.ALT = { id: id.ALT, name: 'ALT' };\n    obj.id.CAT = { id: id.CAT, name: 'CAT' };\n    obj.id.REP = { id: id.REP, name: 'REP' };\n    obj.id.RNM = { id: id.RNM, name: 'RNM' };\n    obj.id.TLS = { id: id.TLS, name: 'TLS' };\n    obj.id.TBS = { id: id.TBS, name: 'TBS' };\n    obj.id.TRG = { id: id.TRG, name: 'TRG' };\n    obj.id.UDT = { id: id.UDT, name: 'UDT' };\n    obj.id.AND = { id: id.AND, name: 'AND' };\n    obj.id.NOT = { id: id.NOT, name: 'NOT' };\n    obj.id.BKR = { id: id.BKR, name: 'BKR' };\n    obj.id.BKA = { id: id.BKA, name: 'BKA' };\n    obj.id.BKN = { id: id.BKN, name: 'BKN' };\n    obj.id.ABG = { id: id.ABG, name: 'ABG' };\n    obj.id.AEN = { id: id.AEN, name: 'AEN' };\n    obj.id.ACTIVE = { id: id.ACTIVE, name: 'ACTIVE' };\n    obj.id.MATCH = { id: id.MATCH, name: 'MATCH' };\n    obj.id.EMPTY = { id: id.EMPTY, name: 'EMPTY' };\n    obj.id.NOMATCH = { id: id.NOMATCH, name: 'NOMATCH' };\n    /* generate the max tree depth */\n    obj.treeDepth = treeDepth;\n    /* generate the number of leaf nodes (branches) */\n    obj.leafNodes = leafNodes;\n    /* generate the types of the left- and right-most branches */\n    let branchesIncomplete;\n    if (root.down) {\n      if (root.up) {\n        branchesIncomplete = 'none';\n      } else {\n        branchesIncomplete = 'right';\n      }\n    } else if (root.up) {\n      branchesIncomplete = 'left';\n    } else {\n      branchesIncomplete = 'both';\n    }\n    obj.branchesIncomplete = branchesIncomplete;\n    obj.tree = display(root, root.depth, false);\n    return obj;\n  };\n  // Returns the trace records as JSON parse tree object.\n  // - stringify: if `true`, the object is 'stringified' before returning, otherwise, the object itself is returned.\n  this.toTree = function (stringify) {\n    const obj = toTreeObj();\n    if (stringify) {\n      return JSON.stringify(obj);\n    }\n    return obj;\n  };\n  // Translate the trace records to HTML format and create a complete HTML page for browser display.\n  this.toHtmlPage = function (mode, caption, title) {\n    return utils.htmlToPage(this.toHtml(mode, caption), title);\n  };\n\n  /* From here on down, these are just helper functions for `toHtml()`. */\n  const htmlHeader = function (mode, caption) {\n    /* open the page */\n    /* write the HTML5 header with table style */\n    /* open the <table> tag */\n    let modeName;\n    switch (mode) {\n      case MODE_HEX:\n        modeName = 'hexadecimal';\n        break;\n      case MODE_DEC:\n        modeName = 'decimal';\n        break;\n      case MODE_ASCII:\n        modeName = 'ASCII';\n        break;\n      case MODE_UNICODE:\n        modeName = 'UNICODE';\n        break;\n      default:\n        throw new Error(`${thisFileName}htmlHeader: unrecognized mode: ${mode}`);\n    }\n    let header = '';\n    header += `<p>display mode: ${modeName}</p>\\n`;\n    header += `<table class=\"${style.CLASS_TRACE}\">\\n`;\n    if (typeof caption === 'string') {\n      header += `<caption>${caption}</caption>`;\n    }\n    return header;\n  };\n  const htmlFooter = function () {\n    let footer = '';\n    /* close the </table> tag */\n    footer += '</table>\\n';\n    /* display a table legend */\n    footer += `<p class=\"${style.CLASS_MONOSPACE}\">legend:<br>\\n`;\n    footer += '(a)&nbsp;-&nbsp;line number<br>\\n';\n    footer += '(b)&nbsp;-&nbsp;matching line number<br>\\n';\n    footer += '(c)&nbsp;-&nbsp;phrase offset<br>\\n';\n    footer += '(d)&nbsp;-&nbsp;phrase length<br>\\n';\n    footer += '(e)&nbsp;-&nbsp;tree depth<br>\\n';\n    footer += '(f)&nbsp;-&nbsp;operator state<br>\\n';\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_ACTIVE}\">&darr;</span>&nbsp;&nbsp;phrase opened<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_MATCH}\">&uarr;M</span> phrase matched<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_EMPTY}\">&uarr;E</span> empty phrase matched<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_NOMATCH}\">&uarr;N</span> phrase not matched<br>\\n`;\n    footer +=\n      'operator&nbsp;-&nbsp;ALT, CAT, REP, RNM, TRG, TLS, TBS<sup>&dagger;</sup>, UDT, AND, NOT, BKA, BKN, BKR, ABG, AEN<sup>&Dagger;</sup><br>\\n';\n    footer += `phrase&nbsp;&nbsp;&nbsp;-&nbsp;up to ${MAX_PHRASE} characters of the phrase being matched<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_MATCH}\">matched characters</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_LOOKAHEAD}\">matched characters in look ahead mode</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_LOOKBEHIND}\">matched characters in look behind mode</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_REMAINDER}\">remainder characters(not yet examined by parser)</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_CTRLCHAR}\">control characters, TAB, LF, CR, etc. (ASCII mode only)</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_EMPTY} empty string<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_END} end of input string<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_CONTINUE} input string display truncated<br>\\n`;\n    footer += '</p>\\n';\n    footer += `<p class=\"${style.CLASS_MONOSPACE}\">\\n`;\n    footer += '<sup>&dagger;</sup>original ABNF operators:<br>\\n';\n    footer += 'ALT - alternation<br>\\n';\n    footer += 'CAT - concatenation<br>\\n';\n    footer += 'REP - repetition<br>\\n';\n    footer += 'RNM - rule name<br>\\n';\n    footer += 'TRG - terminal range<br>\\n';\n    footer += 'TLS - terminal literal string (case insensitive)<br>\\n';\n    footer += 'TBS - terminal binary string (case sensitive)<br>\\n';\n    footer += '<br>\\n';\n    footer += '<sup>&Dagger;</sup>super set SABNF operators:<br>\\n';\n    footer += 'UDT - user-defined terminal<br>\\n';\n    footer += 'AND - positive look ahead<br>\\n';\n    footer += 'NOT - negative look ahead<br>\\n';\n    footer += 'BKA - positive look behind<br>\\n';\n    footer += 'BKN - negative look behind<br>\\n';\n    footer += 'BKR - back reference<br>\\n';\n    footer += 'ABG - anchor - begin of input string<br>\\n';\n    footer += 'AEN - anchor - end of input string<br>\\n';\n    footer += '</p>\\n';\n    return footer;\n  };\n  this.indent = function (depth) {\n    let html = '';\n    for (let i = 0; i < depth; i += 1) {\n      html += '.';\n    }\n    return html;\n  };\n  /* format the TRG operator */\n  const displayTrg = function (mode, op) {\n    let html = '';\n    if (op.type === id.TRG) {\n      if (mode === MODE_HEX || mode === MODE_UNICODE) {\n        let hex = op.min.toString(16).toUpperCase();\n        if (hex.length % 2 !== 0) {\n          hex = `0${hex}`;\n        }\n        html += mode === MODE_HEX ? '%x' : 'U+';\n        html += hex;\n        hex = op.max.toString(16).toUpperCase();\n        if (hex.length % 2 !== 0) {\n          hex = `0${hex}`;\n        }\n        html += `&ndash;${hex}`;\n      } else {\n        html = `%d${op.min.toString(10)}&ndash;${op.max.toString(10)}`;\n      }\n    }\n    return html;\n  };\n  /* format the REP operator */\n  const displayRep = function (mode, op) {\n    let html = '';\n    if (op.type === id.REP) {\n      if (mode === MODE_HEX) {\n        let hex = op.min.toString(16).toUpperCase();\n        if (hex.length % 2 !== 0) {\n          hex = `0${hex}`;\n        }\n        html = `x${hex}`;\n        if (op.max < Infinity) {\n          hex = op.max.toString(16).toUpperCase();\n          if (hex.length % 2 !== 0) {\n            hex = `0${hex}`;\n          }\n        } else {\n          hex = 'inf';\n        }\n        html += `&ndash;${hex}`;\n      } else if (op.max < Infinity) {\n        html = `${op.min.toString(10)}&ndash;${op.max.toString(10)}`;\n      } else {\n        html = `${op.min.toString(10)}&ndash;inf`;\n      }\n    }\n    return html;\n  };\n  /* format the TBS operator */\n  const displayTbs = function (mode, op) {\n    let html = '';\n    if (op.type === id.TBS) {\n      const len = Math.min(op.string.length, MAX_TLS * 2);\n      if (mode === MODE_HEX || mode === MODE_UNICODE) {\n        html += mode === MODE_HEX ? '%x' : 'U+';\n        for (let i = 0; i < len; i += 1) {\n          let hex;\n          if (i > 0) {\n            html += '.';\n          }\n          hex = op.string[i].toString(16).toUpperCase();\n          if (hex.length % 2 !== 0) {\n            hex = `0${hex}`;\n          }\n          html += hex;\n        }\n      } else {\n        html = '%d';\n        for (let i = 0; i < len; i += 1) {\n          if (i > 0) {\n            html += '.';\n          }\n          html += op.string[i].toString(10);\n        }\n      }\n      if (len < op.string.length) {\n        html += PHRASE_CONTINUE;\n      }\n    }\n    return html;\n  };\n  /* format the TLS operator */\n  const displayTls = function (mode, op) {\n    let html = '';\n    if (op.type === id.TLS) {\n      const len = Math.min(op.string.length, MAX_TLS);\n      if (mode === MODE_HEX || mode === MODE_DEC) {\n        let charu;\n        let charl;\n        let base;\n        if (mode === MODE_HEX) {\n          html = '%x';\n          base = 16;\n        } else {\n          html = '%d';\n          base = 10;\n        }\n        for (let i = 0; i < len; i += 1) {\n          if (i > 0) {\n            html += '.';\n          }\n          charl = op.string[i];\n          if (charl >= 97 && charl <= 122) {\n            charu = charl - 32;\n            html += `${charu.toString(base)}/${charl.toString(base)}`.toUpperCase();\n          } else if (charl >= 65 && charl <= 90) {\n            charu = charl;\n            charl += 32;\n            html += `${charu.toString(base)}/${charl.toString(base)}`.toUpperCase();\n          } else {\n            html += charl.toString(base).toUpperCase();\n          }\n        }\n        if (len < op.string.length) {\n          html += PHRASE_CONTINUE;\n        }\n      } else {\n        html = '\"';\n        for (let i = 0; i < len; i += 1) {\n          html += utils.asciiChars[op.string[i]];\n        }\n        if (len < op.string.length) {\n          html += PHRASE_CONTINUE;\n        }\n        html += '\"';\n      }\n    }\n    return html;\n  };\n  const subPhrase = function (mode, charsArg, index, length, prev) {\n    if (length === 0) {\n      return '';\n    }\n    let phrase = '';\n    const comma = prev ? ',' : '';\n    switch (mode) {\n      case MODE_HEX:\n        phrase = comma + utils.charsToHex(charsArg, index, length);\n        break;\n      case MODE_DEC:\n        if (prev) {\n          return `,${utils.charsToDec(charsArg, index, length)}`;\n        }\n        phrase = comma + utils.charsToDec(charsArg, index, length);\n        break;\n      case MODE_UNICODE:\n        phrase = utils.charsToUnicode(charsArg, index, length);\n        break;\n      case MODE_ASCII:\n      default:\n        phrase = utils.charsToAsciiHtml(charsArg, index, length);\n        break;\n    }\n    return phrase;\n  };\n  /* display phrases matched in look-behind mode */\n  const displayBehind = function (mode, charsArg, state, index, length, anchor) {\n    let html = '';\n    let beg1;\n    let len1;\n    let beg2;\n    let len2;\n    let lastchar = PHRASE_END;\n    const spanBehind = `<span class=\"${style.CLASS_LOOKBEHIND}\">`;\n    const spanRemainder = `<span class=\"${style.CLASS_REMAINDER}\">`;\n    const spanend = '</span>';\n    let prev = false;\n    switch (state) {\n      case id.EMPTY:\n        html += PHRASE_EMPTY;\n      /* // eslint-disable-next-line no-fallthrough */\n      case id.NOMATCH:\n      case id.MATCH:\n      case id.ACTIVE:\n        beg1 = index - length;\n        len1 = anchor - beg1;\n        beg2 = anchor;\n        len2 = charsArg.length - beg2;\n        break;\n      default:\n        throw new Error('unrecognized state');\n    }\n    lastchar = PHRASE_END;\n    if (len1 > MAX_PHRASE) {\n      len1 = MAX_PHRASE;\n      lastchar = PHRASE_CONTINUE;\n      len2 = 0;\n    } else if (len1 + len2 > MAX_PHRASE) {\n      lastchar = PHRASE_CONTINUE;\n      len2 = MAX_PHRASE - len1;\n    }\n    if (len1 > 0) {\n      html += spanBehind;\n      html += subPhrase(mode, charsArg, beg1, len1, prev);\n      html += spanend;\n      prev = true;\n    }\n    if (len2 > 0) {\n      html += spanRemainder;\n      html += subPhrase(mode, charsArg, beg2, len2, prev);\n      html += spanend;\n    }\n    return html + lastchar;\n  };\n  const displayForward = function (mode, charsArg, state, index, length, spanAhead) {\n    let html = '';\n    let beg1;\n    let len1;\n    let beg2;\n    let len2;\n    let lastchar = PHRASE_END;\n    const spanRemainder = `<span class=\"${style.CLASS_REMAINDER}\">`;\n    const spanend = '</span>';\n    let prev = false;\n    switch (state) {\n      case id.EMPTY:\n        html += PHRASE_EMPTY;\n      /* // eslint-disable-next-line no-fallthrough */\n      case id.NOMATCH:\n      case id.ACTIVE:\n        beg1 = index;\n        len1 = 0;\n        beg2 = index;\n        len2 = charsArg.length - beg2;\n        break;\n      case id.MATCH:\n        beg1 = index;\n        len1 = length;\n        beg2 = index + len1;\n        len2 = charsArg.length - beg2;\n        break;\n      default:\n        throw new Error('unrecognized state');\n    }\n    lastchar = PHRASE_END;\n    if (len1 > MAX_PHRASE) {\n      len1 = MAX_PHRASE;\n      lastchar = PHRASE_CONTINUE;\n      len2 = 0;\n    } else if (len1 + len2 > MAX_PHRASE) {\n      lastchar = PHRASE_CONTINUE;\n      len2 = MAX_PHRASE - len1;\n    }\n    if (len1 > 0) {\n      html += spanAhead;\n      html += subPhrase(mode, charsArg, beg1, len1, prev);\n      html += spanend;\n      prev = true;\n    }\n    if (len2 > 0) {\n      html += spanRemainder;\n      html += subPhrase(mode, charsArg, beg2, len2, prev);\n      html += spanend;\n    }\n    return html + lastchar;\n  };\n  /* display phrases matched in look-ahead mode */\n  const displayAhead = function (mode, charsArg, state, index, length) {\n    const spanAhead = `<span class=\"${style.CLASS_LOOKAHEAD}\">`;\n    return displayForward(mode, charsArg, state, index, length, spanAhead);\n  };\n  /* display phrases matched in normal parsing mode */\n  const displayNone = function (mode, charsArg, state, index, length) {\n    const spanAhead = `<span class=\"${style.CLASS_MATCH}\">`;\n    return displayForward(mode, charsArg, state, index, length, spanAhead);\n  };\n  /* Returns the filtered records, formatted as an HTML table. */\n  const htmlTable = function (mode) {\n    if (rules === null) {\n      return '';\n    }\n    let html = '';\n    let thisLine;\n    let thatLine;\n    let lookAhead;\n    let lookBehind;\n    let lookAround;\n    let anchor;\n    html += '<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>';\n    html += '<th>operator</th><th>phrase</th></tr>\\n';\n    circular.forEach((lineIndex) => {\n      const line = records[lineIndex];\n      thisLine = line.thisLine;\n      thatLine = line.thatLine !== undefined ? line.thatLine : '--';\n      lookAhead = false;\n      lookBehind = false;\n      lookAround = false;\n      if (line.lookAround === id.LOOKAROUND_AHEAD) {\n        lookAhead = true;\n        lookAround = true;\n        anchor = line.lookAnchor;\n      }\n      if (line.opcode.type === id.AND || line.opcode.type === id.NOT) {\n        lookAhead = true;\n        lookAround = true;\n        anchor = line.phraseIndex;\n      }\n      if (line.lookAround === id.LOOKAROUND_BEHIND) {\n        lookBehind = true;\n        lookAround = true;\n        anchor = line.lookAnchor;\n      }\n      if (line.opcode.type === id.BKA || line.opcode.type === id.BKN) {\n        lookBehind = true;\n        lookAround = true;\n        anchor = line.phraseIndex;\n      }\n      html += '<tr>';\n      html += `<td>${thisLine}</td><td>${thatLine}</td>`;\n      html += `<td>${line.phraseIndex}</td>`;\n      html += `<td>${line.phraseLength}</td>`;\n      html += `<td>${line.depth}</td>`;\n      html += '<td>';\n      switch (line.state) {\n        case id.ACTIVE:\n          html += `<span class=\"${style.CLASS_ACTIVE}\">&darr;&nbsp;</span>`;\n          break;\n        case id.MATCH:\n          html += `<span class=\"${style.CLASS_MATCH}\">&uarr;M</span>`;\n          break;\n        case id.NOMATCH:\n          html += `<span class=\"${style.CLASS_NOMATCH}\">&uarr;N</span>`;\n          break;\n        case id.EMPTY:\n          html += `<span class=\"${style.CLASS_EMPTY}\">&uarr;E</span>`;\n          break;\n        default:\n          html += `<span class=\"${style.CLASS_ACTIVE}\">--</span>`;\n          break;\n      }\n      html += '</td>';\n      html += '<td>';\n      html += that.indent(line.depth);\n      if (lookAhead) {\n        html += `<span class=\"${style.CLASS_LOOKAHEAD}\">`;\n      } else if (lookBehind) {\n        html += `<span class=\"${style.CLASS_LOOKBEHIND}\">`;\n      }\n      html += utils.opcodeToString(line.opcode.type);\n      if (line.opcode.type === id.RNM) {\n        html += `(${rules[line.opcode.index].name}) `;\n      }\n      if (line.opcode.type === id.BKR) {\n        const casetype = line.opcode.bkrCase === id.BKR_MODE_CI ? '%i' : '%s';\n        const modetype = line.opcode.bkrMode === id.BKR_MODE_UM ? '%u' : '%p';\n        html += `(\\\\${casetype}${modetype}${rules[line.opcode.index].name}) `;\n      }\n      if (line.opcode.type === id.UDT) {\n        html += `(${udts[line.opcode.index].name}) `;\n      }\n      if (line.opcode.type === id.TRG) {\n        html += `(${displayTrg(mode, line.opcode)}) `;\n      }\n      if (line.opcode.type === id.TBS) {\n        html += `(${displayTbs(mode, line.opcode)}) `;\n      }\n      if (line.opcode.type === id.TLS) {\n        html += `(${displayTls(mode, line.opcode)}) `;\n      }\n      if (line.opcode.type === id.REP) {\n        html += `(${displayRep(mode, line.opcode)}) `;\n      }\n      if (lookAround) {\n        html += '</span>';\n      }\n      html += '</td>';\n      html += '<td>';\n      if (lookBehind) {\n        html += displayBehind(mode, chars, line.state, line.phraseIndex, line.phraseLength, anchor);\n      } else if (lookAhead) {\n        html += displayAhead(mode, chars, line.state, line.phraseIndex, line.phraseLength);\n      } else {\n        html += displayNone(mode, chars, line.state, line.phraseIndex, line.phraseLength);\n      }\n      html += '</td></tr>\\n';\n    });\n    html += '<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>';\n    html += '<th>operator</th><th>phrase</th></tr>\\n';\n    html += '</table>\\n';\n    return html;\n  };\n  // Translate the trace records to HTML format.\n  // - *modearg* - can be `\"ascii\"`, `\"decimal\"`, `\"hexadecimal\"` or `\"unicode\"`.\n  // Determines the format of the string character code display.\n  // - *caption* - optional caption for the HTML table.\n  this.toHtml = function (modearg, caption) {\n    /* writes the trace records as a table in a complete html page */\n    let mode = MODE_ASCII;\n    if (typeof modearg === 'string' && modearg.length >= 3) {\n      const modein = modearg.toLowerCase().slice(0, 3);\n      if (modein === 'hex') {\n        mode = MODE_HEX;\n      } else if (modein === 'dec') {\n        mode = MODE_DEC;\n      } else if (modein === 'uni') {\n        mode = MODE_UNICODE;\n      }\n    }\n    let html = '';\n    html += htmlHeader(mode, caption);\n    html += htmlTable(mode);\n    html += htmlFooter();\n    return html;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3RyYWNlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLG1FQUFhO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLDJEQUFTO0FBQ2pDLHdCQUF3QixtQkFBTyxDQUFDLCtFQUFtQjtBQUNuRCxhQUFhLG1CQUFPLENBQUMsdUVBQWU7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsb0JBQW9CLFFBQVE7QUFDakUsMENBQTBDLG9CQUFvQixVQUFVO0FBQ3hFLHVDQUF1QyxrQkFBa0IsV0FBVztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLGFBQWEsYUFBYSxzQkFBc0IsS0FBSztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWEsbUJBQW1CLEtBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUyxFQUFFLFNBQVMsRUFBRSxLQUFLO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWEsaUNBQWlDLEtBQUs7QUFDOUU7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRCx3QkFBd0IsT0FBTztBQUMvQix3QkFBd0IsT0FBTztBQUMvQix3QkFBd0IsT0FBTztBQUMvQix3QkFBd0IsT0FBTztBQUMvQix3QkFBd0IsT0FBTztBQUMvQix3QkFBd0IsT0FBTztBQUMvQixxQkFBcUIsTUFBTSxNQUFNLE1BQU0sT0FBTyxlQUFlLG1CQUFtQixRQUFRLGFBQWEsTUFBTTtBQUMzRyxxQkFBcUIsTUFBTSxNQUFNLE1BQU0sT0FBTyxlQUFlLGtCQUFrQixRQUFRO0FBQ3ZGLHFCQUFxQixNQUFNLE1BQU0sTUFBTSxPQUFPLGVBQWUsa0JBQWtCLFFBQVE7QUFDdkYscUJBQXFCLE1BQU0sTUFBTSxNQUFNLE9BQU8sZUFBZSxvQkFBb0IsUUFBUTtBQUN6RjtBQUNBLHFCQUFxQixPQUFPLDhDQUE4QywyREFBMkQ7QUFDckksMkJBQTJCLE1BQU0sTUFBTSxPQUFPLFFBQVEsWUFBWTtBQUNsRSxxQkFBcUIsTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE9BQU8sZUFBZSxrQkFBa0I7QUFDN0cscUJBQXFCLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxPQUFPLGVBQWUsc0JBQXNCO0FBQ2pILHFCQUFxQixNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sT0FBTyxlQUFlLHVCQUF1QjtBQUNsSCxxQkFBcUIsTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE9BQU8sZUFBZSxzQkFBc0I7QUFDakgscUJBQXFCLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxPQUFPLGVBQWUscUJBQXFCO0FBQ2hILHFCQUFxQixNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sT0FBTyxFQUFFLGNBQWM7QUFDNUYscUJBQXFCLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxPQUFPLEVBQUUsWUFBWTtBQUMxRixxQkFBcUIsTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE9BQU8sRUFBRSxpQkFBaUI7QUFDL0Y7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pELDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixJQUFJO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsSUFBSTtBQUN4QjtBQUNBLHdCQUF3QixFQUFFLElBQUk7QUFDOUIsUUFBUTtBQUNSLG9CQUFvQixvQkFBb0IsT0FBTyxFQUFFLG9CQUFvQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLElBQUk7QUFDeEI7QUFDQSxtQkFBbUIsSUFBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSTtBQUMxQjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esd0JBQXdCLEVBQUUsSUFBSTtBQUM5QixRQUFRO0FBQ1Isa0JBQWtCLG9CQUFvQixPQUFPLEVBQUUsb0JBQW9CO0FBQ25FLFFBQVE7QUFDUixrQkFBa0Isb0JBQW9CLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixJQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCLEdBQUcscUJBQXFCO0FBQ3BFLFlBQVk7QUFDWjtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQixHQUFHLHFCQUFxQjtBQUNwRSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQTBDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUI7QUFDOUQsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNCQUFzQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrQkFBa0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTLFdBQVcsU0FBUztBQUNsRCxxQkFBcUIsaUJBQWlCO0FBQ3RDLHFCQUFxQixrQkFBa0I7QUFDdkMscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1CQUFtQixRQUFRLE1BQU07QUFDbkU7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0IsUUFBUTtBQUM1RDtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQixRQUFRO0FBQzlEO0FBQ0E7QUFDQSxrQ0FBa0Msa0JBQWtCLFFBQVE7QUFDNUQ7QUFDQTtBQUNBLGtDQUFrQyxtQkFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNCQUFzQjtBQUN0RCxRQUFRO0FBQ1IsZ0NBQWdDLHVCQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVMsRUFBRSxTQUFTLEVBQUUsOEJBQThCO0FBQzFFO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1saWIvdHJhY2UuanM/NzYzOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBmdW5jLW5hbWVzICovXG4vKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItZGVzdHJ1Y3R1cmluZyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1zeW50YXggKi9cbi8qIGVzbGludC1kaXNhYmxlIGd1YXJkLWZvci1pbiAqL1xuLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgcHJvdmlkZXMgYSBtZWFucyBvZiB0cmFjaW5nIHRoZSBwYXJzZXIgdGhyb3VnaCB0aGUgcGFyc2UgdHJlZSBhcyBpdCBnb2VzLlxuLy8gSXQgaXMgdGhlIHByaW1hcnkgZGVidWdnaW5nIGZhY2lsaXR5IGZvciBkZWJ1Z2dpbmcgYm90aCB0aGUgU0FCTkYgZ3JhbW1hciBzeW50YXhcbi8vIGFuZCB0aGUgaW5wdXQgc3RyaW5ncyB0aGF0IGFyZSBzdXBwb3NlZCB0byBiZSB2YWxpZCBncmFtbWFyIHNlbnRlbmNlcy5cbi8vIEl0IGlzIGFsc28gYSB2ZXJ5IGluZm9ybWF0aXZlIGFuZCBlZHVjYXRpb25hbCB0b29sIGZvciB1bmRlcnN0YW5kaW5nXG4vLyBob3cgYSBwYXJzZXIgYWN0dWFsbHkgb3BlcmF0ZXMgZm9yIGEgZ2l2ZW4gbGFuZ3VhZ2UuXG4vL1xuLy8gVHJhY2luZyBpcyB0aGUgcHJvY2VzcyBvZiBnZW5lcmF0aW5nIGFuZCBzYXZpbmcgYSByZWNvcmQgb2YgaW5mb3JtYXRpb24gZm9yIGVhY2ggcGFzc2FnZVxuLy8gb2YgdGhlIHBhcnNlciB0aHJvdWdoIGEgcGFyc2UgdHJlZSBub2RlLiBBbmQgc2luY2UgaXQgdHJhdmVyc2VzIGVhY2ggbm9kZSB0d2ljZSwgb25jZSBkb3duIHRoZSB0cmVlXG4vLyBhbmQgb25jZSBjb21pbmcgYmFjayB1cCwgdGhlcmUgYXJlIHR3byByZWNvcmRzIGZvciBlYWNoIG5vZGUuXG4vLyBUaGlzLCBvYnZpb3VzbHksIGhhcyB0aGUgcG90ZW50aWFsIG9mIGdlbmVyYXRpbmcgbG90cyBvZiByZWNvcmRzLlxuLy8gQW5kIHNpbmNlIHRoZXNlIHJlY29yZHMgYXJlIG5vcm1hbGx5IGRpc3BsYXllZCBvbiBhIHdlYiBwYWdlXG4vLyBpdCBpcyBpbXBvcnRhbnQgdG8gaGF2ZSBhIG1lYW5zIHRvIGxpbWl0IHRoZSBhY3R1YWwgbnVtYmVyIG9mIHJlY29yZHMgZ2VuZXJhdGVkIHRvXG4vLyBwcm9iYWJseSBubyBtb3JlIHRoYXQgYSBmZXcgdGhvdXNhbmQuIFRoaXMgaXMgYWxtb3N0IGFsd2F5cyBlbm91Z2ggdG8gZmluZCBhbnkgZXJyb3JzLlxuLy8gVGhlIHByb2JsZW0gaXMgdG8gZ2V0IHRoZSAqcmlnaHQqIGZldyB0aG91c2FuZCByZWNvcmRzLlxuLy8gVGhlcmVmb3JlLCB0aGlzIG1vZHVsZSBoYXMgYSBudW1iZXIgb2Ygd2F5cyBvZiBsaW1pdGluZyBhbmQvb3IgZmlsdGVyaW5nLCB0aGUgbnVtYmVyIGFuZCB0eXBlIG9mIHJlY29yZHMuXG4vLyBDb25zaWRlcmFibGUgZWZmb3J0IGhhcyBiZWVuIG1hZGUgdG8gbWFrZSB0aGlzIGZpbHRlcmluZyBvZiB0aGUgdHJhY2Ugb3V0cHV0IGFzIHNpbXBsZVxuLy8gYW5kIGludHVpdGl2ZSBhcyBwb3NzaWJsZS5cbi8vXG4vLyBIb3dldmVyLCB0aGUgYWJpbGl0eSB0byBmaWx0ZXIgdGhlIHRyYWNlIHJlY29yZHMsIG9yIGZvciB0aGF0IG1hdHRlciBldmVuIHVuZGVyc3RhbmQgd2hhdCB0aGV5IGFyZVxuLy8gYW5kIHRoZSBpbmZvcm1hdGlvbiB0aGV5IGNvbnRhaW4sIGRvZXMgcmVxdWlyZSBhIG1pbmltdW0gYW1vdW50IG9mIHVuZGVyc3RhbmRpbmcgb2YgdGhlIEFQRyBwYXJzaW5nXG4vLyBtZXRob2QuIFRoZSBwYXJzZSB0cmVlIG5vZGVzIGFyZSBhbGwgcmVwcmVzZW50ZWQgYnkgQVBHIG9wZXJhdG9ycy4gVGhleSBicmVhayBkb3duIGludG8gdHdvIG5hdHVyYWwgZ3JvdXBzLlxuLy8gLSBUaGUgYFJOTWAgb3BlcmF0b3JzIGFuZCBgVURUYCBvcGVyYXRvcnMgYXJlIG5hbWVkIHBocmFzZXMuXG4vLyBUaGVzZSBhcmUgbmFtZXMgY2hvc2VuIGJ5IHRoZSB3cml0ZXIgb2YgdGhlIFNBQk5GIGdyYW1tYXIgdG8gcmVwcmVzZW50IHNwZWNpYWwgcGhyYXNlcyBvZiBpbnRlcmVzdC5cbi8vIC0gQWxsIG90aGVycyBjb2xsZWN0LCBjb25jYXRlbmF0ZSBhbmQgb3RoZXJ3aXNlIG1hbmlwdWxhdGUgdmFyaW91cyBpbnRlcm1lZGlhdGUgcGhyYXNlcyBhbG9uZyB0aGUgd2F5LlxuLy9cbi8vIFRoZXJlIGFyZSBzZXBhcmF0ZSBtZWFucyBvZiBmaWx0ZXJpbmcgd2hpY2ggb2YgdGhlc2Ugb3BlcmF0b3JzIGluIGVhY2ggb2YgdGhlc2UgdHdvIGdyb3VwcyBnZXQgdHJhY2VkLlxuLy8gTGV0IGB0cmFjZWAgYmUgYW4gaW5zdGFudGlhdGVkIGB0cmFjZS5qc2Agb2JqZWN0LlxuLy8gUHJpb3IgdG8gcGFyc2luZyB0aGUgc3RyaW5nLCBmaWx0ZXJpbmcgdGhlIHJ1bGVzIGFuZCBVRFRzIGNhbiBiZSBkZWZpbmVkIGFzIGZvbGxvd3M6XG4vLyBgYGBcbi8vIHRyYWNlLmZpbHRlci5ydWxlc1tcInJ1bGVuYW1lXCJdID0gdHJ1ZTtcbi8vICAgICAvKiB0cmFjZSBydWxlIG5hbWUgXCJydWxlbmFtZVwiICovXG4vLyB0cmFjZS5maWx0ZXIucnVsZXNbXCJ1ZHRuYW1lXCJdICA9IHRydWU7XG4vLyAgICAgLyogdHJhY2UgVURUIG5hbWUgXCJ1ZHRuYW1lXCIgKi9cbi8vIHRyYWNlLmZpbHRlci5ydWxlc1tcIjxBTEw+XCJdICAgID0gdHJ1ZTtcbi8vICAgICAvKiB0cmFjZSBhbGwgcnVsZXMgYW5kIFVEVHMgKHRoZSBkZWZhdWx0KSAqL1xuLy8gdHJhY2UuZmlsdGVyLnJ1bGVzW1wiPE5PTkU+XCJdICAgPSB0cnVlO1xuLy8gICAgIC8qIHRyYWNlIG5vIHJ1bGVzIG9yIFVEVFMgKi9cbi8vIGBgYFxuLy8gSWYgYW55IHJ1bGUgb3IgVURUIG5hbWUgb3RoZXIgdGhhbiBcIiZsdDtBTEw+XCIgb3IgXCImbHQ7Tk9ORT5cIiBpcyBzcGVjaWZpZWQsIGFsbCBvdGhlciBuYW1lcyBhcmUgdHVybmVkIG9mZi5cbi8vIFRoZXJlZm9yZSwgdG8gYmUgc2VsZWN0aXZlIG9mIHJ1bGUgbmFtZXMsIGEgZmlsdGVyIHN0YXRlbWVudCBpcyByZXF1aXJlZCBmb3IgZWFjaCBydWxlL1VEVCBuYW1lIGRlc2lyZWQuXG4vL1xuLy8gRmlsdGVyaW5nIG9mIHRoZSBvdGhlciBvcGVyYXRvcnMgZm9sbG93cyBhIHNpbWlsYXIgcHJvY2VkdXJlLlxuLy8gYGBgXG4vLyB0cmFjZS5maWx0ZXIub3BlcmF0b3JzW1wiVFJHXCJdID0gdHJ1ZTtcbi8vICAgICAvKiB0cmFjZSB0aGUgdGVybWluYWwgcmFuZ2UsIFRSRywgb3BlcmF0b3JzICovXG4vLyB0cmFjZS5maWx0ZXIub3BlcmF0b3JzW1wiQ0FUXCJdICA9IHRydWU7XG4vLyAgICAgLyogdHJhY2UgdGhlIGNvbmNhdGVuYXRpb25zLCBDQVQsIG9wZXJhdG9ycyAqL1xuLy8gdHJhY2UuZmlsdGVyLm9wZXJhdG9yc1tcIjxBTEw+XCJdICAgID0gdHJ1ZTtcbi8vICAgICAvKiB0cmFjZSBhbGwgb3BlcmF0b3JzICovXG4vLyB0cmFjZS5maWx0ZXIub3BlcmF0b3JzW1wiPE5PTkU+XCJdICAgPSB0cnVlO1xuLy8gICAgIC8qIHRyYWNlIG5vIG9wZXJhdG9ycyAodGhlIGRlZmF1bHQpICovXG4vLyBgYGBcbi8vIElmIGFueSBvcGVyYXRvciBuYW1lIG90aGVyIHRoYW4gXCImbHQ7QUxMPlwiIG9yIFwiJmx0O05PTkU+XCIgaXMgc3BlY2lmaWVkLCBhbGwgb3RoZXIgbmFtZXMgYXJlIHR1cm5lZCBvZmYuXG4vLyBUaGVyZWZvcmUsIHRvIGJlIHNlbGVjdGl2ZSBvZiBvcGVyYXRvciBuYW1lcywgYSBmaWx0ZXIgc3RhdGVtZW50IGlzIHJlcXVpcmVkIGZvciBlYWNoIG5hbWUgZGVzaXJlZC5cbi8vXG4vLyBUaGVyZSBpcywgYWRkaXRpb25hbGx5LCBhIG1lYW5zIGZvciBsaW1pdGluZyB0aGUgdG90YWwgbnVtYmVyIG9mIGZpbHRlcmVkIG9yIHNhdmVkIHRyYWNlIHJlY29yZHMuXG4vLyBTZWUgdGhlIGZ1bmN0aW9uLCBgc2V0TWF4UmVjb3JkcyhtYXgpYCBiZWxvdy4gVGhpcyB3aWxsIHJlc3VsdCBpbiBvbmx5IHRoZSBsYXN0IGBtYXhgIHJlY29yZHMgYmVpbmcgc2F2ZWQuXG4vL1xuLy8gKFNlZSBbYGFwZy1leGFtcGxlc2BdKGh0dHBzOi8vZ2l0aHViLmNvbS9sZHRob21hcy9hcGctanMtZXhhbXBsZXMpIGZvciBleGFtcGxlcyBvZiB1c2luZyBgdHJhY2UuanNgLilcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXhwb3J0VHJhY2UoKSB7XG4gIGNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMnKTtcbiAgY29uc3Qgc3R5bGUgPSByZXF1aXJlKCcuL3N0eWxlJyk7XG4gIGNvbnN0IGNpcmN1bGFyID0gbmV3IChyZXF1aXJlKCcuL2NpcmN1bGFyLWJ1ZmZlcicpKSgpO1xuICBjb25zdCBpZCA9IHJlcXVpcmUoJy4vaWRlbnRpZmllcnMnKTtcblxuICBjb25zdCB0aGlzRmlsZU5hbWUgPSAndHJhY2UuanM6ICc7XG4gIGNvbnN0IHRoYXQgPSB0aGlzO1xuICBjb25zdCBNT0RFX0hFWCA9IDE2O1xuICBjb25zdCBNT0RFX0RFQyA9IDEwO1xuICBjb25zdCBNT0RFX0FTQ0lJID0gODtcbiAgY29uc3QgTU9ERV9VTklDT0RFID0gMzI7XG4gIGNvbnN0IE1BWF9QSFJBU0UgPSA4MDtcbiAgY29uc3QgTUFYX1RMUyA9IDU7XG4gIGNvbnN0IHJlY29yZHMgPSBbXTtcbiAgbGV0IG1heFJlY29yZHMgPSA1MDAwO1xuICBsZXQgbGFzdFJlY29yZCA9IC0xO1xuICBsZXQgZmlsdGVyZWRSZWNvcmRzID0gMDtcbiAgbGV0IHRyZWVEZXB0aCA9IDA7XG4gIGNvbnN0IHJlY29yZFN0YWNrID0gW107XG4gIGxldCBjaGFycyA9IG51bGw7XG4gIGxldCBydWxlcyA9IG51bGw7XG4gIGxldCB1ZHRzID0gbnVsbDtcbiAgY29uc3Qgb3BlcmF0b3JGaWx0ZXIgPSBbXTtcbiAgY29uc3QgcnVsZUZpbHRlciA9IFtdO1xuICAvKiBzcGVjaWFsIHRyYWNlIHRhYmxlIHBocmFzZXMgKi9cbiAgY29uc3QgUEhSQVNFX0VORCA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTElORUVORH1cIj4mYnVsbDs8L3NwYW4+YDtcbiAgY29uc3QgUEhSQVNFX0NPTlRJTlVFID0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19MSU5FRU5EfVwiPiZoZWxsaXA7PC9zcGFuPmA7XG4gIGNvbnN0IFBIUkFTRV9FTVBUWSA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfRU1QVFl9XCI+JiMxMjA2MzQ7PC9zcGFuPmA7XG4gIC8qIGZpbHRlciB0aGUgbm9uLVJOTSAmIG5vbi1VRFQgb3BlcmF0b3JzICovXG4gIGNvbnN0IGluaXRPcGVyYXRvckZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBzZXRPcGVyYXRvcnMgPSBmdW5jdGlvbiAoc2V0KSB7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5BTFRdID0gc2V0O1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQ0FUXSA9IHNldDtcbiAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLlJFUF0gPSBzZXQ7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5UTFNdID0gc2V0O1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuVEJTXSA9IHNldDtcbiAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLlRSR10gPSBzZXQ7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5BTkRdID0gc2V0O1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuTk9UXSA9IHNldDtcbiAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkJLUl0gPSBzZXQ7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5CS0FdID0gc2V0O1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQktOXSA9IHNldDtcbiAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkFCR10gPSBzZXQ7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5BRU5dID0gc2V0O1xuICAgIH07XG4gICAgbGV0IGl0ZW1zID0gMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhhdC5maWx0ZXIub3BlcmF0b3JzKSB7XG4gICAgICBpdGVtcyArPSAxO1xuICAgIH1cbiAgICBpZiAoaXRlbXMgPT09IDApIHtcbiAgICAgIC8qIGNhc2UgMTogbm8gb3BlcmF0b3JzIHNwZWNpZmllZDogZGVmYXVsdDogZG8gbm90IHRyYWNlIGFueSBvcGVyYXRvcnMgKi9cbiAgICAgIHNldE9wZXJhdG9ycyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGF0LmZpbHRlci5vcGVyYXRvcnMpIHtcbiAgICAgIGNvbnN0IHVwcGVyID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKHVwcGVyID09PSAnPEFMTD4nKSB7XG4gICAgICAgIC8qIGNhc2UgMjogPGFsbD4gb3BlcmF0b3JzIHNwZWNpZmllZDogdHJhY2UgYWxsIG9wZXJhdG9ycyBpZ25vcmUgYWxsIG90aGVyIG9wZXJhdG9yIGNvbW1hbmRzICovXG4gICAgICAgIHNldE9wZXJhdG9ycyh0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHVwcGVyID09PSAnPE5PTkU+Jykge1xuICAgICAgICAvKiBjYXNlIDM6IDxub25lPiBvcGVyYXRvcnMgc3BlY2lmaWVkOiB0cmFjZSBOTyBvcGVyYXRvcnMgaWdub3JlIGFsbCBvdGhlciBvcGVyYXRvciBjb21tYW5kcyAqL1xuICAgICAgICBzZXRPcGVyYXRvcnMoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHNldE9wZXJhdG9ycyhmYWxzZSk7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHRoYXQuZmlsdGVyLm9wZXJhdG9ycykge1xuICAgICAgY29uc3QgdXBwZXIgPSBuYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAvKiBjYXNlIDQ6IG9uZSBvciBtb3JlIGluZGl2aWR1YWwgb3BlcmF0b3JzIHNwZWNpZmllZDogdHJhY2UgJ3RydWUnIG9wZXJhdG9ycyBvbmx5ICovXG4gICAgICBpZiAodXBwZXIgPT09ICdBTFQnKSB7XG4gICAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkFMVF0gPSB0aGF0LmZpbHRlci5vcGVyYXRvcnNbbmFtZV0gPT09IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHVwcGVyID09PSAnQ0FUJykge1xuICAgICAgICBvcGVyYXRvckZpbHRlcltpZC5DQVRdID0gdGhhdC5maWx0ZXIub3BlcmF0b3JzW25hbWVdID09PSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1cHBlciA9PT0gJ1JFUCcpIHtcbiAgICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuUkVQXSA9IHRoYXQuZmlsdGVyLm9wZXJhdG9yc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodXBwZXIgPT09ICdBTkQnKSB7XG4gICAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkFORF0gPSB0aGF0LmZpbHRlci5vcGVyYXRvcnNbbmFtZV0gPT09IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHVwcGVyID09PSAnTk9UJykge1xuICAgICAgICBvcGVyYXRvckZpbHRlcltpZC5OT1RdID0gdGhhdC5maWx0ZXIub3BlcmF0b3JzW25hbWVdID09PSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1cHBlciA9PT0gJ1RMUycpIHtcbiAgICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuVExTXSA9IHRoYXQuZmlsdGVyLm9wZXJhdG9yc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodXBwZXIgPT09ICdUQlMnKSB7XG4gICAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLlRCU10gPSB0aGF0LmZpbHRlci5vcGVyYXRvcnNbbmFtZV0gPT09IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHVwcGVyID09PSAnVFJHJykge1xuICAgICAgICBvcGVyYXRvckZpbHRlcltpZC5UUkddID0gdGhhdC5maWx0ZXIub3BlcmF0b3JzW25hbWVdID09PSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1cHBlciA9PT0gJ0JLUicpIHtcbiAgICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQktSXSA9IHRoYXQuZmlsdGVyLm9wZXJhdG9yc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodXBwZXIgPT09ICdCS0EnKSB7XG4gICAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkJLQV0gPSB0aGF0LmZpbHRlci5vcGVyYXRvcnNbbmFtZV0gPT09IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHVwcGVyID09PSAnQktOJykge1xuICAgICAgICBvcGVyYXRvckZpbHRlcltpZC5CS05dID0gdGhhdC5maWx0ZXIub3BlcmF0b3JzW25hbWVdID09PSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1cHBlciA9PT0gJ0FCRycpIHtcbiAgICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQUJHXSA9IHRoYXQuZmlsdGVyLm9wZXJhdG9yc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodXBwZXIgPT09ICdBRU4nKSB7XG4gICAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkFFTl0gPSB0aGF0LmZpbHRlci5vcGVyYXRvcnNbbmFtZV0gPT09IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYCR7dGhpc0ZpbGVOYW1lfWluaXRPcHJhdG9yRmlsdGVyOiAnJHtuYW1lfScgbm90IGEgdmFsaWQgb3BlcmF0b3IgbmFtZS5gICtcbiAgICAgICAgICAgIGAgTXVzdCBiZSA8YWxsPiwgPG5vbmU+LCBhbHQsIGNhdCwgcmVwLCB0bHMsIHRicywgdHJnLCBhbmQsIG5vdCwgYmtyLCBia2Egb3IgYmtuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyogZmlsdGVyIHRoZSBydWxlIGFuZCBgVURUYCBuYW1lZCBvcGVyYXRvcnMgKi9cbiAgY29uc3QgaW5pdFJ1bGVGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgc2V0UnVsZXMgPSBmdW5jdGlvbiAoc2V0KSB7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5STk1dID0gc2V0O1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuVURUXSA9IHNldDtcbiAgICAgIGNvbnN0IGNvdW50ID0gcnVsZXMubGVuZ3RoICsgdWR0cy5sZW5ndGg7XG4gICAgICBydWxlRmlsdGVyLmxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgICAgcnVsZUZpbHRlci5wdXNoKHNldCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgaXRlbXM7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgbGlzdCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgbGlzdC5wdXNoKHJ1bGVzW2ldLmxvd2VyKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHVkdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGxpc3QucHVzaCh1ZHRzW2ldLmxvd2VyKTtcbiAgICB9XG4gICAgcnVsZUZpbHRlci5sZW5ndGggPSAwO1xuICAgIGl0ZW1zID0gMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhhdC5maWx0ZXIucnVsZXMpIHtcbiAgICAgIGl0ZW1zICs9IDE7XG4gICAgfVxuICAgIGlmIChpdGVtcyA9PT0gMCkge1xuICAgICAgLyogY2FzZSAxOiBkZWZhdWx0IHRvIGFsbCBydWxlcyAmIHVkdHMgKi9cbiAgICAgIHNldFJ1bGVzKHRydWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhhdC5maWx0ZXIucnVsZXMpIHtcbiAgICAgIGNvbnN0IGxvd2VyID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyID09PSAnPGFsbD4nKSB7XG4gICAgICAgIC8qIGNhc2UgMjogdHJhY2UgYWxsIHJ1bGVzIGlnbm9yZSBhbGwgb3RoZXIgcnVsZSBjb21tYW5kcyAqL1xuICAgICAgICBzZXRSdWxlcyh0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGxvd2VyID09PSAnPG5vbmU+Jykge1xuICAgICAgICAvKiBjYXNlIDM6IHRyYWNlIG5vIHJ1bGVzICovXG4gICAgICAgIHNldFJ1bGVzKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBjYXNlIDQ6IHRyYWNlIG9ubHkgaW5kaXZpZHVhbGx5IHNwZWNpZmllZCBydWxlcyAqL1xuICAgIHNldFJ1bGVzKGZhbHNlKTtcbiAgICBvcGVyYXRvckZpbHRlcltpZC5STk1dID0gdHJ1ZTtcbiAgICBvcGVyYXRvckZpbHRlcltpZC5VRFRdID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhhdC5maWx0ZXIucnVsZXMpIHtcbiAgICAgIGNvbnN0IGxvd2VyID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaSA9IGxpc3QuaW5kZXhPZihsb3dlcik7XG4gICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1pbml0UnVsZUZpbHRlcjogJyR7bmFtZX0nIG5vdCBhIHZhbGlkIHJ1bGUgb3IgdWR0IG5hbWVgKTtcbiAgICAgIH1cbiAgICAgIHJ1bGVGaWx0ZXJbaV0gPSB0aGF0LmZpbHRlci5ydWxlc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIC8qIHVzZWQgYnkgb3RoZXIgQVBHIGNvbXBvbmVudHMgdG8gdmVyaWZ5IHRoYXQgdGhleSBoYXZlIGEgdmFsaWQgdHJhY2Ugb2JqZWN0ICovXG4gIHRoaXMudHJhY2VPYmplY3QgPSAndHJhY2VPYmplY3QnO1xuICB0aGlzLmZpbHRlciA9IHtcbiAgICBvcGVyYXRvcnM6IFtdLFxuICAgIHJ1bGVzOiBbXSxcbiAgfTtcbiAgLy8gU2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiByZWNvcmRzIHRvIGtlZXAgKGRlZmF1bHQgPSA1MDAwKS5cbiAgLy8gRWFjaCByZWNvcmQgbnVtYmVyIGxhcmdlciB0aGFuIGBtYXhSZWNvcmRzYFxuICAvLyB3aWxsIHJlc3VsdCBpbiBkZWxldGluZyB0aGUgcHJldmlvdXNseSBvbGRlc3QgcmVjb3JkLlxuICAvLyAtIGBtYXhgOiBtYXhpbXVtIG51bWJlciBvZiByZWNvcmRzIHRvIHJldGFpbiAoZGVmYXVsdCA9IDUwMDApXG4gIC8vIC0gYGxhc3RgOiBsYXN0IHJlY29yZCBudW1iZXIgdG8gcmV0YWluLCAoZGVmYXVsdCA9IC0xIGZvciAodW5rbm93bikgYWN0dWFsIGxhc3QgcmVjb3JkKVxuICB0aGlzLnNldE1heFJlY29yZHMgPSBmdW5jdGlvbiAobWF4LCBsYXN0KSB7XG4gICAgbGFzdFJlY29yZCA9IC0xO1xuICAgIGlmICh0eXBlb2YgbWF4ID09PSAnbnVtYmVyJyAmJiBtYXggPiAwKSB7XG4gICAgICBtYXhSZWNvcmRzID0gTWF0aC5jZWlsKG1heCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heFJlY29yZHMgPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGxhc3QgPT09ICdudW1iZXInKSB7XG4gICAgICBsYXN0UmVjb3JkID0gTWF0aC5mbG9vcihsYXN0KTtcbiAgICAgIGlmIChsYXN0UmVjb3JkIDwgMCkge1xuICAgICAgICBsYXN0UmVjb3JkID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBSZXR1cm5zIGBtYXhSZWNvcmRzYCB0byB0aGUgY2FsbGVyLlxuICB0aGlzLmdldE1heFJlY29yZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG1heFJlY29yZHM7XG4gIH07XG4gIC8vIFJldHVybnMgYGxhc3RSZWNvcmRgIHRvIHRoZSBjYWxsZXIuXG4gIHRoaXMuZ2V0TGFzdFJlY29yZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbGFzdFJlY29yZDtcbiAgfTtcbiAgLyogQ2FsbGVkIG9ubHkgYnkgdGhlIGBwYXJzZXIuanNgIG9iamVjdC4gTm8gdmVyaWZpY2F0aW9uIG9mIGlucHV0LiAqL1xuICB0aGlzLmluaXQgPSBmdW5jdGlvbiAocnVsZXNJbiwgdWR0c0luLCBjaGFyc0luKSB7XG4gICAgcmVjb3Jkcy5sZW5ndGggPSAwO1xuICAgIHJlY29yZFN0YWNrLmxlbmd0aCA9IDA7XG4gICAgZmlsdGVyZWRSZWNvcmRzID0gMDtcbiAgICB0cmVlRGVwdGggPSAwO1xuICAgIGNoYXJzID0gY2hhcnNJbjtcbiAgICBydWxlcyA9IHJ1bGVzSW47XG4gICAgdWR0cyA9IHVkdHNJbjtcbiAgICBpbml0T3BlcmF0b3JGaWx0ZXIoKTtcbiAgICBpbml0UnVsZUZpbHRlcigpO1xuICAgIGNpcmN1bGFyLmluaXQobWF4UmVjb3Jkcyk7XG4gIH07XG4gIC8qIHJldHVybnMgdHJ1ZSBpZiB0aGlzIHJlY29yZHMgcGFzc2VzIHRocm91Z2ggdGhlIGRlc2lnbmF0ZWQgZmlsdGVyLCBmYWxzZSBpZiB0aGUgcmVjb3JkIGlzIHRvIGJlIHNraXBwZWQgKi9cbiAgY29uc3QgZmlsdGVyT3BzID0gZnVuY3Rpb24gKG9wKSB7XG4gICAgbGV0IHJldCA9IGZhbHNlO1xuICAgIGlmIChvcC50eXBlID09PSBpZC5STk0pIHtcbiAgICAgIGlmIChvcGVyYXRvckZpbHRlcltvcC50eXBlXSAmJiBydWxlRmlsdGVyW29wLmluZGV4XSkge1xuICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcC50eXBlID09PSBpZC5VRFQpIHtcbiAgICAgIGlmIChvcGVyYXRvckZpbHRlcltvcC50eXBlXSAmJiBydWxlRmlsdGVyW3J1bGVzLmxlbmd0aCArIG9wLmluZGV4XSkge1xuICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldCA9IG9wZXJhdG9yRmlsdGVyW29wLnR5cGVdO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuICBjb25zdCBmaWx0ZXJSZWNvcmRzID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgIGlmIChsYXN0UmVjb3JkID09PSAtMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChyZWNvcmQgPD0gbGFzdFJlY29yZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgLyogQ29sbGVjdCB0aGUgXCJkb3duXCIgcmVjb3JkLiAqL1xuICB0aGlzLmRvd24gPSBmdW5jdGlvbiAob3AsIHN0YXRlLCBvZmZzZXQsIGxlbmd0aCwgYW5jaG9yLCBsb29rQXJvdW5kKSB7XG4gICAgaWYgKGZpbHRlclJlY29yZHMoZmlsdGVyZWRSZWNvcmRzKSAmJiBmaWx0ZXJPcHMob3ApKSB7XG4gICAgICByZWNvcmRTdGFjay5wdXNoKGZpbHRlcmVkUmVjb3Jkcyk7XG4gICAgICByZWNvcmRzW2NpcmN1bGFyLmluY3JlbWVudCgpXSA9IHtcbiAgICAgICAgZGlyVXA6IGZhbHNlLFxuICAgICAgICBkZXB0aDogdHJlZURlcHRoLFxuICAgICAgICB0aGlzTGluZTogZmlsdGVyZWRSZWNvcmRzLFxuICAgICAgICB0aGF0TGluZTogdW5kZWZpbmVkLFxuICAgICAgICBvcGNvZGU6IG9wLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcGhyYXNlSW5kZXg6IG9mZnNldCxcbiAgICAgICAgcGhyYXNlTGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgIGxvb2tBbmNob3I6IGFuY2hvcixcbiAgICAgICAgbG9va0Fyb3VuZCxcbiAgICAgIH07XG4gICAgICBmaWx0ZXJlZFJlY29yZHMgKz0gMTtcbiAgICAgIHRyZWVEZXB0aCArPSAxO1xuICAgIH1cbiAgfTtcbiAgLyogQ29sbGVjdCB0aGUgXCJ1cFwiIHJlY29yZC4gKi9cbiAgdGhpcy51cCA9IGZ1bmN0aW9uIChvcCwgc3RhdGUsIG9mZnNldCwgbGVuZ3RoLCBhbmNob3IsIGxvb2tBcm91bmQpIHtcbiAgICBpZiAoZmlsdGVyUmVjb3JkcyhmaWx0ZXJlZFJlY29yZHMpICYmIGZpbHRlck9wcyhvcCkpIHtcbiAgICAgIGNvbnN0IHRoaXNMaW5lID0gZmlsdGVyZWRSZWNvcmRzO1xuICAgICAgY29uc3QgdGhhdExpbmUgPSByZWNvcmRTdGFjay5wb3AoKTtcbiAgICAgIGNvbnN0IHRoYXRSZWNvcmQgPSBjaXJjdWxhci5nZXRMaXN0SW5kZXgodGhhdExpbmUpO1xuICAgICAgaWYgKHRoYXRSZWNvcmQgIT09IC0xKSB7XG4gICAgICAgIHJlY29yZHNbdGhhdFJlY29yZF0udGhhdExpbmUgPSB0aGlzTGluZTtcbiAgICAgIH1cbiAgICAgIHRyZWVEZXB0aCAtPSAxO1xuICAgICAgcmVjb3Jkc1tjaXJjdWxhci5pbmNyZW1lbnQoKV0gPSB7XG4gICAgICAgIGRpclVwOiB0cnVlLFxuICAgICAgICBkZXB0aDogdHJlZURlcHRoLFxuICAgICAgICB0aGlzTGluZSxcbiAgICAgICAgdGhhdExpbmUsXG4gICAgICAgIG9wY29kZTogb3AsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBwaHJhc2VJbmRleDogb2Zmc2V0LFxuICAgICAgICBwaHJhc2VMZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgbG9va0FuY2hvcjogYW5jaG9yLFxuICAgICAgICBsb29rQXJvdW5kLFxuICAgICAgfTtcbiAgICAgIGZpbHRlcmVkUmVjb3JkcyArPSAxO1xuICAgIH1cbiAgfTtcbiAgLyogY29udmVydCB0aGUgdHJhY2UgcmVjb3JkcyB0byBhIHRyZWUgb2Ygbm9kZXMgKi9cbiAgY29uc3QgdG9UcmVlT2JqID0gZnVuY3Rpb24gKCkge1xuICAgIC8qIHByaXZhdGUgaGVscGVyIGZ1bmN0aW9ucyAqL1xuICAgIGZ1bmN0aW9uIG5vZGVPcGNvZGUobm9kZSwgb3Bjb2RlKSB7XG4gICAgICBsZXQgbmFtZTtcbiAgICAgIGxldCBjYXNldHlwZTtcbiAgICAgIGxldCBtb2RldHlwZTtcbiAgICAgIGlmIChvcGNvZGUpIHtcbiAgICAgICAgbm9kZS5vcCA9IHsgaWQ6IG9wY29kZS50eXBlLCBuYW1lOiB1dGlscy5vcGNvZGVUb1N0cmluZyhvcGNvZGUudHlwZSkgfTtcbiAgICAgICAgbm9kZS5vcERhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHN3aXRjaCAob3Bjb2RlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIGlkLlJOTTpcbiAgICAgICAgICAgIG5vZGUub3BEYXRhID0gcnVsZXNbb3Bjb2RlLmluZGV4XS5uYW1lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5VRFQ6XG4gICAgICAgICAgICBub2RlLm9wRGF0YSA9IHVkdHNbb3Bjb2RlLmluZGV4XS5uYW1lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5CS1I6XG4gICAgICAgICAgICBpZiAob3Bjb2RlLmluZGV4IDwgcnVsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG5hbWUgPSBydWxlc1tvcGNvZGUuaW5kZXhdLm5hbWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuYW1lID0gdWR0c1tvcGNvZGUuaW5kZXggLSBydWxlcy5sZW5ndGhdLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNldHlwZSA9IG9wY29kZS5ia3JDYXNlID09PSBpZC5CS1JfTU9ERV9DSSA/ICclaScgOiAnJXMnO1xuICAgICAgICAgICAgbW9kZXR5cGUgPSBvcGNvZGUuYmtyTW9kZSA9PT0gaWQuQktSX01PREVfVU0gPyAnJXUnIDogJyVwJztcbiAgICAgICAgICAgIG5vZGUub3BEYXRhID0gYFxcXFxcXFxcJHtjYXNldHlwZX0ke21vZGV0eXBlfSR7bmFtZX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5UTFM6XG4gICAgICAgICAgICBub2RlLm9wRGF0YSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcGNvZGUuc3RyaW5nLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgIG5vZGUub3BEYXRhLnB1c2gob3Bjb2RlLnN0cmluZ1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlRCUzpcbiAgICAgICAgICAgIG5vZGUub3BEYXRhID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wY29kZS5zdHJpbmcubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgbm9kZS5vcERhdGEucHVzaChvcGNvZGUuc3RyaW5nW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuVFJHOlxuICAgICAgICAgICAgbm9kZS5vcERhdGEgPSBbb3Bjb2RlLm1pbiwgb3Bjb2RlLm1heF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlJFUDpcbiAgICAgICAgICAgIG5vZGUub3BEYXRhID0gW29wY29kZS5taW4sIG9wY29kZS5tYXhdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIG9wY29kZScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLm9wID0geyBpZDogdW5kZWZpbmVkLCBuYW1lOiB1bmRlZmluZWQgfTtcbiAgICAgICAgbm9kZS5vcERhdGEgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vZGVQaHJhc2Uoc3RhdGUsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gaWQuTUFUQ0gpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBsZW5ndGgsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUgPT09IGlkLk5PTUFUQ0gpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUgPT09IGlkLkVNUFRZKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBub2RlSWQgPSAtMTtcbiAgICBmdW5jdGlvbiBub2RlRG93bihwYXJlbnQsIHJlY29yZCwgZGVwdGgpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wbHVzcGx1c1xuICAgICAgICBpZDogbm9kZUlkKyssXG4gICAgICAgIGJyYW5jaDogLTEsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgdXA6IGZhbHNlLFxuICAgICAgICBkb3duOiBmYWxzZSxcbiAgICAgICAgZGVwdGgsXG4gICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIH07XG4gICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgIG5vZGUuZG93biA9IHRydWU7XG4gICAgICAgIG5vZGUuc3RhdGUgPSB7IGlkOiByZWNvcmQuc3RhdGUsIG5hbWU6IHV0aWxzLnN0YXRlVG9TdHJpbmcocmVjb3JkLnN0YXRlKSB9O1xuICAgICAgICBub2RlLnBocmFzZSA9IG51bGw7XG4gICAgICAgIG5vZGVPcGNvZGUobm9kZSwgcmVjb3JkLm9wY29kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnN0YXRlID0geyBpZDogdW5kZWZpbmVkLCBuYW1lOiB1bmRlZmluZWQgfTtcbiAgICAgICAgbm9kZS5waHJhc2UgPSBub2RlUGhyYXNlKCk7XG4gICAgICAgIG5vZGVPcGNvZGUobm9kZSwgdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub2RlVXAobm9kZSwgcmVjb3JkKSB7XG4gICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgIG5vZGUudXAgPSB0cnVlO1xuICAgICAgICBub2RlLnN0YXRlID0geyBpZDogcmVjb3JkLnN0YXRlLCBuYW1lOiB1dGlscy5zdGF0ZVRvU3RyaW5nKHJlY29yZC5zdGF0ZSkgfTtcbiAgICAgICAgbm9kZS5waHJhc2UgPSBub2RlUGhyYXNlKHJlY29yZC5zdGF0ZSwgcmVjb3JkLnBocmFzZUluZGV4LCByZWNvcmQucGhyYXNlTGVuZ3RoKTtcbiAgICAgICAgaWYgKCFub2RlLmRvd24pIHtcbiAgICAgICAgICBub2RlT3Bjb2RlKG5vZGUsIHJlY29yZC5vcGNvZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIHdhbGsgdGhlIGZpbmFsIHRyZWU6IGxhYmVsIGJyYW5jaGVzIGFuZCBjb3VudCBsZWFmIG5vZGVzICovXG4gICAgbGV0IGxlYWZOb2RlcyA9IDA7XG4gICAgbGV0IGRlcHRoID0gLTE7XG4gICAgbGV0IGJyYW5jaENvdW50ID0gMTtcbiAgICBmdW5jdGlvbiB3YWxrKG5vZGUpIHtcbiAgICAgIGRlcHRoICs9IDE7XG4gICAgICBub2RlLmJyYW5jaCA9IGJyYW5jaENvdW50O1xuICAgICAgaWYgKGRlcHRoID4gdHJlZURlcHRoKSB7XG4gICAgICAgIHRyZWVEZXB0aCA9IGRlcHRoO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGxlYWZOb2RlcyArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBicmFuY2hDb3VudCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLmNoaWxkcmVuW2ldLmxlZnRNb3N0ID0gZmFsc2U7XG4gICAgICAgICAgbm9kZS5jaGlsZHJlbltpXS5yaWdodE1vc3QgPSBmYWxzZTtcbiAgICAgICAgICBpZiAobm9kZS5sZWZ0TW9zdCkge1xuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbltpXS5sZWZ0TW9zdCA9IGkgPT09IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlLnJpZ2h0TW9zdCkge1xuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbltpXS5yaWdodE1vc3QgPSBpID09PSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdhbGsobm9kZS5jaGlsZHJlbltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlcHRoIC09IDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3BsYXkobm9kZSwgb2Zmc2V0KSB7XG4gICAgICBsZXQgbmFtZTtcbiAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgb2JqLmlkID0gbm9kZS5pZDtcbiAgICAgIG9iai5icmFuY2ggPSBub2RlLmJyYW5jaDtcbiAgICAgIG9iai5sZWZ0TW9zdCA9IG5vZGUubGVmdE1vc3Q7XG4gICAgICBvYmoucmlnaHRNb3N0ID0gbm9kZS5yaWdodE1vc3Q7XG4gICAgICBuYW1lID0gbm9kZS5zdGF0ZS5uYW1lID8gbm9kZS5zdGF0ZS5uYW1lIDogJ0FDVElWRSc7XG4gICAgICBvYmouc3RhdGUgPSB7IGlkOiBub2RlLnN0YXRlLmlkLCBuYW1lIH07XG4gICAgICBuYW1lID0gbm9kZS5vcC5uYW1lID8gbm9kZS5vcC5uYW1lIDogJz8nO1xuICAgICAgb2JqLm9wID0geyBpZDogbm9kZS5vcC5pZCwgbmFtZSB9O1xuICAgICAgaWYgKHR5cGVvZiBub2RlLm9wRGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2JqLm9wRGF0YSA9IG5vZGUub3BEYXRhO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5vZGUub3BEYXRhKSkge1xuICAgICAgICBvYmoub3BEYXRhID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5vcERhdGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBvYmoub3BEYXRhW2ldID0gbm9kZS5vcERhdGFbaV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iai5vcERhdGEgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5waHJhc2UpIHtcbiAgICAgICAgb2JqLnBocmFzZSA9IHsgaW5kZXg6IG5vZGUucGhyYXNlLmluZGV4LCBsZW5ndGg6IG5vZGUucGhyYXNlLmxlbmd0aCB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqLnBocmFzZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBvYmouZGVwdGggPSBub2RlLmRlcHRoO1xuICAgICAgb2JqLmNoaWxkcmVuID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgYyA9IGkgIT09IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgb2JqLmNoaWxkcmVuW2ldID0gZGlzcGxheShub2RlLmNoaWxkcmVuW2ldLCBvZmZzZXQsIGMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICAvKiBjb25zdHJ1Y3QgdGhlIHRyZWUgYmVnaW5uaW5nIGhlcmUgKi9cbiAgICBjb25zdCBicmFuY2ggPSBbXTtcbiAgICBsZXQgcm9vdDtcbiAgICBsZXQgbm9kZTtcbiAgICBsZXQgcGFyZW50O1xuICAgIGxldCByZWNvcmQ7XG4gICAgbGV0IGZpcnN0UmVjb3JkID0gdHJ1ZTtcbiAgICAvKiBwdXNoIGEgZHVtbXkgbm9kZSBzbyB0aGUgcm9vdCBub2RlIHdpbGwgaGF2ZSBhIG5vbi1udWxsIHBhcmVudCAqL1xuICAgIGNvbnN0IGR1bW15ID0gbm9kZURvd24obnVsbCwgbnVsbCwgLTEpO1xuICAgIGJyYW5jaC5wdXNoKGR1bW15KTtcbiAgICBub2RlID0gZHVtbXk7XG4gICAgY2lyY3VsYXIuZm9yRWFjaCgobGluZUluZGV4KSA9PiB7XG4gICAgICByZWNvcmQgPSByZWNvcmRzW2xpbmVJbmRleF07XG4gICAgICBpZiAoZmlyc3RSZWNvcmQpIHtcbiAgICAgICAgZmlyc3RSZWNvcmQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHJlY29yZC5kZXB0aCA+IDApIHtcbiAgICAgICAgICAvKiBwdXNoIHNvbWUgZHVtbXkgbm9kZXMgdG8gZmlsbCBpbiBmb3IgbWlzc2luZyByZWNvcmRzICovXG4gICAgICAgICAgY29uc3QgbnVtID0gcmVjb3JkLmRpclVwID8gcmVjb3JkLmRlcHRoICsgMSA6IHJlY29yZC5kZXB0aDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bTsgaSArPSAxKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGVEb3duKG5vZGUsIG51bGwsIGkpO1xuICAgICAgICAgICAgYnJhbmNoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZWNvcmQuZGlyVXApIHtcbiAgICAgICAgLyogaGFuZGxlIHRoZSBuZXh0IHJlY29yZCB1cCAqL1xuICAgICAgICBub2RlID0gYnJhbmNoLnBvcCgpO1xuICAgICAgICBub2RlVXAobm9kZSwgcmVjb3JkKTtcbiAgICAgICAgbm9kZSA9IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBoYW5kbGUgdGhlIG5leHQgcmVjb3JkIGRvd24gKi9cbiAgICAgICAgcGFyZW50ID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGVEb3duKG5vZGUsIHJlY29yZCwgcmVjb3JkLmRlcHRoKTtcbiAgICAgICAgYnJhbmNoLnB1c2gobm9kZSk7XG4gICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyogaWYgbm90IGF0IHJvb3QsIHdhbGsgaXQgdXAgdG8gcm9vdCAqL1xuICAgIHdoaWxlIChicmFuY2gubGVuZ3RoID4gMSkge1xuICAgICAgbm9kZSA9IGJyYW5jaC5wb3AoKTtcbiAgICAgIG5vZGVVcChub2RlLCBudWxsKTtcbiAgICB9XG4gICAgLyogbWF5YmUgcmVkdW5kYW50IG9yIHBhcmFub2lkIHRlc3RzOiB0aGVzZSBzaG91bGQgbmV2ZXIgaGFwcGVuICovXG4gICAgaWYgKGR1bW15LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFjZS50b1RyZWUoKTogcGFyc2UgdHJlZSBoYXMgbm8gbm9kZXMnKTtcbiAgICB9XG4gICAgaWYgKGJyYW5jaC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHJhY2UudG9UcmVlKCk6IGludGVncml0eSBjaGVjazogZHVtbXkgcm9vdCBub2RlIGRpc2FwcGVhcmVkPycpO1xuICAgIH1cblxuICAgIC8qIGlmIG5vIHJlY29yZCBmb3Igc3RhcnQgcnVsZTogZmluZCB0aGUgcHNldWRvIHJvb3Qgbm9kZSAoZmlyc3QgZHVtbXkgbm9kZSBhYm92ZSBhIHJlYWwgbm9kZSkgKi9cbiAgICByb290ID0gZHVtbXkuY2hpbGRyZW5bMF07XG4gICAgbGV0IHByZXYgPSByb290O1xuICAgIHdoaWxlIChyb290ICYmICFyb290LmRvd24gJiYgIXJvb3QudXApIHtcbiAgICAgIHByZXYgPSByb290O1xuICAgICAgcm9vdCA9IHJvb3QuY2hpbGRyZW5bMF07XG4gICAgfVxuICAgIHJvb3QgPSBwcmV2O1xuXG4gICAgLyogd2FsayB0aGUgdHJlZSBvZiBub2RlczogbGFiZWwgYnJhbmNlcyBhbmQgY291bnQgbGVhdmVzICovXG4gICAgcm9vdC5sZWZ0TW9zdCA9IHRydWU7XG4gICAgcm9vdC5yaWdodE1vc3QgPSB0cnVlO1xuICAgIHdhbGsocm9vdCk7XG4gICAgcm9vdC5icmFuY2ggPSAwO1xuXG4gICAgLyogZ2VuZXJhdGUgdGhlIGV4cG9ydGVkIG9iamVjdCAqL1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIG9iai5zdHJpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBvYmouc3RyaW5nW2ldID0gY2hhcnNbaV07XG4gICAgfVxuICAgIC8qIGdlbmVyYXRlIHRoZSBleHBvcnRlZCBydWxlIG5hbWVzICovXG4gICAgb2JqLnJ1bGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgb2JqLnJ1bGVzW2ldID0gcnVsZXNbaV0ubmFtZTtcbiAgICB9XG4gICAgLyogZ2VuZXJhdGUgdGhlIGV4cG9ydGVkIFVEVCBuYW1lcyAqL1xuICAgIG9iai51ZHRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1ZHRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBvYmoudWR0c1tpXSA9IHVkdHNbaV0ubmFtZTtcbiAgICB9XG4gICAgLyogZ2VuZXJhdGUgdGhlIGlkcyAqL1xuICAgIG9iai5pZCA9IHt9O1xuICAgIG9iai5pZC5BTFQgPSB7IGlkOiBpZC5BTFQsIG5hbWU6ICdBTFQnIH07XG4gICAgb2JqLmlkLkNBVCA9IHsgaWQ6IGlkLkNBVCwgbmFtZTogJ0NBVCcgfTtcbiAgICBvYmouaWQuUkVQID0geyBpZDogaWQuUkVQLCBuYW1lOiAnUkVQJyB9O1xuICAgIG9iai5pZC5STk0gPSB7IGlkOiBpZC5STk0sIG5hbWU6ICdSTk0nIH07XG4gICAgb2JqLmlkLlRMUyA9IHsgaWQ6IGlkLlRMUywgbmFtZTogJ1RMUycgfTtcbiAgICBvYmouaWQuVEJTID0geyBpZDogaWQuVEJTLCBuYW1lOiAnVEJTJyB9O1xuICAgIG9iai5pZC5UUkcgPSB7IGlkOiBpZC5UUkcsIG5hbWU6ICdUUkcnIH07XG4gICAgb2JqLmlkLlVEVCA9IHsgaWQ6IGlkLlVEVCwgbmFtZTogJ1VEVCcgfTtcbiAgICBvYmouaWQuQU5EID0geyBpZDogaWQuQU5ELCBuYW1lOiAnQU5EJyB9O1xuICAgIG9iai5pZC5OT1QgPSB7IGlkOiBpZC5OT1QsIG5hbWU6ICdOT1QnIH07XG4gICAgb2JqLmlkLkJLUiA9IHsgaWQ6IGlkLkJLUiwgbmFtZTogJ0JLUicgfTtcbiAgICBvYmouaWQuQktBID0geyBpZDogaWQuQktBLCBuYW1lOiAnQktBJyB9O1xuICAgIG9iai5pZC5CS04gPSB7IGlkOiBpZC5CS04sIG5hbWU6ICdCS04nIH07XG4gICAgb2JqLmlkLkFCRyA9IHsgaWQ6IGlkLkFCRywgbmFtZTogJ0FCRycgfTtcbiAgICBvYmouaWQuQUVOID0geyBpZDogaWQuQUVOLCBuYW1lOiAnQUVOJyB9O1xuICAgIG9iai5pZC5BQ1RJVkUgPSB7IGlkOiBpZC5BQ1RJVkUsIG5hbWU6ICdBQ1RJVkUnIH07XG4gICAgb2JqLmlkLk1BVENIID0geyBpZDogaWQuTUFUQ0gsIG5hbWU6ICdNQVRDSCcgfTtcbiAgICBvYmouaWQuRU1QVFkgPSB7IGlkOiBpZC5FTVBUWSwgbmFtZTogJ0VNUFRZJyB9O1xuICAgIG9iai5pZC5OT01BVENIID0geyBpZDogaWQuTk9NQVRDSCwgbmFtZTogJ05PTUFUQ0gnIH07XG4gICAgLyogZ2VuZXJhdGUgdGhlIG1heCB0cmVlIGRlcHRoICovXG4gICAgb2JqLnRyZWVEZXB0aCA9IHRyZWVEZXB0aDtcbiAgICAvKiBnZW5lcmF0ZSB0aGUgbnVtYmVyIG9mIGxlYWYgbm9kZXMgKGJyYW5jaGVzKSAqL1xuICAgIG9iai5sZWFmTm9kZXMgPSBsZWFmTm9kZXM7XG4gICAgLyogZ2VuZXJhdGUgdGhlIHR5cGVzIG9mIHRoZSBsZWZ0LSBhbmQgcmlnaHQtbW9zdCBicmFuY2hlcyAqL1xuICAgIGxldCBicmFuY2hlc0luY29tcGxldGU7XG4gICAgaWYgKHJvb3QuZG93bikge1xuICAgICAgaWYgKHJvb3QudXApIHtcbiAgICAgICAgYnJhbmNoZXNJbmNvbXBsZXRlID0gJ25vbmUnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJhbmNoZXNJbmNvbXBsZXRlID0gJ3JpZ2h0JztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJvb3QudXApIHtcbiAgICAgIGJyYW5jaGVzSW5jb21wbGV0ZSA9ICdsZWZ0JztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJhbmNoZXNJbmNvbXBsZXRlID0gJ2JvdGgnO1xuICAgIH1cbiAgICBvYmouYnJhbmNoZXNJbmNvbXBsZXRlID0gYnJhbmNoZXNJbmNvbXBsZXRlO1xuICAgIG9iai50cmVlID0gZGlzcGxheShyb290LCByb290LmRlcHRoLCBmYWxzZSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbiAgLy8gUmV0dXJucyB0aGUgdHJhY2UgcmVjb3JkcyBhcyBKU09OIHBhcnNlIHRyZWUgb2JqZWN0LlxuICAvLyAtIHN0cmluZ2lmeTogaWYgYHRydWVgLCB0aGUgb2JqZWN0IGlzICdzdHJpbmdpZmllZCcgYmVmb3JlIHJldHVybmluZywgb3RoZXJ3aXNlLCB0aGUgb2JqZWN0IGl0c2VsZiBpcyByZXR1cm5lZC5cbiAgdGhpcy50b1RyZWUgPSBmdW5jdGlvbiAoc3RyaW5naWZ5KSB7XG4gICAgY29uc3Qgb2JqID0gdG9UcmVlT2JqKCk7XG4gICAgaWYgKHN0cmluZ2lmeSkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG4gIC8vIFRyYW5zbGF0ZSB0aGUgdHJhY2UgcmVjb3JkcyB0byBIVE1MIGZvcm1hdCBhbmQgY3JlYXRlIGEgY29tcGxldGUgSFRNTCBwYWdlIGZvciBicm93c2VyIGRpc3BsYXkuXG4gIHRoaXMudG9IdG1sUGFnZSA9IGZ1bmN0aW9uIChtb2RlLCBjYXB0aW9uLCB0aXRsZSkge1xuICAgIHJldHVybiB1dGlscy5odG1sVG9QYWdlKHRoaXMudG9IdG1sKG1vZGUsIGNhcHRpb24pLCB0aXRsZSk7XG4gIH07XG5cbiAgLyogRnJvbSBoZXJlIG9uIGRvd24sIHRoZXNlIGFyZSBqdXN0IGhlbHBlciBmdW5jdGlvbnMgZm9yIGB0b0h0bWwoKWAuICovXG4gIGNvbnN0IGh0bWxIZWFkZXIgPSBmdW5jdGlvbiAobW9kZSwgY2FwdGlvbikge1xuICAgIC8qIG9wZW4gdGhlIHBhZ2UgKi9cbiAgICAvKiB3cml0ZSB0aGUgSFRNTDUgaGVhZGVyIHdpdGggdGFibGUgc3R5bGUgKi9cbiAgICAvKiBvcGVuIHRoZSA8dGFibGU+IHRhZyAqL1xuICAgIGxldCBtb2RlTmFtZTtcbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgIGNhc2UgTU9ERV9IRVg6XG4gICAgICAgIG1vZGVOYW1lID0gJ2hleGFkZWNpbWFsJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE1PREVfREVDOlxuICAgICAgICBtb2RlTmFtZSA9ICdkZWNpbWFsJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE1PREVfQVNDSUk6XG4gICAgICAgIG1vZGVOYW1lID0gJ0FTQ0lJJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE1PREVfVU5JQ09ERTpcbiAgICAgICAgbW9kZU5hbWUgPSAnVU5JQ09ERSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1odG1sSGVhZGVyOiB1bnJlY29nbml6ZWQgbW9kZTogJHttb2RlfWApO1xuICAgIH1cbiAgICBsZXQgaGVhZGVyID0gJyc7XG4gICAgaGVhZGVyICs9IGA8cD5kaXNwbGF5IG1vZGU6ICR7bW9kZU5hbWV9PC9wPlxcbmA7XG4gICAgaGVhZGVyICs9IGA8dGFibGUgY2xhc3M9XCIke3N0eWxlLkNMQVNTX1RSQUNFfVwiPlxcbmA7XG4gICAgaWYgKHR5cGVvZiBjYXB0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgaGVhZGVyICs9IGA8Y2FwdGlvbj4ke2NhcHRpb259PC9jYXB0aW9uPmA7XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXI7XG4gIH07XG4gIGNvbnN0IGh0bWxGb290ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IGZvb3RlciA9ICcnO1xuICAgIC8qIGNsb3NlIHRoZSA8L3RhYmxlPiB0YWcgKi9cbiAgICBmb290ZXIgKz0gJzwvdGFibGU+XFxuJztcbiAgICAvKiBkaXNwbGF5IGEgdGFibGUgbGVnZW5kICovXG4gICAgZm9vdGVyICs9IGA8cCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTU9OT1NQQUNFfVwiPmxlZ2VuZDo8YnI+XFxuYDtcbiAgICBmb290ZXIgKz0gJyhhKSZuYnNwOy0mbmJzcDtsaW5lIG51bWJlcjxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnKGIpJm5ic3A7LSZuYnNwO21hdGNoaW5nIGxpbmUgbnVtYmVyPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICcoYykmbmJzcDstJm5ic3A7cGhyYXNlIG9mZnNldDxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnKGQpJm5ic3A7LSZuYnNwO3BocmFzZSBsZW5ndGg8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJyhlKSZuYnNwOy0mbmJzcDt0cmVlIGRlcHRoPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICcoZikmbmJzcDstJm5ic3A7b3BlcmF0b3Igc3RhdGU8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gYCZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOy0mbmJzcDs8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfQUNUSVZFfVwiPiZkYXJyOzwvc3Bhbj4mbmJzcDsmbmJzcDtwaHJhc2Ugb3BlbmVkPGJyPlxcbmA7XG4gICAgZm9vdGVyICs9IGAmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDstJm5ic3A7PHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX01BVENIfVwiPiZ1YXJyO008L3NwYW4+IHBocmFzZSBtYXRjaGVkPGJyPlxcbmA7XG4gICAgZm9vdGVyICs9IGAmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDstJm5ic3A7PHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0VNUFRZfVwiPiZ1YXJyO0U8L3NwYW4+IGVtcHR5IHBocmFzZSBtYXRjaGVkPGJyPlxcbmA7XG4gICAgZm9vdGVyICs9IGAmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDstJm5ic3A7PHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX05PTUFUQ0h9XCI+JnVhcnI7Tjwvc3Bhbj4gcGhyYXNlIG5vdCBtYXRjaGVkPGJyPlxcbmA7XG4gICAgZm9vdGVyICs9XG4gICAgICAnb3BlcmF0b3ImbmJzcDstJm5ic3A7QUxULCBDQVQsIFJFUCwgUk5NLCBUUkcsIFRMUywgVEJTPHN1cD4mZGFnZ2VyOzwvc3VwPiwgVURULCBBTkQsIE5PVCwgQktBLCBCS04sIEJLUiwgQUJHLCBBRU48c3VwPiZEYWdnZXI7PC9zdXA+PGJyPlxcbic7XG4gICAgZm9vdGVyICs9IGBwaHJhc2UmbmJzcDsmbmJzcDsmbmJzcDstJm5ic3A7dXAgdG8gJHtNQVhfUEhSQVNFfSBjaGFyYWN0ZXJzIG9mIHRoZSBwaHJhc2UgYmVpbmcgbWF0Y2hlZDxicj5cXG5gO1xuICAgIGZvb3RlciArPSBgJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7LSZuYnNwOzxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj5tYXRjaGVkIGNoYXJhY3RlcnM8L3NwYW4+PGJyPlxcbmA7XG4gICAgZm9vdGVyICs9IGAmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDstJm5ic3A7PHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0xPT0tBSEVBRH1cIj5tYXRjaGVkIGNoYXJhY3RlcnMgaW4gbG9vayBhaGVhZCBtb2RlPC9zcGFuPjxicj5cXG5gO1xuICAgIGZvb3RlciArPSBgJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7LSZuYnNwOzxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19MT09LQkVISU5EfVwiPm1hdGNoZWQgY2hhcmFjdGVycyBpbiBsb29rIGJlaGluZCBtb2RlPC9zcGFuPjxicj5cXG5gO1xuICAgIGZvb3RlciArPSBgJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7LSZuYnNwOzxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19SRU1BSU5ERVJ9XCI+cmVtYWluZGVyIGNoYXJhY3RlcnMobm90IHlldCBleGFtaW5lZCBieSBwYXJzZXIpPC9zcGFuPjxicj5cXG5gO1xuICAgIGZvb3RlciArPSBgJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7LSZuYnNwOzxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19DVFJMQ0hBUn1cIj5jb250cm9sIGNoYXJhY3RlcnMsIFRBQiwgTEYsIENSLCBldGMuIChBU0NJSSBtb2RlIG9ubHkpPC9zcGFuPjxicj5cXG5gO1xuICAgIGZvb3RlciArPSBgJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7LSZuYnNwOyR7UEhSQVNFX0VNUFRZfSBlbXB0eSBzdHJpbmc8YnI+XFxuYDtcbiAgICBmb290ZXIgKz0gYCZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOy0mbmJzcDske1BIUkFTRV9FTkR9IGVuZCBvZiBpbnB1dCBzdHJpbmc8YnI+XFxuYDtcbiAgICBmb290ZXIgKz0gYCZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOy0mbmJzcDske1BIUkFTRV9DT05USU5VRX0gaW5wdXQgc3RyaW5nIGRpc3BsYXkgdHJ1bmNhdGVkPGJyPlxcbmA7XG4gICAgZm9vdGVyICs9ICc8L3A+XFxuJztcbiAgICBmb290ZXIgKz0gYDxwIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NT05PU1BBQ0V9XCI+XFxuYDtcbiAgICBmb290ZXIgKz0gJzxzdXA+JmRhZ2dlcjs8L3N1cD5vcmlnaW5hbCBBQk5GIG9wZXJhdG9yczo8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ0FMVCAtIGFsdGVybmF0aW9uPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdDQVQgLSBjb25jYXRlbmF0aW9uPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdSRVAgLSByZXBldGl0aW9uPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdSTk0gLSBydWxlIG5hbWU8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ1RSRyAtIHRlcm1pbmFsIHJhbmdlPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdUTFMgLSB0ZXJtaW5hbCBsaXRlcmFsIHN0cmluZyAoY2FzZSBpbnNlbnNpdGl2ZSk8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ1RCUyAtIHRlcm1pbmFsIGJpbmFyeSBzdHJpbmcgKGNhc2Ugc2Vuc2l0aXZlKTxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICc8c3VwPiZEYWdnZXI7PC9zdXA+c3VwZXIgc2V0IFNBQk5GIG9wZXJhdG9yczo8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ1VEVCAtIHVzZXItZGVmaW5lZCB0ZXJtaW5hbDxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnQU5EIC0gcG9zaXRpdmUgbG9vayBhaGVhZDxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnTk9UIC0gbmVnYXRpdmUgbG9vayBhaGVhZDxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnQktBIC0gcG9zaXRpdmUgbG9vayBiZWhpbmQ8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ0JLTiAtIG5lZ2F0aXZlIGxvb2sgYmVoaW5kPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdCS1IgLSBiYWNrIHJlZmVyZW5jZTxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnQUJHIC0gYW5jaG9yIC0gYmVnaW4gb2YgaW5wdXQgc3RyaW5nPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdBRU4gLSBhbmNob3IgLSBlbmQgb2YgaW5wdXQgc3RyaW5nPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICc8L3A+XFxuJztcbiAgICByZXR1cm4gZm9vdGVyO1xuICB9O1xuICB0aGlzLmluZGVudCA9IGZ1bmN0aW9uIChkZXB0aCkge1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXB0aDsgaSArPSAxKSB7XG4gICAgICBodG1sICs9ICcuJztcbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIC8qIGZvcm1hdCB0aGUgVFJHIG9wZXJhdG9yICovXG4gIGNvbnN0IGRpc3BsYXlUcmcgPSBmdW5jdGlvbiAobW9kZSwgb3ApIHtcbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGlmIChvcC50eXBlID09PSBpZC5UUkcpIHtcbiAgICAgIGlmIChtb2RlID09PSBNT0RFX0hFWCB8fCBtb2RlID09PSBNT0RFX1VOSUNPREUpIHtcbiAgICAgICAgbGV0IGhleCA9IG9wLm1pbi50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgICAgaGV4ID0gYDAke2hleH1gO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwgKz0gbW9kZSA9PT0gTU9ERV9IRVggPyAnJXgnIDogJ1UrJztcbiAgICAgICAgaHRtbCArPSBoZXg7XG4gICAgICAgIGhleCA9IG9wLm1heC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgICAgaGV4ID0gYDAke2hleH1gO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwgKz0gYCZuZGFzaDske2hleH1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHRtbCA9IGAlZCR7b3AubWluLnRvU3RyaW5nKDEwKX0mbmRhc2g7JHtvcC5tYXgudG9TdHJpbmcoMTApfWA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBodG1sO1xuICB9O1xuICAvKiBmb3JtYXQgdGhlIFJFUCBvcGVyYXRvciAqL1xuICBjb25zdCBkaXNwbGF5UmVwID0gZnVuY3Rpb24gKG1vZGUsIG9wKSB7XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBpZiAob3AudHlwZSA9PT0gaWQuUkVQKSB7XG4gICAgICBpZiAobW9kZSA9PT0gTU9ERV9IRVgpIHtcbiAgICAgICAgbGV0IGhleCA9IG9wLm1pbi50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgICAgaGV4ID0gYDAke2hleH1gO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwgPSBgeCR7aGV4fWA7XG4gICAgICAgIGlmIChvcC5tYXggPCBJbmZpbml0eSkge1xuICAgICAgICAgIGhleCA9IG9wLm1heC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgICAgIGhleCA9IGAwJHtoZXh9YDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGV4ID0gJ2luZic7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbCArPSBgJm5kYXNoOyR7aGV4fWA7XG4gICAgICB9IGVsc2UgaWYgKG9wLm1heCA8IEluZmluaXR5KSB7XG4gICAgICAgIGh0bWwgPSBgJHtvcC5taW4udG9TdHJpbmcoMTApfSZuZGFzaDske29wLm1heC50b1N0cmluZygxMCl9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGh0bWwgPSBgJHtvcC5taW4udG9TdHJpbmcoMTApfSZuZGFzaDtpbmZgO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaHRtbDtcbiAgfTtcbiAgLyogZm9ybWF0IHRoZSBUQlMgb3BlcmF0b3IgKi9cbiAgY29uc3QgZGlzcGxheVRicyA9IGZ1bmN0aW9uIChtb2RlLCBvcCkge1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgaWYgKG9wLnR5cGUgPT09IGlkLlRCUykge1xuICAgICAgY29uc3QgbGVuID0gTWF0aC5taW4ob3Auc3RyaW5nLmxlbmd0aCwgTUFYX1RMUyAqIDIpO1xuICAgICAgaWYgKG1vZGUgPT09IE1PREVfSEVYIHx8IG1vZGUgPT09IE1PREVfVU5JQ09ERSkge1xuICAgICAgICBodG1sICs9IG1vZGUgPT09IE1PREVfSEVYID8gJyV4JyA6ICdVKyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBsZXQgaGV4O1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgaHRtbCArPSAnLic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhleCA9IG9wLnN0cmluZ1tpXS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgICAgIGhleCA9IGAwJHtoZXh9YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaHRtbCArPSBoZXg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGh0bWwgPSAnJWQnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBodG1sICs9ICcuJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaHRtbCArPSBvcC5zdHJpbmdbaV0udG9TdHJpbmcoMTApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGVuIDwgb3Auc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICBodG1sICs9IFBIUkFTRV9DT05USU5VRTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIC8qIGZvcm1hdCB0aGUgVExTIG9wZXJhdG9yICovXG4gIGNvbnN0IGRpc3BsYXlUbHMgPSBmdW5jdGlvbiAobW9kZSwgb3ApIHtcbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGlmIChvcC50eXBlID09PSBpZC5UTFMpIHtcbiAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWluKG9wLnN0cmluZy5sZW5ndGgsIE1BWF9UTFMpO1xuICAgICAgaWYgKG1vZGUgPT09IE1PREVfSEVYIHx8IG1vZGUgPT09IE1PREVfREVDKSB7XG4gICAgICAgIGxldCBjaGFydTtcbiAgICAgICAgbGV0IGNoYXJsO1xuICAgICAgICBsZXQgYmFzZTtcbiAgICAgICAgaWYgKG1vZGUgPT09IE1PREVfSEVYKSB7XG4gICAgICAgICAgaHRtbCA9ICcleCc7XG4gICAgICAgICAgYmFzZSA9IDE2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGh0bWwgPSAnJWQnO1xuICAgICAgICAgIGJhc2UgPSAxMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBodG1sICs9ICcuJztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hhcmwgPSBvcC5zdHJpbmdbaV07XG4gICAgICAgICAgaWYgKGNoYXJsID49IDk3ICYmIGNoYXJsIDw9IDEyMikge1xuICAgICAgICAgICAgY2hhcnUgPSBjaGFybCAtIDMyO1xuICAgICAgICAgICAgaHRtbCArPSBgJHtjaGFydS50b1N0cmluZyhiYXNlKX0vJHtjaGFybC50b1N0cmluZyhiYXNlKX1gLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFybCA+PSA2NSAmJiBjaGFybCA8PSA5MCkge1xuICAgICAgICAgICAgY2hhcnUgPSBjaGFybDtcbiAgICAgICAgICAgIGNoYXJsICs9IDMyO1xuICAgICAgICAgICAgaHRtbCArPSBgJHtjaGFydS50b1N0cmluZyhiYXNlKX0vJHtjaGFybC50b1N0cmluZyhiYXNlKX1gLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh0bWwgKz0gY2hhcmwudG9TdHJpbmcoYmFzZSkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbiA8IG9wLnN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICBodG1sICs9IFBIUkFTRV9DT05USU5VRTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHRtbCA9ICdcIic7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBodG1sICs9IHV0aWxzLmFzY2lpQ2hhcnNbb3Auc3RyaW5nW2ldXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuIDwgb3Auc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgIGh0bWwgKz0gUEhSQVNFX0NPTlRJTlVFO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwgKz0gJ1wiJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIGNvbnN0IHN1YlBocmFzZSA9IGZ1bmN0aW9uIChtb2RlLCBjaGFyc0FyZywgaW5kZXgsIGxlbmd0aCwgcHJldikge1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgbGV0IHBocmFzZSA9ICcnO1xuICAgIGNvbnN0IGNvbW1hID0gcHJldiA/ICcsJyA6ICcnO1xuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSBNT0RFX0hFWDpcbiAgICAgICAgcGhyYXNlID0gY29tbWEgKyB1dGlscy5jaGFyc1RvSGV4KGNoYXJzQXJnLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE1PREVfREVDOlxuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgIHJldHVybiBgLCR7dXRpbHMuY2hhcnNUb0RlYyhjaGFyc0FyZywgaW5kZXgsIGxlbmd0aCl9YDtcbiAgICAgICAgfVxuICAgICAgICBwaHJhc2UgPSBjb21tYSArIHV0aWxzLmNoYXJzVG9EZWMoY2hhcnNBcmcsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTU9ERV9VTklDT0RFOlxuICAgICAgICBwaHJhc2UgPSB1dGlscy5jaGFyc1RvVW5pY29kZShjaGFyc0FyZywgaW5kZXgsIGxlbmd0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBNT0RFX0FTQ0lJOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcGhyYXNlID0gdXRpbHMuY2hhcnNUb0FzY2lpSHRtbChjaGFyc0FyZywgaW5kZXgsIGxlbmd0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcGhyYXNlO1xuICB9O1xuICAvKiBkaXNwbGF5IHBocmFzZXMgbWF0Y2hlZCBpbiBsb29rLWJlaGluZCBtb2RlICovXG4gIGNvbnN0IGRpc3BsYXlCZWhpbmQgPSBmdW5jdGlvbiAobW9kZSwgY2hhcnNBcmcsIHN0YXRlLCBpbmRleCwgbGVuZ3RoLCBhbmNob3IpIHtcbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGxldCBiZWcxO1xuICAgIGxldCBsZW4xO1xuICAgIGxldCBiZWcyO1xuICAgIGxldCBsZW4yO1xuICAgIGxldCBsYXN0Y2hhciA9IFBIUkFTRV9FTkQ7XG4gICAgY29uc3Qgc3BhbkJlaGluZCA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTE9PS0JFSElORH1cIj5gO1xuICAgIGNvbnN0IHNwYW5SZW1haW5kZXIgPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX1JFTUFJTkRFUn1cIj5gO1xuICAgIGNvbnN0IHNwYW5lbmQgPSAnPC9zcGFuPic7XG4gICAgbGV0IHByZXYgPSBmYWxzZTtcbiAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBodG1sICs9IFBIUkFTRV9FTVBUWTtcbiAgICAgIC8qIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaCAqL1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBiZWcxID0gaW5kZXggLSBsZW5ndGg7XG4gICAgICAgIGxlbjEgPSBhbmNob3IgLSBiZWcxO1xuICAgICAgICBiZWcyID0gYW5jaG9yO1xuICAgICAgICBsZW4yID0gY2hhcnNBcmcubGVuZ3RoIC0gYmVnMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVjb2duaXplZCBzdGF0ZScpO1xuICAgIH1cbiAgICBsYXN0Y2hhciA9IFBIUkFTRV9FTkQ7XG4gICAgaWYgKGxlbjEgPiBNQVhfUEhSQVNFKSB7XG4gICAgICBsZW4xID0gTUFYX1BIUkFTRTtcbiAgICAgIGxhc3RjaGFyID0gUEhSQVNFX0NPTlRJTlVFO1xuICAgICAgbGVuMiA9IDA7XG4gICAgfSBlbHNlIGlmIChsZW4xICsgbGVuMiA+IE1BWF9QSFJBU0UpIHtcbiAgICAgIGxhc3RjaGFyID0gUEhSQVNFX0NPTlRJTlVFO1xuICAgICAgbGVuMiA9IE1BWF9QSFJBU0UgLSBsZW4xO1xuICAgIH1cbiAgICBpZiAobGVuMSA+IDApIHtcbiAgICAgIGh0bWwgKz0gc3BhbkJlaGluZDtcbiAgICAgIGh0bWwgKz0gc3ViUGhyYXNlKG1vZGUsIGNoYXJzQXJnLCBiZWcxLCBsZW4xLCBwcmV2KTtcbiAgICAgIGh0bWwgKz0gc3BhbmVuZDtcbiAgICAgIHByZXYgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobGVuMiA+IDApIHtcbiAgICAgIGh0bWwgKz0gc3BhblJlbWFpbmRlcjtcbiAgICAgIGh0bWwgKz0gc3ViUGhyYXNlKG1vZGUsIGNoYXJzQXJnLCBiZWcyLCBsZW4yLCBwcmV2KTtcbiAgICAgIGh0bWwgKz0gc3BhbmVuZDtcbiAgICB9XG4gICAgcmV0dXJuIGh0bWwgKyBsYXN0Y2hhcjtcbiAgfTtcbiAgY29uc3QgZGlzcGxheUZvcndhcmQgPSBmdW5jdGlvbiAobW9kZSwgY2hhcnNBcmcsIHN0YXRlLCBpbmRleCwgbGVuZ3RoLCBzcGFuQWhlYWQpIHtcbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGxldCBiZWcxO1xuICAgIGxldCBsZW4xO1xuICAgIGxldCBiZWcyO1xuICAgIGxldCBsZW4yO1xuICAgIGxldCBsYXN0Y2hhciA9IFBIUkFTRV9FTkQ7XG4gICAgY29uc3Qgc3BhblJlbWFpbmRlciA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfUkVNQUlOREVSfVwiPmA7XG4gICAgY29uc3Qgc3BhbmVuZCA9ICc8L3NwYW4+JztcbiAgICBsZXQgcHJldiA9IGZhbHNlO1xuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGh0bWwgKz0gUEhSQVNFX0VNUFRZO1xuICAgICAgLyogLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoICovXG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYmVnMSA9IGluZGV4O1xuICAgICAgICBsZW4xID0gMDtcbiAgICAgICAgYmVnMiA9IGluZGV4O1xuICAgICAgICBsZW4yID0gY2hhcnNBcmcubGVuZ3RoIC0gYmVnMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBiZWcxID0gaW5kZXg7XG4gICAgICAgIGxlbjEgPSBsZW5ndGg7XG4gICAgICAgIGJlZzIgPSBpbmRleCArIGxlbjE7XG4gICAgICAgIGxlbjIgPSBjaGFyc0FyZy5sZW5ndGggLSBiZWcyO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIHN0YXRlJyk7XG4gICAgfVxuICAgIGxhc3RjaGFyID0gUEhSQVNFX0VORDtcbiAgICBpZiAobGVuMSA+IE1BWF9QSFJBU0UpIHtcbiAgICAgIGxlbjEgPSBNQVhfUEhSQVNFO1xuICAgICAgbGFzdGNoYXIgPSBQSFJBU0VfQ09OVElOVUU7XG4gICAgICBsZW4yID0gMDtcbiAgICB9IGVsc2UgaWYgKGxlbjEgKyBsZW4yID4gTUFYX1BIUkFTRSkge1xuICAgICAgbGFzdGNoYXIgPSBQSFJBU0VfQ09OVElOVUU7XG4gICAgICBsZW4yID0gTUFYX1BIUkFTRSAtIGxlbjE7XG4gICAgfVxuICAgIGlmIChsZW4xID4gMCkge1xuICAgICAgaHRtbCArPSBzcGFuQWhlYWQ7XG4gICAgICBodG1sICs9IHN1YlBocmFzZShtb2RlLCBjaGFyc0FyZywgYmVnMSwgbGVuMSwgcHJldik7XG4gICAgICBodG1sICs9IHNwYW5lbmQ7XG4gICAgICBwcmV2ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGxlbjIgPiAwKSB7XG4gICAgICBodG1sICs9IHNwYW5SZW1haW5kZXI7XG4gICAgICBodG1sICs9IHN1YlBocmFzZShtb2RlLCBjaGFyc0FyZywgYmVnMiwgbGVuMiwgcHJldik7XG4gICAgICBodG1sICs9IHNwYW5lbmQ7XG4gICAgfVxuICAgIHJldHVybiBodG1sICsgbGFzdGNoYXI7XG4gIH07XG4gIC8qIGRpc3BsYXkgcGhyYXNlcyBtYXRjaGVkIGluIGxvb2stYWhlYWQgbW9kZSAqL1xuICBjb25zdCBkaXNwbGF5QWhlYWQgPSBmdW5jdGlvbiAobW9kZSwgY2hhcnNBcmcsIHN0YXRlLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgY29uc3Qgc3BhbkFoZWFkID0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19MT09LQUhFQUR9XCI+YDtcbiAgICByZXR1cm4gZGlzcGxheUZvcndhcmQobW9kZSwgY2hhcnNBcmcsIHN0YXRlLCBpbmRleCwgbGVuZ3RoLCBzcGFuQWhlYWQpO1xuICB9O1xuICAvKiBkaXNwbGF5IHBocmFzZXMgbWF0Y2hlZCBpbiBub3JtYWwgcGFyc2luZyBtb2RlICovXG4gIGNvbnN0IGRpc3BsYXlOb25lID0gZnVuY3Rpb24gKG1vZGUsIGNoYXJzQXJnLCBzdGF0ZSwgaW5kZXgsIGxlbmd0aCkge1xuICAgIGNvbnN0IHNwYW5BaGVhZCA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTUFUQ0h9XCI+YDtcbiAgICByZXR1cm4gZGlzcGxheUZvcndhcmQobW9kZSwgY2hhcnNBcmcsIHN0YXRlLCBpbmRleCwgbGVuZ3RoLCBzcGFuQWhlYWQpO1xuICB9O1xuICAvKiBSZXR1cm5zIHRoZSBmaWx0ZXJlZCByZWNvcmRzLCBmb3JtYXR0ZWQgYXMgYW4gSFRNTCB0YWJsZS4gKi9cbiAgY29uc3QgaHRtbFRhYmxlID0gZnVuY3Rpb24gKG1vZGUpIHtcbiAgICBpZiAocnVsZXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBsZXQgdGhpc0xpbmU7XG4gICAgbGV0IHRoYXRMaW5lO1xuICAgIGxldCBsb29rQWhlYWQ7XG4gICAgbGV0IGxvb2tCZWhpbmQ7XG4gICAgbGV0IGxvb2tBcm91bmQ7XG4gICAgbGV0IGFuY2hvcjtcbiAgICBodG1sICs9ICc8dHI+PHRoPihhKTwvdGg+PHRoPihiKTwvdGg+PHRoPihjKTwvdGg+PHRoPihkKTwvdGg+PHRoPihlKTwvdGg+PHRoPihmKTwvdGg+JztcbiAgICBodG1sICs9ICc8dGg+b3BlcmF0b3I8L3RoPjx0aD5waHJhc2U8L3RoPjwvdHI+XFxuJztcbiAgICBjaXJjdWxhci5mb3JFYWNoKChsaW5lSW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGxpbmUgPSByZWNvcmRzW2xpbmVJbmRleF07XG4gICAgICB0aGlzTGluZSA9IGxpbmUudGhpc0xpbmU7XG4gICAgICB0aGF0TGluZSA9IGxpbmUudGhhdExpbmUgIT09IHVuZGVmaW5lZCA/IGxpbmUudGhhdExpbmUgOiAnLS0nO1xuICAgICAgbG9va0FoZWFkID0gZmFsc2U7XG4gICAgICBsb29rQmVoaW5kID0gZmFsc2U7XG4gICAgICBsb29rQXJvdW5kID0gZmFsc2U7XG4gICAgICBpZiAobGluZS5sb29rQXJvdW5kID09PSBpZC5MT09LQVJPVU5EX0FIRUFEKSB7XG4gICAgICAgIGxvb2tBaGVhZCA9IHRydWU7XG4gICAgICAgIGxvb2tBcm91bmQgPSB0cnVlO1xuICAgICAgICBhbmNob3IgPSBsaW5lLmxvb2tBbmNob3I7XG4gICAgICB9XG4gICAgICBpZiAobGluZS5vcGNvZGUudHlwZSA9PT0gaWQuQU5EIHx8IGxpbmUub3Bjb2RlLnR5cGUgPT09IGlkLk5PVCkge1xuICAgICAgICBsb29rQWhlYWQgPSB0cnVlO1xuICAgICAgICBsb29rQXJvdW5kID0gdHJ1ZTtcbiAgICAgICAgYW5jaG9yID0gbGluZS5waHJhc2VJbmRleDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lLmxvb2tBcm91bmQgPT09IGlkLkxPT0tBUk9VTkRfQkVISU5EKSB7XG4gICAgICAgIGxvb2tCZWhpbmQgPSB0cnVlO1xuICAgICAgICBsb29rQXJvdW5kID0gdHJ1ZTtcbiAgICAgICAgYW5jaG9yID0gbGluZS5sb29rQW5jaG9yO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUub3Bjb2RlLnR5cGUgPT09IGlkLkJLQSB8fCBsaW5lLm9wY29kZS50eXBlID09PSBpZC5CS04pIHtcbiAgICAgICAgbG9va0JlaGluZCA9IHRydWU7XG4gICAgICAgIGxvb2tBcm91bmQgPSB0cnVlO1xuICAgICAgICBhbmNob3IgPSBsaW5lLnBocmFzZUluZGV4O1xuICAgICAgfVxuICAgICAgaHRtbCArPSAnPHRyPic7XG4gICAgICBodG1sICs9IGA8dGQ+JHt0aGlzTGluZX08L3RkPjx0ZD4ke3RoYXRMaW5lfTwvdGQ+YDtcbiAgICAgIGh0bWwgKz0gYDx0ZD4ke2xpbmUucGhyYXNlSW5kZXh9PC90ZD5gO1xuICAgICAgaHRtbCArPSBgPHRkPiR7bGluZS5waHJhc2VMZW5ndGh9PC90ZD5gO1xuICAgICAgaHRtbCArPSBgPHRkPiR7bGluZS5kZXB0aH08L3RkPmA7XG4gICAgICBodG1sICs9ICc8dGQ+JztcbiAgICAgIHN3aXRjaCAobGluZS5zdGF0ZSkge1xuICAgICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgICBodG1sICs9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfQUNUSVZFfVwiPiZkYXJyOyZuYnNwOzwvc3Bhbj5gO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICAgIGh0bWwgKz0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj4mdWFycjtNPC9zcGFuPmA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgICBodG1sICs9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTk9NQVRDSH1cIj4mdWFycjtOPC9zcGFuPmA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgICAgaHRtbCArPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0VNUFRZfVwiPiZ1YXJyO0U8L3NwYW4+YDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBodG1sICs9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfQUNUSVZFfVwiPi0tPC9zcGFuPmA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBodG1sICs9ICc8L3RkPic7XG4gICAgICBodG1sICs9ICc8dGQ+JztcbiAgICAgIGh0bWwgKz0gdGhhdC5pbmRlbnQobGluZS5kZXB0aCk7XG4gICAgICBpZiAobG9va0FoZWFkKSB7XG4gICAgICAgIGh0bWwgKz0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19MT09LQUhFQUR9XCI+YDtcbiAgICAgIH0gZWxzZSBpZiAobG9va0JlaGluZCkge1xuICAgICAgICBodG1sICs9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTE9PS0JFSElORH1cIj5gO1xuICAgICAgfVxuICAgICAgaHRtbCArPSB1dGlscy5vcGNvZGVUb1N0cmluZyhsaW5lLm9wY29kZS50eXBlKTtcbiAgICAgIGlmIChsaW5lLm9wY29kZS50eXBlID09PSBpZC5STk0pIHtcbiAgICAgICAgaHRtbCArPSBgKCR7cnVsZXNbbGluZS5vcGNvZGUuaW5kZXhdLm5hbWV9KSBgO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUub3Bjb2RlLnR5cGUgPT09IGlkLkJLUikge1xuICAgICAgICBjb25zdCBjYXNldHlwZSA9IGxpbmUub3Bjb2RlLmJrckNhc2UgPT09IGlkLkJLUl9NT0RFX0NJID8gJyVpJyA6ICclcyc7XG4gICAgICAgIGNvbnN0IG1vZGV0eXBlID0gbGluZS5vcGNvZGUuYmtyTW9kZSA9PT0gaWQuQktSX01PREVfVU0gPyAnJXUnIDogJyVwJztcbiAgICAgICAgaHRtbCArPSBgKFxcXFwke2Nhc2V0eXBlfSR7bW9kZXR5cGV9JHtydWxlc1tsaW5lLm9wY29kZS5pbmRleF0ubmFtZX0pIGA7XG4gICAgICB9XG4gICAgICBpZiAobGluZS5vcGNvZGUudHlwZSA9PT0gaWQuVURUKSB7XG4gICAgICAgIGh0bWwgKz0gYCgke3VkdHNbbGluZS5vcGNvZGUuaW5kZXhdLm5hbWV9KSBgO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUub3Bjb2RlLnR5cGUgPT09IGlkLlRSRykge1xuICAgICAgICBodG1sICs9IGAoJHtkaXNwbGF5VHJnKG1vZGUsIGxpbmUub3Bjb2RlKX0pIGA7XG4gICAgICB9XG4gICAgICBpZiAobGluZS5vcGNvZGUudHlwZSA9PT0gaWQuVEJTKSB7XG4gICAgICAgIGh0bWwgKz0gYCgke2Rpc3BsYXlUYnMobW9kZSwgbGluZS5vcGNvZGUpfSkgYDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lLm9wY29kZS50eXBlID09PSBpZC5UTFMpIHtcbiAgICAgICAgaHRtbCArPSBgKCR7ZGlzcGxheVRscyhtb2RlLCBsaW5lLm9wY29kZSl9KSBgO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUub3Bjb2RlLnR5cGUgPT09IGlkLlJFUCkge1xuICAgICAgICBodG1sICs9IGAoJHtkaXNwbGF5UmVwKG1vZGUsIGxpbmUub3Bjb2RlKX0pIGA7XG4gICAgICB9XG4gICAgICBpZiAobG9va0Fyb3VuZCkge1xuICAgICAgICBodG1sICs9ICc8L3NwYW4+JztcbiAgICAgIH1cbiAgICAgIGh0bWwgKz0gJzwvdGQ+JztcbiAgICAgIGh0bWwgKz0gJzx0ZD4nO1xuICAgICAgaWYgKGxvb2tCZWhpbmQpIHtcbiAgICAgICAgaHRtbCArPSBkaXNwbGF5QmVoaW5kKG1vZGUsIGNoYXJzLCBsaW5lLnN0YXRlLCBsaW5lLnBocmFzZUluZGV4LCBsaW5lLnBocmFzZUxlbmd0aCwgYW5jaG9yKTtcbiAgICAgIH0gZWxzZSBpZiAobG9va0FoZWFkKSB7XG4gICAgICAgIGh0bWwgKz0gZGlzcGxheUFoZWFkKG1vZGUsIGNoYXJzLCBsaW5lLnN0YXRlLCBsaW5lLnBocmFzZUluZGV4LCBsaW5lLnBocmFzZUxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBodG1sICs9IGRpc3BsYXlOb25lKG1vZGUsIGNoYXJzLCBsaW5lLnN0YXRlLCBsaW5lLnBocmFzZUluZGV4LCBsaW5lLnBocmFzZUxlbmd0aCk7XG4gICAgICB9XG4gICAgICBodG1sICs9ICc8L3RkPjwvdHI+XFxuJztcbiAgICB9KTtcbiAgICBodG1sICs9ICc8dHI+PHRoPihhKTwvdGg+PHRoPihiKTwvdGg+PHRoPihjKTwvdGg+PHRoPihkKTwvdGg+PHRoPihlKTwvdGg+PHRoPihmKTwvdGg+JztcbiAgICBodG1sICs9ICc8dGg+b3BlcmF0b3I8L3RoPjx0aD5waHJhc2U8L3RoPjwvdHI+XFxuJztcbiAgICBodG1sICs9ICc8L3RhYmxlPlxcbic7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIC8vIFRyYW5zbGF0ZSB0aGUgdHJhY2UgcmVjb3JkcyB0byBIVE1MIGZvcm1hdC5cbiAgLy8gLSAqbW9kZWFyZyogLSBjYW4gYmUgYFwiYXNjaWlcImAsIGBcImRlY2ltYWxcImAsIGBcImhleGFkZWNpbWFsXCJgIG9yIGBcInVuaWNvZGVcImAuXG4gIC8vIERldGVybWluZXMgdGhlIGZvcm1hdCBvZiB0aGUgc3RyaW5nIGNoYXJhY3RlciBjb2RlIGRpc3BsYXkuXG4gIC8vIC0gKmNhcHRpb24qIC0gb3B0aW9uYWwgY2FwdGlvbiBmb3IgdGhlIEhUTUwgdGFibGUuXG4gIHRoaXMudG9IdG1sID0gZnVuY3Rpb24gKG1vZGVhcmcsIGNhcHRpb24pIHtcbiAgICAvKiB3cml0ZXMgdGhlIHRyYWNlIHJlY29yZHMgYXMgYSB0YWJsZSBpbiBhIGNvbXBsZXRlIGh0bWwgcGFnZSAqL1xuICAgIGxldCBtb2RlID0gTU9ERV9BU0NJSTtcbiAgICBpZiAodHlwZW9mIG1vZGVhcmcgPT09ICdzdHJpbmcnICYmIG1vZGVhcmcubGVuZ3RoID49IDMpIHtcbiAgICAgIGNvbnN0IG1vZGVpbiA9IG1vZGVhcmcudG9Mb3dlckNhc2UoKS5zbGljZSgwLCAzKTtcbiAgICAgIGlmIChtb2RlaW4gPT09ICdoZXgnKSB7XG4gICAgICAgIG1vZGUgPSBNT0RFX0hFWDtcbiAgICAgIH0gZWxzZSBpZiAobW9kZWluID09PSAnZGVjJykge1xuICAgICAgICBtb2RlID0gTU9ERV9ERUM7XG4gICAgICB9IGVsc2UgaWYgKG1vZGVpbiA9PT0gJ3VuaScpIHtcbiAgICAgICAgbW9kZSA9IE1PREVfVU5JQ09ERTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBodG1sICs9IGh0bWxIZWFkZXIobW9kZSwgY2FwdGlvbik7XG4gICAgaHRtbCArPSBodG1sVGFibGUobW9kZSk7XG4gICAgaHRtbCArPSBodG1sRm9vdGVyKCk7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-lib/trace.js\n"));

/***/ }),

/***/ "./node_modules/apg-js/src/apg-lib/utilities.js":
/*!******************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/utilities.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* eslint-disable func-names */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module exports a variety of utility functions that support\n// [`apg`](https://github.com/ldthomas/apg-js2), [`apg-lib`](https://github.com/ldthomas/apg-js2-lib)\n// and the generated parser applications.\n\nconst style = __webpack_require__(/*! ./style */ \"./node_modules/apg-js/src/apg-lib/style.js\");\nconst converter = __webpack_require__(/*! ../apg-conv-api/converter */ \"./node_modules/apg-js/src/apg-conv-api/converter.js\");\nconst emitCss = __webpack_require__(/*! ./emitcss */ \"./node_modules/apg-js/src/apg-lib/emitcss.js\");\nconst id = __webpack_require__(/*! ./identifiers */ \"./node_modules/apg-js/src/apg-lib/identifiers.js\");\n\nconst thisFileName = 'utilities.js: ';\nconst thisThis = this;\n\n/* translate (implied) phrase beginning character and length to actual first and last character indexes */\n/* used by multiple phrase handling functions */\nconst getBounds = function (length, begArg, len) {\n  let end;\n  let beg = begArg;\n  const TRUE = true;\n  while (TRUE) {\n    if (length <= 0) {\n      beg = 0;\n      end = 0;\n      break;\n    }\n    if (typeof beg !== 'number') {\n      beg = 0;\n      end = length;\n      break;\n    }\n    if (beg >= length) {\n      beg = length;\n      end = length;\n      break;\n    }\n    if (typeof len !== 'number') {\n      end = length;\n      break;\n    }\n    end = beg + len;\n    if (end > length) {\n      end = length;\n      break;\n    }\n    break;\n  }\n  return {\n    beg,\n    end,\n  };\n};\n// Generates a complete, minimal HTML5 page, inserting the user's HTML text on the page.\n// - *html* - the page text in HTML format\n// - *title* - the HTML page `<title>` - defaults to `htmlToPage`.\nexports.htmlToPage = function (html, titleArg) {\n  let title;\n  if (typeof html !== 'string') {\n    throw new Error(`${thisFileName}htmlToPage: input HTML is not a string`);\n  }\n  if (typeof titleArg !== 'string') {\n    title = 'htmlToPage';\n  } else {\n    title = titleArg;\n  }\n  let page = '';\n  page += '<!DOCTYPE html>\\n';\n  page += '<html lang=\"en\">\\n';\n  page += '<head>\\n';\n  page += '<meta charset=\"utf-8\">\\n';\n  page += `<title>${title}</title>\\n`;\n  page += '<style>\\n';\n  page += emitCss();\n  page += '</style>\\n';\n  page += '</head>\\n<body>\\n';\n  page += `<p>${new Date()}</p>\\n`;\n  page += html;\n  page += '</body>\\n</html>\\n';\n  return page;\n};\n// Formats the returned object from `parser.parse()`\n// into an HTML table.\n// ```\n// return {\n//   success : sysData.success,\n//   state : sysData.state,\n//   length : charsLength,\n//   matched : sysData.phraseLength,\n//   maxMatched : maxMatched,\n//   maxTreeDepth : maxTreeDepth,\n//   nodeHits : nodeHits,\n//   inputLength : chars.length,\n//   subBegin : charsBegin,\n//   subEnd : charsEnd,\n//   subLength : charsLength\n// };\n// ```\nexports.parserResultToHtml = function (result, caption) {\n  let cap = null;\n  if (typeof caption === 'string' && caption !== '') {\n    cap = caption;\n  }\n  let success;\n  let state;\n  if (result.success === true) {\n    success = `<span class=\"${style.CLASS_MATCH}\">true</span>`;\n  } else {\n    success = `<span class=\"${style.CLASS_NOMATCH}\">false</span>`;\n  }\n  if (result.state === id.EMPTY) {\n    state = `<span class=\"${style.CLASS_EMPTY}\">EMPTY</span>`;\n  } else if (result.state === id.MATCH) {\n    state = `<span class=\"${style.CLASS_MATCH}\">MATCH</span>`;\n  } else if (result.state === id.NOMATCH) {\n    state = `<span class=\"${style.CLASS_NOMATCH}\">NOMATCH</span>`;\n  } else {\n    state = `<span class=\"${style.CLASS_NOMATCH}\">unrecognized</span>`;\n  }\n  let html = '';\n  html += `<table class=\"${style.CLASS_STATE}\">\\n`;\n  if (cap) {\n    html += `<caption>${cap}</caption>\\n`;\n  }\n  html += '<tr><th>state item</th><th>value</th><th>description</th></tr>\\n';\n  html += `<tr><td>parser success</td><td>${success}</td>\\n`;\n  html += `<td><span class=\"${style.CLASS_MATCH}\">true</span> if the parse succeeded,\\n`;\n  html += ` <span class=\"${style.CLASS_NOMATCH}\">false</span> otherwise`;\n  html += '<br><i>NOTE: for success, entire string must be matched</i></td></tr>\\n';\n  html += `<tr><td>parser state</td><td>${state}</td>\\n`;\n  html += `<td><span class=\"${style.CLASS_EMPTY}\">EMPTY</span>, `;\n  html += `<span class=\"${style.CLASS_MATCH}\">MATCH</span> or \\n`;\n  html += `<span class=\"${style.CLASS_NOMATCH}\">NOMATCH</span></td></tr>\\n`;\n  html += `<tr><td>string length</td><td>${result.length}</td><td>length of the input (sub)string</td></tr>\\n`;\n  html += `<tr><td>matched length</td><td>${result.matched}</td><td>number of input string characters matched</td></tr>\\n`;\n  html += `<tr><td>max matched</td><td>${result.maxMatched}</td><td>maximum number of input string characters matched</td></tr>\\n`;\n  html += `<tr><td>max tree depth</td><td>${result.maxTreeDepth}</td><td>maximum depth of the parse tree reached</td></tr>\\n`;\n  html += `<tr><td>node hits</td><td>${result.nodeHits}</td><td>number of parse tree node hits (opcode function calls)</td></tr>\\n`;\n  html += `<tr><td>input length</td><td>${result.inputLength}</td><td>length of full input string</td></tr>\\n`;\n  html += `<tr><td>sub-string begin</td><td>${result.subBegin}</td><td>sub-string first character index</td></tr>\\n`;\n  html += `<tr><td>sub-string end</td><td>${result.subEnd}</td><td>sub-string end-of-string index</td></tr>\\n`;\n  html += `<tr><td>sub-string length</td><td>${result.subLength}</td><td>sub-string length</td></tr>\\n`;\n  html += '</table>\\n';\n  return html;\n};\n// Translates a sub-array of integer character codes into a string.\n// Very useful in callback functions to translate the matched phrases into strings.\nexports.charsToString = function (chars, phraseIndex, phraseLength) {\n  let beg;\n  let end;\n  if (typeof phraseIndex === 'number') {\n    if (phraseIndex >= chars.length) {\n      return '';\n    }\n    beg = phraseIndex < 0 ? 0 : phraseIndex;\n  } else {\n    beg = 0;\n  }\n  if (typeof phraseLength === 'number') {\n    if (phraseLength <= 0) {\n      return '';\n    }\n    end = phraseLength > chars.length - beg ? chars.length : beg + phraseLength;\n  } else {\n    end = chars.length;\n  }\n  if (beg < end) {\n    return converter.encode('UTF16LE', chars.slice(beg, end)).toString('utf16le');\n  }\n  return '';\n};\n// Translates a string into an array of integer character codes.\nexports.stringToChars = function (string) {\n  return converter.decode('STRING', string);\n};\n// Translates an opcode identifier into a human-readable string.\nexports.opcodeToString = function (type) {\n  let ret = 'unknown';\n  switch (type) {\n    case id.ALT:\n      ret = 'ALT';\n      break;\n    case id.CAT:\n      ret = 'CAT';\n      break;\n    case id.RNM:\n      ret = 'RNM';\n      break;\n    case id.UDT:\n      ret = 'UDT';\n      break;\n    case id.AND:\n      ret = 'AND';\n      break;\n    case id.NOT:\n      ret = 'NOT';\n      break;\n    case id.REP:\n      ret = 'REP';\n      break;\n    case id.TRG:\n      ret = 'TRG';\n      break;\n    case id.TBS:\n      ret = 'TBS';\n      break;\n    case id.TLS:\n      ret = 'TLS';\n      break;\n    case id.BKR:\n      ret = 'BKR';\n      break;\n    case id.BKA:\n      ret = 'BKA';\n      break;\n    case id.BKN:\n      ret = 'BKN';\n      break;\n    case id.ABG:\n      ret = 'ABG';\n      break;\n    case id.AEN:\n      ret = 'AEN';\n      break;\n    default:\n      throw new Error('unrecognized opcode');\n  }\n  return ret;\n};\n// Translates an state identifier into a human-readable string.\nexports.stateToString = function (state) {\n  let ret = 'unknown';\n  switch (state) {\n    case id.ACTIVE:\n      ret = 'ACTIVE';\n      break;\n    case id.MATCH:\n      ret = 'MATCH';\n      break;\n    case id.EMPTY:\n      ret = 'EMPTY';\n      break;\n    case id.NOMATCH:\n      ret = 'NOMATCH';\n      break;\n    default:\n      throw new Error('unrecognized state');\n  }\n  return ret;\n};\n// Array which translates all 128, 7-bit ASCII character codes to their respective HTML format.\nexports.asciiChars = [\n  'NUL',\n  'SOH',\n  'STX',\n  'ETX',\n  'EOT',\n  'ENQ',\n  'ACK',\n  'BEL',\n  'BS',\n  'TAB',\n  'LF',\n  'VT',\n  'FF',\n  'CR',\n  'SO',\n  'SI',\n  'DLE',\n  'DC1',\n  'DC2',\n  'DC3',\n  'DC4',\n  'NAK',\n  'SYN',\n  'ETB',\n  'CAN',\n  'EM',\n  'SUB',\n  'ESC',\n  'FS',\n  'GS',\n  'RS',\n  'US',\n  '&nbsp;',\n  '!',\n  '&#34;',\n  '#',\n  '$',\n  '%',\n  '&#38;',\n  '&#39;',\n  '(',\n  ')',\n  '*',\n  '+',\n  ',',\n  '-',\n  '.',\n  '/',\n  '0',\n  '1',\n  '2',\n  '3',\n  '4',\n  '5',\n  '6',\n  '7',\n  '8',\n  '9',\n  ':',\n  ';',\n  '&#60;',\n  '=',\n  '&#62;',\n  '?',\n  '@',\n  'A',\n  'B',\n  'C',\n  'D',\n  'E',\n  'F',\n  'G',\n  'H',\n  'I',\n  'J',\n  'K',\n  'L',\n  'M',\n  'N',\n  'O',\n  'P',\n  'Q',\n  'R',\n  'S',\n  'T',\n  'U',\n  'V',\n  'W',\n  'X',\n  'Y',\n  'Z',\n  '[',\n  '&#92;',\n  ']',\n  '^',\n  '_',\n  '`',\n  'a',\n  'b',\n  'c',\n  'd',\n  'e',\n  'f',\n  'g',\n  'h',\n  'i',\n  'j',\n  'k',\n  'l',\n  'm',\n  'n',\n  'o',\n  'p',\n  'q',\n  'r',\n  's',\n  't',\n  'u',\n  'v',\n  'w',\n  'x',\n  'y',\n  'z',\n  '{',\n  '|',\n  '}',\n  '~',\n  'DEL',\n];\n// Translates a single character to hexadecimal with leading zeros for 2, 4, or 8 digit display.\nexports.charToHex = function (char) {\n  let ch = char.toString(16).toUpperCase();\n  switch (ch.length) {\n    case 1:\n    case 3:\n    case 7:\n      ch = `0${ch}`;\n      break;\n    case 2:\n    case 6:\n      ch = `00${ch}`;\n      break;\n    case 4:\n      break;\n    case 5:\n      ch = `000${ch}`;\n      break;\n    default:\n      throw new Error('unrecognized option');\n  }\n  return ch;\n};\n// Translates a sub-array of character codes to decimal display format.\nexports.charsToDec = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToDec: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    ret += chars[bounds.beg];\n    for (let i = bounds.beg + 1; i < bounds.end; i += 1) {\n      ret += `,${chars[i]}`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to hexadecimal display format.\nexports.charsToHex = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToHex: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    ret += `\\\\x${thisThis.charToHex(chars[bounds.beg])}`;\n    for (let i = bounds.beg + 1; i < bounds.end; i += 1) {\n      ret += `,\\\\x${thisThis.charToHex(chars[i])}`;\n    }\n  }\n  return ret;\n};\nexports.charsToHtmlEntities = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToHex: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    for (let i = bounds.beg; i < bounds.end; i += 1) {\n      ret += `&#x${chars[i].toString(16)};`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to Unicode display format.\nfunction isUnicode(char) {\n  if (char >= 0xd800 && char <= 0xdfff) {\n    return false;\n  }\n  if (char > 0x10ffff) {\n    return false;\n  }\n  return true;\n}\nexports.charsToUnicode = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToUnicode: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    for (let i = bounds.beg; i < bounds.end; i += 1) {\n      if (isUnicode(chars[i])) {\n        ret += `&#${chars[i]};`;\n      } else {\n        ret += ` U+${thisThis.charToHex(chars[i])}`;\n      }\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to JavaScript Unicode display format (`\\uXXXX`).\nexports.charsToJsUnicode = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToJsUnicode: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    ret += `\\\\u${thisThis.charToHex(chars[bounds.beg])}`;\n    for (let i = bounds.beg + 1; i < bounds.end; i += 1) {\n      ret += `,\\\\u${thisThis.charToHex(chars[i])}`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to printing ASCII character display format.\nexports.charsToAscii = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToAscii: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  for (let i = bounds.beg; i < bounds.end; i += 1) {\n    const char = chars[i];\n    if (char >= 32 && char <= 126) {\n      ret += String.fromCharCode(char);\n    } else {\n      ret += `\\\\x${thisThis.charToHex(char)}`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to HTML display format.\nexports.charsToAsciiHtml = function (chars, beg, len) {\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToAsciiHtml: input must be an array of integers`);\n  }\n  let html = '';\n  let char;\n  const bounds = getBounds(chars.length, beg, len);\n  for (let i = bounds.beg; i < bounds.end; i += 1) {\n    char = chars[i];\n    if (char < 32 || char === 127) {\n      /* control characters */\n      html += `<span class=\"${style.CLASS_CTRLCHAR}\">${thisThis.asciiChars[char]}</span>`;\n    } else if (char > 127) {\n      /* non-ASCII */\n      html += `<span class=\"${style.CLASS_CTRLCHAR}\">U+${thisThis.charToHex(char)}</span>`;\n    } else {\n      /* printing ASCII, 32 <= char <= 126 */\n      html += thisThis.asciiChars[char];\n    }\n  }\n  return html;\n};\n// Translates a JavaScript string to HTML display format.\nexports.stringToAsciiHtml = function (str) {\n  const chars = converter.decode('STRING', str);\n  return this.charsToAsciiHtml(chars);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3V0aWxpdGllcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQywyREFBUztBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBMkI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMsK0RBQVc7QUFDbkMsV0FBVyxtQkFBTyxDQUFDLHVFQUFlOztBQUVsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtCQUFrQjtBQUNoRCxJQUFJO0FBQ0osOEJBQThCLG9CQUFvQjtBQUNsRDtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QyxJQUFJO0FBQ0osNEJBQTRCLGtCQUFrQjtBQUM5QyxJQUFJO0FBQ0osNEJBQTRCLG9CQUFvQjtBQUNoRCxJQUFJO0FBQ0osNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBLHdCQUF3QixJQUFJO0FBQzVCO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRCw4QkFBOEIsa0JBQWtCO0FBQ2hELDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQSwwQ0FBMEMsTUFBTTtBQUNoRCw4QkFBOEIsa0JBQWtCO0FBQ2hELDBCQUEwQixrQkFBa0I7QUFDNUMsMEJBQTBCLG9CQUFvQjtBQUM5QywyQ0FBMkMsY0FBYztBQUN6RCw0Q0FBNEMsZUFBZTtBQUMzRCx5Q0FBeUMsa0JBQWtCO0FBQzNELDRDQUE0QyxvQkFBb0I7QUFDaEUsdUNBQXVDLGdCQUFnQjtBQUN2RCwwQ0FBMEMsbUJBQW1CO0FBQzdELDhDQUE4QyxnQkFBZ0I7QUFDOUQsNENBQTRDLGNBQWM7QUFDMUQsK0NBQStDLGlCQUFpQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEdBQUc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pELGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQ0FBc0M7QUFDdkQsaUNBQWlDLGdCQUFnQjtBQUNqRCxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0JBQWdCO0FBQzdDLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBLG9CQUFvQixVQUFVO0FBQzlCLFFBQVE7QUFDUixxQkFBcUIsNkJBQTZCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNDQUFzQztBQUN2RCxpQ0FBaUMsZ0JBQWdCO0FBQ2pELG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscUJBQXFCLElBQUksMEJBQTBCO0FBQ2pGLE1BQU07QUFDTjtBQUNBLDhCQUE4QixxQkFBcUIsTUFBTSx5QkFBeUI7QUFDbEYsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3V0aWxpdGllcy5qcz9jMGU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGZ1bmMtbmFtZXMgKi9cbi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIGV4cG9ydHMgYSB2YXJpZXR5IG9mIHV0aWxpdHkgZnVuY3Rpb25zIHRoYXQgc3VwcG9ydFxuLy8gW2BhcGdgXShodHRwczovL2dpdGh1Yi5jb20vbGR0aG9tYXMvYXBnLWpzMiksIFtgYXBnLWxpYmBdKGh0dHBzOi8vZ2l0aHViLmNvbS9sZHRob21hcy9hcGctanMyLWxpYilcbi8vIGFuZCB0aGUgZ2VuZXJhdGVkIHBhcnNlciBhcHBsaWNhdGlvbnMuXG5cbmNvbnN0IHN0eWxlID0gcmVxdWlyZSgnLi9zdHlsZScpO1xuY29uc3QgY29udmVydGVyID0gcmVxdWlyZSgnLi4vYXBnLWNvbnYtYXBpL2NvbnZlcnRlcicpO1xuY29uc3QgZW1pdENzcyA9IHJlcXVpcmUoJy4vZW1pdGNzcycpO1xuY29uc3QgaWQgPSByZXF1aXJlKCcuL2lkZW50aWZpZXJzJyk7XG5cbmNvbnN0IHRoaXNGaWxlTmFtZSA9ICd1dGlsaXRpZXMuanM6ICc7XG5jb25zdCB0aGlzVGhpcyA9IHRoaXM7XG5cbi8qIHRyYW5zbGF0ZSAoaW1wbGllZCkgcGhyYXNlIGJlZ2lubmluZyBjaGFyYWN0ZXIgYW5kIGxlbmd0aCB0byBhY3R1YWwgZmlyc3QgYW5kIGxhc3QgY2hhcmFjdGVyIGluZGV4ZXMgKi9cbi8qIHVzZWQgYnkgbXVsdGlwbGUgcGhyYXNlIGhhbmRsaW5nIGZ1bmN0aW9ucyAqL1xuY29uc3QgZ2V0Qm91bmRzID0gZnVuY3Rpb24gKGxlbmd0aCwgYmVnQXJnLCBsZW4pIHtcbiAgbGV0IGVuZDtcbiAgbGV0IGJlZyA9IGJlZ0FyZztcbiAgY29uc3QgVFJVRSA9IHRydWU7XG4gIHdoaWxlIChUUlVFKSB7XG4gICAgaWYgKGxlbmd0aCA8PSAwKSB7XG4gICAgICBiZWcgPSAwO1xuICAgICAgZW5kID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGJlZyAhPT0gJ251bWJlcicpIHtcbiAgICAgIGJlZyA9IDA7XG4gICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGJlZyA+PSBsZW5ndGgpIHtcbiAgICAgIGJlZyA9IGxlbmd0aDtcbiAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGxlbiAhPT0gJ251bWJlcicpIHtcbiAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBlbmQgPSBiZWcgKyBsZW47XG4gICAgaWYgKGVuZCA+IGxlbmd0aCkge1xuICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB7XG4gICAgYmVnLFxuICAgIGVuZCxcbiAgfTtcbn07XG4vLyBHZW5lcmF0ZXMgYSBjb21wbGV0ZSwgbWluaW1hbCBIVE1MNSBwYWdlLCBpbnNlcnRpbmcgdGhlIHVzZXIncyBIVE1MIHRleHQgb24gdGhlIHBhZ2UuXG4vLyAtICpodG1sKiAtIHRoZSBwYWdlIHRleHQgaW4gSFRNTCBmb3JtYXRcbi8vIC0gKnRpdGxlKiAtIHRoZSBIVE1MIHBhZ2UgYDx0aXRsZT5gIC0gZGVmYXVsdHMgdG8gYGh0bWxUb1BhZ2VgLlxuZXhwb3J0cy5odG1sVG9QYWdlID0gZnVuY3Rpb24gKGh0bWwsIHRpdGxlQXJnKSB7XG4gIGxldCB0aXRsZTtcbiAgaWYgKHR5cGVvZiBodG1sICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9aHRtbFRvUGFnZTogaW5wdXQgSFRNTCBpcyBub3QgYSBzdHJpbmdgKTtcbiAgfVxuICBpZiAodHlwZW9mIHRpdGxlQXJnICE9PSAnc3RyaW5nJykge1xuICAgIHRpdGxlID0gJ2h0bWxUb1BhZ2UnO1xuICB9IGVsc2Uge1xuICAgIHRpdGxlID0gdGl0bGVBcmc7XG4gIH1cbiAgbGV0IHBhZ2UgPSAnJztcbiAgcGFnZSArPSAnPCFET0NUWVBFIGh0bWw+XFxuJztcbiAgcGFnZSArPSAnPGh0bWwgbGFuZz1cImVuXCI+XFxuJztcbiAgcGFnZSArPSAnPGhlYWQ+XFxuJztcbiAgcGFnZSArPSAnPG1ldGEgY2hhcnNldD1cInV0Zi04XCI+XFxuJztcbiAgcGFnZSArPSBgPHRpdGxlPiR7dGl0bGV9PC90aXRsZT5cXG5gO1xuICBwYWdlICs9ICc8c3R5bGU+XFxuJztcbiAgcGFnZSArPSBlbWl0Q3NzKCk7XG4gIHBhZ2UgKz0gJzwvc3R5bGU+XFxuJztcbiAgcGFnZSArPSAnPC9oZWFkPlxcbjxib2R5Plxcbic7XG4gIHBhZ2UgKz0gYDxwPiR7bmV3IERhdGUoKX08L3A+XFxuYDtcbiAgcGFnZSArPSBodG1sO1xuICBwYWdlICs9ICc8L2JvZHk+XFxuPC9odG1sPlxcbic7XG4gIHJldHVybiBwYWdlO1xufTtcbi8vIEZvcm1hdHMgdGhlIHJldHVybmVkIG9iamVjdCBmcm9tIGBwYXJzZXIucGFyc2UoKWBcbi8vIGludG8gYW4gSFRNTCB0YWJsZS5cbi8vIGBgYFxuLy8gcmV0dXJuIHtcbi8vICAgc3VjY2VzcyA6IHN5c0RhdGEuc3VjY2Vzcyxcbi8vICAgc3RhdGUgOiBzeXNEYXRhLnN0YXRlLFxuLy8gICBsZW5ndGggOiBjaGFyc0xlbmd0aCxcbi8vICAgbWF0Y2hlZCA6IHN5c0RhdGEucGhyYXNlTGVuZ3RoLFxuLy8gICBtYXhNYXRjaGVkIDogbWF4TWF0Y2hlZCxcbi8vICAgbWF4VHJlZURlcHRoIDogbWF4VHJlZURlcHRoLFxuLy8gICBub2RlSGl0cyA6IG5vZGVIaXRzLFxuLy8gICBpbnB1dExlbmd0aCA6IGNoYXJzLmxlbmd0aCxcbi8vICAgc3ViQmVnaW4gOiBjaGFyc0JlZ2luLFxuLy8gICBzdWJFbmQgOiBjaGFyc0VuZCxcbi8vICAgc3ViTGVuZ3RoIDogY2hhcnNMZW5ndGhcbi8vIH07XG4vLyBgYGBcbmV4cG9ydHMucGFyc2VyUmVzdWx0VG9IdG1sID0gZnVuY3Rpb24gKHJlc3VsdCwgY2FwdGlvbikge1xuICBsZXQgY2FwID0gbnVsbDtcbiAgaWYgKHR5cGVvZiBjYXB0aW9uID09PSAnc3RyaW5nJyAmJiBjYXB0aW9uICE9PSAnJykge1xuICAgIGNhcCA9IGNhcHRpb247XG4gIH1cbiAgbGV0IHN1Y2Nlc3M7XG4gIGxldCBzdGF0ZTtcbiAgaWYgKHJlc3VsdC5zdWNjZXNzID09PSB0cnVlKSB7XG4gICAgc3VjY2VzcyA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTUFUQ0h9XCI+dHJ1ZTwvc3Bhbj5gO1xuICB9IGVsc2Uge1xuICAgIHN1Y2Nlc3MgPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX05PTUFUQ0h9XCI+ZmFsc2U8L3NwYW4+YDtcbiAgfVxuICBpZiAocmVzdWx0LnN0YXRlID09PSBpZC5FTVBUWSkge1xuICAgIHN0YXRlID0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19FTVBUWX1cIj5FTVBUWTwvc3Bhbj5gO1xuICB9IGVsc2UgaWYgKHJlc3VsdC5zdGF0ZSA9PT0gaWQuTUFUQ0gpIHtcbiAgICBzdGF0ZSA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTUFUQ0h9XCI+TUFUQ0g8L3NwYW4+YDtcbiAgfSBlbHNlIGlmIChyZXN1bHQuc3RhdGUgPT09IGlkLk5PTUFUQ0gpIHtcbiAgICBzdGF0ZSA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTk9NQVRDSH1cIj5OT01BVENIPC9zcGFuPmA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUgPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX05PTUFUQ0h9XCI+dW5yZWNvZ25pemVkPC9zcGFuPmA7XG4gIH1cbiAgbGV0IGh0bWwgPSAnJztcbiAgaHRtbCArPSBgPHRhYmxlIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19TVEFURX1cIj5cXG5gO1xuICBpZiAoY2FwKSB7XG4gICAgaHRtbCArPSBgPGNhcHRpb24+JHtjYXB9PC9jYXB0aW9uPlxcbmA7XG4gIH1cbiAgaHRtbCArPSAnPHRyPjx0aD5zdGF0ZSBpdGVtPC90aD48dGg+dmFsdWU8L3RoPjx0aD5kZXNjcmlwdGlvbjwvdGg+PC90cj5cXG4nO1xuICBodG1sICs9IGA8dHI+PHRkPnBhcnNlciBzdWNjZXNzPC90ZD48dGQ+JHtzdWNjZXNzfTwvdGQ+XFxuYDtcbiAgaHRtbCArPSBgPHRkPjxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj50cnVlPC9zcGFuPiBpZiB0aGUgcGFyc2Ugc3VjY2VlZGVkLFxcbmA7XG4gIGh0bWwgKz0gYCA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTk9NQVRDSH1cIj5mYWxzZTwvc3Bhbj4gb3RoZXJ3aXNlYDtcbiAgaHRtbCArPSAnPGJyPjxpPk5PVEU6IGZvciBzdWNjZXNzLCBlbnRpcmUgc3RyaW5nIG11c3QgYmUgbWF0Y2hlZDwvaT48L3RkPjwvdHI+XFxuJztcbiAgaHRtbCArPSBgPHRyPjx0ZD5wYXJzZXIgc3RhdGU8L3RkPjx0ZD4ke3N0YXRlfTwvdGQ+XFxuYDtcbiAgaHRtbCArPSBgPHRkPjxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19FTVBUWX1cIj5FTVBUWTwvc3Bhbj4sIGA7XG4gIGh0bWwgKz0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj5NQVRDSDwvc3Bhbj4gb3IgXFxuYDtcbiAgaHRtbCArPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX05PTUFUQ0h9XCI+Tk9NQVRDSDwvc3Bhbj48L3RkPjwvdHI+XFxuYDtcbiAgaHRtbCArPSBgPHRyPjx0ZD5zdHJpbmcgbGVuZ3RoPC90ZD48dGQ+JHtyZXN1bHQubGVuZ3RofTwvdGQ+PHRkPmxlbmd0aCBvZiB0aGUgaW5wdXQgKHN1YilzdHJpbmc8L3RkPjwvdHI+XFxuYDtcbiAgaHRtbCArPSBgPHRyPjx0ZD5tYXRjaGVkIGxlbmd0aDwvdGQ+PHRkPiR7cmVzdWx0Lm1hdGNoZWR9PC90ZD48dGQ+bnVtYmVyIG9mIGlucHV0IHN0cmluZyBjaGFyYWN0ZXJzIG1hdGNoZWQ8L3RkPjwvdHI+XFxuYDtcbiAgaHRtbCArPSBgPHRyPjx0ZD5tYXggbWF0Y2hlZDwvdGQ+PHRkPiR7cmVzdWx0Lm1heE1hdGNoZWR9PC90ZD48dGQ+bWF4aW11bSBudW1iZXIgb2YgaW5wdXQgc3RyaW5nIGNoYXJhY3RlcnMgbWF0Y2hlZDwvdGQ+PC90cj5cXG5gO1xuICBodG1sICs9IGA8dHI+PHRkPm1heCB0cmVlIGRlcHRoPC90ZD48dGQ+JHtyZXN1bHQubWF4VHJlZURlcHRofTwvdGQ+PHRkPm1heGltdW0gZGVwdGggb2YgdGhlIHBhcnNlIHRyZWUgcmVhY2hlZDwvdGQ+PC90cj5cXG5gO1xuICBodG1sICs9IGA8dHI+PHRkPm5vZGUgaGl0czwvdGQ+PHRkPiR7cmVzdWx0Lm5vZGVIaXRzfTwvdGQ+PHRkPm51bWJlciBvZiBwYXJzZSB0cmVlIG5vZGUgaGl0cyAob3Bjb2RlIGZ1bmN0aW9uIGNhbGxzKTwvdGQ+PC90cj5cXG5gO1xuICBodG1sICs9IGA8dHI+PHRkPmlucHV0IGxlbmd0aDwvdGQ+PHRkPiR7cmVzdWx0LmlucHV0TGVuZ3RofTwvdGQ+PHRkPmxlbmd0aCBvZiBmdWxsIGlucHV0IHN0cmluZzwvdGQ+PC90cj5cXG5gO1xuICBodG1sICs9IGA8dHI+PHRkPnN1Yi1zdHJpbmcgYmVnaW48L3RkPjx0ZD4ke3Jlc3VsdC5zdWJCZWdpbn08L3RkPjx0ZD5zdWItc3RyaW5nIGZpcnN0IGNoYXJhY3RlciBpbmRleDwvdGQ+PC90cj5cXG5gO1xuICBodG1sICs9IGA8dHI+PHRkPnN1Yi1zdHJpbmcgZW5kPC90ZD48dGQ+JHtyZXN1bHQuc3ViRW5kfTwvdGQ+PHRkPnN1Yi1zdHJpbmcgZW5kLW9mLXN0cmluZyBpbmRleDwvdGQ+PC90cj5cXG5gO1xuICBodG1sICs9IGA8dHI+PHRkPnN1Yi1zdHJpbmcgbGVuZ3RoPC90ZD48dGQ+JHtyZXN1bHQuc3ViTGVuZ3RofTwvdGQ+PHRkPnN1Yi1zdHJpbmcgbGVuZ3RoPC90ZD48L3RyPlxcbmA7XG4gIGh0bWwgKz0gJzwvdGFibGU+XFxuJztcbiAgcmV0dXJuIGh0bWw7XG59O1xuLy8gVHJhbnNsYXRlcyBhIHN1Yi1hcnJheSBvZiBpbnRlZ2VyIGNoYXJhY3RlciBjb2RlcyBpbnRvIGEgc3RyaW5nLlxuLy8gVmVyeSB1c2VmdWwgaW4gY2FsbGJhY2sgZnVuY3Rpb25zIHRvIHRyYW5zbGF0ZSB0aGUgbWF0Y2hlZCBwaHJhc2VzIGludG8gc3RyaW5ncy5cbmV4cG9ydHMuY2hhcnNUb1N0cmluZyA9IGZ1bmN0aW9uIChjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUxlbmd0aCkge1xuICBsZXQgYmVnO1xuICBsZXQgZW5kO1xuICBpZiAodHlwZW9mIHBocmFzZUluZGV4ID09PSAnbnVtYmVyJykge1xuICAgIGlmIChwaHJhc2VJbmRleCA+PSBjaGFycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgYmVnID0gcGhyYXNlSW5kZXggPCAwID8gMCA6IHBocmFzZUluZGV4O1xuICB9IGVsc2Uge1xuICAgIGJlZyA9IDA7XG4gIH1cbiAgaWYgKHR5cGVvZiBwaHJhc2VMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHBocmFzZUxlbmd0aCA8PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGVuZCA9IHBocmFzZUxlbmd0aCA+IGNoYXJzLmxlbmd0aCAtIGJlZyA/IGNoYXJzLmxlbmd0aCA6IGJlZyArIHBocmFzZUxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICBlbmQgPSBjaGFycy5sZW5ndGg7XG4gIH1cbiAgaWYgKGJlZyA8IGVuZCkge1xuICAgIHJldHVybiBjb252ZXJ0ZXIuZW5jb2RlKCdVVEYxNkxFJywgY2hhcnMuc2xpY2UoYmVnLCBlbmQpKS50b1N0cmluZygndXRmMTZsZScpO1xuICB9XG4gIHJldHVybiAnJztcbn07XG4vLyBUcmFuc2xhdGVzIGEgc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgaW50ZWdlciBjaGFyYWN0ZXIgY29kZXMuXG5leHBvcnRzLnN0cmluZ1RvQ2hhcnMgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBjb252ZXJ0ZXIuZGVjb2RlKCdTVFJJTkcnLCBzdHJpbmcpO1xufTtcbi8vIFRyYW5zbGF0ZXMgYW4gb3Bjb2RlIGlkZW50aWZpZXIgaW50byBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZy5cbmV4cG9ydHMub3Bjb2RlVG9TdHJpbmcgPSBmdW5jdGlvbiAodHlwZSkge1xuICBsZXQgcmV0ID0gJ3Vua25vd24nO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGlkLkFMVDpcbiAgICAgIHJldCA9ICdBTFQnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5DQVQ6XG4gICAgICByZXQgPSAnQ0FUJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuUk5NOlxuICAgICAgcmV0ID0gJ1JOTSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLlVEVDpcbiAgICAgIHJldCA9ICdVRFQnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5BTkQ6XG4gICAgICByZXQgPSAnQU5EJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuTk9UOlxuICAgICAgcmV0ID0gJ05PVCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLlJFUDpcbiAgICAgIHJldCA9ICdSRVAnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5UUkc6XG4gICAgICByZXQgPSAnVFJHJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuVEJTOlxuICAgICAgcmV0ID0gJ1RCUyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLlRMUzpcbiAgICAgIHJldCA9ICdUTFMnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5CS1I6XG4gICAgICByZXQgPSAnQktSJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuQktBOlxuICAgICAgcmV0ID0gJ0JLQSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLkJLTjpcbiAgICAgIHJldCA9ICdCS04nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5BQkc6XG4gICAgICByZXQgPSAnQUJHJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuQUVOOlxuICAgICAgcmV0ID0gJ0FFTic7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgb3Bjb2RlJyk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG4vLyBUcmFuc2xhdGVzIGFuIHN0YXRlIGlkZW50aWZpZXIgaW50byBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZy5cbmV4cG9ydHMuc3RhdGVUb1N0cmluZyA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICBsZXQgcmV0ID0gJ3Vua25vd24nO1xuICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICByZXQgPSAnQUNUSVZFJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICByZXQgPSAnTUFUQ0gnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgIHJldCA9ICdFTVBUWSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICByZXQgPSAnTk9NQVRDSCc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgc3RhdGUnKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbi8vIEFycmF5IHdoaWNoIHRyYW5zbGF0ZXMgYWxsIDEyOCwgNy1iaXQgQVNDSUkgY2hhcmFjdGVyIGNvZGVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgSFRNTCBmb3JtYXQuXG5leHBvcnRzLmFzY2lpQ2hhcnMgPSBbXG4gICdOVUwnLFxuICAnU09IJyxcbiAgJ1NUWCcsXG4gICdFVFgnLFxuICAnRU9UJyxcbiAgJ0VOUScsXG4gICdBQ0snLFxuICAnQkVMJyxcbiAgJ0JTJyxcbiAgJ1RBQicsXG4gICdMRicsXG4gICdWVCcsXG4gICdGRicsXG4gICdDUicsXG4gICdTTycsXG4gICdTSScsXG4gICdETEUnLFxuICAnREMxJyxcbiAgJ0RDMicsXG4gICdEQzMnLFxuICAnREM0JyxcbiAgJ05BSycsXG4gICdTWU4nLFxuICAnRVRCJyxcbiAgJ0NBTicsXG4gICdFTScsXG4gICdTVUInLFxuICAnRVNDJyxcbiAgJ0ZTJyxcbiAgJ0dTJyxcbiAgJ1JTJyxcbiAgJ1VTJyxcbiAgJyZuYnNwOycsXG4gICchJyxcbiAgJyYjMzQ7JyxcbiAgJyMnLFxuICAnJCcsXG4gICclJyxcbiAgJyYjMzg7JyxcbiAgJyYjMzk7JyxcbiAgJygnLFxuICAnKScsXG4gICcqJyxcbiAgJysnLFxuICAnLCcsXG4gICctJyxcbiAgJy4nLFxuICAnLycsXG4gICcwJyxcbiAgJzEnLFxuICAnMicsXG4gICczJyxcbiAgJzQnLFxuICAnNScsXG4gICc2JyxcbiAgJzcnLFxuICAnOCcsXG4gICc5JyxcbiAgJzonLFxuICAnOycsXG4gICcmIzYwOycsXG4gICc9JyxcbiAgJyYjNjI7JyxcbiAgJz8nLFxuICAnQCcsXG4gICdBJyxcbiAgJ0InLFxuICAnQycsXG4gICdEJyxcbiAgJ0UnLFxuICAnRicsXG4gICdHJyxcbiAgJ0gnLFxuICAnSScsXG4gICdKJyxcbiAgJ0snLFxuICAnTCcsXG4gICdNJyxcbiAgJ04nLFxuICAnTycsXG4gICdQJyxcbiAgJ1EnLFxuICAnUicsXG4gICdTJyxcbiAgJ1QnLFxuICAnVScsXG4gICdWJyxcbiAgJ1cnLFxuICAnWCcsXG4gICdZJyxcbiAgJ1onLFxuICAnWycsXG4gICcmIzkyOycsXG4gICddJyxcbiAgJ14nLFxuICAnXycsXG4gICdgJyxcbiAgJ2EnLFxuICAnYicsXG4gICdjJyxcbiAgJ2QnLFxuICAnZScsXG4gICdmJyxcbiAgJ2cnLFxuICAnaCcsXG4gICdpJyxcbiAgJ2onLFxuICAnaycsXG4gICdsJyxcbiAgJ20nLFxuICAnbicsXG4gICdvJyxcbiAgJ3AnLFxuICAncScsXG4gICdyJyxcbiAgJ3MnLFxuICAndCcsXG4gICd1JyxcbiAgJ3YnLFxuICAndycsXG4gICd4JyxcbiAgJ3knLFxuICAneicsXG4gICd7JyxcbiAgJ3wnLFxuICAnfScsXG4gICd+JyxcbiAgJ0RFTCcsXG5dO1xuLy8gVHJhbnNsYXRlcyBhIHNpbmdsZSBjaGFyYWN0ZXIgdG8gaGV4YWRlY2ltYWwgd2l0aCBsZWFkaW5nIHplcm9zIGZvciAyLCA0LCBvciA4IGRpZ2l0IGRpc3BsYXkuXG5leHBvcnRzLmNoYXJUb0hleCA9IGZ1bmN0aW9uIChjaGFyKSB7XG4gIGxldCBjaCA9IGNoYXIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gIHN3aXRjaCAoY2gubGVuZ3RoKSB7XG4gICAgY2FzZSAxOlxuICAgIGNhc2UgMzpcbiAgICBjYXNlIDc6XG4gICAgICBjaCA9IGAwJHtjaH1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgIGNhc2UgNjpcbiAgICAgIGNoID0gYDAwJHtjaH1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSA1OlxuICAgICAgY2ggPSBgMDAwJHtjaH1gO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIG9wdGlvbicpO1xuICB9XG4gIHJldHVybiBjaDtcbn07XG4vLyBUcmFuc2xhdGVzIGEgc3ViLWFycmF5IG9mIGNoYXJhY3RlciBjb2RlcyB0byBkZWNpbWFsIGRpc3BsYXkgZm9ybWF0LlxuZXhwb3J0cy5jaGFyc1RvRGVjID0gZnVuY3Rpb24gKGNoYXJzLCBiZWcsIGxlbikge1xuICBsZXQgcmV0ID0gJyc7XG4gIGlmICghQXJyYXkuaXNBcnJheShjaGFycykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWNoYXJzVG9EZWM6IGlucHV0IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50ZWdlcnNgKTtcbiAgfVxuICBjb25zdCBib3VuZHMgPSBnZXRCb3VuZHMoY2hhcnMubGVuZ3RoLCBiZWcsIGxlbik7XG4gIGlmIChib3VuZHMuZW5kID4gYm91bmRzLmJlZykge1xuICAgIHJldCArPSBjaGFyc1tib3VuZHMuYmVnXTtcbiAgICBmb3IgKGxldCBpID0gYm91bmRzLmJlZyArIDE7IGkgPCBib3VuZHMuZW5kOyBpICs9IDEpIHtcbiAgICAgIHJldCArPSBgLCR7Y2hhcnNbaV19YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG4vLyBUcmFuc2xhdGVzIGEgc3ViLWFycmF5IG9mIGNoYXJhY3RlciBjb2RlcyB0byBoZXhhZGVjaW1hbCBkaXNwbGF5IGZvcm1hdC5cbmV4cG9ydHMuY2hhcnNUb0hleCA9IGZ1bmN0aW9uIChjaGFycywgYmVnLCBsZW4pIHtcbiAgbGV0IHJldCA9ICcnO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY2hhcnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1jaGFyc1RvSGV4OiBpbnB1dCBtdXN0IGJlIGFuIGFycmF5IG9mIGludGVnZXJzYCk7XG4gIH1cbiAgY29uc3QgYm91bmRzID0gZ2V0Qm91bmRzKGNoYXJzLmxlbmd0aCwgYmVnLCBsZW4pO1xuICBpZiAoYm91bmRzLmVuZCA+IGJvdW5kcy5iZWcpIHtcbiAgICByZXQgKz0gYFxcXFx4JHt0aGlzVGhpcy5jaGFyVG9IZXgoY2hhcnNbYm91bmRzLmJlZ10pfWA7XG4gICAgZm9yIChsZXQgaSA9IGJvdW5kcy5iZWcgKyAxOyBpIDwgYm91bmRzLmVuZDsgaSArPSAxKSB7XG4gICAgICByZXQgKz0gYCxcXFxceCR7dGhpc1RoaXMuY2hhclRvSGV4KGNoYXJzW2ldKX1gO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbmV4cG9ydHMuY2hhcnNUb0h0bWxFbnRpdGllcyA9IGZ1bmN0aW9uIChjaGFycywgYmVnLCBsZW4pIHtcbiAgbGV0IHJldCA9ICcnO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY2hhcnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1jaGFyc1RvSGV4OiBpbnB1dCBtdXN0IGJlIGFuIGFycmF5IG9mIGludGVnZXJzYCk7XG4gIH1cbiAgY29uc3QgYm91bmRzID0gZ2V0Qm91bmRzKGNoYXJzLmxlbmd0aCwgYmVnLCBsZW4pO1xuICBpZiAoYm91bmRzLmVuZCA+IGJvdW5kcy5iZWcpIHtcbiAgICBmb3IgKGxldCBpID0gYm91bmRzLmJlZzsgaSA8IGJvdW5kcy5lbmQ7IGkgKz0gMSkge1xuICAgICAgcmV0ICs9IGAmI3gke2NoYXJzW2ldLnRvU3RyaW5nKDE2KX07YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG4vLyBUcmFuc2xhdGVzIGEgc3ViLWFycmF5IG9mIGNoYXJhY3RlciBjb2RlcyB0byBVbmljb2RlIGRpc3BsYXkgZm9ybWF0LlxuZnVuY3Rpb24gaXNVbmljb2RlKGNoYXIpIHtcbiAgaWYgKGNoYXIgPj0gMHhkODAwICYmIGNoYXIgPD0gMHhkZmZmKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChjaGFyID4gMHgxMGZmZmYpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmNoYXJzVG9Vbmljb2RlID0gZnVuY3Rpb24gKGNoYXJzLCBiZWcsIGxlbikge1xuICBsZXQgcmV0ID0gJyc7XG4gIGlmICghQXJyYXkuaXNBcnJheShjaGFycykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWNoYXJzVG9Vbmljb2RlOiBpbnB1dCBtdXN0IGJlIGFuIGFycmF5IG9mIGludGVnZXJzYCk7XG4gIH1cbiAgY29uc3QgYm91bmRzID0gZ2V0Qm91bmRzKGNoYXJzLmxlbmd0aCwgYmVnLCBsZW4pO1xuICBpZiAoYm91bmRzLmVuZCA+IGJvdW5kcy5iZWcpIHtcbiAgICBmb3IgKGxldCBpID0gYm91bmRzLmJlZzsgaSA8IGJvdW5kcy5lbmQ7IGkgKz0gMSkge1xuICAgICAgaWYgKGlzVW5pY29kZShjaGFyc1tpXSkpIHtcbiAgICAgICAgcmV0ICs9IGAmIyR7Y2hhcnNbaV19O2A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgKz0gYCBVKyR7dGhpc1RoaXMuY2hhclRvSGV4KGNoYXJzW2ldKX1gO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbi8vIFRyYW5zbGF0ZXMgYSBzdWItYXJyYXkgb2YgY2hhcmFjdGVyIGNvZGVzIHRvIEphdmFTY3JpcHQgVW5pY29kZSBkaXNwbGF5IGZvcm1hdCAoYFxcdVhYWFhgKS5cbmV4cG9ydHMuY2hhcnNUb0pzVW5pY29kZSA9IGZ1bmN0aW9uIChjaGFycywgYmVnLCBsZW4pIHtcbiAgbGV0IHJldCA9ICcnO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY2hhcnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1jaGFyc1RvSnNVbmljb2RlOiBpbnB1dCBtdXN0IGJlIGFuIGFycmF5IG9mIGludGVnZXJzYCk7XG4gIH1cbiAgY29uc3QgYm91bmRzID0gZ2V0Qm91bmRzKGNoYXJzLmxlbmd0aCwgYmVnLCBsZW4pO1xuICBpZiAoYm91bmRzLmVuZCA+IGJvdW5kcy5iZWcpIHtcbiAgICByZXQgKz0gYFxcXFx1JHt0aGlzVGhpcy5jaGFyVG9IZXgoY2hhcnNbYm91bmRzLmJlZ10pfWA7XG4gICAgZm9yIChsZXQgaSA9IGJvdW5kcy5iZWcgKyAxOyBpIDwgYm91bmRzLmVuZDsgaSArPSAxKSB7XG4gICAgICByZXQgKz0gYCxcXFxcdSR7dGhpc1RoaXMuY2hhclRvSGV4KGNoYXJzW2ldKX1gO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbi8vIFRyYW5zbGF0ZXMgYSBzdWItYXJyYXkgb2YgY2hhcmFjdGVyIGNvZGVzIHRvIHByaW50aW5nIEFTQ0lJIGNoYXJhY3RlciBkaXNwbGF5IGZvcm1hdC5cbmV4cG9ydHMuY2hhcnNUb0FzY2lpID0gZnVuY3Rpb24gKGNoYXJzLCBiZWcsIGxlbikge1xuICBsZXQgcmV0ID0gJyc7XG4gIGlmICghQXJyYXkuaXNBcnJheShjaGFycykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWNoYXJzVG9Bc2NpaTogaW5wdXQgbXVzdCBiZSBhbiBhcnJheSBvZiBpbnRlZ2Vyc2ApO1xuICB9XG4gIGNvbnN0IGJvdW5kcyA9IGdldEJvdW5kcyhjaGFycy5sZW5ndGgsIGJlZywgbGVuKTtcbiAgZm9yIChsZXQgaSA9IGJvdW5kcy5iZWc7IGkgPCBib3VuZHMuZW5kOyBpICs9IDEpIHtcbiAgICBjb25zdCBjaGFyID0gY2hhcnNbaV07XG4gICAgaWYgKGNoYXIgPj0gMzIgJiYgY2hhciA8PSAxMjYpIHtcbiAgICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQgKz0gYFxcXFx4JHt0aGlzVGhpcy5jaGFyVG9IZXgoY2hhcil9YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG4vLyBUcmFuc2xhdGVzIGEgc3ViLWFycmF5IG9mIGNoYXJhY3RlciBjb2RlcyB0byBIVE1MIGRpc3BsYXkgZm9ybWF0LlxuZXhwb3J0cy5jaGFyc1RvQXNjaWlIdG1sID0gZnVuY3Rpb24gKGNoYXJzLCBiZWcsIGxlbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY2hhcnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1jaGFyc1RvQXNjaWlIdG1sOiBpbnB1dCBtdXN0IGJlIGFuIGFycmF5IG9mIGludGVnZXJzYCk7XG4gIH1cbiAgbGV0IGh0bWwgPSAnJztcbiAgbGV0IGNoYXI7XG4gIGNvbnN0IGJvdW5kcyA9IGdldEJvdW5kcyhjaGFycy5sZW5ndGgsIGJlZywgbGVuKTtcbiAgZm9yIChsZXQgaSA9IGJvdW5kcy5iZWc7IGkgPCBib3VuZHMuZW5kOyBpICs9IDEpIHtcbiAgICBjaGFyID0gY2hhcnNbaV07XG4gICAgaWYgKGNoYXIgPCAzMiB8fCBjaGFyID09PSAxMjcpIHtcbiAgICAgIC8qIGNvbnRyb2wgY2hhcmFjdGVycyAqL1xuICAgICAgaHRtbCArPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0NUUkxDSEFSfVwiPiR7dGhpc1RoaXMuYXNjaWlDaGFyc1tjaGFyXX08L3NwYW4+YDtcbiAgICB9IGVsc2UgaWYgKGNoYXIgPiAxMjcpIHtcbiAgICAgIC8qIG5vbi1BU0NJSSAqL1xuICAgICAgaHRtbCArPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0NUUkxDSEFSfVwiPlUrJHt0aGlzVGhpcy5jaGFyVG9IZXgoY2hhcil9PC9zcGFuPmA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIHByaW50aW5nIEFTQ0lJLCAzMiA8PSBjaGFyIDw9IDEyNiAqL1xuICAgICAgaHRtbCArPSB0aGlzVGhpcy5hc2NpaUNoYXJzW2NoYXJdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaHRtbDtcbn07XG4vLyBUcmFuc2xhdGVzIGEgSmF2YVNjcmlwdCBzdHJpbmcgdG8gSFRNTCBkaXNwbGF5IGZvcm1hdC5cbmV4cG9ydHMuc3RyaW5nVG9Bc2NpaUh0bWwgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIGNvbnN0IGNoYXJzID0gY29udmVydGVyLmRlY29kZSgnU1RSSU5HJywgc3RyKTtcbiAgcmV0dXJuIHRoaXMuY2hhcnNUb0FzY2lpSHRtbChjaGFycyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/apg-js/src/apg-lib/utilities.js\n"));

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzPzM3NzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxvREFBVztBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyxnREFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLHlCQUF5Qjs7QUFFekI7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EscUJBQXFCLFdBQVcsR0FBRyxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsZ0JBQWdCLFdBQVcsR0FBRyxJQUFJLEtBQUssYUFBYTtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixLQUFLLG1EQUFtRCxjQUFjO0FBQ3pGLEdBQUc7QUFDSDtBQUNBO0FBQ0EsK0JBQStCLElBQUk7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNLGFBQWEsU0FBUztBQUN0RDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdCQUFnQjtBQUN6QixjQUFjLG9CQUFvQixFQUFFLElBQUk7QUFDeEM7QUFDQSxZQUFZLGdCQUFnQixFQUFFLElBQUk7QUFDbEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEdBQUcsU0FBUyxHQUFHLEtBQUsscUJBQXFCLEVBQUUsRUFBRTtBQUNwRSxRQUFRO0FBQ1IseUJBQXlCLEdBQUcsS0FBSyx5QkFBeUIsRUFBRSxFQUFFO0FBQzlELG1CQUFtQix5QkFBeUIsRUFBRSxFQUFFO0FBQ2hEO0FBQ0EsTUFBTTtBQUNOLG9CQUFvQixJQUFJLEVBQUUsR0FBRyxTQUFTLElBQUksRUFBRSxFQUFFO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxjQUFjLFNBQVMsT0FBTztBQUN4RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanM/OTAxZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxuY29uc3QgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuY29uc3QgY3VzdG9tSW5zcGVjdFN5bWJvbCA9XG4gICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2xbJ2ZvciddID09PSAnZnVuY3Rpb24nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgID8gU3ltYm9sWydmb3InXSgnbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIDogbnVsbFxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbmNvbnN0IEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgY29uc3QgcHJvdG8gPSB7IGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3RvLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJyLCBwcm90bylcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5Vmlldyh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICBjb25zdCB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBjb25zdCBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsIFVpbnQ4QXJyYXkpXG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIGxldCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIGNvbnN0IGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5VmlldyAoYXJyYXlWaWV3KSB7XG4gIGlmIChpc0luc3RhbmNlKGFycmF5VmlldywgVWludDhBcnJheSkpIHtcbiAgICBjb25zdCBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlWaWV3KVxuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIoY29weS5idWZmZXIsIGNvcHkuYnl0ZU9mZnNldCwgY29weS5ieXRlTGVuZ3RoKVxuICB9XG4gIHJldHVybiBmcm9tQXJyYXlMaWtlKGFycmF5Vmlldylcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGxldCBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgY29uc3QgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgbGV0IHggPSBhLmxlbmd0aFxuICBsZXQgeSA9IGIubGVuZ3RoXG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICBsZXQgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIGxldCBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBpZiAocG9zICsgYnVmLmxlbmd0aCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICBidWYsXG4gICAgICAgICAgcG9zXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgfVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgY29uc3QgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBjb25zdCBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcmNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICBjb25zdCBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICBsZXQgc3RyID0gJydcbiAgY29uc3QgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cbmlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBCdWZmZXIucHJvdG90eXBlLmluc3BlY3Rcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgbGV0IHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIGxldCB5ID0gZW5kIC0gc3RhcnRcbiAgY29uc3QgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICBjb25zdCB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICBjb25zdCB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgbGV0IGluZGV4U2l6ZSA9IDFcbiAgbGV0IGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgbGV0IHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGRpcikge1xuICAgIGxldCBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGxldCBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgY29uc3QgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGxldCBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICBjb25zdCByZXMgPSBbXVxuXG4gIGxldCBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICBsZXQgY29kZVBvaW50ID0gbnVsbFxuICAgIGxldCBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpXG4gICAgICA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpXG4gICAgICAgICAgPyAzXG4gICAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRilcbiAgICAgICAgICAgICAgPyAyXG4gICAgICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgbGV0IHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxuY29uc3QgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIGNvbnN0IGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIGxldCBvdXQgPSAnJ1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIGxldCByZXMgPSAnJ1xuICAvLyBJZiBieXRlcy5sZW5ndGggaXMgb2RkLCB0aGUgbGFzdCA4IGJpdHMgbXVzdCBiZSBpZ25vcmVkIChzYW1lIGFzIG5vZGUuanMpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIGNvbnN0IG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld0J1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgbGV0IG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCBsbyA9IGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjRcblxuICBjb25zdCBoaSA9IHRoaXNbKytvZmZzZXRdICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICBsYXN0ICogMiAqKiAyNFxuXG4gIHJldHVybiBCaWdJbnQobG8pICsgKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGhpID0gZmlyc3QgKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XVxuXG4gIGNvbnN0IGxvID0gdGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0XG5cbiAgcmV0dXJuIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KGxvKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XVxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aFxuICBsZXQgbXVsID0gMVxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyA0XSArXG4gICAgdGhpc1tvZmZzZXQgKyA1XSAqIDIgKiogOCArXG4gICAgdGhpc1tvZmZzZXQgKyA2XSAqIDIgKiogMTYgK1xuICAgIChsYXN0IDw8IDI0KSAvLyBPdmVyZmxvd1xuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludChmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IChmaXJzdCA8PCAyNCkgKyAvLyBPdmVyZmxvd1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgbGFzdClcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMVxuICBsZXQgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gd3J0QmlnVUludDY0TEUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KVxuXG4gIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgcmV0dXJuIG9mZnNldFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRCRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgN10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDZdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA1XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNF0gPSBsb1xuICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCArIDNdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAyXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0ICsgMV0gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldF0gPSBoaVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IDBcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIGxldCBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRCRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpXG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgbGV0IGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gQ1VTVE9NIEVSUk9SU1xuLy8gPT09PT09PT09PT09PVxuXG4vLyBTaW1wbGlmaWVkIHZlcnNpb25zIGZyb20gTm9kZSwgY2hhbmdlZCBmb3IgQnVmZmVyLW9ubHkgdXNhZ2VcbmNvbnN0IGVycm9ycyA9IHt9XG5mdW5jdGlvbiBFIChzeW0sIGdldE1lc3NhZ2UsIEJhc2UpIHtcbiAgZXJyb3JzW3N5bV0gPSBjbGFzcyBOb2RlRXJyb3IgZXh0ZW5kcyBCYXNlIHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICBzdXBlcigpXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWVzc2FnZScsIHtcbiAgICAgICAgdmFsdWU6IGdldE1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSlcblxuICAgICAgLy8gQWRkIHRoZSBlcnJvciBjb2RlIHRvIHRoZSBuYW1lIHRvIGluY2x1ZGUgaXQgaW4gdGhlIHN0YWNrIHRyYWNlLlxuICAgICAgdGhpcy5uYW1lID0gYCR7dGhpcy5uYW1lfSBbJHtzeW19XWBcbiAgICAgIC8vIEFjY2VzcyB0aGUgc3RhY2sgdG8gZ2VuZXJhdGUgdGhlIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHRoZSBlcnJvciBjb2RlXG4gICAgICAvLyBmcm9tIHRoZSBuYW1lLlxuICAgICAgdGhpcy5zdGFjayAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgLy8gUmVzZXQgdGhlIG5hbWUgdG8gdGhlIGFjdHVhbCBuYW1lLlxuICAgICAgZGVsZXRlIHRoaXMubmFtZVxuICAgIH1cblxuICAgIGdldCBjb2RlICgpIHtcbiAgICAgIHJldHVybiBzeW1cbiAgICB9XG5cbiAgICBzZXQgY29kZSAodmFsdWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29kZScsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIGAke3RoaXMubmFtZX0gWyR7c3ltfV06ICR7dGhpcy5tZXNzYWdlfWBcbiAgICB9XG4gIH1cbn1cblxuRSgnRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTJyxcbiAgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuIGAke25hbWV9IGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2BcbiAgICB9XG5cbiAgICByZXR1cm4gJ0F0dGVtcHQgdG8gYWNjZXNzIG1lbW9yeSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnXG4gIH0sIFJhbmdlRXJyb3IpXG5FKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsXG4gIGZ1bmN0aW9uIChuYW1lLCBhY3R1YWwpIHtcbiAgICByZXR1cm4gYFRoZSBcIiR7bmFtZX1cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFjdHVhbH1gXG4gIH0sIFR5cGVFcnJvcilcbkUoJ0VSUl9PVVRfT0ZfUkFOR0UnLFxuICBmdW5jdGlvbiAoc3RyLCByYW5nZSwgaW5wdXQpIHtcbiAgICBsZXQgbXNnID0gYFRoZSB2YWx1ZSBvZiBcIiR7c3RyfVwiIGlzIG91dCBvZiByYW5nZS5gXG4gICAgbGV0IHJlY2VpdmVkID0gaW5wdXRcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihpbnB1dCkgJiYgTWF0aC5hYnMoaW5wdXQpID4gMiAqKiAzMikge1xuICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IoU3RyaW5nKGlucHV0KSlcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIHJlY2VpdmVkID0gU3RyaW5nKGlucHV0KVxuICAgICAgaWYgKGlucHV0ID4gQmlnSW50KDIpICoqIEJpZ0ludCgzMikgfHwgaW5wdXQgPCAtKEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpKSkge1xuICAgICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihyZWNlaXZlZClcbiAgICAgIH1cbiAgICAgIHJlY2VpdmVkICs9ICduJ1xuICAgIH1cbiAgICBtc2cgKz0gYCBJdCBtdXN0IGJlICR7cmFuZ2V9LiBSZWNlaXZlZCAke3JlY2VpdmVkfWBcbiAgICByZXR1cm4gbXNnXG4gIH0sIFJhbmdlRXJyb3IpXG5cbmZ1bmN0aW9uIGFkZE51bWVyaWNhbFNlcGFyYXRvciAodmFsKSB7XG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IHZhbC5sZW5ndGhcbiAgY29uc3Qgc3RhcnQgPSB2YWxbMF0gPT09ICctJyA/IDEgOiAwXG4gIGZvciAoOyBpID49IHN0YXJ0ICsgNDsgaSAtPSAzKSB7XG4gICAgcmVzID0gYF8ke3ZhbC5zbGljZShpIC0gMywgaSl9JHtyZXN9YFxuICB9XG4gIHJldHVybiBgJHt2YWwuc2xpY2UoMCwgaSl9JHtyZXN9YFxufVxuXG4vLyBDSEVDSyBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBjaGVja0JvdW5kcyAoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgaWYgKGJ1ZltvZmZzZXRdID09PSB1bmRlZmluZWQgfHwgYnVmW29mZnNldCArIGJ5dGVMZW5ndGhdID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIGJ1Zi5sZW5ndGggLSAoYnl0ZUxlbmd0aCArIDEpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50QkkgKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB7XG4gICAgY29uc3QgbiA9IHR5cGVvZiBtaW4gPT09ICdiaWdpbnQnID8gJ24nIDogJydcbiAgICBsZXQgcmFuZ2VcbiAgICBpZiAoYnl0ZUxlbmd0aCA+IDMpIHtcbiAgICAgIGlmIChtaW4gPT09IDAgfHwgbWluID09PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gMCR7bn0gYW5kIDwgMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOH0ke259YFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gLSgyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259KSBhbmQgPCAyICoqIGAgK1xuICAgICAgICAgICAgICAgIGAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259YFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZSA9IGA+PSAke21pbn0ke259IGFuZCA8PSAke21heH0ke259YFxuICAgIH1cbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UoJ3ZhbHVlJywgcmFuZ2UsIHZhbHVlKVxuICB9XG4gIGNoZWNrQm91bmRzKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlciAodmFsdWUsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdudW1iZXInLCB2YWx1ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBib3VuZHNFcnJvciAodmFsdWUsIGxlbmd0aCwgdHlwZSkge1xuICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSB7XG4gICAgdmFsaWRhdGVOdW1iZXIodmFsdWUsIHR5cGUpXG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsICdhbiBpbnRlZ2VyJywgdmFsdWUpXG4gIH1cblxuICBpZiAobGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTKClcbiAgfVxuXG4gIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICdvZmZzZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYD49ICR7dHlwZSA/IDEgOiAwfSBhbmQgPD0gJHtsZW5ndGh9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlKVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbmNvbnN0IElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICBsZXQgY29kZVBvaW50XG4gIGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgbGV0IGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIGNvbnN0IGJ5dGVzID0gW11cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICBsZXQgYywgaGksIGxvXG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8vIENyZWF0ZSBsb29rdXAgdGFibGUgZm9yIGB0b1N0cmluZygnaGV4JylgXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcbmNvbnN0IGhleFNsaWNlTG9va3VwVGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICBjb25zdCBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJ1xuICBjb25zdCB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIGNvbnN0IGkxNiA9IGkgKiAxNlxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdXG4gICAgfVxuICB9XG4gIHJldHVybiB0YWJsZVxufSkoKVxuXG4vLyBSZXR1cm4gbm90IGZ1bmN0aW9uIHdpdGggRXJyb3IgaWYgQmlnSW50IG5vdCBzdXBwb3J0ZWRcbmZ1bmN0aW9uIGRlZmluZUJpZ0ludE1ldGhvZCAoZm4pIHtcbiAgcmV0dXJuIHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCA6IGZuXG59XG5cbmZ1bmN0aW9uIEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0JpZ0ludCBub3Qgc3VwcG9ydGVkJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/buffer/index.js\n"));

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQSxTQUFTLFVBQVU7O0FBRW5CO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanM/ZWJjMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ieee754/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[5].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[5].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[2].oneOf[5].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[2].oneOf[5].use[4]!./styles/Home.module.scss":
/*!***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[5].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[5].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[2].oneOf[5].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[2].oneOf[5].use[4]!./styles/Home.module.scss ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".Home_container__97eC3 {\\n  padding: 0;\\n  background-color: #2C2C2C;\\n  color: white;\\n}\\n\\n.Home_main__OVLM4 {\\n  min-height: 100vh;\\n  width: 100%;\\n  display: flex;\\n  align-items: center;\\n}\\n\\n.Home_left__PDvAo,\\n.Home_right__Q3ZHY {\\n  display: flex;\\n  /*  justify-content: center; */\\n  height: 100%;\\n  width: 50%;\\n  text-align: left;\\n  flex-wrap: wrap;\\n  align-items: center;\\n}\\n\\n.Home_footer__zed0_ {\\n  display: flex;\\n  flex: 1 1;\\n  padding: 2rem 0;\\n  border-top: 1px solid #eaeaea;\\n  background-color: black;\\n  justify-content: center;\\n  align-items: center;\\n  width: 100%;\\n}\\n\\n.Home_footer__zed0_ a {\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  flex-grow: 1;\\n}\\n\\n.Home_title__q0Qg4 a {\\n  color: black;\\n  text-decoration: none;\\n}\\n\\n.Home_title__q0Qg4 a:hover,\\n.Home_title__q0Qg4 a:focus,\\n.Home_title__q0Qg4 a:active {\\n  text-decoration: underline;\\n}\\n\\n.Home_title__q0Qg4 {\\n  font-weight: 350;\\n  margin: 0 0 0 17%;\\n  font-size: 10rem;\\n}\\n\\n.Home_subTitle__s2Xh0 {\\n  font-weight: 350;\\n  margin: 0 0 0 17%;\\n}\\n\\n.Home_title__q0Qg4,\\n.Home_description__JhekB {\\n  text-align: center;\\n}\\n\\n.Home_description__JhekB {\\n  margin: 4rem 0;\\n  line-height: 1.5;\\n  font-size: 1.5rem;\\n}\\n\\n.Home_code__2i1pD {\\n  background: #fafafa;\\n  border-radius: 5px;\\n  padding: 0.75rem;\\n  font-size: 1.1rem;\\n  font-family: Menlo, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono, Bitstream Vera Sans Mono, Courier New, monospace;\\n}\\n\\n.Home_grid__npx0i {\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  flex-wrap: wrap;\\n  max-width: 800px;\\n}\\n\\n.Home_card__K7aTN {\\n  margin: 1rem;\\n  padding: 1.5rem;\\n  text-align: left;\\n  color: inherit;\\n  text-decoration: none;\\n  border: 1px solid #eaeaea;\\n  border-radius: 10px;\\n  transition: color 0.15s ease, border-color 0.15s ease;\\n  max-width: 300px;\\n}\\n\\n.Home_card__K7aTN:hover,\\n.Home_card__K7aTN:focus,\\n.Home_card__K7aTN:active {\\n  color: #0070f3;\\n  border-color: #0070f3;\\n}\\n\\n.Home_card__K7aTN h2 {\\n  margin: 0 0 1rem 0;\\n  font-size: 1.5rem;\\n}\\n\\n.Home_card__K7aTN p {\\n  margin: 0;\\n  font-size: 1.25rem;\\n  line-height: 1.5;\\n}\\n\\n.Home_logo__FLQOc {\\n  height: 1em;\\n  margin-left: 0.5rem;\\n}\\n\\n@media (max-width: 600px) {\\n  .Home_grid__npx0i {\\n    width: 100%;\\n    flex-direction: column;\\n  }\\n}\\n.Home_buttonContainer__wSNkk {\\n  display: flex;\\n  justify-content: right;\\n  position: absolute;\\n  top: 0;\\n  right: 0;\\n  margin: 3%;\\n  width: 30%;\\n}\\n\\n.Home_button__hQmsM {\\n  background-color: rgba(2, 138, 104, 0.7058823529);\\n  color: white;\\n  padding: 3%;\\n  width: 25%;\\n  border: none;\\n  cursor: pointer;\\n  font-size: 1.2rem;\\n}\\n\\n.Home_button__hQmsM:focus {\\n  outline: none;\\n}\\n\\n.Home_button__hQmsM:active {\\n  box-shadow: inset 1px 1px 1px 1px black;\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://styles/Home.module.scss\"],\"names\":[],\"mappings\":\"AAAA;EACE,UAAA;EACA,yBAAA;EACA,YAAA;AACF;;AAEA;EACE,iBAAA;EACA,WAAA;EAEA,aAAA;EACA,mBAAA;AAAF;;AAGA;;EAEE,aAAA;EACA,8BAAA;EACA,YAAA;EACA,UAAA;EACA,gBAAA;EACA,eAAA;EACA,mBAAA;AAAF;;AAGA;EACE,aAAA;EACA,SAAA;EACA,eAAA;EACA,6BAAA;EACA,uBAAA;EACA,uBAAA;EACA,mBAAA;EACA,WAAA;AAAF;;AAGA;EACE,aAAA;EACA,uBAAA;EACA,mBAAA;EACA,YAAA;AAAF;;AAGA;EAEE,YAAA;EACA,qBAAA;AADF;;AAIA;;;EAGE,0BAAA;AADF;;AAIA;EACE,gBAAA;EACA,iBAAA;EACA,gBAAA;AADF;;AAIA;EACE,gBAAA;EACA,iBAAA;AADF;;AAKA;;EAEE,kBAAA;AAFF;;AAKA;EACE,cAAA;EACA,gBAAA;EACA,iBAAA;AAFF;;AAKA;EACE,mBAAA;EACA,kBAAA;EACA,gBAAA;EACA,iBAAA;EACA,+HAAA;AAFF;;AAMA;EACE,aAAA;EACA,mBAAA;EACA,uBAAA;EACA,eAAA;EACA,gBAAA;AAHF;;AAMA;EACE,YAAA;EACA,eAAA;EACA,gBAAA;EACA,cAAA;EACA,qBAAA;EACA,yBAAA;EACA,mBAAA;EACA,qDAAA;EACA,gBAAA;AAHF;;AAMA;;;EAGE,cAAA;EACA,qBAAA;AAHF;;AAMA;EACE,kBAAA;EACA,iBAAA;AAHF;;AAMA;EACE,SAAA;EACA,kBAAA;EACA,gBAAA;AAHF;;AAMA;EACE,WAAA;EACA,mBAAA;AAHF;;AAMA;EACE;IACE,WAAA;IACA,sBAAA;EAHF;AACF;AAQA;EACE,aAAA;EACA,sBAAA;EACA,kBAAA;EACA,MAAA;EACA,QAAA;EACA,UAAA;EACA,UAAA;AANF;;AASA;EACE,iDAAA;EACA,YAAA;EACA,WAAA;EACA,UAAA;EACA,YAAA;EACA,eAAA;EAEA,iBAAA;AAPF;;AAUA;EACE,aAAA;AAPF;;AAUA;EACE,uCAAA;AAPF\",\"sourcesContent\":[\".container {\\r\\n  padding: 0;\\r\\n  background-color: #2C2C2C;\\r\\n  color: white;\\r\\n}\\r\\n\\r\\n.main {\\r\\n  min-height: 100vh;\\r\\n  width: 100%;\\r\\n\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n}\\r\\n\\r\\n.left,\\r\\n.right {\\r\\n  display: flex;\\r\\n  /*  justify-content: center; */\\r\\n  height: 100%;\\r\\n  width: 50%;\\r\\n  text-align: left;\\r\\n  flex-wrap: wrap;\\r\\n  align-items: center;\\r\\n}\\r\\n\\r\\n.footer {\\r\\n  display: flex;\\r\\n  flex: 1;\\r\\n  padding: 2rem 0;\\r\\n  border-top: 1px solid #eaeaea;\\r\\n  background-color: black;\\r\\n  justify-content: center;\\r\\n  align-items: center;\\r\\n  width: 100%;\\r\\n}\\r\\n\\r\\n.footer a {\\r\\n  display: flex;\\r\\n  justify-content: center;\\r\\n  align-items: center;\\r\\n  flex-grow: 1;\\r\\n}\\r\\n\\r\\n.title a {\\r\\n\\r\\n  color: black;\\r\\n  text-decoration: none;\\r\\n}\\r\\n\\r\\n.title a:hover,\\r\\n.title a:focus,\\r\\n.title a:active {\\r\\n  text-decoration: underline;\\r\\n}\\r\\n\\r\\n.title {\\r\\n  font-weight: 350;\\r\\n  margin: 0 0 0 17%;\\r\\n  font-size: 10rem;\\r\\n}\\r\\n\\r\\n.subTitle {\\r\\n  font-weight: 350;\\r\\n  margin: 0 0 0 17%;\\r\\n\\r\\n}\\r\\n\\r\\n.title,\\r\\n.description {\\r\\n  text-align: center;\\r\\n}\\r\\n\\r\\n.description {\\r\\n  margin: 4rem 0;\\r\\n  line-height: 1.5;\\r\\n  font-size: 1.5rem;\\r\\n}\\r\\n\\r\\n.code {\\r\\n  background: #fafafa;\\r\\n  border-radius: 5px;\\r\\n  padding: 0.75rem;\\r\\n  font-size: 1.1rem;\\r\\n  font-family: Menlo, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono,\\r\\n    Bitstream Vera Sans Mono, Courier New, monospace;\\r\\n}\\r\\n\\r\\n.grid {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n  flex-wrap: wrap;\\r\\n  max-width: 800px;\\r\\n}\\r\\n\\r\\n.card {\\r\\n  margin: 1rem;\\r\\n  padding: 1.5rem;\\r\\n  text-align: left;\\r\\n  color: inherit;\\r\\n  text-decoration: none;\\r\\n  border: 1px solid #eaeaea;\\r\\n  border-radius: 10px;\\r\\n  transition: color 0.15s ease, border-color 0.15s ease;\\r\\n  max-width: 300px;\\r\\n}\\r\\n\\r\\n.card:hover,\\r\\n.card:focus,\\r\\n.card:active {\\r\\n  color: #0070f3;\\r\\n  border-color: #0070f3;\\r\\n}\\r\\n\\r\\n.card h2 {\\r\\n  margin: 0 0 1rem 0;\\r\\n  font-size: 1.5rem;\\r\\n}\\r\\n\\r\\n.card p {\\r\\n  margin: 0;\\r\\n  font-size: 1.25rem;\\r\\n  line-height: 1.5;\\r\\n}\\r\\n\\r\\n.logo {\\r\\n  height: 1em;\\r\\n  margin-left: 0.5rem;\\r\\n}\\r\\n\\r\\n@media (max-width: 600px) {\\r\\n  .grid {\\r\\n    width: 100%;\\r\\n    flex-direction: column;\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n.buttonContainer {\\r\\n  display: flex;\\r\\n  justify-content: right;\\r\\n  position: absolute;\\r\\n  top: 0;\\r\\n  right: 0;\\r\\n  margin: 3%;\\r\\n  width: 30%;\\r\\n}\\r\\n\\r\\n.button {\\r\\n  background-color: #028a68b4;\\r\\n  color: white;\\r\\n  padding: 3%;\\r\\n  width: 25%;\\r\\n  border: none;\\r\\n  cursor: pointer;\\r\\n\\r\\n  font-size: 1.2rem;\\r\\n}\\r\\n\\r\\n.button:focus {\\r\\n  outline: none;\\r\\n}\\r\\n\\r\\n.button:active {\\r\\n  box-shadow: inset 1px 1px 1px 1px black;\\r\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"container\": \"Home_container__97eC3\",\n\t\"main\": \"Home_main__OVLM4\",\n\t\"left\": \"Home_left__PDvAo\",\n\t\"right\": \"Home_right__Q3ZHY\",\n\t\"footer\": \"Home_footer__zed0_\",\n\t\"title\": \"Home_title__q0Qg4\",\n\t\"subTitle\": \"Home_subTitle__s2Xh0\",\n\t\"description\": \"Home_description__JhekB\",\n\t\"code\": \"Home_code__2i1pD\",\n\t\"grid\": \"Home_grid__npx0i\",\n\t\"card\": \"Home_card__K7aTN\",\n\t\"logo\": \"Home_logo__FLQOc\",\n\t\"buttonContainer\": \"Home_buttonContainer__wSNkk\",\n\t\"button\": \"Home_button__hQmsM\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS5vbmVPZls1XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0ub25lT2ZbNV0udXNlWzJdIS4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdLm9uZU9mWzVdLnVzZVszXSEuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdLm9uZU9mWzVdLnVzZVs0XSEuL3N0eWxlcy9Ib21lLm1vZHVsZS5zY3NzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0NBQWtDLG1CQUFPLENBQUMsbUtBQStFO0FBQ3pIO0FBQ0E7QUFDQSxrRUFBa0UsZUFBZSw4QkFBOEIsaUJBQWlCLEdBQUcsdUJBQXVCLHNCQUFzQixnQkFBZ0Isa0JBQWtCLHdCQUF3QixHQUFHLDRDQUE0QyxrQkFBa0IsaUNBQWlDLG1CQUFtQixlQUFlLHFCQUFxQixvQkFBb0Isd0JBQXdCLEdBQUcseUJBQXlCLGtCQUFrQixjQUFjLG9CQUFvQixrQ0FBa0MsNEJBQTRCLDRCQUE0Qix3QkFBd0IsZ0JBQWdCLEdBQUcsMkJBQTJCLGtCQUFrQiw0QkFBNEIsd0JBQXdCLGlCQUFpQixHQUFHLDBCQUEwQixpQkFBaUIsMEJBQTBCLEdBQUcsMkZBQTJGLCtCQUErQixHQUFHLHdCQUF3QixxQkFBcUIsc0JBQXNCLHFCQUFxQixHQUFHLDJCQUEyQixxQkFBcUIsc0JBQXNCLEdBQUcsbURBQW1ELHVCQUF1QixHQUFHLDhCQUE4QixtQkFBbUIscUJBQXFCLHNCQUFzQixHQUFHLHVCQUF1Qix3QkFBd0IsdUJBQXVCLHFCQUFxQixzQkFBc0Isb0lBQW9JLEdBQUcsdUJBQXVCLGtCQUFrQix3QkFBd0IsNEJBQTRCLG9CQUFvQixxQkFBcUIsR0FBRyx1QkFBdUIsaUJBQWlCLG9CQUFvQixxQkFBcUIsbUJBQW1CLDBCQUEwQiw4QkFBOEIsd0JBQXdCLDBEQUEwRCxxQkFBcUIsR0FBRyxrRkFBa0YsbUJBQW1CLDBCQUEwQixHQUFHLDBCQUEwQix1QkFBdUIsc0JBQXNCLEdBQUcseUJBQXlCLGNBQWMsdUJBQXVCLHFCQUFxQixHQUFHLHVCQUF1QixnQkFBZ0Isd0JBQXdCLEdBQUcsK0JBQStCLHVCQUF1QixrQkFBa0IsNkJBQTZCLEtBQUssR0FBRyxnQ0FBZ0Msa0JBQWtCLDJCQUEyQix1QkFBdUIsV0FBVyxhQUFhLGVBQWUsZUFBZSxHQUFHLHlCQUF5QixzREFBc0QsaUJBQWlCLGdCQUFnQixlQUFlLGlCQUFpQixvQkFBb0Isc0JBQXNCLEdBQUcsK0JBQStCLGtCQUFrQixHQUFHLGdDQUFnQyw0Q0FBNEMsR0FBRyxPQUFPLHdGQUF3RixVQUFVLFdBQVcsVUFBVSxNQUFNLEtBQUssV0FBVyxVQUFVLFVBQVUsV0FBVyxNQUFNLE1BQU0sVUFBVSxXQUFXLFVBQVUsVUFBVSxXQUFXLFVBQVUsV0FBVyxNQUFNLEtBQUssVUFBVSxVQUFVLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLE1BQU0sS0FBSyxVQUFVLFdBQVcsV0FBVyxVQUFVLE1BQU0sS0FBSyxVQUFVLFdBQVcsTUFBTSxPQUFPLFdBQVcsTUFBTSxLQUFLLFdBQVcsV0FBVyxXQUFXLE1BQU0sS0FBSyxXQUFXLFdBQVcsTUFBTSxNQUFNLFdBQVcsTUFBTSxLQUFLLFVBQVUsV0FBVyxXQUFXLE1BQU0sS0FBSyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsTUFBTSxLQUFLLFVBQVUsV0FBVyxXQUFXLFVBQVUsV0FBVyxNQUFNLEtBQUssVUFBVSxVQUFVLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsTUFBTSxPQUFPLFVBQVUsV0FBVyxNQUFNLEtBQUssV0FBVyxXQUFXLE1BQU0sS0FBSyxVQUFVLFdBQVcsV0FBVyxNQUFNLEtBQUssVUFBVSxXQUFXLE1BQU0sS0FBSyxLQUFLLFVBQVUsV0FBVyxLQUFLLEtBQUssS0FBSyxVQUFVLFdBQVcsV0FBVyxVQUFVLFVBQVUsVUFBVSxVQUFVLE1BQU0sS0FBSyxXQUFXLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxXQUFXLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxXQUFXLHFDQUFxQyxpQkFBaUIsZ0NBQWdDLG1CQUFtQixLQUFLLGVBQWUsd0JBQXdCLGtCQUFrQix3QkFBd0IsMEJBQTBCLEtBQUssMEJBQTBCLG9CQUFvQixtQ0FBbUMscUJBQXFCLGlCQUFpQix1QkFBdUIsc0JBQXNCLDBCQUEwQixLQUFLLGlCQUFpQixvQkFBb0IsY0FBYyxzQkFBc0Isb0NBQW9DLDhCQUE4Qiw4QkFBOEIsMEJBQTBCLGtCQUFrQixLQUFLLG1CQUFtQixvQkFBb0IsOEJBQThCLDBCQUEwQixtQkFBbUIsS0FBSyxrQkFBa0IsdUJBQXVCLDRCQUE0QixLQUFLLCtEQUErRCxpQ0FBaUMsS0FBSyxnQkFBZ0IsdUJBQXVCLHdCQUF3Qix1QkFBdUIsS0FBSyxtQkFBbUIsdUJBQXVCLHdCQUF3QixTQUFTLGlDQUFpQyx5QkFBeUIsS0FBSyxzQkFBc0IscUJBQXFCLHVCQUF1Qix3QkFBd0IsS0FBSyxlQUFlLDBCQUEwQix5QkFBeUIsdUJBQXVCLHdCQUF3Qiw2SUFBNkksS0FBSyxlQUFlLG9CQUFvQiwwQkFBMEIsOEJBQThCLHNCQUFzQix1QkFBdUIsS0FBSyxlQUFlLG1CQUFtQixzQkFBc0IsdUJBQXVCLHFCQUFxQiw0QkFBNEIsZ0NBQWdDLDBCQUEwQiw0REFBNEQsdUJBQXVCLEtBQUssc0RBQXNELHFCQUFxQiw0QkFBNEIsS0FBSyxrQkFBa0IseUJBQXlCLHdCQUF3QixLQUFLLGlCQUFpQixnQkFBZ0IseUJBQXlCLHVCQUF1QixLQUFLLGVBQWUsa0JBQWtCLDBCQUEwQixLQUFLLG1DQUFtQyxhQUFhLG9CQUFvQiwrQkFBK0IsT0FBTyxLQUFLLGtDQUFrQyxvQkFBb0IsNkJBQTZCLHlCQUF5QixhQUFhLGVBQWUsaUJBQWlCLGlCQUFpQixLQUFLLGlCQUFpQixrQ0FBa0MsbUJBQW1CLGtCQUFrQixpQkFBaUIsbUJBQW1CLHNCQUFzQiw0QkFBNEIsS0FBSyx1QkFBdUIsb0JBQW9CLEtBQUssd0JBQXdCLDhDQUE4QyxLQUFLLG1CQUFtQjtBQUMzME47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3N0eWxlcy9Ib21lLm1vZHVsZS5zY3NzPzY4MzUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qc1wiKTtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5Ib21lX2NvbnRhaW5lcl9fOTdlQzMge1xcbiAgcGFkZGluZzogMDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMyQzJDMkM7XFxuICBjb2xvcjogd2hpdGU7XFxufVxcblxcbi5Ib21lX21haW5fX09WTE00IHtcXG4gIG1pbi1oZWlnaHQ6IDEwMHZoO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLkhvbWVfbGVmdF9fUER2QW8sXFxuLkhvbWVfcmlnaHRfX1EzWkhZIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICAvKiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7ICovXFxuICBoZWlnaHQ6IDEwMCU7XFxuICB3aWR0aDogNTAlO1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG4gIGZsZXgtd3JhcDogd3JhcDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5Ib21lX2Zvb3Rlcl9femVkMF8ge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXg6IDEgMTtcXG4gIHBhZGRpbmc6IDJyZW0gMDtcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCAjZWFlYWVhO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICB3aWR0aDogMTAwJTtcXG59XFxuXFxuLkhvbWVfZm9vdGVyX196ZWQwXyBhIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBmbGV4LWdyb3c6IDE7XFxufVxcblxcbi5Ib21lX3RpdGxlX19xMFFnNCBhIHtcXG4gIGNvbG9yOiBibGFjaztcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG59XFxuXFxuLkhvbWVfdGl0bGVfX3EwUWc0IGE6aG92ZXIsXFxuLkhvbWVfdGl0bGVfX3EwUWc0IGE6Zm9jdXMsXFxuLkhvbWVfdGl0bGVfX3EwUWc0IGE6YWN0aXZlIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbn1cXG5cXG4uSG9tZV90aXRsZV9fcTBRZzQge1xcbiAgZm9udC13ZWlnaHQ6IDM1MDtcXG4gIG1hcmdpbjogMCAwIDAgMTclO1xcbiAgZm9udC1zaXplOiAxMHJlbTtcXG59XFxuXFxuLkhvbWVfc3ViVGl0bGVfX3MyWGgwIHtcXG4gIGZvbnQtd2VpZ2h0OiAzNTA7XFxuICBtYXJnaW46IDAgMCAwIDE3JTtcXG59XFxuXFxuLkhvbWVfdGl0bGVfX3EwUWc0LFxcbi5Ib21lX2Rlc2NyaXB0aW9uX19KaGVrQiB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcbi5Ib21lX2Rlc2NyaXB0aW9uX19KaGVrQiB7XFxuICBtYXJnaW46IDRyZW0gMDtcXG4gIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICBmb250LXNpemU6IDEuNXJlbTtcXG59XFxuXFxuLkhvbWVfY29kZV9fMmkxcEQge1xcbiAgYmFja2dyb3VuZDogI2ZhZmFmYTtcXG4gIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gIHBhZGRpbmc6IDAuNzVyZW07XFxuICBmb250LXNpemU6IDEuMXJlbTtcXG4gIGZvbnQtZmFtaWx5OiBNZW5sbywgTW9uYWNvLCBMdWNpZGEgQ29uc29sZSwgTGliZXJhdGlvbiBNb25vLCBEZWphVnUgU2FucyBNb25vLCBCaXRzdHJlYW0gVmVyYSBTYW5zIE1vbm8sIENvdXJpZXIgTmV3LCBtb25vc3BhY2U7XFxufVxcblxcbi5Ib21lX2dyaWRfX25weDBpIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBmbGV4LXdyYXA6IHdyYXA7XFxuICBtYXgtd2lkdGg6IDgwMHB4O1xcbn1cXG5cXG4uSG9tZV9jYXJkX19LN2FUTiB7XFxuICBtYXJnaW46IDFyZW07XFxuICBwYWRkaW5nOiAxLjVyZW07XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZWFlYWVhO1xcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXG4gIHRyYW5zaXRpb246IGNvbG9yIDAuMTVzIGVhc2UsIGJvcmRlci1jb2xvciAwLjE1cyBlYXNlO1xcbiAgbWF4LXdpZHRoOiAzMDBweDtcXG59XFxuXFxuLkhvbWVfY2FyZF9fSzdhVE46aG92ZXIsXFxuLkhvbWVfY2FyZF9fSzdhVE46Zm9jdXMsXFxuLkhvbWVfY2FyZF9fSzdhVE46YWN0aXZlIHtcXG4gIGNvbG9yOiAjMDA3MGYzO1xcbiAgYm9yZGVyLWNvbG9yOiAjMDA3MGYzO1xcbn1cXG5cXG4uSG9tZV9jYXJkX19LN2FUTiBoMiB7XFxuICBtYXJnaW46IDAgMCAxcmVtIDA7XFxuICBmb250LXNpemU6IDEuNXJlbTtcXG59XFxuXFxuLkhvbWVfY2FyZF9fSzdhVE4gcCB7XFxuICBtYXJnaW46IDA7XFxuICBmb250LXNpemU6IDEuMjVyZW07XFxuICBsaW5lLWhlaWdodDogMS41O1xcbn1cXG5cXG4uSG9tZV9sb2dvX19GTFFPYyB7XFxuICBoZWlnaHQ6IDFlbTtcXG4gIG1hcmdpbi1sZWZ0OiAwLjVyZW07XFxufVxcblxcbkBtZWRpYSAobWF4LXdpZHRoOiA2MDBweCkge1xcbiAgLkhvbWVfZ3JpZF9fbnB4MGkge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIH1cXG59XFxuLkhvbWVfYnV0dG9uQ29udGFpbmVyX193U05rayB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiByaWdodDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIHJpZ2h0OiAwO1xcbiAgbWFyZ2luOiAzJTtcXG4gIHdpZHRoOiAzMCU7XFxufVxcblxcbi5Ib21lX2J1dHRvbl9faFFtc00ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyLCAxMzgsIDEwNCwgMC43MDU4ODIzNTI5KTtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIHBhZGRpbmc6IDMlO1xcbiAgd2lkdGg6IDI1JTtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGZvbnQtc2l6ZTogMS4ycmVtO1xcbn1cXG5cXG4uSG9tZV9idXR0b25fX2hRbXNNOmZvY3VzIHtcXG4gIG91dGxpbmU6IG5vbmU7XFxufVxcblxcbi5Ib21lX2J1dHRvbl9faFFtc006YWN0aXZlIHtcXG4gIGJveC1zaGFkb3c6IGluc2V0IDFweCAxcHggMXB4IDFweCBibGFjaztcXG59XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL3N0eWxlcy9Ib21lLm1vZHVsZS5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0UsVUFBQTtFQUNBLHlCQUFBO0VBQ0EsWUFBQTtBQUNGOztBQUVBO0VBQ0UsaUJBQUE7RUFDQSxXQUFBO0VBRUEsYUFBQTtFQUNBLG1CQUFBO0FBQUY7O0FBR0E7O0VBRUUsYUFBQTtFQUNBLDhCQUFBO0VBQ0EsWUFBQTtFQUNBLFVBQUE7RUFDQSxnQkFBQTtFQUNBLGVBQUE7RUFDQSxtQkFBQTtBQUFGOztBQUdBO0VBQ0UsYUFBQTtFQUNBLFNBQUE7RUFDQSxlQUFBO0VBQ0EsNkJBQUE7RUFDQSx1QkFBQTtFQUNBLHVCQUFBO0VBQ0EsbUJBQUE7RUFDQSxXQUFBO0FBQUY7O0FBR0E7RUFDRSxhQUFBO0VBQ0EsdUJBQUE7RUFDQSxtQkFBQTtFQUNBLFlBQUE7QUFBRjs7QUFHQTtFQUVFLFlBQUE7RUFDQSxxQkFBQTtBQURGOztBQUlBOzs7RUFHRSwwQkFBQTtBQURGOztBQUlBO0VBQ0UsZ0JBQUE7RUFDQSxpQkFBQTtFQUNBLGdCQUFBO0FBREY7O0FBSUE7RUFDRSxnQkFBQTtFQUNBLGlCQUFBO0FBREY7O0FBS0E7O0VBRUUsa0JBQUE7QUFGRjs7QUFLQTtFQUNFLGNBQUE7RUFDQSxnQkFBQTtFQUNBLGlCQUFBO0FBRkY7O0FBS0E7RUFDRSxtQkFBQTtFQUNBLGtCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxpQkFBQTtFQUNBLCtIQUFBO0FBRkY7O0FBTUE7RUFDRSxhQUFBO0VBQ0EsbUJBQUE7RUFDQSx1QkFBQTtFQUNBLGVBQUE7RUFDQSxnQkFBQTtBQUhGOztBQU1BO0VBQ0UsWUFBQTtFQUNBLGVBQUE7RUFDQSxnQkFBQTtFQUNBLGNBQUE7RUFDQSxxQkFBQTtFQUNBLHlCQUFBO0VBQ0EsbUJBQUE7RUFDQSxxREFBQTtFQUNBLGdCQUFBO0FBSEY7O0FBTUE7OztFQUdFLGNBQUE7RUFDQSxxQkFBQTtBQUhGOztBQU1BO0VBQ0Usa0JBQUE7RUFDQSxpQkFBQTtBQUhGOztBQU1BO0VBQ0UsU0FBQTtFQUNBLGtCQUFBO0VBQ0EsZ0JBQUE7QUFIRjs7QUFNQTtFQUNFLFdBQUE7RUFDQSxtQkFBQTtBQUhGOztBQU1BO0VBQ0U7SUFDRSxXQUFBO0lBQ0Esc0JBQUE7RUFIRjtBQUNGO0FBUUE7RUFDRSxhQUFBO0VBQ0Esc0JBQUE7RUFDQSxrQkFBQTtFQUNBLE1BQUE7RUFDQSxRQUFBO0VBQ0EsVUFBQTtFQUNBLFVBQUE7QUFORjs7QUFTQTtFQUNFLGlEQUFBO0VBQ0EsWUFBQTtFQUNBLFdBQUE7RUFDQSxVQUFBO0VBQ0EsWUFBQTtFQUNBLGVBQUE7RUFFQSxpQkFBQTtBQVBGOztBQVVBO0VBQ0UsYUFBQTtBQVBGOztBQVVBO0VBQ0UsdUNBQUE7QUFQRlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuY29udGFpbmVyIHtcXHJcXG4gIHBhZGRpbmc6IDA7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMkMyQzJDO1xcclxcbiAgY29sb3I6IHdoaXRlO1xcclxcbn1cXHJcXG5cXHJcXG4ubWFpbiB7XFxyXFxuICBtaW4taGVpZ2h0OiAxMDB2aDtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcblxcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxufVxcclxcblxcclxcbi5sZWZ0LFxcclxcbi5yaWdodCB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgLyogIGp1c3RpZnktY29udGVudDogY2VudGVyOyAqL1xcclxcbiAgaGVpZ2h0OiAxMDAlO1xcclxcbiAgd2lkdGg6IDUwJTtcXHJcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxyXFxuICBmbGV4LXdyYXA6IHdyYXA7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG4uZm9vdGVyIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBmbGV4OiAxO1xcclxcbiAgcGFkZGluZzogMnJlbSAwO1xcclxcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNlYWVhZWE7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztcXHJcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbn1cXHJcXG5cXHJcXG4uZm9vdGVyIGEge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIGZsZXgtZ3JvdzogMTtcXHJcXG59XFxyXFxuXFxyXFxuLnRpdGxlIGEge1xcclxcblxcclxcbiAgY29sb3I6IGJsYWNrO1xcclxcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG4udGl0bGUgYTpob3ZlcixcXHJcXG4udGl0bGUgYTpmb2N1cyxcXHJcXG4udGl0bGUgYTphY3RpdmUge1xcclxcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxyXFxufVxcclxcblxcclxcbi50aXRsZSB7XFxyXFxuICBmb250LXdlaWdodDogMzUwO1xcclxcbiAgbWFyZ2luOiAwIDAgMCAxNyU7XFxyXFxuICBmb250LXNpemU6IDEwcmVtO1xcclxcbn1cXHJcXG5cXHJcXG4uc3ViVGl0bGUge1xcclxcbiAgZm9udC13ZWlnaHQ6IDM1MDtcXHJcXG4gIG1hcmdpbjogMCAwIDAgMTclO1xcclxcblxcclxcbn1cXHJcXG5cXHJcXG4udGl0bGUsXFxyXFxuLmRlc2NyaXB0aW9uIHtcXHJcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLmRlc2NyaXB0aW9uIHtcXHJcXG4gIG1hcmdpbjogNHJlbSAwO1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuNTtcXHJcXG4gIGZvbnQtc2l6ZTogMS41cmVtO1xcclxcbn1cXHJcXG5cXHJcXG4uY29kZSB7XFxyXFxuICBiYWNrZ3JvdW5kOiAjZmFmYWZhO1xcclxcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xcclxcbiAgcGFkZGluZzogMC43NXJlbTtcXHJcXG4gIGZvbnQtc2l6ZTogMS4xcmVtO1xcclxcbiAgZm9udC1mYW1pbHk6IE1lbmxvLCBNb25hY28sIEx1Y2lkYSBDb25zb2xlLCBMaWJlcmF0aW9uIE1vbm8sIERlamFWdSBTYW5zIE1vbm8sXFxyXFxuICAgIEJpdHN0cmVhbSBWZXJhIFNhbnMgTW9ubywgQ291cmllciBOZXcsIG1vbm9zcGFjZTtcXHJcXG59XFxyXFxuXFxyXFxuLmdyaWQge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIGZsZXgtd3JhcDogd3JhcDtcXHJcXG4gIG1heC13aWR0aDogODAwcHg7XFxyXFxufVxcclxcblxcclxcbi5jYXJkIHtcXHJcXG4gIG1hcmdpbjogMXJlbTtcXHJcXG4gIHBhZGRpbmc6IDEuNXJlbTtcXHJcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxyXFxuICBjb2xvcjogaW5oZXJpdDtcXHJcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlYWVhZWE7XFxyXFxuICBib3JkZXItcmFkaXVzOiAxMHB4O1xcclxcbiAgdHJhbnNpdGlvbjogY29sb3IgMC4xNXMgZWFzZSwgYm9yZGVyLWNvbG9yIDAuMTVzIGVhc2U7XFxyXFxuICBtYXgtd2lkdGg6IDMwMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uY2FyZDpob3ZlcixcXHJcXG4uY2FyZDpmb2N1cyxcXHJcXG4uY2FyZDphY3RpdmUge1xcclxcbiAgY29sb3I6ICMwMDcwZjM7XFxyXFxuICBib3JkZXItY29sb3I6ICMwMDcwZjM7XFxyXFxufVxcclxcblxcclxcbi5jYXJkIGgyIHtcXHJcXG4gIG1hcmdpbjogMCAwIDFyZW0gMDtcXHJcXG4gIGZvbnQtc2l6ZTogMS41cmVtO1xcclxcbn1cXHJcXG5cXHJcXG4uY2FyZCBwIHtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG4gIGZvbnQtc2l6ZTogMS4yNXJlbTtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxLjU7XFxyXFxufVxcclxcblxcclxcbi5sb2dvIHtcXHJcXG4gIGhlaWdodDogMWVtO1xcclxcbiAgbWFyZ2luLWxlZnQ6IDAuNXJlbTtcXHJcXG59XFxyXFxuXFxyXFxuQG1lZGlhIChtYXgtd2lkdGg6IDYwMHB4KSB7XFxyXFxuICAuZ3JpZCB7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4uYnV0dG9uQ29udGFpbmVyIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHJpZ2h0O1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgdG9wOiAwO1xcclxcbiAgcmlnaHQ6IDA7XFxyXFxuICBtYXJnaW46IDMlO1xcclxcbiAgd2lkdGg6IDMwJTtcXHJcXG59XFxyXFxuXFxyXFxuLmJ1dHRvbiB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDI4YTY4YjQ7XFxyXFxuICBjb2xvcjogd2hpdGU7XFxyXFxuICBwYWRkaW5nOiAzJTtcXHJcXG4gIHdpZHRoOiAyNSU7XFxyXFxuICBib3JkZXI6IG5vbmU7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuXFxyXFxuICBmb250LXNpemU6IDEuMnJlbTtcXHJcXG59XFxyXFxuXFxyXFxuLmJ1dHRvbjpmb2N1cyB7XFxyXFxuICBvdXRsaW5lOiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG4uYnV0dG9uOmFjdGl2ZSB7XFxyXFxuICBib3gtc2hhZG93OiBpbnNldCAxcHggMXB4IDFweCAxcHggYmxhY2s7XFxyXFxufVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcImNvbnRhaW5lclwiOiBcIkhvbWVfY29udGFpbmVyX185N2VDM1wiLFxuXHRcIm1haW5cIjogXCJIb21lX21haW5fX09WTE00XCIsXG5cdFwibGVmdFwiOiBcIkhvbWVfbGVmdF9fUER2QW9cIixcblx0XCJyaWdodFwiOiBcIkhvbWVfcmlnaHRfX1EzWkhZXCIsXG5cdFwiZm9vdGVyXCI6IFwiSG9tZV9mb290ZXJfX3plZDBfXCIsXG5cdFwidGl0bGVcIjogXCJIb21lX3RpdGxlX19xMFFnNFwiLFxuXHRcInN1YlRpdGxlXCI6IFwiSG9tZV9zdWJUaXRsZV9fczJYaDBcIixcblx0XCJkZXNjcmlwdGlvblwiOiBcIkhvbWVfZGVzY3JpcHRpb25fX0poZWtCXCIsXG5cdFwiY29kZVwiOiBcIkhvbWVfY29kZV9fMmkxcERcIixcblx0XCJncmlkXCI6IFwiSG9tZV9ncmlkX19ucHgwaVwiLFxuXHRcImNhcmRcIjogXCJIb21lX2NhcmRfX0s3YVROXCIsXG5cdFwibG9nb1wiOiBcIkhvbWVfbG9nb19fRkxRT2NcIixcblx0XCJidXR0b25Db250YWluZXJcIjogXCJIb21lX2J1dHRvbkNvbnRhaW5lcl9fd1NOa2tcIixcblx0XCJidXR0b25cIjogXCJIb21lX2J1dHRvbl9faFFtc01cIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[5].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[5].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[2].oneOf[5].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[2].oneOf[5].use[4]!./styles/Home.module.scss\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5Cjrdaz%5CNextJS_App%5Cpages%5Cindex.js&page=%2F!":
/*!******************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5Cjrdaz%5CNextJS_App%5Cpages%5Cindex.js&page=%2F! ***!
  \******************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return __webpack_require__(/*! ./pages/index.js */ \"./pages/index.js\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD1DJTNBJTVDVXNlcnMlNUNqcmRheiU1Q05leHRKU19BcHAlNUNwYWdlcyU1Q2luZGV4LmpzJnBhZ2U9JTJGIS5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDBDQUFrQjtBQUN6QztBQUNBO0FBQ0EsT0FBTyxJQUFVO0FBQ2pCLE1BQU0sVUFBVTtBQUNoQjtBQUNBLE9BQU87QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/ZDlkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAod2luZG93Ll9fTkVYVF9QID0gd2luZG93Ll9fTkVYVF9QIHx8IFtdKS5wdXNoKFtcbiAgICAgIFwiL1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZShcIi4vcGFnZXMvaW5kZXguanNcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL1wiXSlcbiAgICAgIH0pO1xuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5Cjrdaz%5CNextJS_App%5Cpages%5Cindex.js&page=%2F!\n"));

/***/ }),

/***/ "./styles/Home.module.scss":
/*!*********************************!*\
  !*** ./styles/Home.module.scss ***!
  \*********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[5].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[5].use[2]!../node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[2].oneOf[5].use[3]!../node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[2].oneOf[5].use[4]!./Home.module.scss */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[5].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[5].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[2].oneOf[5].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[2].oneOf[5].use[4]!./styles/Home.module.scss\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[5].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[5].use[2]!../node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[2].oneOf[5].use[3]!../node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[2].oneOf[5].use[4]!./Home.module.scss */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[5].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[5].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[2].oneOf[5].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[2].oneOf[5].use[4]!./styles/Home.module.scss\",\n      function () {\n        content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[5].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[5].use[2]!../node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[2].oneOf[5].use[3]!../node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[2].oneOf[5].use[4]!./Home.module.scss */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[5].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[5].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[2].oneOf[5].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[2].oneOf[5].use[4]!./styles/Home.module.scss\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvSG9tZS5tb2R1bGUuc2Nzcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsb05BQXdHO0FBQzFILDBCQUEwQixtQkFBTyxDQUFDLHU0QkFBZ2M7O0FBRWxlOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxJQUFJLElBQVU7QUFDZCx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxpQkFBaUI7QUFDckIsTUFBTSx1NEJBQWdjO0FBQ3RjO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsdTRCQUFnYzs7QUFFMWQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFVBQVU7O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxVQUFVO0FBQ1o7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3R5bGVzL0hvbWUubW9kdWxlLnNjc3M/ZTU5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0ub25lT2ZbNV0udXNlWzFdIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS5vbmVPZls1XS51c2VbMl0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdLm9uZU9mWzVdLnVzZVszXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Nhc3MtbG9hZGVyL2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS5vbmVPZls1XS51c2VbNF0hLi9Ib21lLm1vZHVsZS5zY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBzdHlsZS1sb2FkZXIgaW5qZWN0cyBDU1MgaW50byB0aGUgYm90dG9tXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIDxoZWFkPi4gVGhpcyBjYXVzZXMgb3JkZXJpbmcgcHJvYmxlbXMgYmV0d2VlbiBkZXZcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHByb2QuIFRvIGZpeCB0aGlzLCB3ZSByZW5kZXIgYSA8bm9zY3JpcHQ+IHRhZyBhc1xuICAgICAgICAgICAgICAgICAgICAvLyBhbiBhbmNob3IgZm9yIHRoZSBzdHlsZXMgdG8gYmUgcGxhY2VkIGJlZm9yZS4gVGhlc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGVzIHdpbGwgYmUgYXBwbGllZCBfYmVmb3JlXyA8c3R5bGUganN4IGdsb2JhbD4uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNfX25leHRfY3NzX19ET19OT1RfVVNFX19cIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBhbmNob3JFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IocCBpbiBiKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYVtwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS5vbmVPZls1XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdLm9uZU9mWzVdLnVzZVsyXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9yZXNvbHZlLXVybC1sb2FkZXIvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0ub25lT2ZbNV0udXNlWzNdIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdLm9uZU9mWzVdLnVzZVs0XSEuL0hvbWUubW9kdWxlLnNjc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdLm9uZU9mWzVdLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0ub25lT2ZbNV0udXNlWzJdIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Jlc29sdmUtdXJsLWxvYWRlci9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS5vbmVPZls1XS51c2VbM10hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zYXNzLWxvYWRlci9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0ub25lT2ZbNV0udXNlWzRdIS4vSG9tZS5tb2R1bGUuc2Nzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./styles/Home.module.scss\n"));

/***/ }),

/***/ "./pages/index.js":
/*!************************!*\
  !*** ./pages/index.js ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ home; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_src_async_to_generator_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @swc/helpers/src/_async_to_generator.mjs */ \"./node_modules/@swc/helpers/src/_async_to_generator.mjs\");\n/* harmony import */ var C_Users_jrdaz_NextJS_App_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/dist/compiled/regenerator-runtime/runtime.js */ \"./node_modules/next/dist/compiled/regenerator-runtime/runtime.js\");\n/* harmony import */ var C_Users_jrdaz_NextJS_App_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(C_Users_jrdaz_NextJS_App_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _styles_Home_module_scss__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../styles/Home.module.scss */ \"./styles/Home.module.scss\");\n/* harmony import */ var _styles_Home_module_scss__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_styles_Home_module_scss__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next-auth/react */ \"./node_modules/next-auth/react/index.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var siwe__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! siwe */ \"./node_modules/siwe/dist/siwe.js\");\n/* harmony import */ var siwe__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(siwe__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var wagmi__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! wagmi */ \"./node_modules/wagmi/dist/wagmi.esm.js\");\n/* harmony import */ var wagmi_connectors_metaMask__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! wagmi/connectors/metaMask */ \"./node_modules/wagmi/connectors/metaMask/dist/wagmi-connectors-metaMask.esm.js\");\n\n\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\nfunction home() {\n    _s();\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false), isConnected = ref[0], setIsConnected = ref[1];\n    var signMessageAsync = (0,wagmi__WEBPACK_IMPORTED_MODULE_7__.useSignMessage)().signMessageAsync;\n    var ref1 = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false), mmValid = ref1[0], setMmValid = ref1[1];\n    var address = (0,wagmi__WEBPACK_IMPORTED_MODULE_7__.useAccount)().address;\n    var ref2 = (0,wagmi__WEBPACK_IMPORTED_MODULE_7__.useConnect)({\n        connector: new wagmi_connectors_metaMask__WEBPACK_IMPORTED_MODULE_6__.MetaMaskConnector()\n    }), connectors = ref2.connectors, connect = ref2.connect;\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function() {\n        //Check for Metamask\n        if (window.ethereum.selectedAddress === undefined) {\n            alert(\"We noticed you don't have metamask installed. \\n Metamask is required to access our site.\");\n        } else {\n            setMmValid(true);\n            // Check if connected\n            if (window.ethereum.selectedAddress !== undefined) {\n                setIsConnected(true);\n            } else {\n                setIsConnected(false);\n            }\n        }\n    }, []);\n    // Sign message and POST then next/auth handles session\n    var handleLogin = function() {\n        var _ref = (0,_swc_helpers_src_async_to_generator_mjs__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(C_Users_jrdaz_NextJS_App_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee() {\n            var callbackUrl, message, signature;\n            return C_Users_jrdaz_NextJS_App_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_ctx) {\n                while(1)switch(_ctx.prev = _ctx.next){\n                    case 0:\n                        _ctx.prev = 0;\n                        callbackUrl = \"/dashboard\";\n                        _ctx.t0 = siwe__WEBPACK_IMPORTED_MODULE_5__.SiweMessage;\n                        _ctx.t1 = window.location.host;\n                        _ctx.t2 = address;\n                        _ctx.t3 = window.location.origin;\n                        _ctx.next = 8;\n                        return (0,next_auth_react__WEBPACK_IMPORTED_MODULE_4__.getCsrfToken)();\n                    case 8:\n                        _ctx.t4 = _ctx.sent;\n                        _ctx.t5 = {\n                            domain: _ctx.t1,\n                            address: _ctx.t2,\n                            statement: \"In order to verify please sign this message\",\n                            uri: _ctx.t3,\n                            version: \"1\",\n                            chainId: 1,\n                            nonce: _ctx.t4\n                        };\n                        message = new _ctx.t0(_ctx.t5);\n                        _ctx.next = 13;\n                        return signMessageAsync({\n                            message: message.prepareMessage()\n                        });\n                    case 13:\n                        signature = _ctx.sent;\n                        (0,next_auth_react__WEBPACK_IMPORTED_MODULE_4__.signIn)(\"credentials\", {\n                            message: JSON.stringify(message),\n                            signature: signature,\n                            callbackUrl: callbackUrl\n                        });\n                        _ctx.next = 20;\n                        break;\n                    case 17:\n                        _ctx.prev = 17;\n                        _ctx.t6 = _ctx[\"catch\"](0);\n                        window.alert(_ctx.t6);\n                    case 20:\n                    case \"end\":\n                        return _ctx.stop();\n                }\n            }, _callee, null, [\n                [\n                    0,\n                    17\n                ]\n            ]);\n        }));\n        return function handleLogin() {\n            return _ref.apply(this, arguments);\n        };\n    }();\n    var connectWallet = function() {\n        connect(connectors[0]);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"div\", {\n        className: (_styles_Home_module_scss__WEBPACK_IMPORTED_MODULE_9___default().container),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_2___default()), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"title\", {\n                        children: \"Vois\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\jrdaz\\\\NextJS_App\\\\pages\\\\index.js\",\n                        lineNumber: 63,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"meta\", {\n                        name: \"description\",\n                        content: \"Vois\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\jrdaz\\\\NextJS_App\\\\pages\\\\index.js\",\n                        lineNumber: 64,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"link\", {\n                        rel: \"icon\",\n                        href: \"/favicon.ico\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\jrdaz\\\\NextJS_App\\\\pages\\\\index.js\",\n                        lineNumber: 65,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\jrdaz\\\\NextJS_App\\\\pages\\\\index.js\",\n                lineNumber: 62,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"main\", {\n                className: (_styles_Home_module_scss__WEBPACK_IMPORTED_MODULE_9___default().main),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"div\", {\n                        className: (_styles_Home_module_scss__WEBPACK_IMPORTED_MODULE_9___default().left),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"h3\", {\n                                className: (_styles_Home_module_scss__WEBPACK_IMPORTED_MODULE_9___default().title),\n                                children: \"Vois\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\jrdaz\\\\NextJS_App\\\\pages\\\\index.js\",\n                                lineNumber: 70,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"h3\", {\n                                className: (_styles_Home_module_scss__WEBPACK_IMPORTED_MODULE_9___default().subTitle),\n                                children: \"A community driven NFT-oriented social media platform \"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\jrdaz\\\\NextJS_App\\\\pages\\\\index.js\",\n                                lineNumber: 73,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\jrdaz\\\\NextJS_App\\\\pages\\\\index.js\",\n                        lineNumber: 69,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"div\", {\n                        className: (_styles_Home_module_scss__WEBPACK_IMPORTED_MODULE_9___default().right),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"div\", {\n                            className: (_styles_Home_module_scss__WEBPACK_IMPORTED_MODULE_9___default().buttonContainer),\n                            children: [\n                                !isConnected && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"button\", {\n                                    className: (_styles_Home_module_scss__WEBPACK_IMPORTED_MODULE_9___default().button),\n                                    onClick: connectWallet,\n                                    children: \"Connect\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\jrdaz\\\\NextJS_App\\\\pages\\\\index.js\",\n                                    lineNumber: 77,\n                                    columnNumber: 30\n                                }, this),\n                                isConnected && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"button\", {\n                                    className: (_styles_Home_module_scss__WEBPACK_IMPORTED_MODULE_9___default().button),\n                                    onClick: handleLogin,\n                                    children: \"Sign In\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\jrdaz\\\\NextJS_App\\\\pages\\\\index.js\",\n                                    lineNumber: 78,\n                                    columnNumber: 29\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\jrdaz\\\\NextJS_App\\\\pages\\\\index.js\",\n                            lineNumber: 76,\n                            columnNumber: 11\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\jrdaz\\\\NextJS_App\\\\pages\\\\index.js\",\n                        lineNumber: 75,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\jrdaz\\\\NextJS_App\\\\pages\\\\index.js\",\n                lineNumber: 68,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\jrdaz\\\\NextJS_App\\\\pages\\\\index.js\",\n        lineNumber: 61,\n        columnNumber: 5\n    }, this);\n};\n_s(home, \"NXZbeG2pzY2EEpiMXLYNxk4Mm38=\", false, function() {\n    return [\n        wagmi__WEBPACK_IMPORTED_MODULE_7__.useSignMessage,\n        wagmi__WEBPACK_IMPORTED_MODULE_7__.useAccount,\n        wagmi__WEBPACK_IMPORTED_MODULE_7__.useConnect\n    ];\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUE0QjtBQUNtQjtBQUNIO0FBQ1c7QUFDckI7QUFDNEI7QUFDRDtBQUU5QyxTQUFTVyxJQUFJLEdBQUc7O0lBQzdCLElBQXNDUixHQUFlLEdBQWZBLCtDQUFRLENBQUMsS0FBSyxDQUFDLEVBQTlDUyxXQUFXLEdBQW9CVCxHQUFlLEdBQW5DLEVBQUVVLGNBQWMsR0FBSVYsR0FBZSxHQUFuQjtJQUNsQyxJQUFNLGdCQUFrQixHQUFLTSxxREFBYyxFQUFFLENBQXJDSyxnQkFBZ0I7SUFDeEIsSUFBOEJYLElBQWUsR0FBZkEsK0NBQVEsQ0FBQyxLQUFLLENBQUMsRUFBdENZLE9BQU8sR0FBZ0JaLElBQWUsR0FBL0IsRUFBRWEsVUFBVSxHQUFJYixJQUFlLEdBQW5CO0lBQzFCLElBQU0sT0FBUyxHQUFLSSxpREFBVSxFQUFFLENBQXhCVSxPQUFPO0lBQ2YsSUFBZ0NULElBRS9CLEdBRitCQSxpREFBVSxDQUN4QztRQUFFVSxTQUFTLEVBQUUsSUFBSVIsd0VBQWlCLEVBQUU7S0FBRSxDQUN2QyxFQUZPUyxVQUFVLEdBQWNYLElBRS9CLENBRk9XLFVBQVUsRUFBRUMsT0FBTyxHQUFLWixJQUUvQixDQUZtQlksT0FBTztJQUkzQmxCLGdEQUFTLENBQUMsV0FBTTtRQUNkLG9CQUFvQjtRQUNwQixJQUFJbUIsTUFBTSxDQUFDQyxRQUFRLENBQUNDLGVBQWUsS0FBS0MsU0FBUyxFQUFFO1lBQ2pEQyxLQUFLLENBQUMsMkZBQTJGLENBQUMsQ0FBQztTQUNwRyxNQUFNO1lBQ0xULFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUVqQixxQkFBcUI7WUFDckIsSUFBSUssTUFBTSxDQUFDQyxRQUFRLENBQUNDLGVBQWUsS0FBS0MsU0FBUyxFQUFFO2dCQUNqRFgsY0FBYyxDQUFDLElBQUksQ0FBQzthQUNyQixNQUFNO2dCQUNMQSxjQUFjLENBQUMsS0FBSyxDQUFDO2FBQ3RCO1NBQ0Y7S0FFRixFQUFFLEVBQUUsQ0FBQztJQUVOLHVEQUF1RDtJQUN2RCxJQUFNYSxXQUFXO21CQUFHLDJPQUFZO2dCQUV0QkMsV0FBVyxFQUNYQyxPQUFPLEVBU1BDLFNBQVM7Ozs7O3dCQVZURixXQUFXLEdBQUcsWUFBWSxDQUFDO2tDQUNickIsNkNBQVc7a0NBQ3JCZSxNQUFNLENBQUNTLFFBQVEsQ0FBQ0MsSUFBSTtrQ0FDbkJkLE9BQU87a0NBRVhJLE1BQU0sQ0FBQ1MsUUFBUSxDQUFDRSxNQUFNOzsrQkFHZDVCLDZEQUFZLEVBQUU7OztrQ0FQRzs0QkFDOUI2QixNQUFNOzRCQUNOaEIsT0FBTzs0QkFDUGlCLFNBQVMsRUFBRSw2Q0FBNkM7NEJBQ3hEQyxHQUFHOzRCQUNIQyxPQUFPLEVBQUUsR0FBRzs0QkFDWkMsT0FBTyxFQUFFLENBQUM7NEJBQ1ZDLEtBQUs7eUJBQ047d0JBUktWLE9BQU8sR0FBRyxvQkFRZDs7K0JBQ3NCZCxnQkFBZ0IsQ0FBQzs0QkFBRWMsT0FBTyxFQUFFQSxPQUFPLENBQUNXLGNBQWMsRUFBRTt5QkFBRSxDQUFDOzt3QkFBekVWLFNBQVMsWUFBZ0U7d0JBQy9FeEIsdURBQU0sQ0FBQyxhQUFhLEVBQUU7NEJBQUV1QixPQUFPLEVBQUVZLElBQUksQ0FBQ0MsU0FBUyxDQUFDYixPQUFPLENBQUM7NEJBQUVDLFNBQVMsRUFBRUEsU0FBUzs0QkFBRUYsV0FBVyxFQUFFQSxXQUFXO3lCQUFFLENBQUMsQ0FBQzs7Ozs7O3dCQUU1R04sTUFBTSxDQUFDSSxLQUFLLFNBQU87Ozs7Ozs7Ozs7O1NBRXRCO3dCQWpCS0MsV0FBVzs7O09BaUJoQjtJQUVELElBQU1nQixhQUFhLEdBQUcsV0FBTTtRQUMxQnRCLE9BQU8sQ0FBQ0QsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBRXZCO0lBRUQscUJBQ0UsOERBQUN3QixLQUFHO1FBQUNDLFNBQVMsRUFBRTNDLDJFQUFnQjs7MEJBQzlCLDhEQUFDRCxrREFBSTs7a0NBQ0gsOERBQUM4QyxPQUFLO2tDQUFDLE1BQUk7Ozs7OzRCQUFRO2tDQUNuQiw4REFBQ0MsTUFBSTt3QkFBQ0MsSUFBSSxFQUFDLGFBQWE7d0JBQUNDLE9BQU8sRUFBQyxNQUFNOzs7Ozs0QkFBRztrQ0FDMUMsOERBQUNDLE1BQUk7d0JBQUNDLEdBQUcsRUFBQyxNQUFNO3dCQUFDQyxJQUFJLEVBQUMsY0FBYzs7Ozs7NEJBQUc7Ozs7OztvQkFDbEM7MEJBRVAsOERBQUNDLE1BQUk7Z0JBQUNULFNBQVMsRUFBRTNDLHNFQUFXOztrQ0FDMUIsOERBQUMwQyxLQUFHO3dCQUFDQyxTQUFTLEVBQUUzQyxzRUFBVzs7MENBQ3pCLDhEQUFDc0QsSUFBRTtnQ0FBQ1gsU0FBUyxFQUFFM0MsdUVBQVk7MENBQUUsTUFFN0I7Ozs7O29DQUFLOzBDQUNMLDhEQUFDc0QsSUFBRTtnQ0FBQ1gsU0FBUyxFQUFFM0MsMEVBQWU7MENBQUUsd0RBQXNEOzs7OztvQ0FBSzs7Ozs7OzRCQUN2RjtrQ0FDTiw4REFBQzBDLEtBQUc7d0JBQUNDLFNBQVMsRUFBRTNDLHVFQUFZO2tDQUMxQiw0RUFBQzBDLEtBQUc7NEJBQUNDLFNBQVMsRUFBRTNDLGlGQUFzQjs7Z0NBQ25DLENBQUNXLFdBQVcsa0JBQUksOERBQUMrQyxRQUFNO29DQUFDZixTQUFTLEVBQUUzQyx3RUFBYTtvQ0FBRTJELE9BQU8sRUFBRWxCLGFBQWE7OENBQUUsU0FBTzs7Ozs7d0NBQVM7Z0NBQzFGOUIsV0FBVyxrQkFBSSw4REFBQytDLFFBQU07b0NBQUNmLFNBQVMsRUFBRTNDLHdFQUFhO29DQUFFMkQsT0FBTyxFQUFFbEMsV0FBVzs4Q0FBRSxTQUFPOzs7Ozt3Q0FBUzs7Ozs7O2dDQUNwRjs7Ozs7NEJBQ0Y7Ozs7OztvQkFDRDs7Ozs7O1lBQ0gsQ0FDUDtDQUNGO0dBM0V1QmYsSUFBSTs7UUFFR0YsaURBQWM7UUFFdkJGLDZDQUFVO1FBQ0VDLDZDQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3BhZ2VzL2luZGV4LmpzP2JlZTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEhlYWQgZnJvbSBcIm5leHQvaGVhZFwiXHJcbmltcG9ydCBzdHlsZXMgZnJvbSBcIi4uL3N0eWxlcy9Ib21lLm1vZHVsZS5zY3NzXCJcclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyBnZXRDc3JmVG9rZW4sIHNpZ25JbiwgfSBmcm9tIFwibmV4dC1hdXRoL3JlYWN0XCJcclxuaW1wb3J0IHsgU2l3ZU1lc3NhZ2UgfSBmcm9tIFwic2l3ZVwiXHJcbmltcG9ydCB7IHVzZUFjY291bnQsIHVzZUNvbm5lY3QsIHVzZVNpZ25NZXNzYWdlIH0gZnJvbSBcIndhZ21pXCJcclxuaW1wb3J0IHsgTWV0YU1hc2tDb25uZWN0b3IgfSBmcm9tIFwid2FnbWkvY29ubmVjdG9ycy9tZXRhTWFza1wiXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBob21lKCkge1xyXG4gIGNvbnN0IFtpc0Nvbm5lY3RlZCwgc2V0SXNDb25uZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpXHJcbiAgY29uc3QgeyBzaWduTWVzc2FnZUFzeW5jIH0gPSB1c2VTaWduTWVzc2FnZSgpXHJcbiAgY29uc3QgW21tVmFsaWQsIHNldE1tVmFsaWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IHsgYWRkcmVzcyB9ID0gdXNlQWNjb3VudCgpXHJcbiAgY29uc3QgeyBjb25uZWN0b3JzLCBjb25uZWN0IH0gPSB1c2VDb25uZWN0KFxyXG4gICAgeyBjb25uZWN0b3I6IG5ldyBNZXRhTWFza0Nvbm5lY3RvcigpIH1cclxuICApXHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAvL0NoZWNrIGZvciBNZXRhbWFza1xyXG4gICAgaWYgKHdpbmRvdy5ldGhlcmV1bS5zZWxlY3RlZEFkZHJlc3MgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBhbGVydChcIldlIG5vdGljZWQgeW91IGRvbid0IGhhdmUgbWV0YW1hc2sgaW5zdGFsbGVkLiBcXG4gTWV0YW1hc2sgaXMgcmVxdWlyZWQgdG8gYWNjZXNzIG91ciBzaXRlLlwiKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNldE1tVmFsaWQodHJ1ZSk7XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiBjb25uZWN0ZWRcclxuICAgICAgaWYgKHdpbmRvdy5ldGhlcmV1bS5zZWxlY3RlZEFkZHJlc3MgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHNldElzQ29ubmVjdGVkKHRydWUpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2V0SXNDb25uZWN0ZWQoZmFsc2UpXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgfSwgW10pXHJcblxyXG4gIC8vIFNpZ24gbWVzc2FnZSBhbmQgUE9TVCB0aGVuIG5leHQvYXV0aCBoYW5kbGVzIHNlc3Npb25cclxuICBjb25zdCBoYW5kbGVMb2dpbiA9IGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNhbGxiYWNrVXJsID0gXCIvZGFzaGJvYXJkXCI7XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgU2l3ZU1lc3NhZ2Uoe1xyXG4gICAgICAgIGRvbWFpbjogd2luZG93LmxvY2F0aW9uLmhvc3QsXHJcbiAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcclxuICAgICAgICBzdGF0ZW1lbnQ6IFwiSW4gb3JkZXIgdG8gdmVyaWZ5IHBsZWFzZSBzaWduIHRoaXMgbWVzc2FnZVwiLFxyXG4gICAgICAgIHVyaTogd2luZG93LmxvY2F0aW9uLm9yaWdpbixcclxuICAgICAgICB2ZXJzaW9uOiBcIjFcIixcclxuICAgICAgICBjaGFpbklkOiAxLFxyXG4gICAgICAgIG5vbmNlOiBhd2FpdCBnZXRDc3JmVG9rZW4oKVxyXG4gICAgICB9KTtcclxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2lnbk1lc3NhZ2VBc3luYyh7IG1lc3NhZ2U6IG1lc3NhZ2UucHJlcGFyZU1lc3NhZ2UoKSB9KTtcclxuICAgICAgc2lnbkluKFwiY3JlZGVudGlhbHNcIiwgeyBtZXNzYWdlOiBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSwgc2lnbmF0dXJlOiBzaWduYXR1cmUsIGNhbGxiYWNrVXJsOiBjYWxsYmFja1VybCB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHdpbmRvdy5hbGVydChlcnJvcilcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IGNvbm5lY3RXYWxsZXQgPSAoKSA9PiB7XHJcbiAgICBjb25uZWN0KGNvbm5lY3RvcnNbMF0pXHJcblxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY29udGFpbmVyfT5cclxuICAgICAgPEhlYWQ+XHJcbiAgICAgICAgPHRpdGxlPlZvaXM8L3RpdGxlPlxyXG4gICAgICAgIDxtZXRhIG5hbWU9XCJkZXNjcmlwdGlvblwiIGNvbnRlbnQ9XCJWb2lzXCIgLz5cclxuICAgICAgICA8bGluayByZWw9XCJpY29uXCIgaHJlZj1cIi9mYXZpY29uLmljb1wiIC8+XHJcbiAgICAgIDwvSGVhZD5cclxuXHJcbiAgICAgIDxtYWluIGNsYXNzTmFtZT17c3R5bGVzLm1haW59PlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubGVmdH0+XHJcbiAgICAgICAgICA8aDMgY2xhc3NOYW1lPXtzdHlsZXMudGl0bGV9PlxyXG4gICAgICAgICAgICBWb2lzXHJcbiAgICAgICAgICA8L2gzPlxyXG4gICAgICAgICAgPGgzIGNsYXNzTmFtZT17c3R5bGVzLnN1YlRpdGxlfT5BIGNvbW11bml0eSBkcml2ZW4gTkZULW9yaWVudGVkIHNvY2lhbCBtZWRpYSBwbGF0Zm9ybSA8L2gzPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMucmlnaHR9PlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5idXR0b25Db250YWluZXJ9ID5cclxuICAgICAgICAgICAgeyFpc0Nvbm5lY3RlZCAmJiA8YnV0dG9uIGNsYXNzTmFtZT17c3R5bGVzLmJ1dHRvbn0gb25DbGljaz17Y29ubmVjdFdhbGxldH0+Q29ubmVjdDwvYnV0dG9uPn1cclxuICAgICAgICAgICAge2lzQ29ubmVjdGVkICYmIDxidXR0b24gY2xhc3NOYW1lPXtzdHlsZXMuYnV0dG9ufSBvbkNsaWNrPXtoYW5kbGVMb2dpbn0+U2lnbiBJbjwvYnV0dG9uPn1cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L21haW4+XHJcbiAgICA8L2Rpdj5cclxuICApXHJcbn1cclxuIl0sIm5hbWVzIjpbIkhlYWQiLCJzdHlsZXMiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsImdldENzcmZUb2tlbiIsInNpZ25JbiIsIlNpd2VNZXNzYWdlIiwidXNlQWNjb3VudCIsInVzZUNvbm5lY3QiLCJ1c2VTaWduTWVzc2FnZSIsIk1ldGFNYXNrQ29ubmVjdG9yIiwiaG9tZSIsImlzQ29ubmVjdGVkIiwic2V0SXNDb25uZWN0ZWQiLCJzaWduTWVzc2FnZUFzeW5jIiwibW1WYWxpZCIsInNldE1tVmFsaWQiLCJhZGRyZXNzIiwiY29ubmVjdG9yIiwiY29ubmVjdG9ycyIsImNvbm5lY3QiLCJ3aW5kb3ciLCJldGhlcmV1bSIsInNlbGVjdGVkQWRkcmVzcyIsInVuZGVmaW5lZCIsImFsZXJ0IiwiaGFuZGxlTG9naW4iLCJjYWxsYmFja1VybCIsIm1lc3NhZ2UiLCJzaWduYXR1cmUiLCJsb2NhdGlvbiIsImhvc3QiLCJvcmlnaW4iLCJkb21haW4iLCJzdGF0ZW1lbnQiLCJ1cmkiLCJ2ZXJzaW9uIiwiY2hhaW5JZCIsIm5vbmNlIiwicHJlcGFyZU1lc3NhZ2UiLCJKU09OIiwic3RyaW5naWZ5IiwiY29ubmVjdFdhbGxldCIsImRpdiIsImNsYXNzTmFtZSIsImNvbnRhaW5lciIsInRpdGxlIiwibWV0YSIsIm5hbWUiLCJjb250ZW50IiwibGluayIsInJlbCIsImhyZWYiLCJtYWluIiwibGVmdCIsImgzIiwic3ViVGl0bGUiLCJyaWdodCIsImJ1dHRvbkNvbnRhaW5lciIsImJ1dHRvbiIsIm9uQ2xpY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/index.js\n"));

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlIQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzPzg4NDkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvc2hhcmVkL2xpYi9oZWFkJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/head.js\n"));

/***/ }),

/***/ "./node_modules/siwe/dist/client.js":
/*!******************************************!*\
  !*** ./node_modules/siwe/dist/client.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.generateNonce = exports.checkContractWalletSignature = exports.SiweMessage = exports.SignatureType = exports.ErrorTypes = void 0;\nconst random_1 = __webpack_require__(/*! @stablelib/random */ \"./node_modules/@stablelib/random/lib/random.js\");\n// TODO: Figure out how to get types from this lib:\nconst ethers_1 = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\nconst siwe_parser_1 = __webpack_require__(/*! @spruceid/siwe-parser */ \"./node_modules/@spruceid/siwe-parser/dist/parsers.js\");\n/**\n * Possible message error types.\n */\nvar ErrorTypes;\n(function (ErrorTypes) {\n    /**Thrown when the `validate()` function can verify the message. */\n    ErrorTypes[\"INVALID_SIGNATURE\"] = \"Invalid signature.\";\n    /**Thrown when the `expirationTime` is present and in the past. */\n    ErrorTypes[\"EXPIRED_MESSAGE\"] = \"Expired message.\";\n    /**Thrown when some required field is missing. */\n    ErrorTypes[\"MALFORMED_SESSION\"] = \"Malformed session.\";\n})(ErrorTypes = exports.ErrorTypes || (exports.ErrorTypes = {}));\n/**@deprecated\n * Possible signature types that this library supports.\n *\n * This enum will be removed in future releases. And signature type will be\n * inferred from version.\n */\nvar SignatureType;\n(function (SignatureType) {\n    /**EIP-191 signature scheme */\n    SignatureType[\"PERSONAL_SIGNATURE\"] = \"Personal signature\";\n})(SignatureType = exports.SignatureType || (exports.SignatureType = {}));\nclass SiweMessage {\n    /**\n     * Creates a parsed Sign-In with Ethereum Message (EIP-4361) object from a\n     * string or an object. If a string is used an ABNF parser is called to\n     * validate the parameter, otherwise the fields are attributed.\n     * @param param {string | SiweMessage} Sign message as a string or an object.\n     */\n    constructor(param) {\n        if (typeof param === 'string') {\n            const parsedMessage = new siwe_parser_1.ParsedMessage(param);\n            this.domain = parsedMessage.domain;\n            this.address = parsedMessage.address;\n            this.statement = parsedMessage.statement;\n            this.uri = parsedMessage.uri;\n            this.version = parsedMessage.version;\n            this.nonce = parsedMessage.nonce;\n            this.issuedAt = parsedMessage.issuedAt;\n            this.expirationTime = parsedMessage.expirationTime;\n            this.notBefore = parsedMessage.notBefore;\n            this.requestId = parsedMessage.requestId;\n            this.chainId = parsedMessage.chainId;\n            this.resources = parsedMessage.resources;\n        }\n        else {\n            Object.assign(this, param);\n            if (typeof this.chainId === 'string') {\n                this.chainId = parseInt(this.chainId);\n            }\n        }\n    }\n    /**\n     * Given a sign message (EIP-4361) returns the correct matching groups.\n     * @param message {string}\n     * @returns {RegExpExecArray} The matching groups for the message\n     */\n    regexFromMessage(message) {\n        const parsedMessage = new siwe_parser_1.ParsedMessageRegExp(message);\n        return parsedMessage.match;\n    }\n    /**\n     * This function can be used to retrieve an EIP-4361 formated message for\n     * signature, although you can call it directly it's advised to use\n     * [signMessage()] instead which will resolve to the correct method based\n     * on the [type] attribute of this object, in case of other formats being\n     * implemented.\n     * @returns {string} EIP-4361 formated message, ready for EIP-191 signing.\n     */\n    toMessage() {\n        const header = `${this.domain} wants you to sign in with your Ethereum account:`;\n        const uriField = `URI: ${this.uri}`;\n        let prefix = [header, this.address].join('\\n');\n        const versionField = `Version: ${this.version}`;\n        if (!this.nonce) {\n            this.nonce = (0, exports.generateNonce)();\n        }\n        const chainField = `Chain ID: ` + this.chainId || 0;\n        const nonceField = `Nonce: ${this.nonce}`;\n        const suffixArray = [uriField, versionField, chainField, nonceField];\n        if (this.issuedAt) {\n            Date.parse(this.issuedAt);\n        }\n        this.issuedAt = this.issuedAt\n            ? this.issuedAt\n            : new Date().toISOString();\n        suffixArray.push(`Issued At: ${this.issuedAt}`);\n        if (this.expirationTime) {\n            const expiryField = `Expiration Time: ${this.expirationTime}`;\n            suffixArray.push(expiryField);\n        }\n        if (this.notBefore) {\n            suffixArray.push(`Not Before: ${this.notBefore}`);\n        }\n        if (this.requestId) {\n            suffixArray.push(`Request ID: ${this.requestId}`);\n        }\n        if (this.resources) {\n            suffixArray.push([`Resources:`, ...this.resources.map((x) => `- ${x}`)].join('\\n'));\n        }\n        let suffix = suffixArray.join('\\n');\n        prefix = [prefix, this.statement].join('\\n\\n');\n        if (this.statement) {\n            prefix += '\\n';\n        }\n        return [prefix, suffix].join('\\n');\n    }\n    /** @deprecated\n     * signMessage method is deprecated, use prepareMessage instead.\n     *\n     * This method parses all the fields in the object and creates a sign\n     * message according with the type defined.\n     * @returns {string} Returns a message ready to be signed according with the\n     * type defined in the object.\n     */\n    signMessage() {\n        console &&\n            console.warn &&\n            console.warn('signMessage method is deprecated, use prepareMessage instead.');\n        return this.prepareMessage();\n    }\n    /**\n     * This method parses all the fields in the object and creates a sign\n     * message according with the type defined.\n     * @returns {string} Returns a message ready to be signed according with the\n     * type defined in the object.\n     */\n    prepareMessage() {\n        let message;\n        switch (this.version) {\n            case '1': {\n                message = this.toMessage();\n                break;\n            }\n            default: {\n                message = this.toMessage();\n                break;\n            }\n        }\n        return message;\n    }\n    /**\n     * Validates the integrity of the fields of this objects by matching it's\n     * signature.\n     * @param provider A Web3 provider able to perform a contract check, this is\n     * required if support for Smart Contract Wallets that implement EIP-1271 is\n     * needed.\n     * @returns {Promise<SiweMessage>} This object if valid.\n     */\n    validate(signature = this.signature, provider) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                const message = this.prepareMessage();\n                try {\n                    let missing = [];\n                    if (!message) {\n                        missing.push('`message`');\n                    }\n                    if (!signature) {\n                        missing.push('`signature`');\n                    }\n                    if (!this.address) {\n                        missing.push('`address`');\n                    }\n                    if (missing.length > 0) {\n                        throw new Error(`${ErrorTypes.MALFORMED_SESSION} missing: ${missing.join(', ')}.`);\n                    }\n                    let addr;\n                    try {\n                        addr = ethers_1.ethers.utils.verifyMessage(message, signature);\n                    }\n                    catch (_) { }\n                    finally {\n                        if (addr !== this.address) {\n                            try {\n                                //EIP-1271\n                                const isValidSignature = yield (0, exports.checkContractWalletSignature)(this, signature, provider);\n                                if (!isValidSignature) {\n                                    throw new Error(`${ErrorTypes.INVALID_SIGNATURE}: ${addr} !== ${this.address}`);\n                                }\n                            }\n                            catch (e) {\n                                throw e;\n                            }\n                        }\n                    }\n                    const parsedMessage = new SiweMessage(message);\n                    if (parsedMessage.expirationTime) {\n                        const exp = new Date(parsedMessage.expirationTime).getTime();\n                        if (isNaN(exp)) {\n                            throw new Error(`${ErrorTypes.MALFORMED_SESSION} invalid expiration date.`);\n                        }\n                        if (new Date().getTime() >= exp) {\n                            throw new Error(ErrorTypes.EXPIRED_MESSAGE);\n                        }\n                    }\n                    resolve(parsedMessage);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            }));\n        });\n    }\n}\nexports.SiweMessage = SiweMessage;\n/**\n * This method calls the EIP-1271 method for Smart Contract wallets\n * @param message The EIP-4361 parsed message\n * @param provider Web3 provider able to perform a contract check (Web3/EthersJS).\n * @returns {Promise<boolean>} Checks for the smart contract (if it exists) if\n * the signature is valid for given address.\n */\nconst checkContractWalletSignature = (message, signature, provider) => __awaiter(void 0, void 0, void 0, function* () {\n    if (!provider) {\n        return false;\n    }\n    const abi = [\n        'function isValidSignature(bytes32 _message, bytes _signature) public view returns (bool)',\n    ];\n    try {\n        const walletContract = new ethers_1.Contract(message.address, abi, provider);\n        const hashMessage = ethers_1.utils.hashMessage(message.signMessage());\n        return yield walletContract.isValidSignature(hashMessage, signature);\n    }\n    catch (e) {\n        throw e;\n    }\n});\nexports.checkContractWalletSignature = checkContractWalletSignature;\n/**\n * This method leverages a native CSPRNG with support for both browser and Node.js\n * environments in order generate a cryptographically secure nonce for use in the\n * SiweMessage in order to prevent replay attacks.\n *\n * 96 bits has been chosen as a number to sufficiently balance size and security considerations\n * relative to the lifespan of it's usage.\n *\n * @returns cryptographically generated random nonce with 96 bits of entropy encoded with\n * an alphanumeric character set.\n */\nconst generateNonce = () => {\n    return (0, random_1.randomStringForEntropy)(96);\n};\nexports.generateNonce = generateNonce;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2l3ZS9kaXN0L2NsaWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsb0NBQW9DLEdBQUcsbUJBQW1CLEdBQUcscUJBQXFCLEdBQUcsa0JBQWtCO0FBQy9ILGlCQUFpQixtQkFBTyxDQUFDLHlFQUFtQjtBQUM1QztBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHNEQUFRO0FBQ2pDLHNCQUFzQixtQkFBTyxDQUFDLG1GQUF1QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0Msa0JBQWtCLEtBQUs7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QyxxQkFBcUIsS0FBSztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QyxpQ0FBaUMsU0FBUztBQUMxQztBQUNBLHlDQUF5QyxhQUFhO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxDQUFHO0FBQzdELHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQSxvREFBb0Qsb0JBQW9CO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxlQUFlO0FBQzNEO0FBQ0E7QUFDQSw0Q0FBNEMsZUFBZTtBQUMzRDtBQUNBO0FBQ0EsOEVBQThFLEVBQUU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsOEJBQThCLFdBQVcsbUJBQW1CO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCw2QkFBNkIsSUFBSSxNQUFNLE1BQU0sYUFBYTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDhCQUE4QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Npd2UvZGlzdC9jbGllbnQuanM/MjI3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZW5lcmF0ZU5vbmNlID0gZXhwb3J0cy5jaGVja0NvbnRyYWN0V2FsbGV0U2lnbmF0dXJlID0gZXhwb3J0cy5TaXdlTWVzc2FnZSA9IGV4cG9ydHMuU2lnbmF0dXJlVHlwZSA9IGV4cG9ydHMuRXJyb3JUeXBlcyA9IHZvaWQgMDtcbmNvbnN0IHJhbmRvbV8xID0gcmVxdWlyZShcIkBzdGFibGVsaWIvcmFuZG9tXCIpO1xuLy8gVE9ETzogRmlndXJlIG91dCBob3cgdG8gZ2V0IHR5cGVzIGZyb20gdGhpcyBsaWI6XG5jb25zdCBldGhlcnNfMSA9IHJlcXVpcmUoXCJldGhlcnNcIik7XG5jb25zdCBzaXdlX3BhcnNlcl8xID0gcmVxdWlyZShcIkBzcHJ1Y2VpZC9zaXdlLXBhcnNlclwiKTtcbi8qKlxuICogUG9zc2libGUgbWVzc2FnZSBlcnJvciB0eXBlcy5cbiAqL1xudmFyIEVycm9yVHlwZXM7XG4oZnVuY3Rpb24gKEVycm9yVHlwZXMpIHtcbiAgICAvKipUaHJvd24gd2hlbiB0aGUgYHZhbGlkYXRlKClgIGZ1bmN0aW9uIGNhbiB2ZXJpZnkgdGhlIG1lc3NhZ2UuICovXG4gICAgRXJyb3JUeXBlc1tcIklOVkFMSURfU0lHTkFUVVJFXCJdID0gXCJJbnZhbGlkIHNpZ25hdHVyZS5cIjtcbiAgICAvKipUaHJvd24gd2hlbiB0aGUgYGV4cGlyYXRpb25UaW1lYCBpcyBwcmVzZW50IGFuZCBpbiB0aGUgcGFzdC4gKi9cbiAgICBFcnJvclR5cGVzW1wiRVhQSVJFRF9NRVNTQUdFXCJdID0gXCJFeHBpcmVkIG1lc3NhZ2UuXCI7XG4gICAgLyoqVGhyb3duIHdoZW4gc29tZSByZXF1aXJlZCBmaWVsZCBpcyBtaXNzaW5nLiAqL1xuICAgIEVycm9yVHlwZXNbXCJNQUxGT1JNRURfU0VTU0lPTlwiXSA9IFwiTWFsZm9ybWVkIHNlc3Npb24uXCI7XG59KShFcnJvclR5cGVzID0gZXhwb3J0cy5FcnJvclR5cGVzIHx8IChleHBvcnRzLkVycm9yVHlwZXMgPSB7fSkpO1xuLyoqQGRlcHJlY2F0ZWRcbiAqIFBvc3NpYmxlIHNpZ25hdHVyZSB0eXBlcyB0aGF0IHRoaXMgbGlicmFyeSBzdXBwb3J0cy5cbiAqXG4gKiBUaGlzIGVudW0gd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSByZWxlYXNlcy4gQW5kIHNpZ25hdHVyZSB0eXBlIHdpbGwgYmVcbiAqIGluZmVycmVkIGZyb20gdmVyc2lvbi5cbiAqL1xudmFyIFNpZ25hdHVyZVR5cGU7XG4oZnVuY3Rpb24gKFNpZ25hdHVyZVR5cGUpIHtcbiAgICAvKipFSVAtMTkxIHNpZ25hdHVyZSBzY2hlbWUgKi9cbiAgICBTaWduYXR1cmVUeXBlW1wiUEVSU09OQUxfU0lHTkFUVVJFXCJdID0gXCJQZXJzb25hbCBzaWduYXR1cmVcIjtcbn0pKFNpZ25hdHVyZVR5cGUgPSBleHBvcnRzLlNpZ25hdHVyZVR5cGUgfHwgKGV4cG9ydHMuU2lnbmF0dXJlVHlwZSA9IHt9KSk7XG5jbGFzcyBTaXdlTWVzc2FnZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBhcnNlZCBTaWduLUluIHdpdGggRXRoZXJldW0gTWVzc2FnZSAoRUlQLTQzNjEpIG9iamVjdCBmcm9tIGFcbiAgICAgKiBzdHJpbmcgb3IgYW4gb2JqZWN0LiBJZiBhIHN0cmluZyBpcyB1c2VkIGFuIEFCTkYgcGFyc2VyIGlzIGNhbGxlZCB0b1xuICAgICAqIHZhbGlkYXRlIHRoZSBwYXJhbWV0ZXIsIG90aGVyd2lzZSB0aGUgZmllbGRzIGFyZSBhdHRyaWJ1dGVkLlxuICAgICAqIEBwYXJhbSBwYXJhbSB7c3RyaW5nIHwgU2l3ZU1lc3NhZ2V9IFNpZ24gbWVzc2FnZSBhcyBhIHN0cmluZyBvciBhbiBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGFyYW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZE1lc3NhZ2UgPSBuZXcgc2l3ZV9wYXJzZXJfMS5QYXJzZWRNZXNzYWdlKHBhcmFtKTtcbiAgICAgICAgICAgIHRoaXMuZG9tYWluID0gcGFyc2VkTWVzc2FnZS5kb21haW47XG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MgPSBwYXJzZWRNZXNzYWdlLmFkZHJlc3M7XG4gICAgICAgICAgICB0aGlzLnN0YXRlbWVudCA9IHBhcnNlZE1lc3NhZ2Uuc3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy51cmkgPSBwYXJzZWRNZXNzYWdlLnVyaTtcbiAgICAgICAgICAgIHRoaXMudmVyc2lvbiA9IHBhcnNlZE1lc3NhZ2UudmVyc2lvbjtcbiAgICAgICAgICAgIHRoaXMubm9uY2UgPSBwYXJzZWRNZXNzYWdlLm5vbmNlO1xuICAgICAgICAgICAgdGhpcy5pc3N1ZWRBdCA9IHBhcnNlZE1lc3NhZ2UuaXNzdWVkQXQ7XG4gICAgICAgICAgICB0aGlzLmV4cGlyYXRpb25UaW1lID0gcGFyc2VkTWVzc2FnZS5leHBpcmF0aW9uVGltZTtcbiAgICAgICAgICAgIHRoaXMubm90QmVmb3JlID0gcGFyc2VkTWVzc2FnZS5ub3RCZWZvcmU7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RJZCA9IHBhcnNlZE1lc3NhZ2UucmVxdWVzdElkO1xuICAgICAgICAgICAgdGhpcy5jaGFpbklkID0gcGFyc2VkTWVzc2FnZS5jaGFpbklkO1xuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXMgPSBwYXJzZWRNZXNzYWdlLnJlc291cmNlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcGFyYW0pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNoYWluSWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFpbklkID0gcGFyc2VJbnQodGhpcy5jaGFpbklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHNpZ24gbWVzc2FnZSAoRUlQLTQzNjEpIHJldHVybnMgdGhlIGNvcnJlY3QgbWF0Y2hpbmcgZ3JvdXBzLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIHtzdHJpbmd9XG4gICAgICogQHJldHVybnMge1JlZ0V4cEV4ZWNBcnJheX0gVGhlIG1hdGNoaW5nIGdyb3VwcyBmb3IgdGhlIG1lc3NhZ2VcbiAgICAgKi9cbiAgICByZWdleEZyb21NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkTWVzc2FnZSA9IG5ldyBzaXdlX3BhcnNlcl8xLlBhcnNlZE1lc3NhZ2VSZWdFeHAobWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBwYXJzZWRNZXNzYWdlLm1hdGNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIHJldHJpZXZlIGFuIEVJUC00MzYxIGZvcm1hdGVkIG1lc3NhZ2UgZm9yXG4gICAgICogc2lnbmF0dXJlLCBhbHRob3VnaCB5b3UgY2FuIGNhbGwgaXQgZGlyZWN0bHkgaXQncyBhZHZpc2VkIHRvIHVzZVxuICAgICAqIFtzaWduTWVzc2FnZSgpXSBpbnN0ZWFkIHdoaWNoIHdpbGwgcmVzb2x2ZSB0byB0aGUgY29ycmVjdCBtZXRob2QgYmFzZWRcbiAgICAgKiBvbiB0aGUgW3R5cGVdIGF0dHJpYnV0ZSBvZiB0aGlzIG9iamVjdCwgaW4gY2FzZSBvZiBvdGhlciBmb3JtYXRzIGJlaW5nXG4gICAgICogaW1wbGVtZW50ZWQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gRUlQLTQzNjEgZm9ybWF0ZWQgbWVzc2FnZSwgcmVhZHkgZm9yIEVJUC0xOTEgc2lnbmluZy5cbiAgICAgKi9cbiAgICB0b01lc3NhZ2UoKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGAke3RoaXMuZG9tYWlufSB3YW50cyB5b3UgdG8gc2lnbiBpbiB3aXRoIHlvdXIgRXRoZXJldW0gYWNjb3VudDpgO1xuICAgICAgICBjb25zdCB1cmlGaWVsZCA9IGBVUkk6ICR7dGhpcy51cml9YDtcbiAgICAgICAgbGV0IHByZWZpeCA9IFtoZWFkZXIsIHRoaXMuYWRkcmVzc10uam9pbignXFxuJyk7XG4gICAgICAgIGNvbnN0IHZlcnNpb25GaWVsZCA9IGBWZXJzaW9uOiAke3RoaXMudmVyc2lvbn1gO1xuICAgICAgICBpZiAoIXRoaXMubm9uY2UpIHtcbiAgICAgICAgICAgIHRoaXMubm9uY2UgPSAoMCwgZXhwb3J0cy5nZW5lcmF0ZU5vbmNlKSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYWluRmllbGQgPSBgQ2hhaW4gSUQ6IGAgKyB0aGlzLmNoYWluSWQgfHwgJzEnO1xuICAgICAgICBjb25zdCBub25jZUZpZWxkID0gYE5vbmNlOiAke3RoaXMubm9uY2V9YDtcbiAgICAgICAgY29uc3Qgc3VmZml4QXJyYXkgPSBbdXJpRmllbGQsIHZlcnNpb25GaWVsZCwgY2hhaW5GaWVsZCwgbm9uY2VGaWVsZF07XG4gICAgICAgIGlmICh0aGlzLmlzc3VlZEF0KSB7XG4gICAgICAgICAgICBEYXRlLnBhcnNlKHRoaXMuaXNzdWVkQXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNzdWVkQXQgPSB0aGlzLmlzc3VlZEF0XG4gICAgICAgICAgICA/IHRoaXMuaXNzdWVkQXRcbiAgICAgICAgICAgIDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICBzdWZmaXhBcnJheS5wdXNoKGBJc3N1ZWQgQXQ6ICR7dGhpcy5pc3N1ZWRBdH1gKTtcbiAgICAgICAgaWYgKHRoaXMuZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cGlyeUZpZWxkID0gYEV4cGlyYXRpb24gVGltZTogJHt0aGlzLmV4cGlyYXRpb25UaW1lfWA7XG4gICAgICAgICAgICBzdWZmaXhBcnJheS5wdXNoKGV4cGlyeUZpZWxkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ub3RCZWZvcmUpIHtcbiAgICAgICAgICAgIHN1ZmZpeEFycmF5LnB1c2goYE5vdCBCZWZvcmU6ICR7dGhpcy5ub3RCZWZvcmV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdElkKSB7XG4gICAgICAgICAgICBzdWZmaXhBcnJheS5wdXNoKGBSZXF1ZXN0IElEOiAke3RoaXMucmVxdWVzdElkfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlc291cmNlcykge1xuICAgICAgICAgICAgc3VmZml4QXJyYXkucHVzaChbYFJlc291cmNlczpgLCAuLi50aGlzLnJlc291cmNlcy5tYXAoKHgpID0+IGAtICR7eH1gKV0uam9pbignXFxuJykpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdWZmaXggPSBzdWZmaXhBcnJheS5qb2luKCdcXG4nKTtcbiAgICAgICAgcHJlZml4ID0gW3ByZWZpeCwgdGhpcy5zdGF0ZW1lbnRdLmpvaW4oJ1xcblxcbicpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIHByZWZpeCArPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3ByZWZpeCwgc3VmZml4XS5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkXG4gICAgICogc2lnbk1lc3NhZ2UgbWV0aG9kIGlzIGRlcHJlY2F0ZWQsIHVzZSBwcmVwYXJlTWVzc2FnZSBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcGFyc2VzIGFsbCB0aGUgZmllbGRzIGluIHRoZSBvYmplY3QgYW5kIGNyZWF0ZXMgYSBzaWduXG4gICAgICogbWVzc2FnZSBhY2NvcmRpbmcgd2l0aCB0aGUgdHlwZSBkZWZpbmVkLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgYSBtZXNzYWdlIHJlYWR5IHRvIGJlIHNpZ25lZCBhY2NvcmRpbmcgd2l0aCB0aGVcbiAgICAgKiB0eXBlIGRlZmluZWQgaW4gdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICBzaWduTWVzc2FnZSgpIHtcbiAgICAgICAgY29uc29sZSAmJlxuICAgICAgICAgICAgY29uc29sZS53YXJuICYmXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NpZ25NZXNzYWdlIG1ldGhvZCBpcyBkZXByZWNhdGVkLCB1c2UgcHJlcGFyZU1lc3NhZ2UgaW5zdGVhZC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlcGFyZU1lc3NhZ2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcGFyc2VzIGFsbCB0aGUgZmllbGRzIGluIHRoZSBvYmplY3QgYW5kIGNyZWF0ZXMgYSBzaWduXG4gICAgICogbWVzc2FnZSBhY2NvcmRpbmcgd2l0aCB0aGUgdHlwZSBkZWZpbmVkLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgYSBtZXNzYWdlIHJlYWR5IHRvIGJlIHNpZ25lZCBhY2NvcmRpbmcgd2l0aCB0aGVcbiAgICAgKiB0eXBlIGRlZmluZWQgaW4gdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICBwcmVwYXJlTWVzc2FnZSgpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2U7XG4gICAgICAgIHN3aXRjaCAodGhpcy52ZXJzaW9uKSB7XG4gICAgICAgICAgICBjYXNlICcxJzoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLnRvTWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLnRvTWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIGludGVncml0eSBvZiB0aGUgZmllbGRzIG9mIHRoaXMgb2JqZWN0cyBieSBtYXRjaGluZyBpdCdzXG4gICAgICogc2lnbmF0dXJlLlxuICAgICAqIEBwYXJhbSBwcm92aWRlciBBIFdlYjMgcHJvdmlkZXIgYWJsZSB0byBwZXJmb3JtIGEgY29udHJhY3QgY2hlY2ssIHRoaXMgaXNcbiAgICAgKiByZXF1aXJlZCBpZiBzdXBwb3J0IGZvciBTbWFydCBDb250cmFjdCBXYWxsZXRzIHRoYXQgaW1wbGVtZW50IEVJUC0xMjcxIGlzXG4gICAgICogbmVlZGVkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNpd2VNZXNzYWdlPn0gVGhpcyBvYmplY3QgaWYgdmFsaWQuXG4gICAgICovXG4gICAgdmFsaWRhdGUoc2lnbmF0dXJlID0gdGhpcy5zaWduYXR1cmUsIHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLnByZXBhcmVNZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pc3NpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2goJ2BtZXNzYWdlYCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2goJ2BzaWduYXR1cmVgJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaCgnYGFkZHJlc3NgJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pc3NpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke0Vycm9yVHlwZXMuTUFMRk9STUVEX1NFU1NJT059IG1pc3Npbmc6ICR7bWlzc2luZy5qb2luKCcsICcpfS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgYWRkcjtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHIgPSBldGhlcnNfMS5ldGhlcnMudXRpbHMudmVyaWZ5TWVzc2FnZShtZXNzYWdlLCBzaWduYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkciAhPT0gdGhpcy5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9FSVAtMTI3MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1ZhbGlkU2lnbmF0dXJlID0geWllbGQgKDAsIGV4cG9ydHMuY2hlY2tDb250cmFjdFdhbGxldFNpZ25hdHVyZSkodGhpcywgc2lnbmF0dXJlLCBwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZFNpZ25hdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke0Vycm9yVHlwZXMuSU5WQUxJRF9TSUdOQVRVUkV9OiAke2FkZHJ9ICE9PSAke3RoaXMuYWRkcmVzc31gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRNZXNzYWdlID0gbmV3IFNpd2VNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkTWVzc2FnZS5leHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwID0gbmV3IERhdGUocGFyc2VkTWVzc2FnZS5leHBpcmF0aW9uVGltZSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGV4cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7RXJyb3JUeXBlcy5NQUxGT1JNRURfU0VTU0lPTn0gaW52YWxpZCBleHBpcmF0aW9uIGRhdGUuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3IERhdGUoKS5nZXRUaW1lKCkgPj0gZXhwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVycm9yVHlwZXMuRVhQSVJFRF9NRVNTQUdFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHBhcnNlZE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNpd2VNZXNzYWdlID0gU2l3ZU1lc3NhZ2U7XG4vKipcbiAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBFSVAtMTI3MSBtZXRob2QgZm9yIFNtYXJ0IENvbnRyYWN0IHdhbGxldHNcbiAqIEBwYXJhbSBtZXNzYWdlIFRoZSBFSVAtNDM2MSBwYXJzZWQgbWVzc2FnZVxuICogQHBhcmFtIHByb3ZpZGVyIFdlYjMgcHJvdmlkZXIgYWJsZSB0byBwZXJmb3JtIGEgY29udHJhY3QgY2hlY2sgKFdlYjMvRXRoZXJzSlMpLlxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IENoZWNrcyBmb3IgdGhlIHNtYXJ0IGNvbnRyYWN0IChpZiBpdCBleGlzdHMpIGlmXG4gKiB0aGUgc2lnbmF0dXJlIGlzIHZhbGlkIGZvciBnaXZlbiBhZGRyZXNzLlxuICovXG5jb25zdCBjaGVja0NvbnRyYWN0V2FsbGV0U2lnbmF0dXJlID0gKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcHJvdmlkZXIpID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhYmkgPSBbXG4gICAgICAgICdmdW5jdGlvbiBpc1ZhbGlkU2lnbmF0dXJlKGJ5dGVzMzIgX21lc3NhZ2UsIGJ5dGVzIF9zaWduYXR1cmUpIHB1YmxpYyB2aWV3IHJldHVybnMgKGJvb2wpJyxcbiAgICBdO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHdhbGxldENvbnRyYWN0ID0gbmV3IGV0aGVyc18xLkNvbnRyYWN0KG1lc3NhZ2UuYWRkcmVzcywgYWJpLCBwcm92aWRlcik7XG4gICAgICAgIGNvbnN0IGhhc2hNZXNzYWdlID0gZXRoZXJzXzEudXRpbHMuaGFzaE1lc3NhZ2UobWVzc2FnZS5zaWduTWVzc2FnZSgpKTtcbiAgICAgICAgcmV0dXJuIHlpZWxkIHdhbGxldENvbnRyYWN0LmlzVmFsaWRTaWduYXR1cmUoaGFzaE1lc3NhZ2UsIHNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxufSk7XG5leHBvcnRzLmNoZWNrQ29udHJhY3RXYWxsZXRTaWduYXR1cmUgPSBjaGVja0NvbnRyYWN0V2FsbGV0U2lnbmF0dXJlO1xuLyoqXG4gKiBUaGlzIG1ldGhvZCBsZXZlcmFnZXMgYSBuYXRpdmUgQ1NQUk5HIHdpdGggc3VwcG9ydCBmb3IgYm90aCBicm93c2VyIGFuZCBOb2RlLmpzXG4gKiBlbnZpcm9ubWVudHMgaW4gb3JkZXIgZ2VuZXJhdGUgYSBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgbm9uY2UgZm9yIHVzZSBpbiB0aGVcbiAqIFNpd2VNZXNzYWdlIGluIG9yZGVyIHRvIHByZXZlbnQgcmVwbGF5IGF0dGFja3MuXG4gKlxuICogOTYgYml0cyBoYXMgYmVlbiBjaG9zZW4gYXMgYSBudW1iZXIgdG8gc3VmZmljaWVudGx5IGJhbGFuY2Ugc2l6ZSBhbmQgc2VjdXJpdHkgY29uc2lkZXJhdGlvbnNcbiAqIHJlbGF0aXZlIHRvIHRoZSBsaWZlc3BhbiBvZiBpdCdzIHVzYWdlLlxuICpcbiAqIEByZXR1cm5zIGNyeXB0b2dyYXBoaWNhbGx5IGdlbmVyYXRlZCByYW5kb20gbm9uY2Ugd2l0aCA5NiBiaXRzIG9mIGVudHJvcHkgZW5jb2RlZCB3aXRoXG4gKiBhbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVyIHNldC5cbiAqL1xuY29uc3QgZ2VuZXJhdGVOb25jZSA9ICgpID0+IHtcbiAgICByZXR1cm4gKDAsIHJhbmRvbV8xLnJhbmRvbVN0cmluZ0ZvckVudHJvcHkpKDk2KTtcbn07XG5leHBvcnRzLmdlbmVyYXRlTm9uY2UgPSBnZW5lcmF0ZU5vbmNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/siwe/dist/client.js\n"));

/***/ }),

/***/ "./node_modules/siwe/dist/siwe.js":
/*!****************************************!*\
  !*** ./node_modules/siwe/dist/siwe.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./client */ \"./node_modules/siwe/dist/client.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2l3ZS9kaXN0L3Npd2UuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLG9EQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zaXdlL2Rpc3Qvc2l3ZS5qcz81MzVhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2xpZW50XCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/siwe/dist/siwe.js\n"));

/***/ }),

/***/ "./node_modules/wagmi/connectors/metaMask/dist/wagmi-connectors-metaMask.esm.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/wagmi/connectors/metaMask/dist/wagmi-connectors-metaMask.esm.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MetaMaskConnector\": function() { return /* reexport safe */ _wagmi_core_connectors_metaMask__WEBPACK_IMPORTED_MODULE_0__.MetaMaskConnector; }\n/* harmony export */ });\n/* harmony import */ var _wagmi_core_connectors_metaMask__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wagmi/core/connectors/metaMask */ \"./node_modules/@wagmi/core/connectors/metaMask/dist/wagmi-core-connectors-metaMask.esm.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2FnbWkvY29ubmVjdG9ycy9tZXRhTWFzay9kaXN0L3dhZ21pLWNvbm5lY3RvcnMtbWV0YU1hc2suZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW9FIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy93YWdtaS9jb25uZWN0b3JzL21ldGFNYXNrL2Rpc3Qvd2FnbWktY29ubmVjdG9ycy1tZXRhTWFzay5lc20uanM/ZmFhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBNZXRhTWFza0Nvbm5lY3RvciB9IGZyb20gJ0B3YWdtaS9jb3JlL2Nvbm5lY3RvcnMvbWV0YU1hc2snO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/wagmi/connectors/metaMask/dist/wagmi-connectors-metaMask.esm.js\n"));

/***/ }),

/***/ "?4908":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "./node_modules/@swc/helpers/src/_async_to_generator.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@swc/helpers/src/_async_to_generator.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _asyncToGenerator; }\n/* harmony export */ });\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL3NyYy9fYXN5bmNfdG9fZ2VuZXJhdG9yLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzd2MvaGVscGVycy9zcmMvX2FzeW5jX3RvX2dlbmVyYXRvci5tanM/NmM5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@swc/helpers/src/_async_to_generator.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5Cjrdaz%5CNextJS_App%5Cpages%5Cindex.js&page=%2F!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);